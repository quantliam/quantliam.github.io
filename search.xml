<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Fundamentals of Python</title>
    <url>/2018/06/13/Fundamentals-of-Python/</url>
    <content><![CDATA[<h3 id="The-Python-Conceptual-Hierarchy"><a href="#The-Python-Conceptual-Hierarchy" class="headerlink" title="The Python Conceptual Hierarchy"></a>The Python Conceptual Hierarchy</h3><ol>
<li>Programs are composed of modules</li>
<li>Modules contain statements</li>
<li>Statements contain expressions</li>
<li>Expressions create and process objects</li>
</ol>
<a id="more"></a>

<p>Once create an object, you bind its operation set for all time, i.e. you can perform only string operations on a string and list operations on a list.  This characteristic is typically known as <strong>dynamically typed</strong> - a model that keeps track of types for you automatically instead of requiring declaration code but it is also strongly typed, that means you can perform on an object only operations that are valid for its type. </p>
<h1 id="Numbers"><a href="#Numbers" class="headerlink" title="Numbers"></a>Numbers</h1><ol>
<li><strong>+</strong> performs addition</li>
<li>one asterisk (<em>) performs multiplication and two asterisks (*</em>) are used for exponentiation, e.g.<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span>**<span class="number">2</span> <span class="comment"># 2 to the power 2</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Notes</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Implementations: Linked List-based Stack</title>
    <url>/2018/05/30/C-Implementations-Linked-List-based-Stack/</url>
    <content><![CDATA[<h1 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MYSTACK_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYSTACK_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span>&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> size_type;</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line"></span><br><span class="line">    MyStack(): ptrToHead(<span class="literal">nullptr</span>), count(<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"default constructor"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// O(n)</span></span><br><span class="line">    MyStack(<span class="keyword">const</span> MyStack&amp; s): ptrToHead(<span class="literal">nullptr</span>), count(<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"copy constructor"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span>(!s.empty())&#123;</span><br><span class="line">            ptrToHead = create(s.ptrToHead-&gt;data);</span><br><span class="line">            ++count;</span><br><span class="line">            Node* current = ptrToHead;</span><br><span class="line">            <span class="keyword">const</span> Node* temp = s.ptrToHead;</span><br><span class="line">            <span class="keyword">while</span>(count != s.count)&#123;</span><br><span class="line">                    current-&gt;next = create(temp-&gt;next-&gt;data);</span><br><span class="line">                    current = current-&gt;next;</span><br><span class="line">                    temp = temp-&gt;next;</span><br><span class="line">                    ++count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// O(n)</span></span><br><span class="line">    MyStack&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> MyStack&amp; s)&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"assignment operator"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span>(&amp;s != <span class="keyword">this</span>)&#123;</span><br><span class="line">            <span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">if</span>(!s.empty())&#123;</span><br><span class="line">                ptrToHead = create(s.ptrToHead-&gt;data);</span><br><span class="line">                ++count;</span><br><span class="line">                Node* current = ptrToHead;</span><br><span class="line">                <span class="keyword">const</span> Node* temp = s.ptrToHead;</span><br><span class="line">                <span class="keyword">while</span>(count != s.count)&#123;</span><br><span class="line">                    current-&gt;next = create(temp-&gt;next-&gt;data);</span><br><span class="line">                    current = current-&gt;next;</span><br><span class="line">                    temp = temp-&gt;next;</span><br><span class="line">                    ++count;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// O(n)</span></span><br><span class="line">    ~MyStack() &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"destructor"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// O(n)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node* current = ptrToHead;</span><br><span class="line">        <span class="keyword">while</span>(current != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            ptrToHead = ptrToHead-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> current;</span><br><span class="line">            current = ptrToHead;</span><br><span class="line">            --count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// O(1)</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> ptrToHead == <span class="literal">nullptr</span>; &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> count; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// O(1)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T&amp; val)</span></span>&#123;</span><br><span class="line">        Node* new_node = create(val);</span><br><span class="line">        <span class="keyword">if</span>(ptrToHead != <span class="literal">nullptr</span>)</span><br><span class="line">            new_node-&gt;next = ptrToHead;</span><br><span class="line">        ptrToHead = new_node;</span><br><span class="line">        ++count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// O(1)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ptrToHead == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">std</span>::domain_error(<span class="string">"Stack underflow"</span>);</span><br><span class="line"></span><br><span class="line">        Node* temp = ptrToHead;</span><br><span class="line">        ptrToHead = ptrToHead-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">        --count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// O(1)</span></span><br><span class="line">    <span class="function">T <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ptrToHead == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">std</span>::domain_error(<span class="string">"stack underflow"</span>);</span><br><span class="line">        <span class="keyword">return</span> ptrToHead-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">        T data;</span><br><span class="line">        Node* next;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// data members</span></span><br><span class="line">    Node* ptrToHead;</span><br><span class="line">    size_type count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// private function to create a new Node given a value</span></span><br><span class="line">    <span class="function">Node* <span class="title">create</span><span class="params">(<span class="keyword">const</span> T&amp; val = T())</span></span>&#123;</span><br><span class="line">        Node* new_node = <span class="keyword">new</span> Node;</span><br><span class="line">        new_node-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        new_node-&gt;data = val;</span><br><span class="line">        <span class="keyword">return</span> new_node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* MYSTACK_H_ */</span></span></span><br></pre></td></tr></table></figure>

<h1 id="Test-and-results"><a href="#Test-and-results" class="headerlink" title="Test and results"></a>Test and results</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * this program tests all operations that provided by the MyStack&lt;int&gt; class</span></span><br><span class="line"><span class="comment"> * created by Liam on: 27 May 2018</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MyStack.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::domain_error;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#123;	<span class="comment">// test default constructor</span></span><br><span class="line">        MyStack&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">if</span>(!s.empty())</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"s is an empty stack\n"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// test push</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != <span class="number">10</span>; ++i)</span><br><span class="line">            s.push(i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// test top, pop</span></span><br><span class="line">        <span class="keyword">while</span>(s.<span class="built_in">size</span>() != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; s.top() &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">        <span class="comment">// test stack underflow</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(domain_error e)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; e.what() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">    &#123;	<span class="comment">// test copy and assignment operation</span></span><br><span class="line">        MyStack&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != <span class="number">10</span>; ++i)</span><br><span class="line">            s.push(i);</span><br><span class="line"></span><br><span class="line">        <span class="function">MyStack&lt;<span class="keyword">int</span>&gt; <span class="title">s_copy</span><span class="params">(s)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(s_copy.<span class="built_in">size</span>() != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; s_copy.top() &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">            s_copy.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">        s.pop();</span><br><span class="line"></span><br><span class="line">        s_copy = s;</span><br><span class="line">        <span class="keyword">while</span>(s_copy.<span class="built_in">size</span>() != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; s_copy.top() &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">            s_copy.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Outputs:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">default constructor</span><br><span class="line">9 8 7 6 5 4 3 2 1 0 </span><br><span class="line">Stack underflow</span><br><span class="line">destructor</span><br><span class="line"></span><br><span class="line">default constructor</span><br><span class="line">copy constructor</span><br><span class="line">9 8 7 6 5 4 3 2 1 0 </span><br><span class="line">assignment operator</span><br><span class="line">8 7 6 5 4 3 2 1 0 </span><br><span class="line">destructor</span><br><span class="line">destructor</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Data Structures</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ notes for financial mathematics</title>
    <url>/2018/05/28/C-notes-for-financial-mathematics/</url>
    <content><![CDATA[<ol>
<li><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Inf: positive infinity</span><br><span class="line">-Inf: negative infinity</span><br><span class="line">NaN: <span class="keyword">not</span> a number</span><br></pre></td></tr></table></figure>
</li>
<li><p>Noting that two decimals can only be approximately equal.</p>
</li>
<li><p>Casting an <strong>int</strong> to a <strong>float</strong> is risky since the float data type uses binary scientific notation with only a handful of significant figures. So an int cannot be represented precisely using a float.</p>
</li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>financial modelling</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Implementations - Doubly Circular Linked List</title>
    <url>/2018/05/28/C-Implementations-Doubly-Circular-Linked-List/</url>
    <content><![CDATA[<h1 id="Header-file"><a href="#Header-file" class="headerlink" title="Header file"></a>Header file</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CIRCULARLINKEDLIST_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CIRCULARLINKEDLIST_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircularLinkedList</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> size_type;</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// default constructor</span></span><br><span class="line">    CircularLinkedList(): sentinel(create_sentinel()), count(<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"default constructor"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    CircularLinkedList(size_type, <span class="keyword">const</span> T&amp;val = T());</span><br><span class="line">    CircularLinkedList(<span class="keyword">const</span> CircularLinkedList&amp;);</span><br><span class="line">    CircularLinkedList&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> CircularLinkedList&amp;);</span><br><span class="line">    ~CircularLinkedList();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> sentinel-&gt;next == sentinel; &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> count; &#125;</span><br><span class="line">    <span class="function">Node* <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> sentinel-&gt;next; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> Node* <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> sentinel-&gt;next; &#125;</span><br><span class="line">    <span class="function">Node* <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> sentinel; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> Node* <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> sentinel; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_front</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(size_type, <span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop_front</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(size_type)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">        T data;</span><br><span class="line">        Node* prev;</span><br><span class="line">        Node* next;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Node* sentinel;</span><br><span class="line">    size_type count;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node* <span class="title">create_sentinel</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Node* nil = <span class="keyword">new</span> Node;</span><br><span class="line">        nil-&gt;prev = nil;</span><br><span class="line">        nil-&gt;next = nil;</span><br><span class="line">        <span class="keyword">return</span> nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node* <span class="title">create</span><span class="params">(<span class="keyword">const</span> T&amp;val)</span></span>&#123;</span><br><span class="line">        Node* new_node = <span class="keyword">new</span> Node;</span><br><span class="line">        new_node-&gt;data = val;</span><br><span class="line">        new_node-&gt;prev = sentinel;</span><br><span class="line">        new_node-&gt;next = sentinel;</span><br><span class="line">        <span class="keyword">return</span> new_node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// O(n)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">CircularLinkedList&lt;T&gt;::CircularLinkedList(size_type n, <span class="keyword">const</span> T&amp; val)</span><br><span class="line">    : sentinel(create_sentinel()), count(<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"construtor with parameters"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    Node* current = sentinel;</span><br><span class="line">    <span class="keyword">while</span>(count != n)&#123;</span><br><span class="line">        current-&gt;next = create(val);</span><br><span class="line">        current-&gt;next-&gt;prev = current;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">        ++count;</span><br><span class="line">    &#125;</span><br><span class="line">    sentinel-&gt;prev = current;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// O(n)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">CircularLinkedList&lt;T&gt;::CircularLinkedList(<span class="keyword">const</span> CircularLinkedList&amp; l)</span><br><span class="line">    : sentinel(create_sentinel()), count(<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"copy constructor"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    Node* current = sentinel;</span><br><span class="line">    <span class="keyword">const</span> Node* temp = l.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span>(count != l.<span class="built_in">size</span>())&#123;</span><br><span class="line">        current-&gt;next = create(temp-&gt;data);</span><br><span class="line">        current-&gt;next-&gt;prev = current;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">        ++count;</span><br><span class="line">    &#125;</span><br><span class="line">    sentinel-&gt;prev = current;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// O(n)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">CircularLinkedList&lt;T&gt;&amp; CircularLinkedList&lt;T&gt;::<span class="keyword">operator</span>=</span><br><span class="line">        (<span class="keyword">const</span> CircularLinkedList&amp; l)&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"assignment operator"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span>(&amp;l != <span class="keyword">this</span>)&#123;</span><br><span class="line">        <span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">if</span>(!l.empty())&#123;</span><br><span class="line">            Node* current = sentinel;</span><br><span class="line">            <span class="keyword">const</span> Node* temp = l.<span class="built_in">begin</span>();</span><br><span class="line">            <span class="keyword">while</span>(count != l.<span class="built_in">size</span>())&#123;</span><br><span class="line">                current-&gt;next = create(temp-&gt;data);</span><br><span class="line">                current-&gt;next-&gt;prev = current;</span><br><span class="line">                current = current-&gt;next;</span><br><span class="line">                temp = temp-&gt;next;</span><br><span class="line">                ++count;</span><br><span class="line">            &#125;</span><br><span class="line">            sentinel-&gt;prev = current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// O(n)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> CircularLinkedList&lt;T&gt;::<span class="built_in">clear</span>()&#123;</span><br><span class="line">    <span class="keyword">while</span>(sentinel-&gt;next != sentinel)&#123;</span><br><span class="line">        Node* temp = sentinel-&gt;next;</span><br><span class="line">        sentinel-&gt;next = temp-&gt;next;</span><br><span class="line">        sentinel-&gt;next-&gt;prev = sentinel;</span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">        --count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// O(n)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">CircularLinkedList&lt;T&gt;::~CircularLinkedList() &#123;</span><br><span class="line">    <span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">delete</span> sentinel;</span><br><span class="line">    sentinel = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"destructor"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// O(1)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> CircularLinkedList&lt;T&gt;::push_front(<span class="keyword">const</span> T&amp; val)&#123;</span><br><span class="line">    Node* new_node = create(val);</span><br><span class="line">    new_node-&gt;next = sentinel-&gt;next;</span><br><span class="line">    new_node-&gt;next-&gt;prev = new_node;</span><br><span class="line">    sentinel-&gt;next = new_node;</span><br><span class="line">    new_node-&gt;prev = sentinel;</span><br><span class="line">    ++count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// O(n)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> CircularLinkedList&lt;T&gt;::push_back(<span class="keyword">const</span> T&amp; val)&#123;</span><br><span class="line">    Node* current = sentinel;</span><br><span class="line">    <span class="keyword">while</span>(current-&gt;next != sentinel)</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line"></span><br><span class="line">    current-&gt;next = create(val);</span><br><span class="line">    current-&gt;next-&gt;prev = current;</span><br><span class="line">    sentinel-&gt;prev = current-&gt;next;</span><br><span class="line">    ++count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// O(n)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> CircularLinkedList&lt;T&gt;::insert(size_type <span class="built_in">position</span>, <span class="keyword">const</span> T&amp; val)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">position</span> &lt; <span class="number">1</span> || <span class="built_in">position</span> &gt; <span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">std</span>::domain_error(<span class="string">"Invalid Position"</span>);</span><br><span class="line">    Node* current = sentinel;</span><br><span class="line">    Node* new_node = create(val);</span><br><span class="line">    <span class="keyword">for</span>(size_type i = <span class="number">0</span>; i != <span class="built_in">position</span>; ++i)</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line"></span><br><span class="line">    current-&gt;prev-&gt;next = new_node;</span><br><span class="line">    new_node-&gt;prev = current-&gt;prev;</span><br><span class="line">    new_node-&gt;next = current;</span><br><span class="line">    current-&gt;prev = new_node;</span><br><span class="line">    ++count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// O(1)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> CircularLinkedList&lt;T&gt;::pop_front()&#123;</span><br><span class="line">    erase(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// O(n)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> CircularLinkedList&lt;T&gt;::pop_back()&#123;</span><br><span class="line">    erase(<span class="built_in">size</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// O(n)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> CircularLinkedList&lt;T&gt;::erase(size_type <span class="built_in">position</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">position</span> &lt; <span class="number">1</span> || <span class="built_in">position</span> &gt; <span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">std</span>::domain_error(<span class="string">"Invalid Position"</span>);</span><br><span class="line"></span><br><span class="line">    Node* current = sentinel;</span><br><span class="line">    <span class="keyword">for</span>(size_type i = <span class="number">0</span>; i != <span class="built_in">position</span>; ++i)</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line"></span><br><span class="line">    current-&gt;next-&gt;prev = current-&gt;prev;</span><br><span class="line">    current-&gt;prev-&gt;next = current-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> current;</span><br><span class="line">    --count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// O(n)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">CircularLinkedList</span>&lt;T&gt;:</span>:<span class="built_in">remove</span>(<span class="keyword">const</span> T&amp; val)&#123;</span><br><span class="line">    Node* current = sentinel;</span><br><span class="line">    <span class="keyword">while</span>(current-&gt;next != sentinel)&#123;</span><br><span class="line">        <span class="keyword">if</span>(current-&gt;next-&gt;data == val)&#123;</span><br><span class="line">            Node* temp = current-&gt;next;</span><br><span class="line">            current-&gt;next = temp-&gt;next;</span><br><span class="line">            temp-&gt;next-&gt;prev = current;</span><br><span class="line">            <span class="keyword">delete</span> temp;</span><br><span class="line">            --count;</span><br><span class="line">        &#125;<span class="keyword">else</span> current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// O(n)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">CircularLinkedList</span>&lt;T&gt;:</span>:reverse()&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    sentinel-&gt;prev = sentinel-&gt;next;</span><br><span class="line">    Node* current = sentinel;</span><br><span class="line">    Node* NEXT;</span><br><span class="line">    <span class="keyword">while</span>(current-&gt;next != sentinel)&#123;</span><br><span class="line">        NEXT = current-&gt;next;</span><br><span class="line">        current-&gt;next = current-&gt;prev;</span><br><span class="line">        current-&gt;prev = NEXT;</span><br><span class="line">        current = NEXT;</span><br><span class="line">    &#125;</span><br><span class="line">    current-&gt;next = current-&gt;prev;</span><br><span class="line">    current-&gt;prev = sentinel;</span><br><span class="line">    sentinel-&gt;next = current;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CIRCULARLINKEDLIST_H_ */</span></span></span><br></pre></td></tr></table></figure>

<h1 id="Test-program-and-results"><a href="#Test-program-and-results" class="headerlink" title="Test program and results"></a>Test program and results</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * this program tests all operations that provided by the</span></span><br><span class="line"><span class="comment"> * CircularLinkedList&lt;T&gt; class</span></span><br><span class="line"><span class="comment"> * created by Liam on: 28 Apr 2018</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"CircularLinkedList.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// print and reverse print</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">print</span>(<span class="title">T</span>&amp; <span class="title">l</span>)&#123;</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"print in order: "</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i = l.<span class="built_in">begin</span>(); i != l.<span class="built_in">end</span>(); i = i-&gt;next)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i-&gt;data &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"print in reverse: "</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i = (l.<span class="built_in">end</span>())-&gt;prev; i != l.<span class="built_in">end</span>(); i = i-&gt;prev)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i-&gt;data &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#123;	<span class="comment">// construct an empty linked list</span></span><br><span class="line">    CircularLinkedList&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">if</span>(s.empty())</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"s is an empty linked list\n"</span></span><br><span class="line">                <span class="string">"the size of s1 is: "</span> &lt;&lt; s.<span class="built_in">size</span>()  &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// call destructor once reaches the end of this block</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#123;	<span class="comment">// construct a linked  list that contains 10 elements, all values are 100</span></span><br><span class="line">    <span class="function">CircularLinkedList&lt;<span class="keyword">int</span>&gt; <span class="title">s</span><span class="params">(<span class="number">10</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// construct a linked list by copying from s</span></span><br><span class="line">    <span class="function">CircularLinkedList&lt;<span class="keyword">int</span>&gt; <span class="title">s_copy</span><span class="params">(s)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(!s.empty() &amp;&amp; !s_copy.empty())&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"the size of s is: "</span> &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"the size of s_copy is: "</span> &lt;&lt; s_copy.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// print the contents of s_copy</span></span><br><span class="line">    <span class="built_in">print</span>(s_copy);</span><br><span class="line">    <span class="comment">// call destructor twice</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#123;	<span class="comment">// assignment</span></span><br><span class="line">    <span class="function">CircularLinkedList&lt;<span class="keyword">int</span>&gt; <span class="title">s</span><span class="params">(<span class="number">10</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">    CircularLinkedList&lt;<span class="keyword">int</span>&gt; s_copy;</span><br><span class="line">    s_copy = s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// print the contents of s_copy</span></span><br><span class="line">    <span class="built_in">print</span>(s_copy);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#123;	<span class="comment">// push front</span></span><br><span class="line">    CircularLinkedList&lt;<span class="keyword">double</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">5</span>; i != <span class="number">0</span>; --i)</span><br><span class="line">        s.push_front(i);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"after adding elements at front:\n"</span>;</span><br><span class="line">    <span class="built_in">print</span>(s);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// push back</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">5</span>; i != <span class="number">0</span>; --i)</span><br><span class="line">        s.push_back(i);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"after adding elements at the end:\n"</span>;</span><br><span class="line">        <span class="built_in">print</span>(s);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// insert at position 5</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">5</span>; i != <span class="number">0</span>; --i)</span><br><span class="line">        s.insert(i, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"after inserting elements in-between:\n"</span>;</span><br><span class="line">            <span class="built_in">print</span>(s);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// delete from the begining</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">5</span>; i != <span class="number">0</span>; --i)</span><br><span class="line">        s.pop_front();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"after deleting from the begining:\n"</span>;</span><br><span class="line">    <span class="built_in">print</span>(s);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// delete from the end</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">5</span>; i != <span class="number">0</span>; --i)&#123;</span><br><span class="line">        s.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"after deleting from the end:\n"</span>;</span><br><span class="line">    <span class="built_in">print</span>(s);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// erase at in-between positions</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i != <span class="number">0</span>; --i)</span><br><span class="line">        s.erase(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"after deleting from other positions:\n"</span>;</span><br><span class="line">        <span class="built_in">print</span>(s);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#123;	<span class="comment">// remove</span></span><br><span class="line">    <span class="function">CircularLinkedList&lt;<span class="keyword">int</span>&gt; <span class="title">s</span><span class="params">(<span class="number">5</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">5</span>; i != <span class="number">0</span>; --i)</span><br><span class="line">        s.insert(<span class="number">5</span>, i);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"at present:\n"</span>;</span><br><span class="line">    <span class="built_in">print</span>(s);</span><br><span class="line"></span><br><span class="line">    s.<span class="built_in">remove</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"after removing all elements:\n"</span>;</span><br><span class="line">    <span class="built_in">print</span>(s);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#123;	<span class="comment">// test reverse function</span></span><br><span class="line">    CircularLinkedList&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i != <span class="number">10</span>; ++i)</span><br><span class="line">        s.push_back(i);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"at present, s contains following elements:\n"</span>;</span><br><span class="line">    <span class="built_in">print</span>(s);</span><br><span class="line"></span><br><span class="line">    s.reverse();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"after reverse:\n"</span>;</span><br><span class="line">    <span class="built_in">print</span>(s);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Outputs:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">default constructor</span><br><span class="line">s is an empty linked list</span><br><span class="line">the size of s1 is: 0</span><br><span class="line">destructor</span><br><span class="line"></span><br><span class="line">construtor with parameters</span><br><span class="line">copy constructor</span><br><span class="line">the size of s is: 10</span><br><span class="line">the size of s_copy is: 10</span><br><span class="line">print in order: 100 100 100 100 100 100 100 100 100 100 </span><br><span class="line">print in reverse: 100 100 100 100 100 100 100 100 100 100 </span><br><span class="line">destructor</span><br><span class="line">destructor</span><br><span class="line"></span><br><span class="line">construtor with parameters</span><br><span class="line">default constructor</span><br><span class="line">assignment operator</span><br><span class="line">print in order: 100 100 100 100 100 100 100 100 100 100 </span><br><span class="line">print in reverse: 100 100 100 100 100 100 100 100 100 100 </span><br><span class="line">destructor</span><br><span class="line">destructor</span><br><span class="line"></span><br><span class="line">default constructor</span><br><span class="line">after adding elements at front:</span><br><span class="line">print in order: 1 2 3 4 5 </span><br><span class="line">print in reverse: 5 4 3 2 1 </span><br><span class="line">after adding elements at the end:</span><br><span class="line">print in order: 1 2 3 4 5 5 4 3 2 1 </span><br><span class="line">print in reverse: 1 2 3 4 5 5 4 3 2 1 </span><br><span class="line">after inserting elements in-between:</span><br><span class="line">print in order: 0 1 0 2 0 3 0 4 0 5 5 4 3 2 1 </span><br><span class="line">print in reverse: 1 2 3 4 5 5 0 4 0 3 0 2 0 1 0 </span><br><span class="line">after deleting from the begining:</span><br><span class="line">print in order: 3 0 4 0 5 5 4 3 2 1 </span><br><span class="line">print in reverse: 1 2 3 4 5 5 0 4 0 3 </span><br><span class="line">after deleting from the end:</span><br><span class="line">print in order: 3 0 4 0 5 </span><br><span class="line">print in reverse: 5 0 4 0 3 </span><br><span class="line">after deleting from other positions:</span><br><span class="line">print in order: 3 0 </span><br><span class="line">print in reverse: 0 3 </span><br><span class="line">destructor</span><br><span class="line"></span><br><span class="line">construtor with parameters</span><br><span class="line">at present:</span><br><span class="line">print in order: 5 5 5 5 1 2 3 4 5 5 </span><br><span class="line">print in reverse: 5 5 4 3 2 1 5 5 5 5 </span><br><span class="line">after removing all elements:</span><br><span class="line">print in order: 1 2 3 4 </span><br><span class="line">print in reverse: 4 3 2 1 </span><br><span class="line">destructor</span><br><span class="line"></span><br><span class="line">default constructor</span><br><span class="line">at present, s contains following elements:</span><br><span class="line">print in order: 0 1 2 3 4 5 6 7 8 9 </span><br><span class="line">print in reverse: 9 8 7 6 5 4 3 2 1 0 </span><br><span class="line">after reverse:</span><br><span class="line">print in order: 9 8 7 6 5 4 3 2 1 0 </span><br><span class="line">print in reverse: 0 1 2 3 4 5 6 7 8 9 </span><br><span class="line">destructor</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Data Structures</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Implementations: Singly Circular Linked List with a sentinel</title>
    <url>/2018/05/26/C-Implementations-Circular-Doubly-Linked-List/</url>
    <content><![CDATA[<h1 id="Header-file"><a href="#Header-file" class="headerlink" title="Header file"></a>Header file</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CIRCULARLINKEDLIST_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CIRCULARLINKEDLIST_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircularLinkedList</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> size_type;</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create an empty linked list</span></span><br><span class="line">    CircularLinkedList(): sentinel(create_sentinel()), count(<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"default constructor"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create an linked list with user supplied size and value</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">CircularLinkedList</span><span class="params">(size_type, <span class="keyword">const</span> T&amp; val = T())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// copy constructor</span></span><br><span class="line">    CircularLinkedList(<span class="keyword">const</span> CircularLinkedList&amp;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// assignment operator</span></span><br><span class="line">    CircularLinkedList&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> CircularLinkedList&amp;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// destructor</span></span><br><span class="line">    ~CircularLinkedList() &#123;</span><br><span class="line">        <span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">delete</span> sentinel;</span><br><span class="line">        sentinel = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"destructor"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> sentinel == sentinel-&gt;next; &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> count; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node* <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> sentinel-&gt;next; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> Node* <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> sentinel-&gt;next; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node* <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> sentinel; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> Node* <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> sentinel; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// insert at begining</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_front</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// insert at the end</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// insert at the nth position, that is, after (n-1)the position</span></span><br><span class="line">    <span class="comment">// the range of position is [1, size()]</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(size_type, <span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// delete at the begining</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop_front</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// delete the last element</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// delete at nth position</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(size_type)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reverse the order iteratively</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// remove elements with specific values</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">        T data;</span><br><span class="line">        Node* next;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Node* sentinel;</span><br><span class="line">    size_type count;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">Node* <span class="title">create_sentinel</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Node* nil = <span class="keyword">new</span> Node;</span><br><span class="line">        nil-&gt;next = nil;</span><br><span class="line">        <span class="keyword">return</span> nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">Node* <span class="title">create</span><span class="params">(<span class="keyword">const</span> T&amp; val = T())</span></span>&#123;</span><br><span class="line">        Node* new_node = <span class="keyword">new</span> Node;</span><br><span class="line">        new_node-&gt;data = val;</span><br><span class="line">        new_node-&gt;next = sentinel;</span><br><span class="line">        <span class="keyword">return</span> new_node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// O(n)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">CircularLinkedList&lt;T&gt;::CircularLinkedList(size_type n, <span class="keyword">const</span> T&amp; val):</span><br><span class="line">    sentinel(create_sentinel()), count(<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"constructor with parameters"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    Node* current = sentinel;</span><br><span class="line">    <span class="keyword">while</span>(count != n)&#123;</span><br><span class="line">        current-&gt;next = create(val);</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">        ++count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// O(n)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">CircularLinkedList&lt;T&gt;::CircularLinkedList(<span class="keyword">const</span> CircularLinkedList&amp; l):</span><br><span class="line">    sentinel(create_sentinel()), count(<span class="number">0</span>)&#123;</span><br><span class="line">    Node* current = sentinel;</span><br><span class="line">    <span class="keyword">const</span> Node* temp = l.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span>(temp != l.<span class="built_in">end</span>())&#123;</span><br><span class="line">        current-&gt;next = create(temp-&gt;data);</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">        ++count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// O(n)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">CircularLinkedList&lt;T&gt;&amp; CircularLinkedList&lt;T&gt;::<span class="keyword">operator</span>=</span><br><span class="line">        (<span class="keyword">const</span> CircularLinkedList&amp; l)&#123;</span><br><span class="line">    <span class="keyword">if</span>(&amp;l != <span class="keyword">this</span>)&#123;</span><br><span class="line">        <span class="built_in">clear</span>();</span><br><span class="line">        Node* current = sentinel;</span><br><span class="line">        <span class="keyword">const</span> Node* temp = l.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">while</span>(temp != l.<span class="built_in">end</span>())&#123;</span><br><span class="line">            current-&gt;next = create(temp-&gt;data);</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">            ++count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// O(n)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> CircularLinkedList&lt;T&gt;::<span class="built_in">clear</span>()&#123;</span><br><span class="line">    Node* current = sentinel;</span><br><span class="line">    <span class="keyword">if</span>(current-&gt;next != sentinel)&#123;</span><br><span class="line">        Node* temp = current-&gt;next;</span><br><span class="line">        current-&gt;next = temp-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">        --count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// O(1)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">CircularLinkedList</span>&lt;T&gt;:</span>:push_front(<span class="keyword">const</span> T&amp; val) &#123;</span><br><span class="line">    Node* current = sentinel;</span><br><span class="line">    Node* new_node = create(val);</span><br><span class="line">    new_node-&gt;next = current-&gt;next;</span><br><span class="line">    current-&gt;next = new_node;</span><br><span class="line">    ++count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// O(n)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">CircularLinkedList</span>&lt;T&gt;:</span>:push_back(<span class="keyword">const</span> T&amp; val) &#123;</span><br><span class="line">    Node* current = sentinel;</span><br><span class="line">    <span class="keyword">while</span>(current-&gt;next != sentinel)</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line"></span><br><span class="line">    current-&gt;next = create(val);</span><br><span class="line">    ++count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// O(n)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">CircularLinkedList</span>&lt;T&gt;:</span>:insert(size_type <span class="built_in">position</span>, <span class="keyword">const</span> T&amp; val)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">position</span> &lt; <span class="number">1</span> || <span class="built_in">position</span> &gt; <span class="built_in">size</span>())</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::domain_error(<span class="string">"Invalid Position"</span>);</span><br><span class="line"></span><br><span class="line">    Node* new_node = create(val);</span><br><span class="line">    Node* temp = sentinel;</span><br><span class="line">    <span class="keyword">for</span> (size_type i = <span class="number">0</span>; i != <span class="built_in">position</span><span class="number">-1</span>; ++i)</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    new_node-&gt;next = temp-&gt;next;</span><br><span class="line">    temp-&gt;next = new_node;</span><br><span class="line">    ++count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// O(1)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">CircularLinkedList</span>&lt;T&gt;:</span>:pop_front()&#123;</span><br><span class="line">    erase(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// O(n)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">CircularLinkedList</span>&lt;T&gt;:</span>:pop_back()&#123;</span><br><span class="line">    erase(<span class="built_in">size</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// O(n)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">CircularLinkedList</span>&lt;T&gt;:</span>:erase(size_type <span class="built_in">position</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">position</span> &lt; <span class="number">1</span> || <span class="built_in">position</span> &gt; <span class="built_in">size</span>())</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::domain_error(<span class="string">"Invalid Position"</span>);</span><br><span class="line"></span><br><span class="line">    Node* current = sentinel;</span><br><span class="line">    <span class="keyword">for</span>(size_type i = <span class="number">0</span>; i != <span class="built_in">position</span> - <span class="number">1</span>; ++i)</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line"></span><br><span class="line">    Node* temp = current-&gt;next;</span><br><span class="line">    current-&gt;next = temp-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> temp;</span><br><span class="line">    --count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// O(n)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">CircularLinkedList</span>&lt;T&gt;:</span>:<span class="built_in">remove</span>(<span class="keyword">const</span> T&amp; val)&#123;</span><br><span class="line">    Node* current = sentinel;</span><br><span class="line">    <span class="keyword">while</span>(current-&gt;next != sentinel)&#123;</span><br><span class="line">        <span class="keyword">if</span>(current-&gt;next-&gt;data == val)&#123;</span><br><span class="line">            Node* temp = current-&gt;next;</span><br><span class="line">            current-&gt;next = temp-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> temp;</span><br><span class="line">            --count;</span><br><span class="line">        &#125;<span class="keyword">else</span> current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// O(n)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">CircularLinkedList</span>&lt;T&gt;:</span>:reverse()&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    Node* current = sentinel-&gt;next;</span><br><span class="line">    Node* PREV = sentinel;</span><br><span class="line">    Node* NEXT;</span><br><span class="line">    <span class="keyword">while</span>(current-&gt;next != sentinel)&#123;</span><br><span class="line">        NEXT = current-&gt;next;</span><br><span class="line">        current-&gt;next = PREV;</span><br><span class="line">        PREV = current;</span><br><span class="line">        current = NEXT;</span><br><span class="line">    &#125;</span><br><span class="line">    current-&gt;next = PREV;</span><br><span class="line">    sentinel-&gt;next = current;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CIRCULARLINKEDLIST_H_ */</span></span></span><br></pre></td></tr></table></figure>
<h1 id="Test-program-and-results"><a href="#Test-program-and-results" class="headerlink" title="Test program and results"></a>Test program and results</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * this program tests all operations that provided by the</span></span><br><span class="line"><span class="comment"> * CircularLinkedList&lt;T&gt; class</span></span><br><span class="line"><span class="comment"> * created by Liam on: 28 May 2018</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"CircularLinkedList.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Pointer</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">print</span>(<span class="title">Pointer</span> <span class="title">begin</span>, <span class="title">Pointer</span> <span class="title">end</span>)&#123;</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">begin</span> != <span class="built_in">end</span>)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">begin</span>-&gt;data &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        <span class="built_in">begin</span> = <span class="built_in">begin</span>-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#123;	<span class="comment">// construct an empty linked list</span></span><br><span class="line">    CircularLinkedList&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">if</span>(s.empty())</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"s is an empty linked list\n"</span></span><br><span class="line">                <span class="string">"the size of s1 is: "</span> &lt;&lt; s.<span class="built_in">size</span>()  &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// call destructor once reaches the end of this block</span></span><br><span class="line">&#125;</span><br><span class="line">	 <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#123;	<span class="comment">// construct a linked  list that contains 10 elements, all values are 100</span></span><br><span class="line">    <span class="function">CircularLinkedList&lt;<span class="keyword">int</span>&gt; <span class="title">s</span><span class="params">(<span class="number">10</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// construct a linked list by copying from s</span></span><br><span class="line">    <span class="function">CircularLinkedList&lt;<span class="keyword">int</span>&gt; <span class="title">s_copy</span><span class="params">(s)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(!s.empty() &amp;&amp; !s_copy.empty())&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"the size of s is: "</span> &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"the size of s_copy is: "</span> &lt;&lt; s_copy.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// print the contents of s_copy</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"all elements in s_copy: "</span>;</span><br><span class="line">    <span class="built_in">print</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// call destructor twice</span></span><br><span class="line">&#125;</span><br><span class="line">	 <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#123;	<span class="comment">// assignment</span></span><br><span class="line">    <span class="function">CircularLinkedList&lt;<span class="keyword">int</span>&gt; <span class="title">s</span><span class="params">(<span class="number">10</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">    CircularLinkedList&lt;<span class="keyword">int</span>&gt; s_copy;</span><br><span class="line">    s_copy = s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// print the contents of s_copy</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"all elements in s_copy: "</span>;</span><br><span class="line">    <span class="built_in">print</span>(s_copy.<span class="built_in">begin</span>(), s_copy.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#123;	<span class="comment">// push front</span></span><br><span class="line">    CircularLinkedList&lt;<span class="keyword">double</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">5</span>; i != <span class="number">0</span>; --i)</span><br><span class="line">        s.push_front(i);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"after adding elements at front, s becomes: "</span>;</span><br><span class="line">    <span class="built_in">print</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// push back</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">5</span>; i != <span class="number">0</span>; --i)</span><br><span class="line">        s.push_back(i);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"after adding elements at the end, s becomes: "</span>;</span><br><span class="line">    <span class="built_in">print</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// insert at position 5</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">5</span>; i != <span class="number">0</span>; --i)</span><br><span class="line">        s.insert(i, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"after inserting elements in-between, s becomes: "</span>;</span><br><span class="line">    <span class="built_in">print</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// delete from the begining</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">5</span>; i != <span class="number">0</span>; --i)</span><br><span class="line">        s.pop_front();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"after deleting from the begining, s becomes: "</span>;</span><br><span class="line">    <span class="built_in">print</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// delete from the end</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">5</span>; i != <span class="number">0</span>; --i)</span><br><span class="line">        s.pop_back();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"after deleting from the end, s becomes: "</span>;</span><br><span class="line">    <span class="built_in">print</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// erase at in-between positions</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i != <span class="number">0</span>; --i)</span><br><span class="line">        s.erase(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"after deleting from other positions, s becomes: "</span>;</span><br><span class="line">    <span class="built_in">print</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#123;	<span class="comment">// remove</span></span><br><span class="line">    <span class="function">CircularLinkedList&lt;<span class="keyword">int</span>&gt; <span class="title">s</span><span class="params">(<span class="number">5</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">5</span>; i != <span class="number">0</span>; --i)</span><br><span class="line">        s.insert(<span class="number">5</span>, i);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"at present, s contains following elements: "</span>;</span><br><span class="line">    <span class="built_in">print</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    s.<span class="built_in">remove</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"after removing all elements equal 5, s becomes: "</span>;</span><br><span class="line">    <span class="built_in">print</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#123;	<span class="comment">// test reverse function</span></span><br><span class="line">    CircularLinkedList&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i != <span class="number">10</span>; ++i)</span><br><span class="line">        s.push_back(i);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"at present, s contains following elements: "</span>;</span><br><span class="line">    <span class="built_in">print</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    s.reverse();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"reverse: "</span>;</span><br><span class="line">    <span class="built_in">print</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    s.reverse();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"reverse again: "</span>;</span><br><span class="line">    <span class="built_in">print</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Outputs:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">default constructor</span><br><span class="line">s is an empty linked list</span><br><span class="line">the size of s1 is: 0</span><br><span class="line">destructor</span><br><span class="line"></span><br><span class="line">constructor with parameters</span><br><span class="line">the size of s is: 10</span><br><span class="line">the size of s_copy is: 10</span><br><span class="line">all elements in s_copy: 100 100 100 100 100 100 100 100 100 100 </span><br><span class="line">destructor</span><br><span class="line">destructor</span><br><span class="line"></span><br><span class="line">constructor with parameters</span><br><span class="line">default constructor</span><br><span class="line">all elements in s_copy: 100 100 100 100 100 100 100 100 100 100 </span><br><span class="line">destructor</span><br><span class="line">destructor</span><br><span class="line"></span><br><span class="line">default constructor</span><br><span class="line">after adding elements at front, s becomes: 1 2 3 4 5 </span><br><span class="line">after adding elements at the end, s becomes: 1 2 3 4 5 5 4 3 2 1 </span><br><span class="line">after inserting elements in-between, s becomes: 0 1 0 2 0 3 0 4 0 5 5 4 3 2 1 </span><br><span class="line">after deleting from the begining, s becomes: 3 0 4 0 5 5 4 3 2 1 </span><br><span class="line">after deleting from the end, s becomes: 3 0 4 0 5 </span><br><span class="line">after deleting from other positions, s becomes: 3 0 </span><br><span class="line">destructor</span><br><span class="line"></span><br><span class="line">constructor with parameters</span><br><span class="line">at present, s contains following elements: 5 5 5 5 1 2 3 4 5 5 </span><br><span class="line">after removing all elements equal 5, s becomes: 1 2 3 4 </span><br><span class="line">destructor</span><br><span class="line"></span><br><span class="line">default constructor</span><br><span class="line">at present, s contains following elements: 0 1 2 3 4 5 6 7 8 9 </span><br><span class="line">reverse: 9 8 7 6 5 4 3 2 1 0 </span><br><span class="line">reverse again: 0 1 2 3 4 5 6 7 8 9 </span><br><span class="line">destructor</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Data Structures</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Implementations: Doubly Linked List</title>
    <url>/2018/05/26/C-Implementations-Doubly-Linked-List/</url>
    <content><![CDATA[<h1 id="Head-files"><a href="#Head-files" class="headerlink" title="Head files"></a>Head files</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DOUBLYLINKEDLIST_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DOUBLYLINKEDLIST_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoublyLinkedList</span>&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span>;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> size_type;</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// default constructor</span></span><br><span class="line">    DoublyLinkedList(): ptrToHead(<span class="literal">nullptr</span>), count(<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"default constructor"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// constructor with parameters</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">DoublyLinkedList</span><span class="params">(size_type, <span class="keyword">const</span> T&amp;val = T())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// copy constructor</span></span><br><span class="line">    DoublyLinkedList(<span class="keyword">const</span> DoublyLinkedList&amp;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// assignment operator</span></span><br><span class="line">    DoublyLinkedList&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> DoublyLinkedList&amp;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// destructor</span></span><br><span class="line">    ~DoublyLinkedList() &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"destructor"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">clear</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> ptrToHead == <span class="literal">nullptr</span>; &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> count; &#125;</span><br><span class="line">    <span class="function">Node* <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> ptrToHead; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> Node* <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> ptrToHead; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_front</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(size_type, <span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop_front</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(size_type)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">        T data;</span><br><span class="line">        Node* prev;</span><br><span class="line">        Node* next;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Node* ptrToHead;</span><br><span class="line">    size_type count;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node* <span class="title">create</span><span class="params">(<span class="keyword">const</span> T&amp; val)</span></span>&#123;</span><br><span class="line">        Node* new_node = <span class="keyword">new</span> Node;</span><br><span class="line">        new_node-&gt;data = val;</span><br><span class="line">        new_node-&gt;prev = <span class="literal">nullptr</span>;</span><br><span class="line">        new_node-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> new_node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// constructor with parameters:O(n)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">DoublyLinkedList&lt;T&gt;::DoublyLinkedList(size_type n, <span class="keyword">const</span> T&amp;val)&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"constructor with parameters"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        ptrToHead = create(val);</span><br><span class="line">        count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        Node* current = ptrToHead;</span><br><span class="line">        <span class="keyword">while</span>(count != n)&#123;</span><br><span class="line">            current-&gt;next = create(val);</span><br><span class="line">            current-&gt;next-&gt;prev = current;</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">            ++count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// copy constructor: O(n)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">DoublyLinkedList&lt;T&gt;::DoublyLinkedList(<span class="keyword">const</span> DoublyLinkedList&amp; l)</span><br><span class="line">    : ptrToHead(<span class="literal">nullptr</span>), count(<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"copy constructor"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span>(!l.empty())&#123;</span><br><span class="line">        ptrToHead = create(l.<span class="built_in">begin</span>()-&gt;data);</span><br><span class="line">        count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> Node* temp = l.<span class="built_in">begin</span>();</span><br><span class="line">        Node* current = ptrToHead;</span><br><span class="line">        <span class="keyword">while</span>(count != l.<span class="built_in">size</span>())&#123;</span><br><span class="line">            current-&gt;next = create(temp-&gt;next-&gt;data);</span><br><span class="line">            current-&gt;next-&gt;prev = current;</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">            ++count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// assignment operator: O(n)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">DoublyLinkedList&lt;T&gt;&amp; DoublyLinkedList&lt;T&gt;::<span class="keyword">operator</span>= (<span class="keyword">const</span> DoublyLinkedList&amp; l)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"assignment operator"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span>(&amp;l != <span class="keyword">this</span>)&#123;</span><br><span class="line">        <span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">if</span>(!l.empty())&#123;</span><br><span class="line">            ptrToHead = create(l.<span class="built_in">begin</span>()-&gt;data);</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> Node* temp = l.<span class="built_in">begin</span>();</span><br><span class="line">            Node* current = ptrToHead;</span><br><span class="line">            <span class="keyword">while</span>(count != l.<span class="built_in">size</span>())&#123;</span><br><span class="line">                current-&gt;next = create(temp-&gt;next-&gt;data);</span><br><span class="line">                current-&gt;next-&gt;prev = current;</span><br><span class="line">                current = current-&gt;next;</span><br><span class="line">                temp = temp-&gt;next;</span><br><span class="line">                ++count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// O(n)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> DoublyLinkedList&lt;T&gt;::<span class="built_in">clear</span>()&#123;</span><br><span class="line">    Node* current = ptrToHead;</span><br><span class="line">    <span class="keyword">while</span>(current != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        ptrToHead = ptrToHead-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> current;</span><br><span class="line">        current = ptrToHead;</span><br><span class="line">        --count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// O(1)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> DoublyLinkedList&lt;T&gt;::push_front(<span class="keyword">const</span> T&amp; val)&#123;</span><br><span class="line">    Node* new_node = create(val);</span><br><span class="line">    <span class="keyword">if</span>(ptrToHead != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        new_node-&gt;next = ptrToHead;</span><br><span class="line">        ptrToHead-&gt;prev = new_node;</span><br><span class="line">    &#125;</span><br><span class="line">    ptrToHead = new_node;</span><br><span class="line">    ++count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// O(n)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> DoublyLinkedList&lt;T&gt;::push_back(<span class="keyword">const</span> T&amp; val)&#123;</span><br><span class="line">    Node* new_node = create(val);</span><br><span class="line">    <span class="keyword">if</span>(ptrToHead == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        ptrToHead = new_node;</span><br><span class="line">        ++count;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    Node* current = ptrToHead;</span><br><span class="line">    <span class="keyword">while</span>(current-&gt;next != <span class="literal">nullptr</span>)</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line"></span><br><span class="line">    current-&gt;next = new_node;</span><br><span class="line">    new_node-&gt;prev = current;</span><br><span class="line">    ++count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// O(n)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> DoublyLinkedList&lt;T&gt;::insert(size_type <span class="built_in">position</span>, <span class="keyword">const</span> T&amp; val)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">position</span> &lt; <span class="number">1</span> || <span class="built_in">position</span> &gt; <span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">std</span>::domain_error(<span class="string">"Invalid Position"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">position</span> == <span class="number">1</span>)</span><br><span class="line">        push_front(val);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        Node* new_node = create(val);</span><br><span class="line">        Node* current = ptrToHead;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(size_type i = <span class="number">0</span>; i != <span class="built_in">position</span> - <span class="number">1</span>; ++i)</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">        current-&gt;prev-&gt;next = new_node;</span><br><span class="line">        new_node-&gt;next = current;</span><br><span class="line">        new_node-&gt;prev = current-&gt;prev;</span><br><span class="line">        current-&gt;prev = new_node;</span><br><span class="line">        ++count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// O(1)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> DoublyLinkedList&lt;T&gt;::pop_front()&#123; erase(<span class="number">1</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// O(n)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> DoublyLinkedList&lt;T&gt;::pop_back()&#123; erase(<span class="built_in">size</span>()); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// O(n)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> DoublyLinkedList&lt;T&gt;::erase(size_type <span class="built_in">position</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">position</span> &lt; <span class="number">1</span> || <span class="built_in">position</span> &gt; <span class="built_in">size</span>())</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::domain_error(<span class="string">"Invalid Position"</span>);</span><br><span class="line"></span><br><span class="line">    Node* current = ptrToHead;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">size</span>() == <span class="number">1</span>)&#123;</span><br><span class="line">        ptrToHead = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">position</span> == <span class="number">1</span>)&#123;</span><br><span class="line">        ptrToHead = ptrToHead-&gt;next;</span><br><span class="line">        ptrToHead-&gt;prev = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">position</span> == <span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">while</span>(current-&gt;next != <span class="literal">nullptr</span>)</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">        current-&gt;prev-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (size_type i = <span class="number">0</span>; i != <span class="built_in">position</span> - <span class="number">1</span>; ++i)&#123;</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        current-&gt;next-&gt;prev = current-&gt;prev;</span><br><span class="line">        current-&gt;prev-&gt;next = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> current;</span><br><span class="line">    --count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// O(n)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> DoublyLinkedList&lt;T&gt;::<span class="built_in">remove</span>(<span class="keyword">const</span> T&amp; val)&#123;</span><br><span class="line">    Node* current = ptrToHead;</span><br><span class="line">    <span class="keyword">while</span>(current != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(current-&gt;data == val)&#123;</span><br><span class="line">            Node* temp = current-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(current-&gt;prev == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                ptrToHead = ptrToHead-&gt;next;</span><br><span class="line">                <span class="keyword">if</span>(ptrToHead != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    ptrToHead-&gt;prev = <span class="literal">nullptr</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(current-&gt;next == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                current-&gt;prev-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                current-&gt;next-&gt;prev = current-&gt;prev;</span><br><span class="line">                current-&gt;prev-&gt;next = current-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">delete</span> current;</span><br><span class="line">            current = temp;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// O(n)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> DoublyLinkedList&lt;T&gt;::reverse()&#123;</span><br><span class="line">    Node* current = ptrToHead;</span><br><span class="line">    Node* PREV = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>(current != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        current-&gt;prev = current-&gt;next;</span><br><span class="line">        current-&gt;next = PREV;</span><br><span class="line">        PREV = current;</span><br><span class="line">        current = current-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line">    ptrToHead = PREV;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* DOUBLYLINKEDLIST_H_ */</span></span></span><br></pre></td></tr></table></figure>


<h1 id="Test-program-and-results"><a href="#Test-program-and-results" class="headerlink" title="Test program and results"></a>Test program and results</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * this program tests all operations that provided by the</span></span><br><span class="line"><span class="comment"> * DoublyLinkedList&lt;T&gt; class</span></span><br><span class="line"><span class="comment"> * created by Liam on: 28 Apr 2018</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"DoublyLinkedList.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// print and reverse print</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">print</span>(<span class="title">T</span>&amp; <span class="title">l</span>)&#123;</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"print in order: "</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = l.<span class="built_in">begin</span>(); it != <span class="literal">nullptr</span>; it = it-&gt;next)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; it-&gt;data &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span> &lt;&lt; <span class="string">"print in reverse: "</span>;</span><br><span class="line">    <span class="keyword">auto</span> it = l.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span>(it-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        it = it-&gt;next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(it != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; it-&gt;data &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        it = it-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#123;	<span class="comment">// construct an empty linked list</span></span><br><span class="line">    DoublyLinkedList&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">if</span>(s.empty())</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"s is an empty linked list\n"</span></span><br><span class="line">                <span class="string">"the size of s1 is: "</span> &lt;&lt; s.<span class="built_in">size</span>()  &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// call destructor once reaches the end of this block</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#123;	<span class="comment">// construct a linked  list that contains 10 elements, all values are 100</span></span><br><span class="line">    <span class="function">DoublyLinkedList&lt;<span class="keyword">int</span>&gt; <span class="title">s</span><span class="params">(<span class="number">10</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// construct a linked list by copying from s</span></span><br><span class="line">    <span class="function">DoublyLinkedList&lt;<span class="keyword">int</span>&gt; <span class="title">s_copy</span><span class="params">(s)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(!s.empty() &amp;&amp; !s_copy.empty())&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"the size of s is: "</span> &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"the size of s_copy is: "</span> &lt;&lt; s_copy.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// print the contents of s_copy</span></span><br><span class="line">    <span class="built_in">print</span>(s_copy);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// call destructor twice</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#123;	<span class="comment">// assignment</span></span><br><span class="line">    <span class="function">DoublyLinkedList&lt;<span class="keyword">int</span>&gt; <span class="title">s</span><span class="params">(<span class="number">10</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">    DoublyLinkedList&lt;<span class="keyword">int</span>&gt; s_copy;</span><br><span class="line">    s_copy = s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// print the contents of s_copy</span></span><br><span class="line">    <span class="built_in">print</span>(s_copy);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    &#123;	<span class="comment">// push front</span></span><br><span class="line">    DoublyLinkedList&lt;<span class="keyword">double</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">5</span>; i != <span class="number">0</span>; --i)</span><br><span class="line">        s.push_front(i);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"after adding elements at front:\n"</span>;</span><br><span class="line">    <span class="built_in">print</span>(s);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// push back</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">5</span>; i != <span class="number">0</span>; --i)</span><br><span class="line">        s.push_back(i);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"after adding elements at the end:\n"</span>;</span><br><span class="line">        <span class="built_in">print</span>(s);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// insert at position 5</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">5</span>; i != <span class="number">0</span>; --i)</span><br><span class="line">        s.insert(i, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"after inserting elements in-between:\n"</span>;</span><br><span class="line">            <span class="built_in">print</span>(s);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// delete from the begining</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">5</span>; i != <span class="number">0</span>; --i)</span><br><span class="line">        s.pop_front();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"after deleting from the begining:\n"</span>;</span><br><span class="line">    <span class="built_in">print</span>(s);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// delete from the end</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">5</span>; i != <span class="number">0</span>; --i)&#123;</span><br><span class="line">        s.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"after deleting from the end:\n"</span>;</span><br><span class="line">    <span class="built_in">print</span>(s);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// erase at in-between positions</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i != <span class="number">0</span>; --i)</span><br><span class="line">        s.erase(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"after deleting from other positions:\n"</span>;</span><br><span class="line">        <span class="built_in">print</span>(s);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#123;	<span class="comment">// remove</span></span><br><span class="line">    <span class="function">DoublyLinkedList&lt;<span class="keyword">int</span>&gt; <span class="title">s</span><span class="params">(<span class="number">5</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">5</span>; i != <span class="number">0</span>; --i)</span><br><span class="line">        s.insert(<span class="number">5</span>, i);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"at present:\n"</span>;</span><br><span class="line">    <span class="built_in">print</span>(s);</span><br><span class="line"></span><br><span class="line">    s.<span class="built_in">remove</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"after removing all elements:\n"</span>;</span><br><span class="line">    <span class="built_in">print</span>(s);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#123;	<span class="comment">// test reverse function</span></span><br><span class="line">    DoublyLinkedList&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i != <span class="number">10</span>; ++i)</span><br><span class="line">        s.push_back(i);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"at present, s contains following elements:\n"</span>;</span><br><span class="line">    <span class="built_in">print</span>(s);</span><br><span class="line"></span><br><span class="line">    s.reverse();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"after reverse:\n"</span>;</span><br><span class="line">    <span class="built_in">print</span>(s);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Outputs:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">default constructor</span><br><span class="line">s is an empty linked list</span><br><span class="line">the size of s1 is: 0</span><br><span class="line">destructor</span><br><span class="line"></span><br><span class="line">constructor with parameters</span><br><span class="line">copy constructor</span><br><span class="line">the size of s is: 10</span><br><span class="line">the size of s_copy is: 10</span><br><span class="line">print in order: 100 100 100 100 100 100 100 100 100 100 </span><br><span class="line">print in reverse: 100 100 100 100 100 100 100 100 100 100 </span><br><span class="line">destructor</span><br><span class="line">destructor</span><br><span class="line"></span><br><span class="line">constructor with parameters</span><br><span class="line">default constructor</span><br><span class="line">assignment operator</span><br><span class="line">print in order: 100 100 100 100 100 100 100 100 100 100 </span><br><span class="line">print in reverse: 100 100 100 100 100 100 100 100 100 100 </span><br><span class="line">destructor</span><br><span class="line">destructor</span><br><span class="line"></span><br><span class="line">default constructor</span><br><span class="line">after adding elements at front:</span><br><span class="line">print in order: 1 2 3 4 5 </span><br><span class="line">print in reverse: 5 4 3 2 1 </span><br><span class="line">after adding elements at the end:</span><br><span class="line">print in order: 1 2 3 4 5 5 4 3 2 1 </span><br><span class="line">print in reverse: 1 2 3 4 5 5 4 3 2 1 </span><br><span class="line">after inserting elements in-between:</span><br><span class="line">print in order: 0 1 0 2 0 3 0 4 0 5 5 4 3 2 1 </span><br><span class="line">print in reverse: 1 2 3 4 5 5 0 4 0 3 0 2 0 1 0 </span><br><span class="line">after deleting from the begining:</span><br><span class="line">print in order: 3 0 4 0 5 5 4 3 2 1 </span><br><span class="line">print in reverse: 1 2 3 4 5 5 0 4 0 3 </span><br><span class="line">after deleting from the end:</span><br><span class="line">print in order: 3 0 4 0 5 </span><br><span class="line">print in reverse: 5 0 4 0 3 </span><br><span class="line">after deleting from other positions:</span><br><span class="line">print in order: 3 0 </span><br><span class="line">print in reverse: 0 3 </span><br><span class="line">destructor</span><br><span class="line"></span><br><span class="line">constructor with parameters</span><br><span class="line">at present:</span><br><span class="line">print in order: 5 5 5 5 1 2 3 4 5 5 </span><br><span class="line">print in reverse: 5 5 4 3 2 1 5 5 5 5 </span><br><span class="line">after removing all elements:</span><br><span class="line">print in order: 1 2 3 4 </span><br><span class="line">print in reverse: 4 3 2 1 </span><br><span class="line">destructor</span><br><span class="line"></span><br><span class="line">default constructor</span><br><span class="line">at present, s contains following elements:</span><br><span class="line">print in order: 0 1 2 3 4 5 6 7 8 9 </span><br><span class="line">print in reverse: 9 8 7 6 5 4 3 2 1 0 </span><br><span class="line">after reverse:</span><br><span class="line">print in order: 9 8 7 6 5 4 3 2 1 0 </span><br><span class="line">print in reverse: 0 1 2 3 4 5 6 7 8 9 </span><br><span class="line">destructor</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Data Structures</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Implementations: Singly Linked List</title>
    <url>/2018/05/19/C-Implementations-Singly-Linked-List/</url>
    <content><![CDATA[<h1 id="Logical-View"><a href="#Logical-View" class="headerlink" title="Logical View"></a>Logical View</h1><p>How to efficiently store a sequence of values (aka. a List) of a given type is crucial for any non-trivial program due to the limited memory. The way we store or organsize data introduces an important concept, that is, data structures. A data structure is proposed to manage data in a specific way so that we can use it efficiently according to specific needs. </p>
<p>In C++/C, the most common facility we use is so called built-in <strong>array</strong>, which stores a given number of elements in a contiguous memory block. All elements are stored in certain order indicated by their addresses. When we want to access any one of the elements, we pass the order of that element to the computer. Then the computer will calculate the address of that element based on the initial address of the array, and then return us the associated value. Since the addresses are contiguous and the size of memory occupied by the given type is fixed, we can always get any element in constant time: there is only one arithmetic operation needed. Naturally, we can modify any one of elements in constant time as well. However, the shortingcoming is obvious: an array has fixed length. There are two ways to solve this problem, one is that we can preset a large enough size for the array, however, doing so is very inefficient in terms of memory usage. Another way is to dynamically allocated an array when it is needed. However, doing so possibly invalidates all pointers/iterators as all elements are moved to a new allocated storage, which is also very inefficient in terms of time cost(O(n)). Even if the allocated storage is sufficient, any modifications of the array, such as, insert or delete element, also invalidates parts or all of the pointers/iterators, and hence these operations have high time cost: O(n). </p>
<p>An alternative data structure is named <strong>Linked List</strong>, which stores data in a noncontinuous memory space through a manner that each element are connected and ordered by pointers. More specific, an element of a singly linked list is an single object (aka. Linked Node) that contains two members: one is the data stored in the object, and the other is the address (i.e. a pointer variable) of the next element. </p>
<h1 id="Basic-Operations"><a href="#Basic-Operations" class="headerlink" title="Basic Operations"></a>Basic Operations</h1><p>The entrance of a singly linked list is a pointer to the <strong>Head Node</strong>, i.e. the first Linked Node. If the linked list is empty, the pointer to the <strong>Head Node</strong> is a <strong>nullptr</strong>. To access one element, we have to start from the <strong>Head Node</strong> and move one <strong>Node</strong> by one <strong>Node</strong>. Therefore, unlike the array, the time to access elements of the linked list is proportational to the size of the linked list, that is, the time complexity is O(n). Naturally if we want to insert or delete one element into/from the list, we have to find the position or the specific element first. The time complexity is also O(n). One advantage compared to the array is that it doesn’t worry about the size of the storage. We do not need to preset the length of the list and hence no extra memory is wasted. But it does need extra memory for storing the pointer variable in each <strong>Linked Node</strong>. Another advantage is that the operations such as insert or delete doesn’t change other elements, which is crucial for us when we manipulate an object by pointers or iterators. Now let’s briefly summarize these two elementary data structures: Array and Linked List.</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">Array</th>
<th align="left">Linked List</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Cost of accessing an element of an element</td>
<td align="left">O(1)</td>
<td align="left">O(n)</td>
</tr>
<tr>
<td align="left">Memory requirement</td>
<td align="left">Fixed size: used memory and unused memory</td>
<td align="left">No unused memory but need extra memory for pointer variables</td>
</tr>
<tr>
<td align="left">Cost of Inserting or deleting an element</td>
<td align="left">Inserting at beging: O(n); Insering at the end: O(1) if there exists unused memory but O(n) is the array is full; Inserting at middle: O(n)</td>
<td align="left">Inserting at begining:O(1); Inserting at the end: O(n); Inserting at middle: O(n)</td>
</tr>
<tr>
<td align="left">Source:<a href="https://www.youtube.com/watch?v=hNP72JdOIgY&index=17&list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P" target="_blank" rel="noopener">mycodeschool</a></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<p>From above table, we can see that whether to use an array or a linked list depends on that what is the most frequent operation the program performs and what is the size of the data structure.</p>
<h1 id="Implementations"><a href="#Implementations" class="headerlink" title="Implementations"></a>Implementations</h1><p>To define a abstract data type based on the <strong>singly linked list</strong>, the first step is to write the <strong>Linked Node</strong>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    T data;</span><br><span class="line">    Node* next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>The <strong>Node</strong> struct is templated for satisfying different underlying types. It contains two items: one is named <strong>data</strong> which for storing values of <strong>T</strong> type and ther other named <strong>next</strong> which is a pointer to a <strong>Node</strong> object. Next we define the class type based on the singly linked list model described above. In fact, we can incorporate the <strong>Node</strong> type into our singly linked list class as a private member for the purpose of hidding the implementation details. As mentioned above, the only information we know is the pointer to the <strong>Head Node</strong>, therefore, I declare a private member <strong>ptrToHead</strong> to indicate the address of the <strong>Head Node</strong>. Also, I define a unsigned integer to count the number of elements stored in a linked list. For the sake of convenience, I write a private function <strong>create</strong> to create a Node with a particular value. Following code shows the full view of the <strong>SinglyLinkedList</strong> class template. Noting that this implementation is not a <strong>STL</strong> style implementation. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SinglyLinkedList</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>;</span> <span class="comment">// forward declaration</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> X&gt;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(SinglyLinkedList&lt;X&gt;&amp;, </span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">typename</span> SinglyLinkedList&lt;X&gt;::Node*)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span>:</span></span><br><span class="line"><span class="function"></span></span><br><span class="line">    SinglyLinkedList(): ptrToHead(nullptr), count(0) &#123;              // create an empty linked_list</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"default constructor"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">SinglyLinkedList</span><span class="params">(<span class="keyword">const</span> size_type, <span class="keyword">const</span> T&amp; val = T())</span></span>; <span class="comment">// create an linked list with size</span></span><br><span class="line">    SinglyLinkedList(<span class="keyword">const</span> SinglyLinkedList&amp;);                      <span class="comment">// copy constructor</span></span><br><span class="line">    SinglyLinkedList&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> SinglyLinkedList&amp;);          <span class="comment">// assignment operator   </span></span><br><span class="line">    ~SinglyLinkedList();                                            <span class="comment">// destructor</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;                                                   <span class="comment">// clear  </span></span><br><span class="line">    <span class="function">Node* <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> ptrToHead; &#125;                             <span class="comment">// get pointer to Head Node</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> Node* <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> ptrToHead; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> ptrToHead == <span class="literal">nullptr</span>; &#125;             <span class="comment">// check whether is empty    </span></span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> count; &#125;                        <span class="comment">// get the size of the list</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_front</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>;                                      <span class="comment">// insert at begining</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>;                                       <span class="comment">// insert at the end</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(size_type, <span class="keyword">const</span> T&amp;)</span></span>;                               <span class="comment">// insert at the nth position</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop_front</span><span class="params">()</span></span>;                                               <span class="comment">// delete at the begining</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span></span>;                                                <span class="comment">// delete the last element</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(size_type)</span></span>;                                          <span class="comment">// delete at nth position</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">()</span></span>;                                                 <span class="comment">// reverse the order iteratively   </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>;                                          <span class="comment">// remove elements with specific values</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// nested Node type</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">        T data;</span><br><span class="line">        Node* next;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// data members</span></span><br><span class="line">    Node* ptrToHead;</span><br><span class="line">    size_type count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create a new Node</span></span><br><span class="line">    <span class="function">Node* <span class="title">create</span><span class="params">(<span class="keyword">const</span> T&amp; val)</span></span>&#123;</span><br><span class="line">        Node* new_node = <span class="keyword">new</span> Node;</span><br><span class="line">        new_node-&gt;data = val;</span><br><span class="line">        new_node-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> new_node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Let’s define the special members first:</p>
<h2 id="constructors"><a href="#constructors" class="headerlink" title="constructors"></a>constructors</h2><p>The default constructor initializes the <strong>ptrToHead</strong> to <strong>nullptr</strong> and <strong>count</strong> to 0, hence constructs an empty linked list. The second constructor constructs a linked list with a size and a value of <strong>T</strong> type. If no value supplied, the <strong>data</strong> member in each <strong>Node</strong> will be default-initialized or value-initialized depending on whether there exists a user-defined <strong>default constructor</strong> in the definition of <strong>T</strong> type. Also I specify this constructor as <strong>explicit</strong> to avoid potential type conversion. To validate my implementation, I instrument these special members by adding outputs when these members are called. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// constructor that takes a size and a value: O(n)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">SinglyLinkedList</span>&lt;T&gt;:</span>:SinglyLinkedList(size_type n, <span class="keyword">const</span> T&amp; val)&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"constructor with parameters"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        ptrToHead = create(val);</span><br><span class="line">        count = <span class="number">1</span>;</span><br><span class="line">        Node* temp = ptrToHead;</span><br><span class="line">        <span class="keyword">while</span>(count != n)&#123;</span><br><span class="line">            temp-&gt;next = create(val);</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">            ++count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The logic is simple: first create the <strong>Head Node</strong> and store its address into <strong>ptrToHead</strong>, at the same time, update the count to 1 representing that currently we have one element in our linked list; Then, create the rest Nodes and link one by one. We use a temporary pointer to move forward as we don’t want to modify the <strong>ptrToHead</strong>. The time cost is proportional to the length of the linked list and therefore the time complexity is big oh of n, where n represents the number of elements stored in the linked list.</p>
<p>Next is the copy constructor which controls the copy operation. The definition is similar to above constructor except that, the copy constructor constructs an object using values stored in the argument. If the argument is an empty linked list, we construct an empty linked list as well through the initialization list. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// copy constructor: O(n)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">SinglyLinkedList</span>&lt;T&gt;:</span>:SinglyLinkedList(<span class="keyword">const</span> SinglyLinkedList&amp; l): ptrToHead(<span class="literal">nullptr</span>), count(<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"copy constructor"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span>(!l.empty())&#123;</span><br><span class="line">        ptrToHead = create(l.<span class="built_in">begin</span>()-&gt;data);</span><br><span class="line">        count = <span class="number">1</span>;</span><br><span class="line">        Node* temp1 = ptrToHead;</span><br><span class="line">        <span class="keyword">const</span> Node* temp2 = l.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">while</span>(count != l.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            temp1-&gt;next = create(temp2-&gt;next-&gt;data);</span><br><span class="line">            temp1 = temp1-&gt;next;</span><br><span class="line">            temp2 = temp2-&gt;next;</span><br><span class="line">            ++count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The assignment operator is similar to our copy costructor except that it needs to obliterate the old values stored in the left-hand side operand. If the argument is an empty linked list, we only need to execute the <strong>clear()</strong> function to delete all nodes (if exist) to get an empty linked list. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// assignment operator: O(n)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">SinglyLinkedList</span>&lt;T&gt;&amp; <span class="title">SinglyLinkedList</span>&lt;T&gt;:</span>:<span class="keyword">operator</span>= (<span class="keyword">const</span> SinglyLinkedList&amp; l)&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"assignment operator"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span>(&amp;l != <span class="keyword">this</span>)&#123;</span><br><span class="line">        <span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">if</span>(!l.empty())&#123;</span><br><span class="line">            ptrToHead = create(l.<span class="built_in">begin</span>()-&gt;data);</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">            Node* temp1 = ptrToHead;</span><br><span class="line">            <span class="keyword">const</span> Node* temp2 = l.<span class="built_in">begin</span>();</span><br><span class="line">            <span class="keyword">while</span>(count != l.<span class="built_in">size</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                temp1-&gt;next = create(temp2-&gt;next-&gt;data);</span><br><span class="line">                temp1 = temp1-&gt;next;</span><br><span class="line">                temp2 = temp2-&gt;next;</span><br><span class="line">                ++count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="destructor-amp-clear-member"><a href="#destructor-amp-clear-member" class="headerlink" title="destructor &amp; clear member"></a>destructor &amp; clear member</h2><p>The destructor is implemented by executing the <strong>clear()</strong> function. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// destructor</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">SinglyLinkedList</span>&lt;T&gt;:</span>:~SinglyLinkedList() &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"destructor"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// clear function: the time complexity O(n)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">SinglyLinkedList</span>&lt;T&gt;:</span>:<span class="built_in">clear</span>()&#123;</span><br><span class="line">    Node* current = ptrToHead;</span><br><span class="line">    <span class="keyword">while</span>(current != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ptrToHead = ptrToHead-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> current;</span><br><span class="line">        current = ptrToHead;</span><br><span class="line">        --count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Due to the <strong>ptrToHead</strong> is the only entrance for us, we cannot delete it directly. Therefore, we do it by virtue of a temporary pointer, which points to the Node to be deleted. For example, let it points to the Head Node, then we can release the <strong>ptrToHead</strong> and let the <strong>ptrToHead</strong> points to our next Node, and then we clear the Head Node by delete the temporary pointer. </p>
<h2 id="push-front-push-back-insert"><a href="#push-front-push-back-insert" class="headerlink" title="push_front, push_back, insert"></a>push_front, push_back, insert</h2><p>The <strong>push_front</strong> means that we can add a new element at the very begining of our linked list. It is simple to do this, making the <strong>ptrToHead</strong> points to our new Node. But noting that when the linked list is not empty, we should stores the address of the original Head Node into the <strong>next</strong> member of our new Node. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// insert at begining: O(1)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">SinglyLinkedList</span>&lt;T&gt;:</span>:push_front(<span class="keyword">const</span> T&amp; val) &#123;</span><br><span class="line">	Node* new_node = create(val);</span><br><span class="line">	<span class="keyword">if</span>(ptrToHead != <span class="literal">nullptr</span>)</span><br><span class="line">		new_node-&gt;next = ptrToHead;</span><br><span class="line">	ptrToHead = new_node;</span><br><span class="line">	++count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The case of appending a new Node at the end of the linked list is a little bit complex. The function is shown below.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// insert at the end: O(n)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">SinglyLinkedList</span>&lt;T&gt;:</span>:push_back(<span class="keyword">const</span> T&amp; val) &#123;</span><br><span class="line">	Node* new_node = create(val);</span><br><span class="line">	<span class="keyword">if</span>(ptrToHead == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">		ptrToHead = new_node;</span><br><span class="line">		++count;</span><br><span class="line">		pointToHead-&gt;data &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Node* temp = ptrToHead;</span><br><span class="line">	<span class="keyword">while</span>(temp-&gt;next != <span class="literal">nullptr</span>)</span><br><span class="line">		temp = temp-&gt;next;</span><br><span class="line">	temp-&gt;next = new_node;</span><br><span class="line">	++count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>If the linked list is empty, we simply create a new Node and let <strong>ptrToHead</strong> points to the new Node. If the linked list is not empty, we need to let the <strong>next</strong> member of the last Node points to the newly created Node. To find the address of the last Node, we use the condition:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">temp-&gt;next == <span class="literal">nullptr</span></span><br></pre></td></tr></table></figure>
<p>This condition stops the while loop and by then, <strong>temp</strong> is the address of the last Node. </p>
<p>Now we consider the case that inserting a new Node at the <strong>n</strong>th position, where <strong>n</strong> is in the range [1, size()]. The case that we insert a new Node at the first position can be tanckled by the <strong>push_front</strong> function. </p>
<p>The graph below illustrate a 5-Node linked list and the case that we intend to insert the new Node at a non-Head position. For example, we insert at the third position, that is, when n == 3:</p>
<p><img src="/images/insertatbegining.png" alt="Singly Linked List Example"></p>
<p>We can observe that:</p>
<ol>
<li>the newly created Node becomes the third Node and the original third Node becomes the fourth Node.</li>
<li>before inserting  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">add2-&gt;next &#x3D;&#x3D; add2</span><br></pre></td></tr></table></figure>
 after inserting <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">add2-&gt;next &#x3D;&#x3D; addx</span><br></pre></td></tr></table></figure></li>
<li>to link following Nodes, we let <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">addx-&gt;next &#x3D;&#x3D; add3</span><br></pre></td></tr></table></figure>
Now everything is clear: if we want to insert at the <strong>n</strong>th position, we have to find the <strong>n-1</strong> position and link the <strong>n-1</strong>th Node to the newly created Node. Let’s starting from the <strong>ptrToHead</strong> and show the relations between Nodes, Addresses and Iteration times:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">        counter i       Address         Node</span><br><span class="line">when    i &#x3D; 0           ptrToHead       1st Node</span><br><span class="line">        i &#x3D; 1           add2            2ed Node</span><br><span class="line">        i &#x3D; 2           add3            3ed Node</span><br><span class="line">        ...             ...             ...</span><br><span class="line">        i &#x3D; n - 2       add(n - 1)      n - 1 Node</span><br><span class="line">        i &#x3D; n - 1       addn            n Node</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>Obviously, we will stop our loop when <strong>i == n - 2</strong> and by then we can manipulate the <strong>n - 1</strong> Node. Following code shows a full view of the <strong>insert</strong> function.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// insert at the nth position, n belongs to [1, size()]: O(n)</span></span><br><span class="line"><span class="comment">// the positions means that we add the new node after (n-1)th position</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">SinglyLinkedList</span>&lt;T&gt;:</span>:insert(size_type <span class="built_in">position</span>, <span class="keyword">const</span> T&amp; val)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">position</span> &lt; <span class="number">1</span> || <span class="built_in">position</span> &gt; <span class="built_in">size</span>())</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::domain_error(<span class="string">"Invalid Position"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">position</span> == <span class="number">1</span>)</span><br><span class="line">        push_front(val);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        Node* new_node = create(val);</span><br><span class="line">        Node* temp = ptrToHead;</span><br><span class="line">        <span class="keyword">for</span>(size_type i = <span class="number">0</span>; i != <span class="built_in">position</span> - <span class="number">2</span>; ++i)</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        new_node-&gt;next = temp-&gt;next;</span><br><span class="line">        temp-&gt;next = new_node;</span><br><span class="line">        ++count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="pop-front-pop-back-erase"><a href="#pop-front-pop-back-erase" class="headerlink" title="pop_front, pop_back, erase"></a>pop_front, pop_back, erase</h2><p>The idea behind these three functions are similar to the inserting operations described above. Hence no further discussion here. </p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">// delete at the begining: O(1)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">SinglyLinkedList</span>&lt;T&gt;:</span>:pop_front()&#123;</span><br><span class="line">	<span class="keyword">if</span>(ptrToHead == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="built_in">std</span>::domain_error(<span class="string">"Empty Linked List"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Node* temp = ptrToHead;</span><br><span class="line">	ptrToHead = ptrToHead-&gt;next;</span><br><span class="line">	<span class="keyword">delete</span> temp;</span><br><span class="line">	--count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// delete the last element: O(n)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">SinglyLinkedList</span>&lt;T&gt;:</span>:pop_back()&#123;</span><br><span class="line">	<span class="keyword">if</span>(ptrToHead == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="built_in">std</span>::domain_error(<span class="string">"Empty Linked List"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    erase(<span class="built_in">size</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// delete at nth position: O(n)</span></span><br><span class="line"><span class="comment">// n belongs to [1, size()], the position after n - 1</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">SinglyLinkedList</span>&lt;T&gt;:</span>:erase(size_type <span class="built_in">position</span>)&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">position</span> &lt; <span class="number">1</span> || <span class="built_in">position</span> &gt; <span class="built_in">size</span>())</span><br><span class="line">		<span class="keyword">throw</span> <span class="built_in">std</span>::domain_error(<span class="string">"Invalid Position"</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">position</span> == <span class="number">1</span>)</span><br><span class="line">		pop_front();</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		Node* current = ptrToHead;</span><br><span class="line">		<span class="keyword">for</span> (size_type i = <span class="number">0</span>; i != <span class="built_in">position</span><span class="number">-2</span>; ++i)</span><br><span class="line">			current = current-&gt;next;</span><br><span class="line">		Node* temp = current-&gt;next;</span><br><span class="line">		current-&gt; next = temp-&gt;next;</span><br><span class="line">		<span class="keyword">delete</span> temp;</span><br><span class="line">		--count;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#<span class="meta"># remove</span></span><br><span class="line"><span class="comment">// remove elements with specific values: O(n^2)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">SinglyLinkedList</span>&lt;T&gt;:</span>:<span class="built_in">remove</span>(<span class="keyword">const</span> T&amp; val)&#123;</span><br><span class="line">	Node* current = ptrToHead;</span><br><span class="line">	size_type i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(current != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(current-&gt;data == val)&#123;</span><br><span class="line">			current = current-&gt;next;</span><br><span class="line">			erase(i + <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			current = current-&gt;next;</span><br><span class="line">			++i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">The remove function allows us to remove all elements that contains data values equal to a supplied value. My solution is to find the positions of the Nodes that should be removed and then call the **erase** function by passing the position. Taking an example(see below graph), suppose one want to remove any element that has value **v3**, we should find the previous position, that is, **2ed Node**, and then break the link and rebuilt the link between **2ed Node** and **4th Node** through:</span><br></pre></td></tr></table></figure>
<p>temp = add2-&gt;next<br>temp = temp-&gt;next</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">![Remove operation](&#x2F;images&#x2F;remove.PNG)</span><br><span class="line"></span><br><span class="line">If we loop through the linked list starting from the **ptrToHead**, the mapping relations are as follows:</span><br></pre></td></tr></table></figure>
<pre><code>counter i       values           position</code></pre><p>when    i = 0           v1               1<br>        i = 1           v2               2<br>        i = 2           v3               3<br>        …             …              …<br>        i = n - 2       v(n - 1)         n - 1<br>        i = n - 1       vn               n</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">When i &#x3D;&#x3D; 2, the position that should be deleted is positioned at **i+1**. Therefore, we pass **i+1** to the **erase** function. But noting that before we delete the Node, we should let **current** points to the Node that closely followed the Node to be deleted. In addition, we should not advance the counter **i** as now the Node pointed by **current** hasn&#39;t be checked. But if a Node doesn&#39;t satisfy the condition, we move forward the **current** as well as the counter **i**. </span><br><span class="line"></span><br><span class="line">## reverse</span><br><span class="line">In our **SinglyLinkedList**, we define two **reverse** functions, one of which is a member defined based on iteration while the other one is a non-member function defined based on recursion. </span><br><span class="line">​&#96;&#96;&#96;c++</span><br><span class="line">&#x2F;&#x2F; reverse the order: iteration version O(n)</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">void SinglyLinkedList&lt;T&gt;::reverse()&#123;</span><br><span class="line">	Node* prev &#x3D; nullptr;</span><br><span class="line">	Node* current &#x3D; ptrToHead;</span><br><span class="line">	Node* next;</span><br><span class="line">	while(current !&#x3D; nullptr)&#123;</span><br><span class="line">		next &#x3D; current-&gt;next;</span><br><span class="line">		current-&gt;next &#x3D; prev;</span><br><span class="line">		prev &#x3D; current;</span><br><span class="line">		current &#x3D; next;</span><br><span class="line">	&#125;</span><br><span class="line">	ptrToHead &#x3D; prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The basic idea behind the <strong>reverse</strong> function is that let each Node stores the address of the previous Node.<br>The initial information is that: </p>
<ol>
<li>the previous address for the Head Node is <strong>nullptr</strong></li>
<li>the current address for the Head Node is <strong>ptrToHead</strong></li>
</ol>
<p>There are four steps in each iteration:</p>
<ol>
<li>temporarily stores the address of next Node as <strong>next = current-&gt;next</strong> will be rewrite </li>
<li>rewrite the <strong>current-&gt;next</strong> with the previous address</li>
<li>in next iteration, the previous address is the current address in this iteration, hence let <strong>prev = current</strong></li>
<li>in next iteration, the current address is the next address in this iteration, hence let <strong>current = next</strong></li>
</ol>
<p>The recursive version starts from the last Node but still uses the same idea. Don’t forget to add this function template as the friend of our <strong>SinglyLinkedList</strong> class. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// reverse the order: recursion version O(n)</span></span><br><span class="line"><span class="comment">// space complexity: O(n)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> X&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(SinglyLinkedList&lt;X&gt;&amp; l, <span class="keyword">typename</span> SinglyLinkedList&lt;X&gt;::Node* p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(p-&gt;next == <span class="literal">nullptr</span> || l.empty())&#123;</span><br><span class="line">		l.ptrToHead = p;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	reverse(l, p-&gt;next);</span><br><span class="line">	<span class="keyword">typename</span> SinglyLinkedList&lt;X&gt;::Node* q = p-&gt;next;</span><br><span class="line">	q-&gt;next = p;</span><br><span class="line">	p-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h2><p>I have tested every member in this class template and the results show that this <strong>SinglyLinkedList</strong> works perfectly. Please find the test program and results below:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * this program tests all operations that provided by the</span></span><br><span class="line"><span class="comment"> * SinglyLinkedList&lt;T&gt; class</span></span><br><span class="line"><span class="comment"> * created by Liam on: 28 Apr 2018</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SinglyLinkedList.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">print</span>(<span class="title">T</span>&amp; <span class="title">l</span>)&#123;</span></span><br><span class="line">    <span class="keyword">auto</span> it = l.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">for</span>(; it != <span class="literal">nullptr</span>; it = it-&gt;next)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; it-&gt;data &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#123;	<span class="comment">// construct an empty linked list</span></span><br><span class="line">    SinglyLinkedList&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">if</span>(s.empty())</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"s is an empty linked list\n"</span></span><br><span class="line">                <span class="string">"the size of s1 is: "</span> &lt;&lt; s.<span class="built_in">size</span>()  &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// call destructor once reaches the end of this block</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#123;	<span class="comment">// construct a linked  list that contains 10 elements, all values are 100</span></span><br><span class="line">    <span class="function">SinglyLinkedList&lt;<span class="keyword">int</span>&gt; <span class="title">s</span><span class="params">(<span class="number">10</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// construct a linked list by copying from s</span></span><br><span class="line">    <span class="function">SinglyLinkedList&lt;<span class="keyword">int</span>&gt; <span class="title">s_copy</span><span class="params">(s)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(!s.empty() &amp;&amp; !s_copy.empty())&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"the size of s is: "</span> &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"the size of s_copy is: "</span> &lt;&lt; s_copy.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// print the contents of s</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"all elements in s: "</span>;</span><br><span class="line">    <span class="built_in">print</span>(s);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// call destructor twice</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#123;	<span class="comment">// assignment</span></span><br><span class="line">    <span class="function">SinglyLinkedList&lt;<span class="keyword">int</span>&gt; <span class="title">s</span><span class="params">(<span class="number">10</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">    SinglyLinkedList&lt;<span class="keyword">int</span>&gt; s_copy;</span><br><span class="line">    s_copy = s;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// print the contents of s</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#123;	<span class="comment">// push front</span></span><br><span class="line">    SinglyLinkedList&lt;<span class="keyword">double</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">5</span>; i != <span class="number">0</span>; --i)</span><br><span class="line">        s.push_front(i);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"after adding elements at front, s becomes: "</span>;</span><br><span class="line">    <span class="built_in">print</span>(s);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// push back</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">5</span>; i != <span class="number">0</span>; --i)</span><br><span class="line">        s.push_back(i);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"after adding elements at the end, s becomes: "</span>;</span><br><span class="line">        <span class="built_in">print</span>(s);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// insert at position 5</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">5</span>; i != <span class="number">0</span>; --i)</span><br><span class="line">        s.insert(i, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"after inserting elements in-between, s becomes: "</span>;</span><br><span class="line">            <span class="built_in">print</span>(s);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// delete from the begining</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">5</span>; i != <span class="number">0</span>; --i)</span><br><span class="line">        s.pop_front();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"after deleting from the begining, s becomes: "</span>;</span><br><span class="line">    <span class="built_in">print</span>(s);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// delete from the end</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">5</span>; i != <span class="number">0</span>; --i)</span><br><span class="line">        s.pop_back();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"after deleting from the end, s becomes: "</span>;</span><br><span class="line">    <span class="built_in">print</span>(s);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// erase at in-between positions</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i != <span class="number">0</span>; --i)</span><br><span class="line">        s.erase(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"after deleting from other positions, s becomes: "</span>;</span><br><span class="line">        <span class="built_in">print</span>(s);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#123;	<span class="comment">// remove</span></span><br><span class="line">    <span class="function">SinglyLinkedList&lt;<span class="keyword">int</span>&gt; <span class="title">s</span><span class="params">(<span class="number">5</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">5</span>; i != <span class="number">0</span>; --i)</span><br><span class="line">        s.insert(<span class="number">5</span>, i);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"at present, s contains following elements: "</span>;</span><br><span class="line">    <span class="built_in">print</span>(s);</span><br><span class="line"></span><br><span class="line">    s.<span class="built_in">remove</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"after removing all elements equal 5, s becomes: "</span>;</span><br><span class="line">    <span class="built_in">print</span>(s);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#123;	<span class="comment">// test reverse function</span></span><br><span class="line">    SinglyLinkedList&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i != <span class="number">10</span>; ++i)</span><br><span class="line">        s.push_back(i);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"at present, s contains following elements: "</span>;</span><br><span class="line">        <span class="built_in">print</span>(s);</span><br><span class="line"></span><br><span class="line">    s.reverse();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"reverse: "</span>;</span><br><span class="line">        <span class="built_in">print</span>(s);</span><br><span class="line"></span><br><span class="line">    s.reverse();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"reverse again: "</span>;</span><br><span class="line">        <span class="built_in">print</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Outputs:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">default constructor</span><br><span class="line">s is an empty linked list</span><br><span class="line">the size of s1 is: 0</span><br><span class="line">destructor</span><br><span class="line"></span><br><span class="line">constructor with parameters</span><br><span class="line">copy constructor</span><br><span class="line">the size of s is: 10</span><br><span class="line">the size of s_copy is: 10</span><br><span class="line">all elements in s: 100 100 100 100 100 100 100 100 100 100 </span><br><span class="line">destructor</span><br><span class="line">destructor</span><br><span class="line"></span><br><span class="line">constructor with parameters</span><br><span class="line">default constructor</span><br><span class="line">assignment operator</span><br><span class="line">destructor</span><br><span class="line">destructor</span><br><span class="line"></span><br><span class="line">default constructor</span><br><span class="line">after adding elements at front, s becomes: 1 2 3 4 5 </span><br><span class="line">after adding elements at the end, s becomes: 1 2 3 4 5 5 4 3 2 1 </span><br><span class="line">after inserting elements in-between, s becomes: 0 1 0 2 0 3 0 4 0 5 5 4 3 2 1 </span><br><span class="line">after deleting from the begining, s becomes: 3 0 4 0 5 5 4 3 2 1 </span><br><span class="line">after deleting from the end, s becomes: 3 0 4 0 5 </span><br><span class="line">after deleting from other positions, s becomes: 3 0 </span><br><span class="line">destructor</span><br><span class="line"></span><br><span class="line">constructor with parameters</span><br><span class="line">at present, s contains following elements: 5 5 5 5 1 2 3 4 5 5 </span><br><span class="line">after removing all elements equal 5, s becomes: 1 2 3 4 </span><br><span class="line">destructor</span><br><span class="line"></span><br><span class="line">default constructor</span><br><span class="line">at present, s contains following elements: 0 1 2 3 4 5 6 7 8 9 </span><br><span class="line">reverse: 9 8 7 6 5 4 3 2 1 0 </span><br><span class="line">reverse again: 0 1 2 3 4 5 6 7 8 9 </span><br><span class="line">destructor</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Data Structures</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Sorting Algorithms C++ Implementations - Quick Sort</title>
    <url>/2018/05/18/Sorting-Algorithms-C-Implementations-Quick-Sort/</url>
    <content><![CDATA[<h1 id="Quick-Sort"><a href="#Quick-Sort" class="headerlink" title="Quick Sort"></a>Quick Sort</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*----------------------------------------------------------------------------- </span></span><br><span class="line"><span class="comment"> * main.cpp || Created on: 18 May 2018 || Author: Liam</span></span><br><span class="line"><span class="comment"> *-----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * this program tests three implementations of the quick sort algorithm</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Logic:</span></span><br><span class="line"><span class="comment"> * 1. select an element from the sequence as the pivot and rearrange the</span></span><br><span class="line"><span class="comment"> *    sequence such that all elements less than the pivot are towards the left</span></span><br><span class="line"><span class="comment"> * of it and all elements greater than the pivot are towards the right of it.</span></span><br><span class="line"><span class="comment"> * 2. above process is called partitioning of the sequence. we recursively</span></span><br><span class="line"><span class="comment"> *    partition the sequence till that there is only one element left in each</span></span><br><span class="line"><span class="comment"> *    segment.</span></span><br><span class="line"><span class="comment"> * 3. for convenience, we can always select the last element as the pivot. If</span></span><br><span class="line"><span class="comment"> *    so, we may encounter the case that the position of the pivot</span></span><br><span class="line"><span class="comment"> *    is still at the end (or begining) of the rearranged sequence. Such case is</span></span><br><span class="line"><span class="comment"> *    the worst case and the time complexity is O(n^). To achieve an average</span></span><br><span class="line"><span class="comment"> *    case, in which the time complexity is O(nlogn), we can randomly select</span></span><br><span class="line"><span class="comment"> *    the pivot and then put the pivot at the end of the sequence for the</span></span><br><span class="line"><span class="comment"> *    rearangement.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Complexity analysis:</span></span><br><span class="line"><span class="comment"> *  time complexity:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Best case: always be balanced at the midpoint in each partition</span></span><br><span class="line"><span class="comment"> *  T(n) = 2T(n/2) + cn</span></span><br><span class="line"><span class="comment"> *  	 = 2^k T(n/2^k) + kcn</span></span><br><span class="line"><span class="comment"> *  	 where k = logn</span></span><br><span class="line"><span class="comment"> *  	 therefore = O(nlogn)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Average case: when randomly selected as any one of the position,</span></span><br><span class="line"><span class="comment"> *  	          the partition index or iterator is an average index</span></span><br><span class="line"><span class="comment"> *  T(n) = T(n - i) + T(i - 1) + cn</span></span><br><span class="line"><span class="comment"> *  	 = 1/n * summation(T(n - i) + T(i - 1)) + cn</span></span><br><span class="line"><span class="comment"> *  	 = O(nlogn)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Worst case: unblanced in each partition</span></span><br><span class="line"><span class="comment"> *  T(n) = T(n - 1) + cn</span></span><br><span class="line"><span class="comment"> *  	 = T(n - 2) + c(n - 1) + cn</span></span><br><span class="line"><span class="comment"> *  	 = T(n - k) + c(n - k + 1 + ... + n)</span></span><br><span class="line"><span class="comment"> *  	 where k = n-1</span></span><br><span class="line"><span class="comment"> *  	 therefore</span></span><br><span class="line"><span class="comment"> *  	 T(n) = T(1) + c*(2 + 3 + ... + n)</span></span><br><span class="line"><span class="comment"> *  	 	  = O(n^2)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * auxiliary space: (non-stable) worst-case = O(1)</span></span><br><span class="line"><span class="comment"> *-----------------------------------------------------------------------------      </span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p> <strong>Implementations</strong><br> <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">ifndef</span> SORTINGALGORITHMS_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SORTINGALGORITHMS_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// array-based version, first always is the index to indicate the</span></span><br><span class="line"><span class="comment">// first position of a sequence, last is the index to indicate the</span></span><br><span class="line"><span class="comment">// last position of a sequence. partitionIndex is the split point</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="title">Partition</span><span class="params">(T*p, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> first, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> last)</span></span>&#123;</span><br><span class="line">    T pivot = p[last];</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> partitionIndex = first;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">std</span>::<span class="keyword">size_t</span> i = first; i != last; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p[i] &lt;= pivot)&#123;</span><br><span class="line">            T temp = p[i];</span><br><span class="line">            p[i] = p[partitionIndex];</span><br><span class="line">            p[partitionIndex] = temp;</span><br><span class="line">            ++partitionIndex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    T temp = p[partitionIndex];</span><br><span class="line">    p[partitionIndex] = p[last];</span><br><span class="line">    p[last] = temp;</span><br><span class="line">    <span class="keyword">return</span> partitionIndex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(T*p, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> first, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> last)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(first &gt;= last) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> partitionIndex = Partition(p, first, last);</span><br><span class="line">    <span class="keyword">if</span>(partitionIndex != <span class="number">0</span>)&#123;</span><br><span class="line">        QuickSort(p, first, partitionIndex - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    QuickSort(p, partitionIndex + <span class="number">1</span>, last);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// iterator-based version STL style (C++11)</span></span><br><span class="line"><span class="comment">// partitionIter denotes the position of the</span></span><br><span class="line"><span class="comment">// split point</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> BidirrectionalIterator&gt;</span><br><span class="line"><span class="function">BidirrectionalIterator <span class="title">Partition</span><span class="params">(BidirrectionalIterator <span class="built_in">begin</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">		BidirrectionalIterator <span class="built_in">end</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> pivot = <span class="built_in">std</span>::prev(<span class="built_in">end</span>);</span><br><span class="line">    <span class="keyword">auto</span> partitionIter = <span class="built_in">begin</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> iter = <span class="built_in">begin</span>; iter != pivot; ++iter)&#123;</span><br><span class="line">        <span class="keyword">if</span>(*iter &lt;= *pivot)&#123;</span><br><span class="line">            <span class="built_in">std</span>::iter_swap(iter, partitionIter);</span><br><span class="line">            ++partitionIter;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::iter_swap(partitionIter, pivot);</span><br><span class="line">    <span class="keyword">return</span> partitionIter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> BidirrectionalIterator&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(BidirrectionalIterator <span class="built_in">begin</span>, BidirrectionalIterator <span class="built_in">end</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">std</span>::distance(<span class="built_in">begin</span>, <span class="built_in">end</span>) &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">auto</span> partitionIter = Partition(<span class="built_in">begin</span>, <span class="built_in">end</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">std</span>::prev(partitionIter) != <span class="built_in">begin</span>)&#123;</span><br><span class="line">        QuickSort(<span class="built_in">begin</span>, partitionIter);</span><br><span class="line">    &#125;</span><br><span class="line">    QuickSort(<span class="built_in">std</span>::next(partitionIter), <span class="built_in">end</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// user-defined comparator + improved using random selected pivot</span></span><br><span class="line"><span class="comment">// return a random integer in the range [0, n)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nrand</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span> || n &gt; RAND_MAX)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::domain_error(<span class="string">"Argument to nrand is out of range"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> bucket_size = RAND_MAX /n;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> r = rand() / bucket_size;</span><br><span class="line">    <span class="keyword">while</span>(r &gt;= n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> BidirrectionalIterator, <span class="keyword">typename</span> Comparator&gt;</span><br><span class="line"><span class="function">BidirrectionalIterator <span class="title">Partition</span><span class="params">(BidirrectionalIterator <span class="built_in">begin</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">		BidirrectionalIterator <span class="built_in">end</span>, Comparator comp)</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::srand (<span class="built_in">std</span>::time(<span class="literal">nullptr</span>));</span><br><span class="line">    <span class="keyword">auto</span> randomIndex = nrand(<span class="built_in">std</span>::distance(<span class="built_in">begin</span>, <span class="built_in">end</span>));</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; randomIndex &lt;&lt; <span class="string">"nihao"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">auto</span> pivot = <span class="built_in">std</span>::prev(<span class="built_in">end</span>);</span><br><span class="line">    <span class="built_in">std</span>::iter_swap(pivot, <span class="built_in">std</span>::next(<span class="built_in">begin</span>, randomIndex));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> partitionIter = <span class="built_in">begin</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> iter = <span class="built_in">begin</span>; iter != pivot; ++iter)&#123;</span><br><span class="line">        <span class="keyword">if</span>(comp(*iter, *pivot))&#123;</span><br><span class="line">            <span class="built_in">std</span>::iter_swap(iter, partitionIter);</span><br><span class="line">            ++partitionIter;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::iter_swap(partitionIter, pivot);</span><br><span class="line">    <span class="keyword">return</span> partitionIter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> BidirrectionalIterator, <span class="keyword">typename</span> Comparator&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(BidirrectionalIterator <span class="built_in">begin</span>, BidirrectionalIterator <span class="built_in">end</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        Comparator comp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">std</span>::distance(<span class="built_in">begin</span>, <span class="built_in">end</span>) &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">auto</span> partitionIter = Partition(<span class="built_in">begin</span>, <span class="built_in">end</span>, comp);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">std</span>::prev(partitionIter) != <span class="built_in">begin</span>)&#123;</span><br><span class="line">        QuickSort(<span class="built_in">begin</span>, partitionIter, comp);</span><br><span class="line">    &#125;</span><br><span class="line">    QuickSort(<span class="built_in">std</span>::next(partitionIter), <span class="built_in">end</span>, comp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* SORTINGALGORITHMS_H_ */</span></span></span><br></pre></td></tr></table></figure></p>
<p><strong>Test program-main.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;	// std::cout, endl</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;	// std::string</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;		// std::list</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;	// std::vector</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SortingAlgorithms.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">list</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// struct defined for testing</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span>&#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// comparator 1</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">compare_age</span>(<span class="title">const</span> <span class="title">T</span>&amp; <span class="title">x</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">y</span>)&#123;</span></span><br><span class="line">    <span class="keyword">return</span> x.age &lt; y.age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// comparator 2</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">compare_name</span>(<span class="title">const</span> <span class="title">T</span>&amp; <span class="title">x</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">y</span>)&#123;</span></span><br><span class="line">    <span class="keyword">return</span> x.name &lt; y.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// test 1: array-based version</span></span><br><span class="line">    <span class="keyword">double</span> arr[<span class="number">10</span>] = &#123;<span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    QuickSort(arr, <span class="number">0</span>, <span class="number">9</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Sorted array: "</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i != <span class="number">10</span>; ++i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// test 2: iterator-based version</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">str</span><span class="params">(<span class="string">"eclipseworkspace"</span>)</span></span>;</span><br><span class="line">    QuickSort(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Sorted string "</span> &lt;&lt; str &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; l&#123;<span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    QuickSort(l.<span class="built_in">begin</span>(), l.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Sorted list: "</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i: l)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// test 3: user-defined comparator</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;student&gt; students;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>)&#123;</span><br><span class="line">        student temp;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; temp.name &gt;&gt; temp.age;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">cin</span>)</span><br><span class="line">            students.push_back(temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    QuickSort(students.<span class="built_in">begin</span>(), students.<span class="built_in">end</span>(), compare_age&lt;student&gt;);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Sorted vector according to age:\n"</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i: students)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i.name &lt;&lt; <span class="string">" "</span> &lt;&lt; i.age &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">    QuickSort(students.<span class="built_in">begin</span>(), students.<span class="built_in">end</span>(), compare_name&lt;student&gt;);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Sorted vector according to name:\n"</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i: students)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i.name &lt;&lt; <span class="string">" "</span> &lt;&lt; i.age &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Outputs:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sorted array: 1 2 3 4 5 6 7 8 9 10 </span><br><span class="line">Sorted string acceeeiklopprssw</span><br><span class="line">Sorted list: 1 2 3 4 5 6 7 8 9 10 </span><br><span class="line">John 18</span><br><span class="line">Mike 16</span><br><span class="line">Liam 23</span><br><span class="line">Anna 26</span><br><span class="line">Bobo 21</span><br><span class="line">2nihao</span><br><span class="line">1nihao</span><br><span class="line">1nihao</span><br><span class="line">Sorted vector according to age:</span><br><span class="line">Mike 16</span><br><span class="line">John 18</span><br><span class="line">Bobo 21</span><br><span class="line">Liam 23</span><br><span class="line">Anna 26</span><br><span class="line">2nihao</span><br><span class="line">1nihao</span><br><span class="line">Sorted vector according to name:</span><br><span class="line">Anna 26</span><br><span class="line">Bobo 21</span><br><span class="line">John 18</span><br><span class="line">Liam 23</span><br><span class="line">Mike 16</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Sorting Algorithms C++ Implementations - Merge Sort</title>
    <url>/2018/05/17/Sorting-Algorithms-C-Implementations-Merge-Sort/</url>
    <content><![CDATA[<h1 id="Merge-Sort"><a href="#Merge-Sort" class="headerlink" title="Merge Sort"></a>Merge Sort</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*----------------------------------------------------------------------------- </span></span><br><span class="line"><span class="comment"> * main.cpp || Created on: 16 May 2018 || Author: Liam</span></span><br><span class="line"><span class="comment"> *-----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * this program tests three implementation of the merge sort algorithm.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Logic:</span></span><br><span class="line"><span class="comment"> * 1. recursively partition the sequence a mid point, until that there is only</span></span><br><span class="line"><span class="comment"> *    one element left, that is when it cannot be partitioned further.</span></span><br><span class="line"><span class="comment"> * 2. each pair of partitioned parts will be rearranged in non-decreasing order.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Complexity analysis:</span></span><br><span class="line"><span class="comment"> * time complexity: Best, Average, Worst = O(nlogn)</span></span><br><span class="line"><span class="comment"> * auxiliary space: worst-case = O(n)</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *-----------------------------------------------------------------------------      </span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p><strong>Implementations:</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SORTINGALGORITHMS_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SORTINGALGORITHMS_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// array-based version</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(T* left, <span class="built_in">std</span>::<span class="keyword">size_t</span> left_size, T* right, <span class="built_in">std</span>::<span class="keyword">size_t</span> right_size)</span></span>&#123;</span><br><span class="line">    T left_copy[left_size];</span><br><span class="line">    T right_copy[right_size];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* O(n): n = left_size + right_size */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">std</span>::<span class="keyword">size_t</span> i = <span class="number">0</span>; i != left_size; ++i)</span><br><span class="line">        left_copy[i] = left[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">std</span>::<span class="keyword">size_t</span> i = <span class="number">0</span>; i != right_size; ++i)</span><br><span class="line">        right_copy[i] = right[i];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* O(n): n = left_size + right_size */</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> i, j, k;</span><br><span class="line">    i = j = k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i != left_size &amp;&amp; j != right_size)&#123;</span><br><span class="line">        <span class="keyword">if</span>(left_copy[i] &lt;= right_copy[j])&#123;</span><br><span class="line">            left[k] = left_copy[i];</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            left[k] = right_copy[j];</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        ++k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(i != left_size)&#123;</span><br><span class="line">        left[k] = left_copy[i];</span><br><span class="line">        ++i;</span><br><span class="line">        ++k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(j != right_size)&#123;</span><br><span class="line">        left[k] = right_copy[j];</span><br><span class="line">        ++j;</span><br><span class="line">        ++k;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(T* p, <span class="built_in">std</span>::<span class="keyword">size_t</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> mid = n/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(mid == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    MergeSort(p, mid);</span><br><span class="line">    MergeSort(p + mid, n - mid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* O(n): n = n*/</span></span><br><span class="line">    Merge(p, mid, p + mid, n - mid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// iterator-based version STL style (C++11)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ForwardIterator&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(ForwardIterator <span class="built_in">begin</span>, ForwardIterator midIterator,</span></span></span><br><span class="line"><span class="function"><span class="params">        ForwardIterator <span class="built_in">end</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;ForwardIterator&gt;::value_type Type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* O(n), n = end - begin*/</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Type&gt; <span class="title">left</span><span class="params">(<span class="built_in">begin</span>, midIterator)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Type&gt; <span class="title">right</span><span class="params">(midIterator, <span class="built_in">end</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> iter_l = left.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">auto</span> iter_r = right.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* O(n), n = end - begin*/</span></span><br><span class="line">    <span class="keyword">while</span>(iter_l != left.<span class="built_in">end</span>() &amp;&amp; iter_r != right.<span class="built_in">end</span>())&#123;</span><br><span class="line">        *<span class="built_in">begin</span>++ = *iter_l &lt;= *iter_r ? *iter_l++ : *iter_r++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::copy(iter_l, left.<span class="built_in">end</span>(), <span class="built_in">begin</span>);</span><br><span class="line">    <span class="built_in">std</span>::copy(iter_r, right.<span class="built_in">end</span>(), <span class="built_in">begin</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ForwardIterator&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(ForwardIterator <span class="built_in">begin</span>, ForwardIterator <span class="built_in">end</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// O(1) for random access iterator</span></span><br><span class="line">    <span class="comment">// O(n) for others: n = end - begin</span></span><br><span class="line">    <span class="keyword">auto</span> mid = <span class="built_in">std</span>::distance(<span class="built_in">begin</span>, <span class="built_in">end</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(mid == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// O(1) for random access iterator</span></span><br><span class="line">    <span class="comment">// O(n) for others: n = end - begin</span></span><br><span class="line">    <span class="keyword">auto</span> midIterator = <span class="built_in">std</span>::next(<span class="built_in">begin</span>, mid);</span><br><span class="line">    MergeSort(<span class="built_in">begin</span>, midIterator);</span><br><span class="line">    MergeSort(midIterator, <span class="built_in">end</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// O(n): n = end - begin</span></span><br><span class="line">    Merge(<span class="built_in">begin</span>, midIterator, <span class="built_in">end</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// iterator-based version with user-defined comparator</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ForwardIterator, <span class="keyword">typename</span> Comparator&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(ForwardIterator <span class="built_in">begin</span>, ForwardIterator midIterator,</span></span></span><br><span class="line"><span class="function"><span class="params">        ForwardIterator <span class="built_in">end</span>, Comparator comp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;ForwardIterator&gt;::value_type Type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* O(n), n = end - begin*/</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Type&gt; <span class="title">left</span><span class="params">(<span class="built_in">begin</span>, midIterator)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Type&gt; <span class="title">right</span><span class="params">(midIterator, <span class="built_in">end</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> iter_l = left.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">auto</span> iter_r = right.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* O(n), n = end - begin*/</span></span><br><span class="line">    <span class="keyword">while</span>(iter_l != left.<span class="built_in">end</span>() &amp;&amp; iter_r != right.<span class="built_in">end</span>())&#123;</span><br><span class="line">        *<span class="built_in">begin</span>++ = comp(*iter_l, *iter_r) ? *iter_l++ : *iter_r++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::copy(iter_l, left.<span class="built_in">end</span>(), <span class="built_in">begin</span>);</span><br><span class="line">    <span class="built_in">std</span>::copy(iter_r, right.<span class="built_in">end</span>(), <span class="built_in">begin</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ForwardIterator, <span class="keyword">typename</span> Comparator&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(ForwardIterator <span class="built_in">begin</span>, ForwardIterator <span class="built_in">end</span>, Comparator comp)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// O(1) for random access iterator</span></span><br><span class="line">    <span class="comment">// O(n) for others: n = end - begin</span></span><br><span class="line">    <span class="keyword">auto</span> mid = <span class="built_in">std</span>::distance(<span class="built_in">begin</span>, <span class="built_in">end</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(mid == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// O(1) for random access iterator</span></span><br><span class="line">    <span class="comment">// O(n) for others: n = end - begin</span></span><br><span class="line">    <span class="keyword">auto</span> midIterator = <span class="built_in">std</span>::next(<span class="built_in">begin</span>, mid);</span><br><span class="line">    MergeSort(<span class="built_in">begin</span>, midIterator, comp);</span><br><span class="line">    MergeSort(midIterator, <span class="built_in">end</span>, comp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// O(n): n = end - begin</span></span><br><span class="line">    Merge(<span class="built_in">begin</span>, midIterator, <span class="built_in">end</span>, comp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* SORTINGALGORITHMS_H_ */</span></span></span><br></pre></td></tr></table></figure>

<p><strong>Test program-main.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;	// std::cout, endl</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;	// std::string</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;		// std::list</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;	// std::vector</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SortingAlgorithms.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">list</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// struct defined for testing</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span>&#123;</span></span><br><span class="line">	<span class="built_in">string</span> name;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// comparator 1</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">compare_age</span>(<span class="title">const</span> <span class="title">T</span>&amp; <span class="title">x</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">y</span>)&#123;</span></span><br><span class="line">	<span class="keyword">return</span> x.age &lt;= y.age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// comparator 2</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">compare_name</span>(<span class="title">const</span> <span class="title">T</span>&amp; <span class="title">x</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">y</span>)&#123;</span></span><br><span class="line">	<span class="keyword">return</span> x.name &lt;= y.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// test 1: array-based version</span></span><br><span class="line">    <span class="keyword">double</span> arr[<span class="number">10</span>] = &#123;<span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    MergeSort(arr, <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Sorted array: "</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i != <span class="number">10</span>; ++i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// test 2: iterator-based version</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">str</span><span class="params">(<span class="string">"eclipseworkspace"</span>)</span></span>;</span><br><span class="line">    MergeSort(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Sorted string "</span> &lt;&lt; str &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; l&#123;<span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    MergeSort(l.<span class="built_in">begin</span>(), l.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Sorted list: "</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i: l)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// test 3: user-defined comparator</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;student&gt; students;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>)&#123;</span><br><span class="line">        student temp;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; temp.name &gt;&gt; temp.age;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">cin</span>)</span><br><span class="line">            students.push_back(temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MergeSort(students.<span class="built_in">begin</span>(), students.<span class="built_in">end</span>(), compare_age&lt;student&gt;);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Sorted vector according to age:\n"</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i: students)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i.name &lt;&lt; <span class="string">" "</span> &lt;&lt; i.age &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">    MergeSort(students.<span class="built_in">begin</span>(), students.<span class="built_in">end</span>(), compare_name&lt;student&gt;);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Sorted vector according to name:\n"</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i: students)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i.name &lt;&lt; <span class="string">" "</span> &lt;&lt; i.age &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Outputs:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sorted array: 1 2 3 4 5 6 7 8 9 10 </span><br><span class="line">Sorted string acceeeiklopprssw</span><br><span class="line">Sorted list: 1 2 3 4 5 6 7 8 9 10 </span><br><span class="line">John 18</span><br><span class="line">Mike 16</span><br><span class="line">Liam 23</span><br><span class="line">Anna 26</span><br><span class="line">Bobo 21</span><br><span class="line">Sorted vector according to age:</span><br><span class="line">Mike 16</span><br><span class="line">John 18</span><br><span class="line">Bobo 21</span><br><span class="line">Liam 23</span><br><span class="line">Anna 26</span><br><span class="line">Sorted vector according to name:</span><br><span class="line">Anna 26</span><br><span class="line">Bobo 21</span><br><span class="line">John 18</span><br><span class="line">Liam 23</span><br><span class="line">Mike 16</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Sorting Algorithms C++ Implementations - Insertion Sort</title>
    <url>/2018/05/15/Sorting-Algorithms-C-Implementations-Insertion-Sort/</url>
    <content><![CDATA[<h1 id="Insertion-Sort"><a href="#Insertion-Sort" class="headerlink" title="Insertion Sort"></a>Insertion Sort</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*----------------------------------------------------------------------------- </span></span><br><span class="line"><span class="comment"> * main.cpp || Created on: 15 May 2018 || Author: Liam</span></span><br><span class="line"><span class="comment"> *-----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * this program tests three versions of insertion sort implementations.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Logic:</span></span><br><span class="line"><span class="comment"> * 1. the sequence can always be divided into two parts: sorted and unsorted.</span></span><br><span class="line"><span class="comment"> * 	  We loop thru from the second position to the last position, before each</span></span><br><span class="line"><span class="comment"> * 	  loop, the elements on the left-side of the position are sorted. we can</span></span><br><span class="line"><span class="comment"> * 	  call this position as sortedIndex. After each loop, [0, sortedIndex] is</span></span><br><span class="line"><span class="comment"> * 	  sorted, and then we forward the sortedIndex 1 position.</span></span><br><span class="line"><span class="comment"> * 2. in each loop, an embeded iteration starts from the initial position to</span></span><br><span class="line"><span class="comment"> * 	  the prev of the sortedIndex, or in reverse order, from the prev of the</span></span><br><span class="line"><span class="comment"> * 	  sortedIndex to the begining, comparing each value denoted in the range</span></span><br><span class="line"><span class="comment"> * 	  with the value denoted by sortedIndex. When found the first element that</span></span><br><span class="line"><span class="comment"> * 	  is greater than the value denoted by sortedIndex, we insert here</span></span><br><span class="line"><span class="comment"> * 	  the element denoted by sortedIndex.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Complexity analysis:</span></span><br><span class="line"><span class="comment"> * time complexity: Best = O(n), Average, Worst O(n^2)</span></span><br><span class="line"><span class="comment"> * auxiliary space: worst-case = O(1)</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *-----------------------------------------------------------------------------      </span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p><strong>Implementations</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SORTINGALGORITHMS_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SORTINGALGORITHMS_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// array-based version</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">InsertionSort</span>(<span class="title">T</span>* <span class="title">p</span>, <span class="title">std</span>:</span>:<span class="keyword">size_t</span> n)&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">std</span>::<span class="keyword">size_t</span> i = <span class="number">1</span>; i != n; ++i)&#123;</span><br><span class="line">        T value = p[i];</span><br><span class="line">        <span class="built_in">std</span>::<span class="keyword">size_t</span> sortedIndex = i;</span><br><span class="line">        <span class="comment">// the left-side of the sortedIndex is sorted</span></span><br><span class="line">        <span class="keyword">while</span>(sortedIndex &gt;<span class="number">0</span> &amp;&amp; p[sortedIndex - <span class="number">1</span>] &gt; value)&#123;</span><br><span class="line">            p[sortedIndex] = p[sortedIndex - <span class="number">1</span>];</span><br><span class="line">            sortedIndex = sortedIndex - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p[sortedIndex] = value;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// iterator-based version STL-stype (C++11)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ForwardIterator&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertionSort</span><span class="params">(ForwardIterator <span class="built_in">begin</span>, ForwardIterator <span class="built_in">end</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">begin</span> == <span class="built_in">end</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = <span class="built_in">std</span>::next(<span class="built_in">begin</span>); iter != <span class="built_in">end</span>; ++iter)&#123;</span><br><span class="line">        <span class="keyword">auto</span> insertPoint = <span class="built_in">std</span>::upper_bound(<span class="built_in">begin</span>, iter, *iter); <span class="comment">// logN</span></span><br><span class="line">        <span class="built_in">std</span>::rotate(insertPoint, iter, <span class="built_in">std</span>::next(iter));		 <span class="comment">// N</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// iterator-based version with comparator</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ForwardIterator, <span class="keyword">typename</span> Comparator&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertionSort</span><span class="params">(ForwardIterator <span class="built_in">begin</span>, ForwardIterator <span class="built_in">end</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        Comparator comp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">begin</span> == <span class="built_in">end</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = <span class="built_in">std</span>::next(<span class="built_in">begin</span>); iter != <span class="built_in">end</span>; ++iter)&#123;</span><br><span class="line">        <span class="keyword">auto</span> insertPoint = <span class="built_in">std</span>::upper_bound(<span class="built_in">begin</span>, iter, *iter, comp);</span><br><span class="line">        <span class="built_in">std</span>::rotate(insertPoint, iter, <span class="built_in">std</span>::next(iter));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* SORTINGALGORITHMS_H_ */</span></span></span><br></pre></td></tr></table></figure>

<p><strong>Test program-main.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; // std::cin, cout, endl</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;	// std::vector</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;	// std::string</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;		// std::list</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SortingAlgorithms.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">list</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// struct defined for testing</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span>&#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// comparator 1</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">compare_age</span>(<span class="title">const</span> <span class="title">T</span>&amp; <span class="title">x</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">y</span>)&#123;</span></span><br><span class="line">    <span class="keyword">return</span> x.age &lt; y.age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// comparator 2</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">compare_name</span>(<span class="title">const</span> <span class="title">T</span>&amp; <span class="title">x</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">y</span>)&#123;</span></span><br><span class="line">    <span class="keyword">return</span> x.name &lt; y.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// test 1: array-based version</span></span><br><span class="line">    <span class="keyword">double</span> arr[<span class="number">10</span>] = &#123;<span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    InsertionSort(arr, arr+ <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Sorted array: "</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i != <span class="number">10</span>; ++i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// test 2: iterator-based version</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">str</span><span class="params">(<span class="string">"eclipseworkspace"</span>)</span></span>;</span><br><span class="line">    InsertionSort(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Sorted string "</span> &lt;&lt; str &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; l&#123;<span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    InsertionSort(l.<span class="built_in">begin</span>(), l.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Sorted list: "</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i: l)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// test 3: user-defined comparator</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;student&gt; students;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>)&#123;</span><br><span class="line">        student temp;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; temp.name &gt;&gt; temp.age;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">cin</span>)</span><br><span class="line">            students.push_back(temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    InsertionSort(students.<span class="built_in">begin</span>(), students.<span class="built_in">end</span>(), compare_age&lt;student&gt;);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Sorted vector according to age:\n"</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i: students)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i.name &lt;&lt; <span class="string">" "</span> &lt;&lt; i.age &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">    InsertionSort(students.<span class="built_in">begin</span>(), students.<span class="built_in">end</span>(), compare_name&lt;student&gt;);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Sorted vector according to name:\n"</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i: students)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i.name &lt;&lt; <span class="string">" "</span> &lt;&lt; i.age &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>Outputs</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sorted array: 1 2 3 4 5 6 7 8 9 10 </span><br><span class="line">Sorted string acceeeiklopprssw</span><br><span class="line">Sorted list: 1 2 3 4 5 6 7 8 9 10 </span><br><span class="line">John 18</span><br><span class="line">Mike 16</span><br><span class="line">Liam 23</span><br><span class="line">Anna 26</span><br><span class="line">Bobo 21</span><br><span class="line">Sorted vector according to age:</span><br><span class="line">Mike 16</span><br><span class="line">John 18</span><br><span class="line">Bobo 21</span><br><span class="line">Liam 23</span><br><span class="line">Anna 26</span><br><span class="line">Sorted vector according to name:</span><br><span class="line">Anna 26</span><br><span class="line">Bobo 21</span><br><span class="line">John 18</span><br><span class="line">Liam 23</span><br><span class="line">Mike 16</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ - Revisiting character pictures</title>
    <url>/2018/05/14/C-Revisiting-character-pictures/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Notes</tag>
      </tags>
  </entry>
  <entry>
    <title>Sorting Algorithms C++ Implementations - Bubble Sort</title>
    <url>/2018/05/14/Sorting-Algorithms-C-Implementations-Bubble-Sort/</url>
    <content><![CDATA[<h1 id="Bubble-Sort"><a href="#Bubble-Sort" class="headerlink" title="Bubble Sort"></a>Bubble Sort</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*-----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * main.cpp || Created on: 13 May 2018 || Author: Liam</span></span><br><span class="line"><span class="comment"> *-----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * this program tests the bubble sort algorithm implemented in three ways</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Logic:</span></span><br><span class="line"><span class="comment"> * 1. each time find the largest number of the unsorted sequence and put it at</span></span><br><span class="line"><span class="comment"> *    the last position of the sequence. Then the unsorted sequence becomes the</span></span><br><span class="line"><span class="comment"> *    sequence, which is the original sequence excludes the last element.</span></span><br><span class="line"><span class="comment"> *	      * compare adjacent numbers one pair by one pair from the begining</span></span><br><span class="line"><span class="comment"> *	        position to the second last position, and exchange the position of</span></span><br><span class="line"><span class="comment"> * 	        two numbers if left-side number is larger than the right-side number</span></span><br><span class="line"><span class="comment"> * 	      * after each iteration, right-most position of the unsorted sequence</span></span><br><span class="line"><span class="comment"> * 	        holds the largest element, and hence the unsorted sequence becomes</span></span><br><span class="line"><span class="comment"> *    		the sequence, which is the original sequence excludes the last</span></span><br><span class="line"><span class="comment"> * 	        element.</span></span><br><span class="line"><span class="comment"> * 2. repectively perform step 1. There are two cases that the iteration stops:</span></span><br><span class="line"><span class="comment"> * 	      * the unsorted sequence only has one number left</span></span><br><span class="line"><span class="comment"> *            * there is no any exchange happens in last iteration, which means that</span></span><br><span class="line"><span class="comment"> *              all elements are in order already. Therefore, we do not need to</span></span><br><span class="line"><span class="comment"> *              perform step 1 again. In this case, we get the best time complexity</span></span><br><span class="line"><span class="comment"> *              if the sequence is completely sorted after the first iteration.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Complexity analysis:</span></span><br><span class="line"><span class="comment"> * time complexity: Best = O(n), Average, Worst = O(n^2)</span></span><br><span class="line"><span class="comment"> * auxiliary space: worst-case = O(1)</span></span><br><span class="line"><span class="comment"> *-----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p> <strong>Implementations</strong><br> <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">ifndef</span> SORTINGALGORITHMS_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SORTINGALGORITHMS_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// array based version</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(T* p, <span class="built_in">std</span>::<span class="keyword">size_t</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">std</span>::<span class="keyword">size_t</span> i = n<span class="number">-1</span>; i != <span class="number">0</span>; --i)&#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">std</span>::<span class="keyword">size_t</span> j = <span class="number">0</span>; j != i; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p[j] &gt; p[j+<span class="number">1</span>])&#123;</span><br><span class="line">                T temp = p[j];</span><br><span class="line">                p[j] = p[j+<span class="number">1</span>];</span><br><span class="line">                p[j+<span class="number">1</span>] = temp;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="literal">true</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// iterator based version STL style (c++11)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> BidirectionalIterator&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(BidirectionalIterator <span class="built_in">begin</span>, BidirectionalIterator <span class="built_in">end</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">begin</span> == <span class="built_in">end</span>)  <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> endIter = <span class="built_in">std</span>::prev(<span class="built_in">end</span>); endIter != <span class="built_in">begin</span>; --endIter)&#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> iter = <span class="built_in">begin</span>; iter != endIter; ++iter)&#123;</span><br><span class="line">            <span class="keyword">auto</span> iterNext = <span class="built_in">std</span>::next(iter);</span><br><span class="line">            <span class="keyword">if</span>(*iter &gt; *iterNext)&#123;</span><br><span class="line">                <span class="built_in">std</span>::iter_swap(iter, iterNext);</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="literal">true</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// iterator based version with user-defined comparator</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> BidirectionalIterator, <span class="keyword">typename</span> Comparator&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(BidirectionalIterator <span class="built_in">begin</span>, BidirectionalIterator <span class="built_in">end</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        Comparator comp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">begin</span> == <span class="built_in">end</span>)  <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> endIter = <span class="built_in">std</span>::prev(<span class="built_in">end</span>); endIter != <span class="built_in">begin</span>; --endIter)&#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> iter = <span class="built_in">begin</span>; iter != endIter; ++iter)&#123;</span><br><span class="line">            <span class="keyword">auto</span> iterNext = <span class="built_in">std</span>::next(iter);</span><br><span class="line">            <span class="keyword">if</span>(comp(*iterNext, *iter))&#123;</span><br><span class="line">                <span class="built_in">std</span>::iter_swap(iter, iterNext);</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="literal">true</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* SORTINGALGORITHMS_H_ */</span></span></span><br></pre></td></tr></table></figure></p>
<p><strong>Test Program-main.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SortingAlgorithms.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">list</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// struct defined for testing</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span>&#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// comparator 1</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">compare_age</span>(<span class="title">const</span> <span class="title">T</span>&amp; <span class="title">x</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">y</span>)&#123;</span></span><br><span class="line">    <span class="keyword">return</span> x.age &lt; y.age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// comparator 2</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">compare_name</span>(<span class="title">const</span> <span class="title">T</span>&amp; <span class="title">x</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">y</span>)&#123;</span></span><br><span class="line">    <span class="keyword">return</span> x.name &lt; y.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// test 1: array-based version</span></span><br><span class="line">    <span class="keyword">double</span> arr[<span class="number">10</span>] = &#123;<span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    BubbleSort(arr, arr+ <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Sorted array: "</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i != <span class="number">10</span>; ++i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// test 2: iterator-based version</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">str</span><span class="params">(<span class="string">"eclipseworkspace"</span>)</span></span>;</span><br><span class="line">    BubbleSort(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Sorted string "</span> &lt;&lt; str &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; l&#123;<span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    BubbleSort(l.<span class="built_in">begin</span>(), l.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Sorted list: "</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i: l)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// test 3: user-defined comparator</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;student&gt; students;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>)&#123;</span><br><span class="line">        student temp;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; temp.name &gt;&gt; temp.age;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">cin</span>)</span><br><span class="line">            students.push_back(temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BubbleSort(students.<span class="built_in">begin</span>(), students.<span class="built_in">end</span>(), compare_age&lt;student&gt;);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Sorted vector according to age:\n"</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i: students)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i.name &lt;&lt; <span class="string">" "</span> &lt;&lt; i.age &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">    BubbleSort(students.<span class="built_in">begin</span>(), students.<span class="built_in">end</span>(), compare_name&lt;student&gt;);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Sorted vector according to name:\n"</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i: students)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i.name &lt;&lt; <span class="string">" "</span> &lt;&lt; i.age &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Outputs:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sorted array: 1 2 3 4 5 6 7 8 9 10 </span><br><span class="line">Sorted string acceeeiklopprssw</span><br><span class="line">Sorted list: 1 2 3 4 5 6 7 8 9 10 </span><br><span class="line">John 18</span><br><span class="line">Mike 16</span><br><span class="line">Liam 23</span><br><span class="line">Anna 26</span><br><span class="line">Bobo 21</span><br><span class="line">Sorted vector according to age:</span><br><span class="line">Mike 16</span><br><span class="line">John 18</span><br><span class="line">Bobo 21</span><br><span class="line">Liam 23</span><br><span class="line">Anna 26</span><br><span class="line">Sorted vector according to name:</span><br><span class="line">Anna 26</span><br><span class="line">Bobo 21</span><br><span class="line">John 18</span><br><span class="line">Liam 23</span><br><span class="line">Mike 16</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Sorting Algorithms C++ Implementations-Selection Sort</title>
    <url>/2018/05/09/Sorting-Algorithms-C-Implementations/</url>
    <content><![CDATA[<h1 id="Selection-Sort"><a href="#Selection-Sort" class="headerlink" title="Selection Sort"></a>Selection Sort</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*-----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * Created on: 9 May 2018 || Author: Liam</span></span><br><span class="line"><span class="comment"> *-----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * This file contains three generic functions that implement</span></span><br><span class="line"><span class="comment"> * the selection sort algorithm, and a test program</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Logical steps:</span></span><br><span class="line"><span class="comment"> * 1. select the minimum value from the sequence</span></span><br><span class="line"><span class="comment"> * 2. put the minimun value in the first position</span></span><br><span class="line"><span class="comment"> * 3. ignore the first position and sort the remaining</span></span><br><span class="line"><span class="comment"> *	  sequence by repetitively executing step 1 and 2</span></span><br><span class="line"><span class="comment"> *	  till the last number</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Complexity analysis:</span></span><br><span class="line"><span class="comment"> * time complexity: Best, Average and Worst-case = O(n^2)</span></span><br><span class="line"><span class="comment"> * auxiliary space: worst-case = O(1)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *-----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p><strong>Implementations</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SORTINGALGORITHMS_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SORTINGALGORITHMS_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// built-in array-based version</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectionSort</span><span class="params">(T* p, <span class="built_in">std</span>::<span class="keyword">size_t</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">std</span>::<span class="keyword">size_t</span> i = <span class="number">0</span>; i != n<span class="number">-1</span>; ++i)&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="keyword">size_t</span> imin = i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">std</span>::<span class="keyword">size_t</span> j = imin+<span class="number">1</span>; j != n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(p[i] &gt; p[j])</span><br><span class="line">                    imin = j;</span><br><span class="line">            &#125;</span><br><span class="line">            T temp = p[i];</span><br><span class="line">            p[i] = p[imin];</span><br><span class="line">            p[imin] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// iterator-based version STL style (C++11)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ForwardIterator&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectionSort</span><span class="params">(ForwardIterator <span class="built_in">begin</span>, ForwardIterator <span class="built_in">end</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">begin</span> != <span class="built_in">end</span>; ++<span class="built_in">begin</span>)&#123;</span><br><span class="line">        <span class="keyword">auto</span> imin = <span class="built_in">std</span>::min_element(<span class="built_in">begin</span>, <span class="built_in">end</span>);</span><br><span class="line">        <span class="keyword">if</span>(imin != <span class="built_in">begin</span>)</span><br><span class="line">            <span class="built_in">std</span>::iter_swap(<span class="built_in">begin</span>, imin);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// iterator-based version with comparator</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ForwardIterator, <span class="keyword">typename</span> Comparator&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectionSort</span><span class="params">(ForwardIterator <span class="built_in">begin</span>, ForwardIterator <span class="built_in">end</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        Comparator comp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">begin</span> != <span class="built_in">end</span>; ++<span class="built_in">begin</span>)&#123;</span><br><span class="line">        <span class="keyword">auto</span> imin = <span class="built_in">std</span>::min_element(<span class="built_in">begin</span>, <span class="built_in">end</span>, comp);</span><br><span class="line">        <span class="keyword">if</span>(imin != <span class="built_in">begin</span>)</span><br><span class="line">            <span class="built_in">std</span>::iter_swap(<span class="built_in">begin</span>, imin);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* SORTINGALGORITHMS_H_ */</span></span></span><br></pre></td></tr></table></figure>

<p><strong>Test Program-main.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;	// std::cout, endl</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;	// std::string</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;		// std::list</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;	// std::vector</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SortingAlgorithms.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">list</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// struct defined for testing</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span>&#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// comparator 1</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">compare_age</span>(<span class="title">const</span> <span class="title">T</span>&amp; <span class="title">x</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">y</span>)&#123;</span></span><br><span class="line">    <span class="keyword">return</span> x.age &lt; y.age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// comparator 2</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">compare_name</span>(<span class="title">const</span> <span class="title">T</span>&amp; <span class="title">x</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">y</span>)&#123;</span></span><br><span class="line">    <span class="keyword">return</span> x.name &lt; y.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// test 1: array-based version</span></span><br><span class="line">    <span class="keyword">double</span> arr[<span class="number">10</span>] = &#123;<span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    SelectionSort(arr, arr+ <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Sorted array: "</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i != <span class="number">10</span>; ++i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// test 2: iterator-based version</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">str</span><span class="params">(<span class="string">"eclipseworkspace"</span>)</span></span>;</span><br><span class="line">    SelectionSort(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Sorted string "</span> &lt;&lt; str &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; l&#123;<span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    SelectionSort(l.<span class="built_in">begin</span>(), l.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Sorted list: "</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i: l)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// test 3: user-defined comparator</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;student&gt; students;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>)&#123;</span><br><span class="line">        student temp;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; temp.name &gt;&gt; temp.age;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">cin</span>)</span><br><span class="line">            students.push_back(temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SelectionSort(students.<span class="built_in">begin</span>(), students.<span class="built_in">end</span>(), compare_age&lt;student&gt;);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Sorted vector according to age:\n"</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i: students)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i.name &lt;&lt; <span class="string">" "</span> &lt;&lt; i.age &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">    SelectionSort(students.<span class="built_in">begin</span>(), students.<span class="built_in">end</span>(), compare_name&lt;student&gt;);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Sorted vector according to name:\n"</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i: students)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i.name &lt;&lt; <span class="string">" "</span> &lt;&lt; i.age &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Outputs:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sorted array: 1 2 3 4 5 6 7 8 9 10 </span><br><span class="line">Sorted string acceeeiklopprssw</span><br><span class="line">Sorted list: 1 2 3 4 5 6 7 8 9 10 </span><br><span class="line">John 18</span><br><span class="line">Mike 16</span><br><span class="line">Liam 23</span><br><span class="line">Anna 26</span><br><span class="line">Bobo 21</span><br><span class="line">Sorted vector according to age:</span><br><span class="line">Mike 16</span><br><span class="line">John 18</span><br><span class="line">Bobo 21</span><br><span class="line">Liam 23</span><br><span class="line">Anna 26</span><br><span class="line">Sorted vector according to name:</span><br><span class="line">Anna 26</span><br><span class="line">Bobo 21</span><br><span class="line">John 18</span><br><span class="line">Liam 23</span><br><span class="line">Mike 16</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ - Managing memory (almost) automatically</title>
    <url>/2018/05/09/C-Managing-memory-almost-automatically/</url>
    <content><![CDATA[<p>In last chapter, we write a new class named <strong>Student_info</strong> to encapsulate the pointer to <strong>Core</strong> so that we do not need to concern about the memory management. Now we’ll further improve our class by seperating the class into two classes: one is a pure interface class and the other is a single pointerlike class which manages the underlying memory. The purpose to do so is that we then can use the pointerlike class with mutiple interface classes. In addition, by doing so, we can avoid copying objects unnecessarily. So what do we mean by saying <strong>copy an object</strong>? If an object <strong>x</strong> refers to an object <strong>y</strong>, does copying <strong>x</strong> cause <strong>y</strong> to be copied too ?</p>
<ol>
<li>if <strong>y</strong> is a memer of <strong>x</strong>, the answer must be yes</li>
<li>if <strong>x</strong> is nothing but a pointer to <strong>y</strong>, the answer is no.</li>
</ol>
<p>This chapter defines three versions of our pointerlike class, each of which differs from the others in how it defines copying. </p>
<h1 id="Handles-that-copy-their-objects"><a href="#Handles-that-copy-their-objects" class="headerlink" title="Handles that copy their objects"></a>Handles that copy their objects</h1><p>It is known that <strong>pointer</strong> is a primitive, low-level data structure. Working with <strong>pointers</strong> directly may leads to severe mistakes due to the fact that <strong>pointers</strong> are independent of the objects to which they point(Koenig and Moo 2000): </p>
<p><em>1. Copying a pointer doesn’t copy the corresponding object, leading to surprises if two pointers inadvertently point to the same object.</em> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>);   <span class="comment">// p: pointer to an int object that has value 10</span></span><br><span class="line"><span class="keyword">int</span>* q = p;             <span class="comment">// q: points to the same int object </span></span><br><span class="line">*q = <span class="number">100</span>;               <span class="comment">// if we modify the object pointed by q</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *p;             <span class="comment">// we inevitably changes the object pointed by p</span></span><br><span class="line">                        <span class="comment">// the output is 100</span></span><br></pre></td></tr></table></figure>
<p><em>2. Destroying a pointer doesn’t destroy its object, leading to memory leaks.</em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nameless</span><span class="params">(<span class="keyword">size_t</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="keyword">int</span>[n];<span class="comment">// local variable p is destroyed when this function </span></span><br><span class="line">&#125;                       <span class="comment">// finishes, however, the dynamically allocated                                  // array still exists on the heap.</span></span><br></pre></td></tr></table></figure>
<p><em>3. Deleting an object without destroying a pointer to it leads to a dangling pointer, which causes undefined behavior if the program uses the pointer.</em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>);   <span class="comment">// p: pointer to an int object that has value 10</span></span><br><span class="line"><span class="keyword">int</span>* q = p;             <span class="comment">// q: points to the same int object </span></span><br><span class="line"><span class="keyword">delete</span> p;               <span class="comment">// destroy the object pointed by p</span></span><br><span class="line">p = <span class="literal">nullptr</span>;            <span class="comment">// p points to nowhere now</span></span><br><span class="line">*q = <span class="number">100</span>;               <span class="comment">// undefined behavior as the object pointed by q has been destroyed.</span></span><br></pre></td></tr></table></figure>

<p><em>4. Creating a pointer without initializing it leaves the pointer unbound, which also causes undefined behavior if the program uses it.</em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>* p;                 <span class="comment">// unnitialized variable p, which is unbound to any object</span></span><br><span class="line">*p = <span class="number">100</span>;               <span class="comment">// undefined behavior</span></span><br></pre></td></tr></table></figure>
<p>The <strong>Student_info</strong> class allows us to use pointers without worrying about above problems. Now we still let <strong>Student_info</strong> to provide the interface, but makes the handle class be independent of the type of the object that it manages. The properties that our class will provide are :</p>
<p><em>1. A <strong>Handle</strong> is a value that refers to an object.</em></p>
<p><em>2. We can copy a <strong>Handle</strong> object.</em></p>
<p><em>3. We can test a <strong>Handle</strong> object to determine whether it is bound to another object.</em></p>
<p><em>4. We can use a <strong>Handle</strong> to trigger polymorphic behavior when it points to an object of a class that belongs to an inheritance hierarchy. That is, if we call a <strong>virtual</strong> function through our class, we want the implementation to choose the function to run dynamically, just as if we’d called the function through a real pointer.</em></p>
<p>Our <strong>Handle</strong> class will take over the memory management and therefore, we should attach only one <strong>Handle</strong> to any object, and we should not access the object directly through a built-in pointer. To tackle problems when using a built-in pointer, </p>
<ol>
<li>When we copy a <strong>Handle</strong> object, we’ll make a new copy of the object so that each <strong>Handle</strong> points to its own copy, such as what the copy constructor does in the <strong>Student_info</strong> class, calling <strong>clone()</strong> to create a new object. </li>
<li>When we destroy a <strong>Handle</strong>, it will destroy the associated object, such as what the <strong>destructor</strong> does in the <strong>Student_info</strong>.  </li>
<li>We allows users to create unbound <strong>Handles</strong> but we will throw an exception if the user attempts to access the object to which an unbound <strong>Handle</strong> refers. Users who want to avoid the exception can test to see whether the <strong>Handle</strong> is bound, for example, the operations defined in the <strong>Student_info</strong> class check whether the handle object was bound to a real object. </li>
</ol>
<h2 id="A-generic-Handle-class"><a href="#A-generic-Handle-class" class="headerlink" title="A generic Handle class"></a>A generic Handle class</h2><p>Now, let’s write the <strong>Handle</strong> class:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">Handle</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Handle(): p(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    Handle(<span class="keyword">const</span> Handle&amp; s): p(<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.p) p = s.p-&gt;clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Handle&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Handle&amp; rhs)&#123;</span><br><span class="line">        <span class="keyword">if</span>(&amp;rhs != <span class="keyword">this</span>)&#123;</span><br><span class="line">            <span class="keyword">delete</span> p;</span><br><span class="line">            p = rhs.p ? rhs.p-&gt;clone() : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Handle() &#123; <span class="keyword">delete</span> p; &#125;</span><br><span class="line"></span><br><span class="line">    Handle(T* t): p(t) &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> p; &#125; <span class="comment">// type conversion</span></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span>;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* p;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Firstly, we observe that the <strong>Handle</strong> is a class template and can accommodate to any type. For example, <strong>Handle<Core></strong> holds a pointer to an object of <strong>Core</strong> type. </p>
<p>The default constructor initializes the pointer to a <strong>nullptr</strong>. The copy constructor lets the <strong>Handle</strong> object refers to a newly created object that has the same value as the object pointed by the passed argument. The <strong>operator=</strong> is samilar to the copy constructor except that it destroyes the original object pointed by the <strong>Handle</strong> object. The destructor is obvious. All these four members are defined exactly the same as those defined in the <strong>Student_info</strong> class. </p>
<p>The other constructor that takes an argument lets us to bind the pointer to an actual object:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Handle&lt;Core&gt; <span class="title">student</span><span class="params">(<span class="keyword">new</span> Grad)</span></span>;</span><br></pre></td></tr></table></figure>
<p>Finally, we define three <strong>operator</strong> functions: the first one <strong>operator bool()</strong> tests the value of a <strong>Handle</strong>, and returns <strong>true</strong> if the <strong>Handle</strong> is bound to an object, and false otherwise(in fact converts the Handle type to a bool type value); The other two deine <strong>operator*</strong> and <strong>operator-&gt;</strong> which give access to the object bound to the <strong>Handle</strong>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span>&amp; <span class="title">Handle</span>&lt;T&gt;:</span>:<span class="keyword">operator</span>* () <span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p)</span><br><span class="line">        <span class="keyword">return</span> *p;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">throw</span> runtime_error(<span class="string">"unbound Handle"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span>* <span class="title">Handle</span>&lt;T&gt;:</span>:<span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(p)</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">throw</span> runtime_error(<span class="string">"unbound Handle"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The <strong>operator*</strong> allows us to access <strong>*student.p</strong> by using <strong>*student</strong>. It yields a reference to the bound object.<br>The <strong>-&gt;</strong> operator is used to access a member whose name appears in its right operand from an object named by its left operand. It returns a value that can be treated as a pointer. Therefore, if x is a value that defines <strong>operator-&gt;</strong>, then</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">x-&gt;y;</span><br></pre></td></tr></table></figure>
<p>is equivalent to </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(x.<span class="keyword">operator</span>-&gt;())-&gt;y;</span><br></pre></td></tr></table></figure>
<p>is equivalent to</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">x.p-&gt;y; <span class="comment">// p is pointer data member, for example, p is Core*</span></span><br></pre></td></tr></table></figure>
<p>By doing so, we can use the <strong>Handle</strong> object as if we are using a pointer to the associated object. Both <strong>operator*</strong> and <strong>operator-&gt;</strong> yield either a reference or a pointer, through which we obtain dynamic binding. For example, if we execute <strong>student-&gt;grade()</strong>, we’re calling <strong>grade()</strong> through <strong>student.p</strong>, that is, a pointer. The particular version of <strong>grade</strong> to be run depends on the type of the object to which <strong>student.p</strong> points to. Similarly, if we execute <strong>(*student).grade()</strong>, we’re calling <strong>grade()</strong> through a reference to the object and so the implementation will decide which particular version of the function to call. </p>
<h2 id="Using-a-generic-Handle"><a href="#Using-a-generic-Handle" class="headerlink" title="Using a generic Handle"></a>Using a generic Handle</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt; Handle&lt;Core&gt; &gt; students;    <span class="comment">// changed type</span></span><br><span class="line">    Handle&lt;Core&gt; record;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="built_in">string</span>::size_type maxlen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read and store the data</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; ch)&#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">'U'</span>)</span><br><span class="line">            record = <span class="keyword">new</span> Core;    (      <span class="comment">// allocate a Core object</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            record = <span class="keyword">new</span> Grad;          <span class="comment">// allocate a Grad object</span></span><br><span class="line">        record-&gt;<span class="built_in">read</span>(<span class="built_in">cin</span>);              <span class="comment">// Handle&lt;T&gt;::-&gt;, then virtual call to read</span></span><br><span class="line">        maxlen = <span class="built_in">max</span>(maxlen, record-&gt;name().<span class="built_in">size</span>());</span><br><span class="line">        students.push_back(record);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write the names and grades</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt; Handle&lt;Core&gt; &gt;::size_type i = <span class="number">0</span>; i != students.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">        <span class="comment">// students[i] is a Handle, which we deference to call the function</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; students[i]-&gt;name()</span><br><span class="line">             &lt;&lt; <span class="built_in">string</span>(maxlen + <span class="number">1</span> - students[i]-&gt;name().<span class="built_in">size</span>(), <span class="string">' '</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">double</span> final_grade = students[i]-&gt;grade();</span><br><span class="line">            streamsize prec = <span class="built_in">cout</span>.precision();</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; setprecision(<span class="number">3</span>) &lt;&lt; final_grade</span><br><span class="line">                &lt;&lt; setprecision(prec) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (domain_error e)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; e.what() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We can rewrite our <strong>Student_info</strong> class to a pure interface class:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student_info</span>&#123;</span></span><br><span class="line">    Student_info () &#123; &#125; <span class="comment">// calls default constructor of Handle&lt;Core&gt;</span></span><br><span class="line">    Student_info (<span class="built_in">std</span>::istream&amp; is) &#123; <span class="built_in">read</span>(is); &#125;</span><br><span class="line">    <span class="comment">// no copy, assign, or destructor: they're no longer needed</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::istream&amp; <span class="title">read</span><span class="params">(<span class="built_in">std</span>::istream)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cp)</span><br><span class="line">            <span class="keyword">return</span> cp-&gt;name();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">throw</span> runtime_error(<span class="string">"uninitialized Student"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cp) </span><br><span class="line">            <span class="keyword">return</span> cp-&gt;grade()</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">throw</span> runtime_error(<span class="string">"uninitialized Student"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> Student_info&amp; s1, <span class="keyword">const</span> Student_info&amp; s2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s1.name() &lt; s2.name();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Handle&lt;Core&gt; cp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Since the **Handle** <span class="class"><span class="keyword">class</span> <span class="title">defines</span> <span class="title">constructor</span>, <span class="title">copy</span> <span class="title">constructor</span>, <span class="title">assignment</span> <span class="title">operator</span>, <span class="title">as</span> <span class="title">well</span> <span class="title">as</span> <span class="title">destructor</span>, <span class="title">we</span> <span class="title">do</span> <span class="title">not</span> <span class="title">need</span> <span class="title">to</span> <span class="title">define</span> <span class="title">these</span> <span class="title">members</span> <span class="title">for</span> <span class="title">our</span> **<span class="title">Student_info</span>** <span class="title">again</span>. <span class="title">Here</span> <span class="title">we</span> <span class="title">need</span> <span class="title">one</span> <span class="title">step</span> <span class="title">more</span>, <span class="title">that</span> <span class="title">is</span>, <span class="title">to</span> <span class="title">redefine</span> <span class="title">the</span> **<span class="title">read</span>** <span class="title">function</span>:</span></span><br><span class="line">```c++</span><br><span class="line"><span class="function">istream&amp; <span class="title">Student_info::read</span><span class="params">(istream&amp; is)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    is &gt;&gt; ch;</span><br><span class="line">    <span class="keyword">if</span>(ch == <span class="string">'U'</span>)</span><br><span class="line">        cp = <span class="keyword">new</span> Core(is);  <span class="comment">// implicitly converts from a Core* to a Handle&lt;Core&gt; through Handle::Handle(T*)</span></span><br><span class="line">    <span class="keyword">else</span>                    <span class="comment">// then assigns the value from the temporary Handle object to cp</span></span><br><span class="line">        cp = <span class="keyword">new</span> Grad(is);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>when we execute the <strong>cp = new Core(is)</strong>, the right-hand side creates a new <strong>Core</strong> object from input stream, which we implicitly convert to a <strong>Handle<Core></strong> using <strong>Handle(T*)</strong> constructor. That <strong>Handle</strong> value is then assigned to <strong>cp</strong> by calling the assignment operator. The assignment constructs and destroys an extra copy of the <strong>Core</strong> object that we created. The reason behind this is that copying or assigning a Handle object always makes a new copy of the object that the <strong>Handle</strong> points to. Doing so can avoid the dangling pointer as each Handle only points to its own object, however, may also make uncessary copies like above assignment operation. </p>
<h1 id="Reference-counted-handles"><a href="#Reference-counted-handles" class="headerlink" title="Reference-counted handles"></a>Reference-counted handles</h1><p>This section solves above problem by providing a <strong>Handle</strong> class that does not copy the underlying object when the <strong>Handle</strong> itself is copied. To avoid danglling pointer problem, we’ll need to free that object at the point when the last <strong>Handle</strong> that points to it goes away. We’ll use a <strong>reference count</strong> to keep track of how many objects refer to another object. Each time we create a new handle that refers to our target object, we increment the reference count object, while each time a referring object goes away we decrement the reference count. Finally, when the last referring object goes away, we know that it is safe to destroy the target object. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">Ref_handle</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// manage reference count as well as pointer</span></span><br><span class="line">    Ref_handle(): refer(<span class="keyword">new</span> <span class="keyword">size_t</span>(<span class="number">1</span>)), p(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    Ref_handle(T* t): refptr(<span class="keyword">new</span> <span class="keyword">size_t</span>(<span class="number">1</span>)), p(t) &#123;&#125;</span><br><span class="line">    Ref_handle(<span class="keyword">const</span> Ref_handle&amp; h): refptr(h.refptr), p(h.p)&#123;</span><br><span class="line">        ++*refptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Ref_handle&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Ref_handle&amp;);</span><br><span class="line">    ~Ref_handle();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// as before</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> p; &#125;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(p)</span><br><span class="line">            <span class="keyword">return</span> *p;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error(<span class="string">"unbound Ref_handle"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p)</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error(<span class="string">"unbound Ref_handle"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* p;</span><br><span class="line">    <span class="keyword">size_t</span>* refptr;     <span class="comment">// newly added</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Above code shows our <strong>Ref_handle</strong> class:</p>
<ol>
<li><p>we add a new pointer, <strong>refptr</strong>, to to the new handle class to track the reference count</p>
</li>
<li><p>if we default construct a Ref_handle object or construct from an existed T<em>, we initialized *</em>refptr** to 1</p>
</li>
<li><p>if we construct a Ref_handle object from another Ref_handle, we do not copy the underlying object but instead only copy the value of the pointer from the passed argument. Then, our <strong>Ref_handle</strong> object points to the same object as the passed argument. In addition, we let the <strong>refptr</strong> points to the counter object pointed by <strong>h.refptr</strong>, then increment the counter value by 1 as there is a new pointer <strong>Ref_handle.p</strong> points to the object pointed by <strong>h.p</strong> now.</p>
</li>
<li><p>the assignment operator also modifies the counter object instead of copying the underlying object:</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Ref_handle</span>&lt;T&gt;&amp; <span class="title">Ref_handle</span>&lt;T&gt;:</span>:<span class="keyword">operator</span>=(<span class="keyword">const</span> Ref_handle&amp; rhs)&#123;</span><br><span class="line">    ++*rhs.refptr;</span><br><span class="line">    <span class="comment">// free the left-hand side, destroy pointers if appropriate</span></span><br><span class="line">    <span class="keyword">if</span>(--*refptr == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">delete</span> refptr;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// copy in values from the right-hand side</span></span><br><span class="line">    refptr = rhs.refptr;</span><br><span class="line">    p = rhs.p;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> the assignment operation typically involves obliterating the value of the left-hand side operand. If the operand is a pointer, we execute <strong>delete p</strong> to free the space occupied by the object that pointed by <strong>p</strong>, if there is no other pointers points to the same object. Therefore, we executes <strong>delete p</strong> as well as <strong>delete refptr</strong> conditional on <strong>–*refptr == 0</strong>. If <strong>–*refptr == 0</strong> is false, we do not execute <strong>delete</strong> operation, but we still need to decrement the counter object pointed by <strong>refptr</strong>, which has been done by executing <strong>–*refptr ==0</strong>. However, we also need to avoid self-assignment and hence we increment <strong>*refptr</strong> first. </p>
<p> The next step is to bind our <strong>Ref_handle</strong> to the object that pointed by the passed argument. Like what the copy constructor does, we copy pointers but don’t copy the underlying object. </p>
</li>
<li><p>the destructor checks whether the <strong>Ref_handle</strong> object being destroyed is the last one bound to its <strong>T</strong> object:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">Ref_handle</span>&lt;T&gt;:</span>:~Ref_handle()&#123;</span><br><span class="line">    <span class="keyword">if</span> (--*refptr == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">delete</span> refptr;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>This version of <strong>*Ref_handle</strong> class works well for classes that can share state between copies of different objects, however, cannot provide valuelike behavior like the <strong>Handle</strong> class described in last section. It does avoid needless copying, however, avoid all copying even we want to copy the underlying data. Next, we discuss how to write a <strong>Handle</strong> that let us decide when to share data.</p>
<h1 id="Handles-that-let-you-decide-when-to-share-data"><a href="#Handles-that-let-you-decide-when-to-share-data" class="headerlink" title="Handles that let you decide when to share data"></a>Handles that let you decide when to share data</h1><p>Now we write our last version of <strong>generic handle class</strong>, which not only preserves the performance of <strong>Ref_handle</strong> but also provides the valuelike behavior of <strong>Handle</strong>s. In general, the new handle class, named as <strong>Ptr</strong>, will copy the object if we are about to change the contents, but only if there is another handle attached to the same object. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">Ptr</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// new member to copy the object conditionally when needed</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">make_unique</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(*refptr != <span class="number">1</span>)&#123;</span><br><span class="line">            --*refptr;</span><br><span class="line">            refptr = <span class="keyword">new</span> <span class="keyword">size_t</span>(<span class="number">1</span>);</span><br><span class="line">            p = p ? p-&gt;clone() : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the rest of the class looks like Ref_handle except for its name</span></span><br><span class="line">    Ptr(): refptr(<span class="keyword">new</span> <span class="keyword">size_t</span>(<span class="number">1</span>)), p(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    Ptr(T* t): refptr(<span class="keyword">new</span> <span class="keyword">size_t</span>(<span class="number">1</span>)), p(t) &#123;&#125;</span><br><span class="line">    Ptr(<span class="keyword">const</span> Ptr&amp; h): refptr(h.refptr), p(h.p) &#123;</span><br><span class="line">        ++*refptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Ptr&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Ptr&amp;); </span><br><span class="line">    ~Ptr();</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> p; &#125;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span>;</span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* p;</span><br><span class="line">    <span class="keyword">size_t</span>* refptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>This new <strong>Ptr</strong> class has the mostly same members and implementations as the <strong>Ref_handle</strong> class, except that it defines a new <strong>make_unique</strong> function. The <strong>make_unique</strong> function calls the <strong>clone()</strong> function to copy the underlying object only in the condition that the reference count is not 1. More specific, if <strong>*refptr == 1</strong>, then it means that there is no any other <strong>Ptr</strong> objects are bound to the underlying object, and hence there is no need to do a underlying copy again;but if <strong>*refptr != 1</strong>, it means that there still other <strong>Ptr</strong>(s) are bound to the underlying object, and hence it is necessary to make our <strong>Ptr</strong> points to its own object to avoid bring changes to the object pointed by other <strong>Ptr</strong>(s). If we intend to add a function that can change the contents of the underlying object, we should call <strong>make_unique</strong> to make a copy of the underlying object. </p>
<h1 id="An-improvement-on-controllable-handles"><a href="#An-improvement-on-controllable-handles" class="headerlink" title="An improvement on controllable handles"></a>An improvement on controllable handles</h1><p>There is one problem when we use above <strong>Ptr</strong> to deal with some classes that do not have a member function <strong>clone()</strong>. In such case, we will define an intermediary global function that we can both call and create:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">T</span>* <span class="title">clone</span>(<span class="title">const</span> <span class="title">T</span>* <span class="title">tp</span>)&#123;</span></span><br><span class="line">    <span class="keyword">return</span> tp-&gt;clone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Then we can change our <strong>make_unique</strong> member to call it</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">Ptr</span>&lt;T&gt;:</span>:make_unique()&#123;</span><br><span class="line">    <span class="keyword">if</span>(*refptr != <span class="number">1</span>)&#123;</span><br><span class="line">        --*refptr;</span><br><span class="line">        refptr = <span class="keyword">new</span> <span class="keyword">size_t</span>(<span class="number">1</span>);</span><br><span class="line">        p = p ? clone(p) : <span class="number">0</span>; <span class="comment">// call global version of clone</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The new clone function does’t make any change to the <strong>make_unique</strong> function and hence works well for our <strong>Student_info</strong> class. Another example, the <strong>Vec<char></strong> doesn’t provide a clone function, how can we define an intermediary function to let the <strong>Ptr&lt; Vec<char> &gt;</strong> work?</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="function">Vec&lt;<span class="keyword">char</span>&gt;* <span class="title">clone</span><span class="params">(<span class="keyword">const</span> Vec&lt;<span class="keyword">char</span>&gt;* vp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Vec&lt;<span class="keyword">char</span>&gt;(*vp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The novelty here is <strong>template&lt;&gt;</strong>, which indicates a function is a <strong>template specialization</strong>. The <strong>template specialization</strong> means that the template is a particular version of a template function for the argument type. If we pass <strong>clone</strong> a <strong>Vec<char>*</strong>, the compiler will use this specialized version of <strong>clone</strong>. If we pass other types of pointers, it will instantiate the general template form of <strong>clone</strong>. </p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Notes</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ - Using inheritance and dynamic binding</title>
    <url>/2018/05/08/C-Using-inheritance-and-dynamic-binding/</url>
    <content><![CDATA[<h1 id="Inheritance"><a href="#Inheritance" class="headerlink" title="Inheritance"></a>Inheritance</h1><p>In this chapter, we intend to extend our grading program such that it meets the new requirements: students can take undergraduate or graduate credit while graduate students have to write a thesis in addition to the homework and exams. In other words, a record for graduate credit is the same as for undergraduate credit except that it has extra properties related to the thesis. This problem can be abstracted and solved by a mechanism called <strong>inheritance</strong>, which is one of the cornerstones of OOP. </p>
<p>Specifically, we’ll write two classes, the first class is the abstraction of the core requirements and is named <strong>Core</strong> while the second class represents the requirements for graduate credit and hence named <strong>Grad</strong>. The <strong>Grad</strong> class captures extra requirements but has same core requirements as the <strong>Core</strong> class. Therefore, We write two classes such that the <strong>Grad</strong> class can inherit the properties from the <strong>Core</strong> class. Typically, we say that the <strong>Grad</strong> class is derived from or inherits from the <strong>base</strong> class, i.e. the <strong>Core</strong> class here. let’s see how to define these two classes:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Core</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Core();</span><br><span class="line">    Core(<span class="built_in">std</span>::istream&amp;);</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::istream&amp; <span class="title">read</span><span class="params">(<span class="built_in">std</span>::istream&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::istream&amp; <span class="title">read_common</span><span class="params">(<span class="built_in">std</span>::istream&amp;)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> n;</span><br><span class="line">    <span class="keyword">double</span> midterm, <span class="keyword">final</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; homework;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grad</span>:</span> <span class="keyword">public</span> Core&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Grad();</span><br><span class="line">    Grad(<span class="built_in">std</span>::istream&amp;);</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::istream&amp; <span class="title">read</span><span class="params">(<span class="built_in">std</span>::istream&amp;)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> thesis;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Since <strong>Grad</strong> class inherits from <strong>Core</strong> class, every member of <strong>Core</strong> is also a member of <strong>Grad</strong>, except for the <strong>constructor, assignment operator</strong>, and <strong>destructor</strong>. The <strong>Grad</strong> class also has its own members, such as the <strong>thesis</strong> and its own <strong>constructor</strong>s. It can also redefine members from the base class, such as the <strong>grade</strong> and <strong>read</strong> function. </p>
<p>The keyword <strong>public</strong> in <strong>public Core</strong> means that <strong>Grad</strong> inherits from <strong>Core</strong> is part of its interface rather than its implementation. In other words, the public interface to <strong>Core</strong> becomes part of the public interface to <strong>Grad</strong>. For example, if we have a <strong>Grad</strong> object, we can call its <strong>name</strong> member thought <strong>Grad</strong> doesn’t define its own <strong>name</strong> function. </p>
<p>Beyond the four data members from the <strong>Core</strong> class,  <strong>Grad</strong> has a member <strong>thesis</strong> and calculates <strong>grade()</strong> using different algorithm. It have two constructors, and four member functions, two of which redefine the corresponding members of <strong>Core</strong>, and <strong>name</strong> and <strong>read_common</strong> functions. </p>
<h2 id="Protection-revisited"><a href="#Protection-revisited" class="headerlink" title="Protection revisited"></a>Protection revisited</h2><p>As it stands, four data members as well as the <strong>read_common</strong> function are inaccessible to member functions in <strong>Grad</strong> as they are <strong>private</strong> and only available to the <strong>Core</strong> members and its friends. But we do need these data members and <strong>read_common</strong> for defining the <strong>grade</strong> and <strong>read</strong> functions in the <strong>Grad</strong>. To achieve this goal, we rewrite the <strong>Core</strong> class using a protection lable:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Core</span>&#123;</span></span><br><span class="line"><span class="comment">// public members are available for users of the derived class</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Core();</span><br><span class="line">    Core(<span class="built_in">std</span>::istream&amp;);</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::istream&amp; <span class="title">read</span><span class="params">(<span class="built_in">std</span>::istream&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// protected members are available for member functions of the derived class but not available for users </span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::istream&amp; <span class="title">read_common</span><span class="params">(<span class="built_in">std</span>::istream&amp;)</span></span>;  </span><br><span class="line">    <span class="keyword">double</span> midterm, <span class="keyword">final</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; homework;</span><br><span class="line"></span><br><span class="line"><span class="comment">// only available for members of the class itself and its friends.</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> n;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>The <strong>protected</strong> members are available for derived classes but still inaccssible users of the classes. <strong>n</strong> is still private but <strong>Grad</strong> can access the name by calling its member function <strong>name</strong>.</p>
<h2 id="Operations"><a href="#Operations" class="headerlink" title="Operations"></a>Operations</h2><p>The next is to implement four constructors(each class has one default constructor and one constructor with arguments) and six operations including common functions <strong>name</strong>, <strong>read_common</strong>,  and <strong>read</strong> and <strong>grade</strong> for two class respectively. We’ll read the <strong>thesis</strong> grade closely after the final exam grade but precede the homework grades.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// name function</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">Core::name</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> n; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// grade function for Core</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Core::grade</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ::grade(midterm, <span class="keyword">final</span>, homework);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// read_common function</span></span><br><span class="line"><span class="function">istream&amp; <span class="title">Core::read_common</span><span class="params">(istream&amp; in)</span></span>&#123;</span><br><span class="line">    in &gt;&gt; n &gt;&gt; midterm &gt;&gt; <span class="keyword">final</span>;</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// read function for Core</span></span><br><span class="line"><span class="function">istream&amp; <span class="title">Core::read</span><span class="params">(istream&amp; in)</span></span>&#123;</span><br><span class="line">    read_common(in);</span><br><span class="line">    read_hw(in, homework);</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// read for Grad</span></span><br><span class="line"><span class="function">istream&amp; <span class="title">Grad::read</span><span class="params">(istream&amp; in)</span></span>&#123;</span><br><span class="line">    Core::read_common(in);</span><br><span class="line">    in &gt;&gt; thesis;</span><br><span class="line">    read_hw(in, Core::homework);</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// grade for Grad</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Grad::grade</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(Core::grade(), thesis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The <strong>Grad::grade</strong> function shows that we calculate the final grade as the lesser between the <strong>grade</strong> excluding thesis, and thesis. Though we can call members of <strong>Core</strong> directly, we’d better explicitly call some functions for avoiding ambiguity. For example, if we don’t explicitly call <strong>Core::grade()</strong>, the compiler may use the <strong>Grad::grade</strong> dirctly. </p>
<h2 id="Inheritance-and-constructors"><a href="#Inheritance-and-constructors" class="headerlink" title="Inheritance and constructors"></a>Inheritance and constructors</h2><p>Derived objects are constructed by(Koenig and Moo 2000):<br><em>1. Allocating space for the entire object (base-class members as well as derived members)</em><br><em>2. Calling the base-class constructor to initialize the base-class part(s) of the object</em><br><em>3. Initializing the members of the derived class as directed by the constructor initializer</em><br><em>4. Executing the body of the derived-class constructor, if any</em></p>
<p>Clearly, the constructor of a derived class not only constructs its own members but also constructs data members of the base class. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Core</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// default constructor for Core</span></span><br><span class="line">    Core(): midterm(<span class="number">0</span>), <span class="keyword">final</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// build a Core from an istream</span></span><br><span class="line">    Core(istream&amp; is)&#123; <span class="built_in">read</span>(is); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grad</span>:</span> <span class="keyword">public</span> Core&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// default constructor for Grad: first implicitly calls the default constructor Core::Core()</span></span><br><span class="line">    Grad(): thesis(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// build a Grad from istream: first implicitly calls Core::Core()</span></span><br><span class="line">    Grad(<span class="built_in">std</span>::istream&amp; is) &#123; <span class="built_in">read</span>(is); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>For example, when execute</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Grad g; <span class="comment">// create an empty object</span></span><br></pre></td></tr></table></figure>
<p>The computer allocates enough space to hold five data members for the Grad object, run the <strong>Core</strong> default constructor to initialize the data members in the <strong>Core</strong> part of <strong>g</strong>, and then run the default constructor of <strong>Grad</strong>. Again, when execute</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Grad <span class="title">g</span><span class="params">(<span class="built_in">cin</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>the computer will run the <strong>Core</strong> default constructor, followed by the <strong>Grad::Grad(istream&amp;)</strong> constructor to read values into five data memners.</p>
<h1 id="Polymorphism-and-virtual-functions"><a href="#Polymorphism-and-virtual-functions" class="headerlink" title="Polymorphism and virtual functions"></a>Polymorphism and virtual functions</h1><p>There is also a support function for the <strong>Student_info</strong> program, that is, the compare function that acts as the predicate of the <strong>std::sort</strong> algorithm. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> Core&amp; c1, <span class="keyword">const</span> Core&amp; c2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c1.name() &lt; c2.name();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>How does it work on the <strong>Grad</strong> class objects? For example</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Grad <span class="title">g</span><span class="params">(<span class="built_in">cin</span>)</span></span>;    <span class="comment">// read a Grad record</span></span><br><span class="line"><span class="function">Grad <span class="title">g2</span><span class="params">(<span class="built_in">cin</span>)</span></span>;   <span class="comment">// read a Grad record</span></span><br><span class="line"></span><br><span class="line"><span class="function">Core <span class="title">c</span><span class="params">(<span class="built_in">cin</span>)</span></span>;    <span class="comment">// read a Core record</span></span><br><span class="line"><span class="function">Core <span class="title">c2</span><span class="params">(<span class="built_in">cin</span>)</span></span>;   <span class="comment">// read a Core record</span></span><br><span class="line"></span><br><span class="line">compare(g, g2); <span class="comment">// compare two Grad records</span></span><br><span class="line">compare(c, c2); <span class="comment">// compare two Core records</span></span><br><span class="line">compare(g, c);  <span class="comment">// compare Grad record with a Core record</span></span><br></pre></td></tr></table></figure>
<p>The compare function can take two <strong>Core</strong> objects as well as two <strong>Grad</strong> objects, even one <strong>Core</strong> and one <strong>Grad</strong>. For the function body, it makes sence as any <strong>Grad</strong> object has a member <strong>name</strong>, which it inherits from the base. But why we can pass a <strong>Grad</strong> object to a function expecting a <strong>Core&amp;</strong>? The reason is that <strong>Grad</strong> is inherited from <strong>Core</strong> and hence has a <strong>Core</strong> part. Then, we can bind <strong>compare</strong>‘s reference parameters to the <strong>Core</strong> portions of <strong>Grad</strong> objects, as if we bind them to plain <strong>Core</strong> objects.</p>
<h2 id="Obtaining-a-value-without-knowing-the-object’s-type"><a href="#Obtaining-a-value-without-knowing-the-object’s-type" class="headerlink" title="Obtaining a value without knowing the object’s type"></a>Obtaining a value without knowing the object’s type</h2><p>The compare function described above works properly. However, if we intend to compare the grade rather than the name, the function seems inappropriate for <strong>Grad</strong> objects as two classes have different <strong>grade</strong> function. A right logical manner is that the compare function can invoke the right <strong>grade</strong> function according to the type of the object that we pass, only at the stage of run time. To support this kind of <strong>run time selection</strong>, C++ provides <strong>virtual</strong> functions:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Core</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">grade</span><span class="params">()</span> <span class="keyword">const</span></span>;   <span class="comment">// virtual added</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>When we call <strong>compare</strong>(grade-version), the implementation will determine which version of the <strong>grade</strong> should execute by looking at the actual type of the objects to which the reference <strong>c1</strong> and <strong>c2</strong> are bound. If the argument is <strong>Grad</strong>,then it calls <strong>Grad::grade</strong> and calls <strong>Core::grade</strong> otherwise. </p>
<p>Noting that the keyword <strong>virtual</strong> may be used only inside the class definition. If we seperate the declaration and definition, we do not need to repeatedly use it in the definition.  </p>
<h2 id="Dynamic-binding"><a href="#Dynamic-binding" class="headerlink" title="Dynamic binding"></a>Dynamic binding</h2><p>Another point about the <strong>virtual</strong> is that it is relevant only when the function is called through a reference or a pointer. If we call the function on behalf of the object, then we know the exact type of the object at compile time. In contrast, a reference or a pointer to a base class object may refer or point to a base-class object or to an object of a type derived from the base class. Assuming we write <strong>compare_grades</strong>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// incorrect implementation</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare_grades</span><span class="params">(Core c1, Core c2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c1.grade() &lt; c2.grade();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In this case, we know exactly that both two objects are <strong>Core</strong> type. Even we call the function with <strong>Grad</strong> objects, the <strong>Grad</strong> objects will be cut down to its <strong>Core</strong> part and a copy of that part will be passed to the <strong>compare_grades</strong> function. This case is known as <strong>statically bound</strong>, that is, the calls to <strong>Grad</strong> are bound at compile to <strong>Core::grade</strong>. Obviously, the <strong>dynamic binding</strong> is that the function is dynamically bound at run time. If we call a <strong>virtual</strong> function through a pointer or a reference, the version of <strong>virtual</strong> function to use depends on the type of the object which the reference or pointer is bound. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Core c;</span><br><span class="line">Grad g;</span><br><span class="line">Core* p;</span><br><span class="line">Core&amp; r = q;</span><br><span class="line"></span><br><span class="line">c.grade();  <span class="comment">// statically bound to Core::grade()  </span></span><br><span class="line">g.grade();  <span class="comment">// statically bound to Grad::grade()</span></span><br><span class="line">p-&gt;grade(); <span class="comment">// dynamically bound, depending on the type of the object to which p points</span></span><br><span class="line">r.grade();  <span class="comment">// dynamically bound, depending on the type of the object to which r refers</span></span><br></pre></td></tr></table></figure>

<p><em>The fact that we can use a derived type where a pointer or reference to the base is expected is an example of <strong>polymorphism</strong>, meaning <strong>of many form</strong>. When we call the <strong>virtual</strong> function by a pointer or reference, we make a polymorphic call.</em> We’ll make the <strong>read</strong> function <strong>virtual</strong> as well and then the version of the <strong>read</strong> function to be called depends on the type of the object on which it is invoked. </p>
<h2 id="Recap"><a href="#Recap" class="headerlink" title="Recap"></a>Recap</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Core</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Core(): midterm(<span class="number">0</span>), <span class="keyword">final</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    Core(<span class="built_in">std</span>::istream&amp; is) &#123; <span class="built_in">read</span>(is); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::istream&amp; <span class="title">read</span><span class="params">(<span class="built_in">std</span>::istream&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">grade</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// accessible to derived classes</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::istream&amp; <span class="title">read_common</span><span class="params">(<span class="built_in">std</span>::istream&amp;)</span></span>;</span><br><span class="line">    <span class="keyword">double</span> midterm, <span class="keyword">final</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; homework;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// accessible only to Core</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grad</span>:</span>: <span class="keyword">public</span> Core&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Grad(): thesis(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    Grad(<span class="built_in">std</span>::istream&amp; is) &#123; <span class="built_in">read</span>(is); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::istream&amp; <span class="title">read</span><span class="params">(<span class="built_in">std</span>::istream)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> thesis;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> Core&amp;, <span class="keyword">const</span> Core&amp;)</span></span>;</span><br></pre></td></tr></table></figure>

<h1 id="Using-inheritance-to-solve-our-problem"><a href="#Using-inheritance-to-solve-our-problem" class="headerlink" title="Using inheritance to solve our problem"></a>Using inheritance to solve our problem</h1><p>Now we can write our student grading prorgam described in chapter 9. The problem is how can we write a program that can handle with both <strong>Core</strong> objects and <strong>Grad</strong> objects. To achieve our goal, we need to eliminate these type dependencies(Koenig and Moo 2000):</p>
<p><em>1. The definition of the vector in which we store the elements as we read them</em><br><em>2. The definition of the local temporary into which we read the records</em><br><em>3. The read function</em><br><em>4. The grade function</em></p>
<p>Now we’ll see how to solve these problems.</p>
<h2 id="Containers-of-virtually-unkown-type"><a href="#Containers-of-virtually-unkown-type" class="headerlink" title="Containers of virtually unkown type"></a>Containers of virtually unkown type</h2><p>Consider if we define a vector as follows:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;Core&gt; students;      <span class="comment">// must hold Core objects, not polymorphic types</span></span><br><span class="line">Core record;                <span class="comment">// Core object, not a type derived from Core</span></span><br></pre></td></tr></table></figure>
<p>It is impossible to hold the Grad objects as we explicitly declare that a vector hold objects of type <strong>Core</strong>. Then, if we call the <strong>read</strong> function or <strong>grade</strong> function we indeed call <strong>Core::read</strong> or <strong>Core::grade</strong>. However, we have mentioned in above section, if we call those functions through pointers or references, these functions are dynamically bound at run time, depending on the type of the object which the reference or pointer is bound. Therefore, a natural solution is that define a vector that stores the pointer to each element rather than the element itself.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;Core*&gt; students;</span><br><span class="line">Core* record;</span><br></pre></td></tr></table></figure>
<p>Howvever, this doesn’t work as no one knows where the record points initially. If the computer executes data reading, the program would crash.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(record-&gt;<span class="built_in">read</span>(<span class="built_in">cin</span>)) &#123; <span class="comment">// crash! &#125;</span></span><br></pre></td></tr></table></figure>
<p>Now we provide a verbose solution to this problem: let users manually control the type of the object. We use lable <strong>U</strong> to represent that the type is a <strong>Core</strong> object, and use <strong>G</strong> to represent that the <strong>type</strong> is a <strong>Grad</strong> object. Before we implement this strategy, we should rewrite our <strong>compare</strong> function such that it can sort two <strong>pointer</strong>s. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare_Core_ptrs</span><span class="params">(<span class="keyword">const</span> Core* cp1, <span class="keyword">const</span> Core* cp2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> compare(*cp1, *cp2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Noting that we can’t name this predicate as <strong>compare</strong> as we cannot pass an overloaded function as a template argument. Now, let’s see the whole program:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// this work almost work</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Core*&gt; students;     <span class="comment">// store pointers, not objects</span></span><br><span class="line">    Core* record;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="built_in">string</span>::size_type maxlen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read and store the data</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; ch)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch == <span class="string">'U'</span>)</span><br><span class="line">            record = <span class="keyword">new</span> Core;  <span class="comment">// allocate a Core object   </span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            record = <span class="keyword">new</span> Grad;  <span class="comment">// allocate a Grad object</span></span><br><span class="line">        record-&gt;<span class="built_in">read</span>(<span class="built_in">cin</span>);      <span class="comment">// virtual call</span></span><br><span class="line">        maxlen = <span class="built_in">max</span>(maxlen, record-&gt;name().<span class="built_in">size</span>()); <span class="comment">// dereference</span></span><br><span class="line">        students.push_back(record);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pass the version of compare that works on pointers</span></span><br><span class="line">    sort(student.<span class="built_in">begin</span>(), student.<span class="built_in">end</span>(), compare_Core_ptrs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write the names and grades</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Core*&gt;::size_type i = <span class="number">0</span>; i != student.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; students[i]-&gt;name()</span><br><span class="line">             &lt;&lt; <span class="built_in">string</span>(maxlen + <span class="number">1</span> - students[i]-&gt;name.<span class="built_in">size</span>(), <span class="string">' '</span>); </span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">double</span> final_grade = students[i]-&gt;grade();</span><br><span class="line">        streamsize prec = <span class="built_in">cout</span>.precision();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; setprecision(<span class="number">3</span>) &lt;&lt; final_grade</span><br><span class="line">             &lt;&lt; setprecision(prec) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(domain_error e)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; e.what() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> student[i];  <span class="comment">// free the object allocating when reading</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Virtual-destructors"><a href="#Virtual-destructors" class="headerlink" title="Virtual destructors"></a>Virtual destructors</h2><p>Above program almost works. The only problem occurs when we <strong>delete</strong> the object. When we store each pointer, we store each as <strong>Core*</strong> though they may point to a <strong>Grad</strong>. Therefore, the <strong>delete</strong> operation can only delete pointers to <strong>Core</strong>. To solve this problem, we define a <strong>virtual</strong> destructor:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Core</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~Core() &#123;&#125;</span><br><span class="line">    <span class="comment">// as before</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><em>Now, when we execute <strong>delete students[i]</strong>, the destructor that will be run depends on the type of the object to which <strong>student[i]</strong> actually points. A <strong>virtual</strong> destructor is needed any time it is possible that an object of derived type is destroyed through a pointer to base.</em></p>
<h1 id="A-simple-handle-class"><a href="#A-simple-handle-class" class="headerlink" title="A simple handle class"></a>A simple handle class</h1><p>The above approach does solve the problem but seems complex. Users have to manage the pointers and memory properly to avoid potential bugs. we can use the technique <strong>handle class</strong> to encapsulate the pointer to <strong>Core</strong>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student_info</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// constructors and copy control</span></span><br><span class="line">    Student_info(): cp(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    Student_info(<span class="built_in">std</span>::istream&amp; is): cp(<span class="number">0</span>) &#123; <span class="built_in">read</span>(is); &#125;</span><br><span class="line">    Student_info(<span class="keyword">const</span> Student_info&amp;);</span><br><span class="line">    Student_info&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Student_info&amp;);</span><br><span class="line">    ~Student_info() &#123; <span class="keyword">delete</span> cp; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// operations</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::istream&amp; <span class="title">read</span><span class="params">(<span class="built_in">std</span>::istream&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cp) <span class="keyword">return</span> cp-&gt;name();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error(<span class="string">"unitialized Student"</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cp) <span class="keyword">return</span> cp-&gt;grade();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error(<span class="string">"unitialized Student"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">compare</span> <span class="params">(<span class="keyword">const</span> Student_info&amp; s1, <span class="keyword">const</span> Student_info&amp; s2)</span></span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> s1.name() &lt; s2.name(); &#125;</span><br><span class="line">    <span class="keyword">private</span>：</span><br><span class="line">        Core* cp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Now the <strong>Student_info</strong> object represents either a <strong>Core</strong> or <strong>Grad</strong>. This <strong>handle</strong> class hids the details of implementations related to pointers as used in above program, and provides an interface that is consistent with the <strong>Core</strong> and <strong>Grad</strong>. Users do not need to worry about memory management any more as all has been done by the handle class. The novelty is that we define the compare function as a <strong>static</strong> member which is associated with a class rather than a particular object.<br>We can call it through <strong>Student_info::compare()</strong> directly even without creating any object first. Therefore, <strong>static function member</strong> cannot access nonstatic data members of objects of the class as there is no object associated with the function and hence no members to use. </p>
<h2 id="Reading-the-handle"><a href="#Reading-the-handle" class="headerlink" title="Reading the handle"></a>Reading the handle</h2><p>The first constructor construct a <strong>nullptr</strong>. The second constructor constructs an object from the input stream, relying on the <strong>read</strong> function:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">istream&amp; <span class="title">Student_info::read</span><span class="params">(istream&amp; is)</span></span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> cp;      <span class="comment">// delete previous object, if any</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> ch;        <span class="comment">// get record type</span></span><br><span class="line">    is &gt;&gt; ch;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ch == <span class="string">'U'</span>)&#123;</span><br><span class="line">        cp = <span class="keyword">new</span> Core(is);  <span class="comment">// construct Core from istream</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        cp = <span class="keyword">new</span> Grad(is);  <span class="comment">// construct Grad from istream</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The <strong>read</strong> function allocate the space and construct the right type object according to the information from input stream. It starts by freeing the existing object (if any) to which the handle object was previously bound. It is worth noting that if <strong>cp</strong> is a <strong>nullptr</strong>, we still can use <strong>delete</strong> without causing any error. </p>
<h2 id="Copying-the-handle-objects"><a href="#Copying-the-handle-objects" class="headerlink" title="Copying the handle objects"></a>Copying the handle objects</h2><p>It also defines the copy constuctor and assignment operator. These two operations typically need to allocate new objects and then initialize or assign values from the object from which we are copying. But the problem is how can we know the type of the object from which we are copying? The object, i.e. <strong>cp</strong>, may point to a <strong>Core</strong> or a <strong>Grad</strong>.  The solution is to define a new <strong>virtual</strong> function:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Core</span>&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Student_info</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Core* <span class="title">clone</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> Core(*<span class="keyword">this</span>); &#125;</span><br><span class="line">    <span class="comment">// as before</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>The <strong>clone()</strong> function creates a new object that holds copies of the values in the original. The <strong>Core</strong> doesn’t have a user-defined copy constructor but have a synthesized copy constructor which copies each member from the existing <strong>Core</strong> object into the newly created object. The member is inaccessible to users and non-derived classes. Therefore, we declare the <strong>Student_info</strong> as a friend. Then all members of the <strong>Student_info</strong> are friends of <strong>Core</strong>. The <strong>Grad</strong> class inherits this member, but will return a new <strong>Grad</strong>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grad</span>:</span> <span class="keyword">public</span> Core&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function">Grad* <span class="title">clone</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> Grad(*<span class="keyword">this</span>); &#125;</span><br><span class="line">    <span class="comment">// as before</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>In general,  when we redefine a member function from the base class, we keep the parameter list and the return type unchanged. However, if the base-class function returns a pointer (or reference) to a base class, then the derived-class function can return a pointer or reference to a corresponding derived class. </p>
<p>In addition to above, the derived class doesn’t inherit the <strong>friend</strong> class from the base class. In this case, it is unnecessary to declare the <strong>Student_info</strong> as the <strong>friend</strong> class of <strong>Grad</strong> due to the fact that the <strong>Student_info</strong> class never refers to <strong>Grad::clone</strong> directly instead through the virtual function defined in <strong>Core</strong>.</p>
<p>The copy constructor and assignment operator are defined as follows:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Student_info::Student_info(<span class="keyword">const</span> Student_info&amp; s): cp(<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s.cp) cp = s.cp-&gt;clone();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student_info&amp; Student_info:: <span class="keyword">operator</span>=(<span class="keyword">const</span> Student_info&amp; s)&#123;</span><br><span class="line">    <span class="keyword">if</span>(&amp;s != <span class="keyword">this</span>)&#123;</span><br><span class="line">        <span class="keyword">delete</span> cp;</span><br><span class="line">        <span class="keyword">if</span>(s.cp)</span><br><span class="line">            cp = s.cp-&gt;clone();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cp = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>One may wonder that why we can access the private member <strong>cp</strong> of object <strong>s</strong>. It is because that <strong>private</strong> only restricts data access from other classes. In other words, if both objects are instances of the same class, they are allowed to access private members with each other. </p>
<h1 id="Using-the-handle-class"><a href="#Using-the-handle-class" class="headerlink" title="Using the handle class"></a>Using the handle class</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Student_info&gt; students;</span><br><span class="line">    Student_info record;</span><br><span class="line">    <span class="built_in">string</span>::size_type maxlen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read and store the data</span></span><br><span class="line">    <span class="keyword">while</span> (record.<span class="built_in">read</span>(<span class="built_in">cin</span>))&#123;</span><br><span class="line">        maxlen = <span class="built_in">max</span>(maxlen, record.name().<span class="built_in">size</span>());</span><br><span class="line">        students.push_back(record);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// alphabetize the student records</span></span><br><span class="line">    sort(students.<span class="built_in">begin</span>(), students.<span class="built_in">end</span>(), Student_info::compare);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write the names and grades</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Student_info&gt;::size_type i = <span class="number">0</span>;</span><br><span class="line">         i != students.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">             <span class="built_in">cout</span> &lt;&lt; students[i].name()</span><br><span class="line">             &lt;&lt; <span class="built_in">string</span>(maxlen + <span class="number">1</span> - students[i].name.<span class="built_in">size</span>(), <span class="string">' '</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">double</span> final_grade = students[i].grade();</span><br><span class="line">            streamsize prec = <span class="built_in">cout</span>.precision();</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; setprecision(<span class="number">3</span>) &lt;&lt; final_grade</span><br><span class="line">                 &lt;&lt; setprecision(prec) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (domain_error e)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; e.what() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Now the program takes either a undergraduate record or a graduate record. It first reads the character that says what kind of record we are about to read, then creates a new object and initializes it from input stream. Then it stores objects and deal with sorting, printing as same as the previous program. When it exits from the main, all created objects are deleted automatically through the destructor defined in the <strong>Student_info</strong> class. </p>
<h1 id="Subtleties"><a href="#Subtleties" class="headerlink" title="Subtleties"></a>Subtleties</h1><p>We are allowed to store <strong>Core</strong> or <strong>Grad</strong> objects into a <strong>vector<Core></strong> due to the fact that <strong>push_back</strong> function takes a reference to the <strong>vector</strong>‘s value type. But the result is that the vector only stores the <strong>Core</strong> part of a <strong>Grad</strong> object. </p>
<p>If we want to declare a <strong>virtual</strong> function, we must give it the same interface in the <strong>base</strong> and the <strong>derived</strong> classes.  </p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Notes</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ - Defining abstract data types(Part 2)</title>
    <url>/2018/05/06/Defining-abstract-data-types-Part-2/</url>
    <content><![CDATA[<p>The full version of <strong>Vec</strong> class template described in <a href="http://quanttour.com/14/04/2018/C-Defining-abstract-data-types/" target="_blank" rel="noopener">C++ - Defining abstract data types</a> is presented below. </p>
<p><strong>Vec.h</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_VEC_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_VEC_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;	 // std::cout, std::endl</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt; 	 // std::size_t</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;     // std::max</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;	 // std::allocator, std::uninitialized_fill, std::uninitialized_copy</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">Vec</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// member types</span></span><br><span class="line">    <span class="keyword">typedef</span> T* iterator;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">const</span> T* const_iterator;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> size_type;</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// constructors</span></span><br><span class="line">    Vec() &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"calling default constructor"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Vec</span><span class="params">(size_type n, <span class="keyword">const</span> T&amp; t = T())</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"calling the explicit constructor"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        create(n, t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// copy constructor,</span></span><br><span class="line">    Vec(<span class="keyword">const</span> Vec&amp; v) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"calling copy constructor"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        create(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//assignment operator</span></span><br><span class="line">    Vec&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Vec&amp;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// destructor</span></span><br><span class="line">    ~Vec() &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"calling destructor"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        uncreate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// indexing operator</span></span><br><span class="line">    <span class="keyword">const</span> T&amp; <span class="keyword">operator</span>[](size_type i) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"calling operation[]"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> data[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// push_back function</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T&amp; t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(avail == limit)</span><br><span class="line">            grow();</span><br><span class="line">        unchecked_append(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// size function</span></span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> avail - data; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// begin(), end() function</span></span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> data; &#125;</span><br><span class="line">    <span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> data; &#125;</span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> avail; &#125;</span><br><span class="line">    <span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> avail; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    iterator data;  <span class="comment">// first element in the Vec</span></span><br><span class="line">    iterator avail; <span class="comment">// (one past) the last element in the Vec</span></span><br><span class="line">    iterator limit; <span class="comment">// (one past) the allocated memory</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// facilities for memory allocation</span></span><br><span class="line">    <span class="built_in">std</span>::allocator&lt;T&gt; alloc; <span class="comment">// object to handle memory allocation</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// allocate and initialize the underlying array</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">(size_type, <span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">(const_iterator, const_iterator)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// destroy the elements in the array and free the memory</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">uncreate</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// support functions for push_back</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">grow</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unchecked_append</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// initialize data members to nullptr</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">Vec</span>&lt;T&gt;:</span>:create()</span><br><span class="line">&#123;</span><br><span class="line">    data = avail = limit = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// create and initialize data members with a size and a value</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">Vec</span>&lt;T&gt;:</span>:create(size_type n, <span class="keyword">const</span> T&amp; val)</span><br><span class="line">&#123;</span><br><span class="line">    data = alloc.allocate(n);</span><br><span class="line">    limit = avail = data + n;</span><br><span class="line">    <span class="built_in">std</span>::uninitialized_fill(data, limit, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// create and initialize data members by copying values from an input sequence</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">Vec</span>&lt;T&gt;:</span>:create(const_iterator i, const_iterator j)</span><br><span class="line">&#123;</span><br><span class="line">    data = alloc.allocate(j - i);</span><br><span class="line">    limit = avail = <span class="built_in">std</span>::uninitialized_copy(i, j, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// destruct the class object using destroy and deallocate functions</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">Vec</span>&lt;T&gt;:</span>:uncreate()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!data)&#123;</span><br><span class="line">        <span class="comment">// destroy the elements in reverse order</span></span><br><span class="line">        iterator it = avail;</span><br><span class="line">        <span class="keyword">while</span>(it != data)</span><br><span class="line">            alloc.destroy(--it);</span><br><span class="line">        alloc.deallocate(data, limit - data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// reset pointers to indicate that Vec is empty again</span></span><br><span class="line">    data = limit = avail = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// assign values from right-hand operand to the left-hand operand</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Vec</span>&lt;T&gt;&amp; <span class="title">Vec</span>&lt;T&gt;:</span>:<span class="keyword">operator</span>= (<span class="keyword">const</span> Vec&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"calling operator= function"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check for self-assignment</span></span><br><span class="line">    <span class="keyword">if</span>(&amp;rhs != <span class="keyword">this</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// free the array in the left-hand side</span></span><br><span class="line">        uncreate();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// copy elements from the right-hand to the left-hand side</span></span><br><span class="line">        create(rhs.<span class="built_in">begin</span>(), rhs.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reallocate storage to hold more elements</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">Vec</span>&lt;T&gt;:</span>:grow()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// when growing, allocate twice as much as space as currently in use</span></span><br><span class="line">    size_type new_size = <span class="built_in">std</span>::<span class="built_in">max</span>(<span class="number">2</span>*(limit-data), <span class="keyword">ptrdiff_t</span>(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// allocate new space and copy existing elements to the new space</span></span><br><span class="line">    iterator new_data = alloc.allocate(new_size);</span><br><span class="line">    iterator new_avail = <span class="built_in">std</span>::uninitialized_copy(data, avail, new_data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// return the old space</span></span><br><span class="line">    uncreate();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reset pointers to point to the newly allocated space</span></span><br><span class="line">    data = new_data;</span><br><span class="line">    avail = new_avail;</span><br><span class="line">    limit = data + new_size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// add new element at the end of the vector</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">Vec</span>&lt;T&gt;:</span>:unchecked_append(<span class="keyword">const</span> T&amp; val)</span><br><span class="line">&#123;</span><br><span class="line">    alloc.construct(avail++, val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* GUARD_VEC_H */</span></span></span><br></pre></td></tr></table></figure>

<p><strong>Test</strong></p>
<p>Now, let’s test our <strong>Vec</strong> class to see how does it work.</p>
<p><strong>main.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Vec.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        Vec&lt;<span class="keyword">int</span>&gt; v;		<span class="comment">// call default constructor</span></span><br><span class="line">        <span class="function">Vec&lt;<span class="keyword">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">10</span>, <span class="number">100</span>)</span></span>;	<span class="comment">// call explicit constructor</span></span><br><span class="line">        <span class="function">Vec&lt;<span class="keyword">int</span>&gt; <span class="title">v2</span><span class="params">(v1)</span></span>;	<span class="comment">// call copy constructor</span></span><br><span class="line">        v = v1;			<span class="comment">// call assignment operator</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// the destructor is expected to be called three times</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        Vec&lt;<span class="keyword">int</span>&gt; v;			<span class="comment">// call default constructor</span></span><br><span class="line">        <span class="keyword">if</span>(v.<span class="built_in">size</span>() == <span class="number">0</span>)&#123;		<span class="comment">// test size</span></span><br><span class="line">            v.push_back(<span class="number">10</span>);	<span class="comment">// test push_back function</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// test indexing operator</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"The first element is: "</span> &lt;&lt; v[<span class="number">0</span>] &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// call the destructor</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">Vec&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">5</span>, <span class="number">100</span>)</span></span>;	<span class="comment">// call explicit constructor</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// test iterator</span></span><br><span class="line">        <span class="keyword">for</span>(Vec&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); ++it)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; *(it) &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">        <span class="comment">// call the destructor</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Outputs</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">calling default constructor</span><br><span class="line">calling the explicit constructor</span><br><span class="line">calling copy constructor</span><br><span class="line">calling operator&#x3D; function</span><br><span class="line">calling destructor</span><br><span class="line">calling destructor</span><br><span class="line">calling destructor</span><br><span class="line"></span><br><span class="line">calling default constructor</span><br><span class="line">calling operation[]</span><br><span class="line">The first element is: 10</span><br><span class="line">calling destructor</span><br><span class="line"></span><br><span class="line">calling the explicit constructor</span><br><span class="line">100 100 100 100 100 </span><br><span class="line">calling destructor</span><br></pre></td></tr></table></figure>
<p>The test program generates outputs as expected. As mentioned in last post, the <strong>operator=</strong> function returns a reference to the new constructed class object can be more efficient than returning the value directly. The reason behind this is that returning a value unnecessarily calls the copy constructor and destructor. Let’s verify this by evaluating following statements within the setting of returning by value:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Vec&lt;<span class="keyword">int</span>&gt; v;			<span class="comment">// call default constructor</span></span><br><span class="line"><span class="function">Vec&lt;<span class="keyword">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">10</span>, <span class="number">100</span>)</span></span>;	<span class="comment">// call explicit constructor</span></span><br><span class="line">v = v1;			<span class="comment">// call assignment operator</span></span><br></pre></td></tr></table></figure>

<p><strong>Outputs</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">calling default constructor</span><br><span class="line">calling the explicit constructor</span><br><span class="line">calling operator&#x3D; function</span><br><span class="line">calling copy constructor</span><br><span class="line">calling destructor</span><br><span class="line">calling destructor</span><br><span class="line">calling destructor</span><br></pre></td></tr></table></figure>
<p>Comparing with the original version, the outputs are the same. However, the previous program evalutes four statements including a copy construction as well. This program only creates two objects: <strong>v</strong> and <strong>v1</strong>, but additionally calls the copy constructor and destructor once for each after calling the assignment operator. The results confirms our expectation. </p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Notes</tag>
      </tags>
  </entry>
  <entry>
    <title>Accelerated C++ Solutions to Exercises (Chapter 11)</title>
    <url>/2018/05/06/Accelerated-C-Solutions-to-Exercises-Chapter-11/</url>
    <content><![CDATA[<h1 id="Exercise-11-0"><a href="#Exercise-11-0" class="headerlink" title="Exercise 11-0"></a>Exercise 11-0</h1><p>Compile, execute, and test the programs in this chapter.</p>
<h2 id="Solution-amp-Results"><a href="#Solution-amp-Results" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>Please find the programs and analysis in <a href="http://quanttour.com/06/05/2018/Defining-abstract-data-types-Part-2/" target="_blank" rel="noopener">Defining abstract data types(Part 2)</a>.</p>
<h1 id="Exercise-11-1-11-2-11-3-11-4"><a href="#Exercise-11-1-11-2-11-3-11-4" class="headerlink" title="Exercise 11-1, 11-2, 11-3, 11-4"></a>Exercise 11-1, 11-2, 11-3, 11-4</h1><p>11-1: The Student_info structure that we defined in Chapter 9 did not define a copy constructor, assignment operator, or destructor. Why not?</p>
<p>11-2: That structure did define a default constructor. Why?</p>
<p>11-3: What does the synthesized assignment operator for Student_info objects do?</p>
<p>11-4: How many members does the synthesized Student_info destructor destroy?</p>
<h2 id="Solution-amp-Results-1"><a href="#Solution-amp-Results-1" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>Recalling the <strong>Student_info</strong> class:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_STUDENT_INFO</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_STUDENT_INFO</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student_info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Student_info ();					<span class="comment">// default constructor</span></span><br><span class="line">	Student_info (<span class="built_in">std</span>::istream &amp;);				<span class="comment">// constructor with argument</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> n; &#125;			<span class="comment">// inline member function return name</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">valid</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> !homework.empty(); &#125;            <span class="comment">// inline member function check state</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::istream &amp; <span class="title">read</span><span class="params">(<span class="built_in">std</span>::istream &amp;)</span></span>;			<span class="comment">// member function read in data</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">()</span> <span class="keyword">const</span></span>;					<span class="comment">// member function calculate final grade</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> n;</span><br><span class="line">    <span class="keyword">double</span> midterm, <span class="keyword">final</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; homework;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::istream &amp; <span class="title">read_hw</span><span class="params">(<span class="built_in">std</span>::istream &amp;, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;)</span></span>; <span class="comment">// nonmember function read data into a vector</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> Student_info &amp;, <span class="keyword">const</span> Student_info &amp;)</span></span>;	   <span class="comment">// nonmember function compare two string</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>If we don’t explicitly define a copy constructor, assignment operator and destructor, the compiler will synthesizes default versions of the unspecified operation. In this case, members <strong>midterm, final</strong> are built-in type variables and hence are copied and assigned by copying or assigning their value. But the destructors for built-in types do nothing. Members <strong>string</strong> and <strong>vector<double></strong> are class type variables and hence are copied, assigned, or destoryed by calling the constructor, assignment operator, and destructor for the data element. It is known that both these two standard classes define the corresponding behaviours in their headers. Therefore, it is unnecessary to define these operations in our class again. When the computer evaluates an assignment, for example</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Student_info <span class="title">record</span><span class="params">(<span class="built_in">cin</span>)</span></span>;   <span class="comment">// construct from input stream</span></span><br><span class="line">Student_info record_copy;   <span class="comment">// construct an empty object</span></span><br><span class="line">record_copy = record;       <span class="comment">// assignment</span></span><br><span class="line">``` </span><br><span class="line">it calls the <span class="keyword">default</span> assignment operators <span class="keyword">for</span> each data member as <span class="keyword">if</span>: </span><br><span class="line">```c++</span><br><span class="line">n = record.n;               <span class="comment">// call assignment operator defined in the string class</span></span><br><span class="line">midterm = record.m;         <span class="comment">// assign values</span></span><br><span class="line"><span class="keyword">final</span> = record.<span class="keyword">final</span>;       <span class="comment">// assign values</span></span><br><span class="line">homework = record.homework; <span class="comment">// call assignment operator defined in the vector class</span></span><br></pre></td></tr></table></figure>
<p>These operations typically involves obliterating the values of the left-hand side operand and then copying values from right-hand side operand into the left-hand side operand. By analogy, we know how the synthesized copy constructor work. When a <strong>Student_info</strong> class object is destructed, the synthesized destructor detroyes its data members by calling their destructors respectively. For <strong>midterm</strong> and <strong>final</strong>, their destructors have no work to do. Therefore, the synthesized Student_info destructor destroyes two data members. </p>
<p>The compiler will synthesize a default constructor for us if and only if we don’t explicitly define any constructors, even a copy constructor. In this case, we explicitly define a contructor with argument and hence no synthesized version for us. In addition, we do need a user-defined default constructor as the built-in types in local scope are undefined following the synthesized operation. </p>
<h1 id="Exercise-11-5"><a href="#Exercise-11-5" class="headerlink" title="Exercise 11-5"></a>Exercise 11-5</h1><p>Instrument the Student_info class to count how often objects are created, copied,assigned, and destroyed. Use this instrumented class to execute the student record programs from Chapter 6. Using the instrumented Student_info class will let you see how many copies the library algorithms are doing. Comparing the number of copies will let you estimate what proportion of the cost differences we saw are accounted for by the use of each library class. Do this instrumentation and analysis. </p>
<h2 id="Solution-amp-Results-2"><a href="#Solution-amp-Results-2" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>To be filled.</p>
<hr>
<h1 id="Exercise-11-6-11-7"><a href="#Exercise-11-6-11-7" class="headerlink" title="Exercise 11-6, 11-7"></a>Exercise 11-6, 11-7</h1><p>Add an operation to remove an element from a Vec and another to empty the entire Vec. These should behave analogously to the erase and clear operations on vectors.</p>
<p>Once you’ve added erase and clear to Vec, you can use that class instead of vector in most of the earlier programs in this book. Rewrite the Student_info programs from Chapter 9 and the programs that work with character pictures from Chapter 5 to use Vecs instead of vectors.</p>
<h2 id="Solution-amp-Results-3"><a href="#Solution-amp-Results-3" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>The original version can be found in <a href="http://quanttour.com/06/05/2018/Defining-abstract-data-types-Part-2/" target="_blank" rel="noopener">C++ - Defining abstract data types(Part 2)</a>. The program below only shows the new contents including the <strong>erase</strong> functions and the <strong>clear</strong> function. </p>
<p><strong>Vec.h</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_VEC_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_VEC_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt; 	 </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">Vec</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// as before</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// erase function</span></span><br><span class="line">    <span class="function">iterator <span class="title">erase</span><span class="params">(iterator iter)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overloaded erase function</span></span><br><span class="line">    <span class="function">iterator <span class="title">erase</span><span class="params">(iterator beg, iterator <span class="built_in">end</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clear function</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; erase(<span class="built_in">begin</span>(), <span class="built_in">end</span>()); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// as before</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">Vec</span>&lt;T&gt;:</span>:iterator Vec&lt;T&gt;::erase(iterator iter)&#123;</span><br><span class="line">    <span class="keyword">if</span> (iter + <span class="number">1</span> != avail)</span><br><span class="line">        <span class="built_in">std</span>::uninitialized_copy(iter + <span class="number">1</span>, avail, iter);</span><br><span class="line">    --avail;</span><br><span class="line">    alloc.destroy(avail);</span><br><span class="line">    <span class="keyword">return</span> iter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">Vec</span>&lt;T&gt;:</span>:iterator Vec&lt;T&gt;::erase(iterator first, iterator last)&#123;</span><br><span class="line">    <span class="keyword">if</span>(last != avail)</span><br><span class="line">        <span class="built_in">std</span>::uninitialized_copy(last, avail, first);</span><br><span class="line">    iterator new_avail = avail - (last - first);</span><br><span class="line">    iterator it = new_avail;</span><br><span class="line">    <span class="keyword">while</span> (it != avail)</span><br><span class="line">        alloc.destroy(it++);</span><br><span class="line">    avail = new_avail;</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The first <strong>erase</strong> function takes one parameter, an iterator, and removes the element pointed by the iterator. The second <strong>erase</strong> function takes two iterators, denoting a range [first, last), and removes all elements in this range. Both <strong>erase</strong> functions return an iterator pointing to the new location of the element that followed the last element erased by the function call. Noting that the position of <strong>limit</strong> keeps unchanged and hence the capacity of this vector remains the same. I only destroy these elements but do not free the space because the destructor will free the space occupied by the range [data, limit). The <strong>clear</strong> function calls the erase function and erase all elements in the range [first(), end()). The test program below shows that all three members work as expected.</p>
<p><strong>mainfunction.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Vec.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Vec&lt;<span class="keyword">double</span>&gt; v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// stores 0-9 into the Vec</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i != <span class="number">10</span>; ++i)</span><br><span class="line">        v.push_back(i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// traverse</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The original list is: "</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i: v)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// erase one by one starting from begin()</span></span><br><span class="line">    Vec&lt;<span class="keyword">double</span>&gt;::iterator i = v.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span>(i != v.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        v.erase(i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i: v)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Vec&lt;<span class="keyword">double</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The size of v1 is: "</span> &lt;&lt; v1.<span class="built_in">size</span>() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// erase first 5 elements</span></span><br><span class="line">    v1.erase(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">begin</span>() + <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The size of v1 is: "</span> &lt;&lt; v1.<span class="built_in">size</span>() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The rest elements are: "</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i: v1)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clear the Vec</span></span><br><span class="line">    v1.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The size of v1 is: "</span> &lt;&lt; v1.<span class="built_in">size</span>() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Outputs</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The original list is: 0 1 2 3 4 5 6 7 8 9 </span><br><span class="line">1 2 3 4 5 6 7 8 9 </span><br><span class="line">2 3 4 5 6 7 8 9 </span><br><span class="line">3 4 5 6 7 8 9 </span><br><span class="line">4 5 6 7 8 9 </span><br><span class="line">5 6 7 8 9 </span><br><span class="line">6 7 8 9 </span><br><span class="line">7 8 9 </span><br><span class="line">8 9 </span><br><span class="line">9 </span><br><span class="line"></span><br><span class="line">The size of v1 is: 10</span><br><span class="line">The size of v1 is: 5</span><br><span class="line">The rest elements are: 10 10 10 10 10 </span><br><span class="line">The size of v1 is: 0</span><br></pre></td></tr></table></figure>
<p>It is easy to rewrite the Student_info programs from Chapter 9 and the programs that work with character pictures from Chapter 5. No more discussion here.</p>
<hr>
<h1 id="Exercise-11-8"><a href="#Exercise-11-8" class="headerlink" title="Exercise 11-8"></a>Exercise 11-8</h1><p>Write a simplified version of the standard list class and its associated iterator.</p>
<h2 id="Solution-amp-Results-4"><a href="#Solution-amp-Results-4" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><h2 id="To-be-filled"><a href="#To-be-filled" class="headerlink" title="To be filled."></a>To be filled.</h2><h1 id="Exercise-11-9"><a href="#Exercise-11-9" class="headerlink" title="Exercise 11-9"></a>Exercise 11-9</h1><p>The grow function in §11.5.1/208 doubles the amount of memory each time it needsmore. Estimate the efficiency gains of this strategy. Once you’ve predicted how much of a difference it makes, change the grow function appropriately and measure the difference.</p>
<h2 id="Solution-amp-Results-5"><a href="#Solution-amp-Results-5" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>There is an article written by the authors Andrew Koenig and Barbara E. Mooon about this topic <a href="http://www.drdobbs.com/c-made-easier-how-vectors-grow/184401375" target="_blank" rel="noopener">C++ Made Easier: How Vectors Grow</a>.</p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Accelerated C++ Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Implementation: Dynamic Array-based Stack</title>
    <url>/2018/04/24/C-Implementations-Dynamic-Array-based-Stack/</url>
    <content><![CDATA[<p><strong>Stack</strong> is one of the rudimentary data structures that use pointers, with a main feature that it implements the <strong>Delete</strong> operation following <strong><em>last in, first out</em></strong> (i.e. <strong><em>LIFO</em></strong>). More specific, a <strong>stack</strong> is a dynamic set that allows <strong>Insert</strong> and <strong>Delete</strong> operations, which are typically named <strong>push</strong> and <strong>pop</strong> respectively. </p>
<p>The program given below illustrates an <strong>ADT</strong> named <strong>my_stack</strong>, which implements the <strong>stack</strong> based on a dynamic allocated array.<br><strong>my_stack</strong> is a class template and provides an interface that allows following operations:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">my_stack ms;        &#x2F;&#x2F; create a stack with fixed capacity 1000</span><br><span class="line">my_stack s(100);    &#x2F;&#x2F; create a stack with a user-supplied capacity </span><br><span class="line">s.get_capacity();   &#x2F;&#x2F; get the current capacity of s</span><br><span class="line">s.size();           &#x2F;&#x2F; get the number of elements contained in s</span><br><span class="line">s.empty();          &#x2F;&#x2F; check whether the stack is empty</span><br><span class="line">s.push();           &#x2F;&#x2F; insert an new element into the stack at the end of it</span><br><span class="line">s.pop();            &#x2F;&#x2F; delete the last inserted element from the stack, and return the deleted element</span><br><span class="line">s.top_element();    &#x2F;&#x2F; return the top element only</span><br></pre></td></tr></table></figure>
<p>Noting that the capacity of a stack means how many elements the stack can contain while the size means how many elements have the stack stored. </p>
<p><strong>stack implementation</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MYSTACK_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYSTACK_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;	// std::cout, std::endl</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;	// std::size_t</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;// std::domain_error</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">MyStack</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> size_type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// default constructor</span></span><br><span class="line">    MyStack(): top(<span class="number">0</span>), capacity(<span class="number">1000</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"default constructor"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        p = <span class="keyword">new</span> T[capacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// constructor with user-defined capacity</span></span><br><span class="line">    explicit MyStack(size_type t): top(0), capacity(t) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"constructor with user-defined size"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        p = <span class="keyword">new</span> T[capacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// copy constructor</span></span><br><span class="line">    MyStack(<span class="keyword">const</span> MyStack&amp; s): top(<span class="number">0</span>), capacity(s.capacity)&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"copy constructor"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        p = <span class="keyword">new</span> T[capacity];</span><br><span class="line">        T* temp = s.p;</span><br><span class="line">        <span class="keyword">while</span>(top != s.top)&#123;</span><br><span class="line">            p[top] = *temp;</span><br><span class="line">            ++top;</span><br><span class="line">            ++temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// assignment operator</span></span><br><span class="line">    MyStack&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> MyStack&amp; s)&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"assignment operator"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span>(&amp;s != <span class="keyword">this</span>)&#123;</span><br><span class="line">            <span class="built_in">clear</span>();</span><br><span class="line">            capacity = s.capacity;</span><br><span class="line">            p = <span class="keyword">new</span> T[capacity];</span><br><span class="line">            T* temp = s.p;</span><br><span class="line">            <span class="keyword">while</span>(top != s.top)&#123;</span><br><span class="line">                p[top] = *temp;</span><br><span class="line">                ++top;</span><br><span class="line">                ++temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// destructor</span></span><br><span class="line">    ~MyStack() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] p;</span><br><span class="line">        p = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        top = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// capacity: O(1)</span></span><br><span class="line">    <span class="function">size_type <span class="title">get_capacity</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> capacity; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// size: O(1)</span></span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> top; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// empty</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> top == <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// top_element: O(1)</span></span><br><span class="line">    <span class="function">T <span class="title">top_element</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> p[top - <span class="number">1</span>]; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// push element: O(1)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T&amp; t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(top == capacity)</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">std</span>::domain_error(<span class="string">"stack overflow"</span>);</span><br><span class="line">        p[top] = t;</span><br><span class="line">        ++top;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pop element and return the deleted element: O(1)</span></span><br><span class="line">    <span class="function">T <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(top == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">std</span>::domain_error(<span class="string">"stack underflow"</span>);</span><br><span class="line">        --top;</span><br><span class="line">        <span class="keyword">return</span> p[top];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	size_type top;		<span class="comment">// count the number of elements</span></span><br><span class="line">	size_type capacity;	<span class="comment">// capacity of the stack</span></span><br><span class="line">	T* p;				<span class="comment">// a hidden pointer to head</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* MYSTACK_H_ */</span></span></span><br></pre></td></tr></table></figure>

<p>The shortcoming of above stack is that it cannot grow automatically. Except constructors, each of member functions has constant complexity. The follwing program tests each operation listed above and shows that the my_stack works as expected. </p>
<p><strong>stack test</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * this program tests all operations that provided by the MyStack&lt;int&gt; class</span></span><br><span class="line"><span class="comment"> * created by Liam on: 27 Apr 2018</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;		// std::cout, std::endl</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;	// std::domain_error</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MyStack.h"</span>	<span class="comment">// MyStack</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::domain_error;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#123;	<span class="comment">// test default constructor</span></span><br><span class="line">        MyStack&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// test member capacity()</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"The capacity of the stack is: "</span> &lt;&lt; s.get_capacity() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// test member empty()</span></span><br><span class="line">        <span class="keyword">if</span>(s.empty())</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"The stack is empty\n"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// test member push(const T&amp; t)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i != <span class="number">10</span>; ++i)</span><br><span class="line">            s.push(i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// test member pop</span></span><br><span class="line">        <span class="keyword">while</span>(s.<span class="built_in">size</span>() != <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; s.pop() &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\n\n"</span>;</span><br><span class="line"></span><br><span class="line">    &#123;	<span class="comment">// test constructor with size</span></span><br><span class="line">        <span class="function">MyStack&lt;<span class="keyword">int</span>&gt; <span class="title">s</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i != s.get_capacity(); ++i)</span><br><span class="line">            s.push(i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// test the case of overflow</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            s.push(<span class="number">10</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(<span class="built_in">std</span>::domain_error e)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; e.what() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// test copy constructor</span></span><br><span class="line">        <span class="function">MyStack&lt;<span class="keyword">int</span>&gt; <span class="title">s_copy</span><span class="params">(s)</span></span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"The top element in MyStack is: "</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; s_copy.top_element() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// test assignment operator</span></span><br><span class="line">        s.pop();</span><br><span class="line">        s_copy = s;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(s_copy.<span class="built_in">size</span>() != <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; s_copy.pop() &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            s_copy.pop();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(domain_error e)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; e.what() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Outputs</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">default</span> constructor</span><br><span class="line">The capacity of the <span class="built_in">stack</span> is: <span class="number">1000</span></span><br><span class="line">The <span class="built_in">stack</span> is empty</span><br><span class="line"><span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">0</span> </span><br><span class="line"></span><br><span class="line">constructor with user-defined <span class="built_in">size</span></span><br><span class="line"><span class="built_in">stack</span> <span class="built_in">overflow</span></span><br><span class="line">copy constructor</span><br><span class="line">The top element in MyStack is: <span class="number">9</span></span><br><span class="line">assignment <span class="keyword">operator</span></span><br><span class="line"><span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">0</span> <span class="built_in">stack</span> underflow</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Data Structures</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ - Making class objects act like values</title>
    <url>/2018/04/22/C-Making-class-objects-act-like-values/</url>
    <content><![CDATA[<p>As last chapter introduces, we can control what happens when objects are created, copied, assigned, and destroyed by defining special members. Now we intend to make class objects act like objects of built-in types through controlling more operations such as type conversion. A typical example is that the standard library class <strong>string</strong> provides rich set of operators and supports automatic conversions. Following the standard <strong>string</strong>, we’ll write our own <strong>Str</strong> class. </p>
<h1 id="A-simple-string-class"><a href="#A-simple-string-class" class="headerlink" title="A simple string class"></a>A simple string class</h1><p>Analogous to the <strong>Vec</strong> class built in last chapter, we could write our <strong>Str</strong> based on dynamiclly allocated array. But it is also known that the standard <strong>string</strong> share many operations with the standard <strong>vector</strong> while the major difference is that a <strong>string</strong> is a container that only contains <strong>char</strong> elements. Therefore, we can design <strong>Str</strong> based on <strong>Vec</strong> rather than the lower level data structure. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Str</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> Vec&lt;<span class="keyword">char</span>&gt;::size_type size_type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// default constructor; create an empty Str</span></span><br><span class="line">    Str() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create a Str containing n copies of c</span></span><br><span class="line">    Str(size_type n, <span class="keyword">char</span> c): data(n, c) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create a Str from a null-terminated array of char</span></span><br><span class="line">    Str(<span class="keyword">const</span> <span class="keyword">char</span>* cp)&#123;</span><br><span class="line">        <span class="built_in">std</span>::copy(cp, cp + <span class="built_in">std</span>::<span class="built_in">strlen</span>(cp), <span class="built_in">std</span>::back_inserter(data));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create a Str from the range denoted by iterators b and e</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">In</span>&gt; <span class="title">Str</span>(<span class="title">In</span> <span class="title">b</span>, <span class="title">In</span> <span class="title">e</span>)&#123;</span></span><br><span class="line">        <span class="built_in">std</span>::copy(b, e, <span class="built_in">std</span>::back_inserter(data));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Vec&lt;<span class="keyword">char</span>&gt; data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>It can be observed that our <strong>Str</strong> is implemented through a hidden <strong>Vec<char></strong>. There are four constructors defined in above class. The first functon is a default constructor that creates an empty <strong>Str</strong> through invoking the <strong>Vec</strong> <strong>default constructor</strong>. It is worth noting that we have to explicitly define a default constructor thought it does exactly . If we don’t define a default constructor,the compiler won’t synthesize one for us as there exist other constructors. The second constructor takes a size and a character and initializes the only data member <strong>data</strong> by invoking another <strong>Vec</strong> constructor that takes a size and a value. The third constructor allows us to create a string with passing an argument that is a pointer to char, that is, a null-terminated array of char. It uses the standard algorithm <strong>copy</strong> to copy the elements from the array of char, covering the range <strong>[cp, cp+std::strlen(cp))</strong> into <strong>data</strong>. <strong>cp</strong> points to the first character of the array and <strong>cp + std::strlen(cp)</strong>, where <strong>strlen(cp) returns the length of the array excluding the ‘\0’</strong>, points to one past the last character in the array. Similarly, the last constructor creates a <strong>string</strong> by taking two input iterators that denotes a sequence of characters. But it is worth nothing that it is not a function but a function template. It accepts different kinds of iterators, which implies that it can construct a string object from various containers like the array of char, standard vector, standard list etc.. </p>
<p>We also observed that the <strong>Str</strong> doesn’t define a copy constructor, assignment operator and default destructor. The synthesized operations call the corresponding members of <strong>Vec</strong> when we copy or assign or destruct the <strong>Str</strong> object. In fact, the <strong>Str</strong> class does no memory allocation and hence doesn’t require a destructor. According to the rule of three, a class that needs no destructor doesn’t need an explicit copy constructor or assignment operator either. </p>
<h1 id="Automatic-conversions"><a href="#Automatic-conversions" class="headerlink" title="Automatic conversions"></a>Automatic conversions</h1><p>In the case of the <strong>Str</strong> class, the conversions may happen when we assign a string literal to a string type object. For example:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Str t;    <span class="comment">// default initialize t</span></span><br><span class="line">t = <span class="string">"hello"</span>;    <span class="comment">// assign a new value to t</span></span><br></pre></td></tr></table></figure>
<p>The first statement creates an empty string and the second statement assigns the value of the right-hand side to the left-hand side. However, the left-hand side has type <strong>Str</strong> while the right-hand side has type <strong>const char*</strong>. In addition, we didn’t define the assignment operator. How does the compiler evaluates this expression? It turns out that the compiler will call the constructor that takes the a <strong>const char*</strong>. In other words, the statement invokes the same constructor as the following statement:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Str <span class="title">t</span><span class="params">(<span class="string">"hello"</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>This example indicates that constructors also acts a <strong>user-defined conversion</strong> which determines how to transform to and from objects of class type. In generally, we define conversions by defining a constructor with a single argument. The above statement <strong>t = “hello”;</strong> involves two steps: firstly, calling the <strong>Str(const char*)</strong> to construct an unnamed local temporary of type <strong>Str</strong> from the string literal; then calls the synthesized assignment operator to assign this temporary to <strong>t</strong>. </p>
<h1 id="Str-operations"><a href="#Str-operations" class="headerlink" title="Str operations"></a>Str operations</h1><p>Now we further extent the operations of our <strong>Str</strong> class such that a <strong>Str</strong> type string <strong>s</strong> supports following operations:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cin</span> &gt;&gt; s;    <span class="comment">// use the input operator to read a string</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s;   <span class="comment">// use the output operator to write a string</span></span><br><span class="line">s[i];        <span class="comment">// use the index operator to access a character</span></span><br><span class="line">s1 + s2;     <span class="comment">// use the addition operator to concatenate two strings</span></span><br></pre></td></tr></table></figure>

<h2 id="indexing-operator"><a href="#indexing-operator" class="headerlink" title="indexing operator"></a>indexing operator</h2><p>We have learned how to define a operator, such as <strong>operator=</strong>, in defining the <strong>Vec</strong> class. We can define these operators in a similar manner. All above operators are binary operators and hence each operator function takes two parameters, one of which may be implicit if the function is a member. We are familar with the indexing operator. Let’s define it first:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Str</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// constructors as before</span></span><br><span class="line">    <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](size_type i) &#123; <span class="keyword">return</span> data[i]; &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](size_type i) <span class="keyword">const</span> &#123; <span class="keyword">return</span> data[i]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Vec&lt;<span class="keyword">char</span>&gt; data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>We define two operators to take the case that access elements of a const string into consideration. Details of the implementation go to the indexing operator defined in the <strong>Vec<char></strong>. </p>
<h2 id="input-and-output-operator"><a href="#input-and-output-operator" class="headerlink" title="input and output operator"></a>input and output operator</h2><p>Now let’s think about how to implement the input operator <strong>&gt;&gt;</strong> and the output operator <strong>&lt;&lt;</strong>. The first problem is should these operators be members of a class? Due to the operator (e.g. &gt;&gt;) changes the state of a string, we might think it should be a member of the <strong>Str</strong>. But it is also known that the left operand is bound to the first parameter while the right operand is bound to the second parameter. Thus, </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cin</span> &gt;&gt; s;</span><br></pre></td></tr></table></figure>
<p>is equivalent to </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cin.operator &gt;&gt; (s);</span><br></pre></td></tr></table></figure>
<p>which calls the overloaded &gt;&gt; operator defined for the object <strong>cin</strong>. This implies that the operator should be a member of the <strong>istream</strong> class. However, we cannot define such operation as we don’t have the definition of the <strong>istream</strong> class. If we define the operator in <strong>Str</strong>, it should invoke the input operation through</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">s.operation&gt;&gt; (<span class="built_in">cin</span>);</span><br></pre></td></tr></table></figure>
<p>or equivalently,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s &gt;&gt; cin;</span><br></pre></td></tr></table></figure>
<p>which obviously would flout the conventions used throughout the library. </p>
<p>Know then that both the input and output operators should be non-member functions. Let’s declare two non-member functions:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::istream&amp; <span class="keyword">operator</span>&gt;&gt;(<span class="built_in">std</span>::istream&amp;, Str&amp;);</span><br><span class="line"><span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp;, <span class="keyword">const</span> Str&amp;);</span><br></pre></td></tr></table></figure>
<p>To write the output operator, we need to access each character stored in the <strong>Str</strong>. Therefore, the implementation could be</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="keyword">const</span> Str&amp; s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(Str::size_type i = <span class="number">0</span>; i != s.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        os &lt;&lt; s[i];</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>To use this function, we have to define the <strong>size</strong> member first</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Str</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> data.<span class="built_in">size</span>(); &#125;</span><br><span class="line">    <span class="comment">// as before</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Friends"><a href="#Friends" class="headerlink" title="Friends"></a>Friends</h3><p>Unlike the output operator, the input operator is a little bit complex. The logic is that each time read one character from the input stream and then add the character to our <strong>Str</strong>. The experience of using the standard <strong>string</strong> tells us that when reading data from the input stream, it discards the leading whitespace. Beyond this, we should also take into consider the case that there exist old values in the <strong>Str</strong>. Let’s see how following code deal with these problems.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// this code won't compile quite yet</span></span><br><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; is, Str&amp; s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// obliterate existing value(s)</span></span><br><span class="line">    s.data.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read and discard leading whitespace</span></span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">while</span>(is.<span class="built_in">get</span>(c) &amp;&amp; <span class="built_in">isspace</span>(c))</span><br><span class="line">        ; <span class="comment">// nothing to do except testing the condition</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// if still something to read, do so until next whitespace character</span></span><br><span class="line">    <span class="keyword">if</span>(is) &#123;</span><br><span class="line">        <span class="keyword">do</span> s.data.push_back(c); </span><br><span class="line">        <span class="keyword">while</span>(is.<span class="built_in">get</span>(c) &amp;&amp; !<span class="built_in">isspace</span>(c));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if we read whitespace, then put it back on the stream</span></span><br><span class="line">        <span class="keyword">if</span>(is)</span><br><span class="line">            is.unget();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>the first step is to obliterate the old values. </li>
<li>the second step is to discard the leading whitespace. Two conditions control the while loop, one is that whether characters are available and another one is that whether the character read from the input stream is a space. The member function <strong>get</strong> extracts one character each time, if there exists characters, it returns the character and will be evaluated to <strong>true</strong>. If there no available character, it returns eof and will be evaluated to <strong>false</strong>. In summary, if the while loop ceases, there would be two situations, no character is available or the character is not a whitespace anymore. </li>
<li>then we perform reading process if there still available character in the input stream after step 2. The reading process calls the member function <strong>push_back</strong> to append one character one time. It stops if it reads nothing from the stream or encounters a whitespace. In the case that it encounters a whitespace, there might be other characters following the extracted whitespace. Therefore, we should put the extracted whitespace back on the stream. This is done by calling another member function of the <strong>istream</strong> class, that is, <strong>unget</strong> which decreases the current location by one character such that the extracted character can be extracted again next. </li>
</ol>
<p>The logic is perfect and we do solve the problems mentioned earlier. However, above code fails to compile due to that <strong>operator&gt;&gt;</strong> is not allowed to access the private data member <strong>data</strong> defined in the <strong>Str</strong>. We could add public member functions <strong>clear</strong> and <strong>push_back</strong> to our <strong>Str</strong> class like we did for our <strong>Vec</strong> class. But in this case, well solve this problem with an alternative method, using keyword <strong>friend</strong>.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Str</span>&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">std</span>::istream&amp; <span class="keyword">operator</span>&gt;&gt;(<span class="built_in">std</span>::istream&amp;, Str&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>A <strong>friend</strong> gives the function <strong>operator&gt;&gt;</strong> access and write rights to the private data members defined in the <strong>Str</strong> class. In other words, if making one function a <strong>friend</strong> of a class, we are saying that the function will be treated as a member (either public or private) by the class. Above code shows that we add the declaration of <strong>operator&gt;&gt;</strong> into the <strong>Str</strong> class and specify it is a friend of the class. </p>
<h2 id="Other-binary-operators"><a href="#Other-binary-operators" class="headerlink" title="Other binary operators"></a>Other binary operators</h2><p>We also consider that define the addition operator as a non-member function. The reason is that the addition operation doesn’t change values of the left-hand operand as well as the right-hand operand. The result of the addition operation between two strings is a string that concatenates two strings. Thus, the return type shoule be <strong>Str</strong>. Therefore, the <strong>operator=</strong> may be declared as follows:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Str <span class="keyword">operator</span>+(<span class="keyword">const</span> Str&amp;, <span class="keyword">const</span> Str&amp;);</span><br></pre></td></tr></table></figure>
<p>After we complete writing the implementation, our program would supports the concatenation operation between two <strong>Str</strong>s through</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Str s1 = <span class="string">"xxx"</span>;</span><br><span class="line">Str s2 = <span class="string">"yyy"</span>;</span><br><span class="line">s1 = s1 + s2;</span><br></pre></td></tr></table></figure>
<p>Our experience tells us that we can concatenate two standard strings in an alternative form:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">s1 += s2;</span><br></pre></td></tr></table></figure>
<p>Both two statements involve two processes: the right-hand side creates a new temporary object that is the concatenation of two strings, then the value of the constructed object is assigned to the left-hand side. The difference is that <strong>operator+=</strong> changes the value of left-hand operand. Therefore, we will define the <strong>operator+=</strong> as a public member of the <strong>Str</strong> class. Let’s see how to define <strong>operator+=</strong> first</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Str</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Str&amp; <span class="keyword">operator</span>+=(<span class="keyword">const</span> Str&amp; s)&#123;</span><br><span class="line">        <span class="built_in">std</span>::copy(s.data.<span class="built_in">begin</span>(), s.data.<span class="built_in">end</span>(), <span class="built_in">std</span>::back_inserter(data));</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// as before</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Vec&lt;<span class="keyword">char</span>&gt; data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// as before</span></span><br><span class="line">Str <span class="keyword">operator</span>+(<span class="keyword">const</span> Str&amp;, <span class="keyword">const</span> Str&amp;);</span><br></pre></td></tr></table></figure>
<p>There is nothing new in above implementation of the <strong>operator+=</strong>. Now let’s define the <strong>operator+</strong>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Str <span class="keyword">operator</span>+(<span class="keyword">const</span> Str&amp; s, <span class="keyword">const</span> Str&amp; t)&#123;</span><br><span class="line">    Str r = s;</span><br><span class="line">    r += t;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In the definition, we use the <strong>operator+=</strong> and the synthesized copy constructor to achieve the concatenation of two strings.  </p>
<h2 id="Mixed-type-expressions"><a href="#Mixed-type-expressions" class="headerlink" title="Mixed-type expressions"></a>Mixed-type expressions</h2><p>The standard library <strong>string</strong> class also allows us to concatenate a string literal and a string regardless there order. As a result, we get a new string type object. For our <strong>Str</strong> class, we have defined the concatenation <strong>operator</strong> that takes operands of type <strong>const Str&amp;</strong>. So, What would happen if following statement is evaluated:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Str greeting = <span class="string">"Hello, "</span> + name + <span class="string">"!"</span>; <span class="comment">// where **name** is a **Str** type object.</span></span><br></pre></td></tr></table></figure>
<p>an alternative and equivalent statement</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Str greeting = (<span class="string">"Hello, "</span> + name) + <span class="string">"!"</span>;</span><br></pre></td></tr></table></figure>
<p>We can observe that there are two forms of <strong>+</strong>. The first <strong>+</strong> takes a string literal as its first operand and a <strong>Str</strong> as its seconnd operand, while in the other, the left operand is a <strong>Str</strong> and the right operand is a string literal. We may think that we should define two additional <strong>operator+</strong> to handle these two case as the <strong>operator+</strong> defined above only takes two arguments that are both <strong>const Str&amp;</strong>. In fact, our <strong>Str</strong> class handles these expressions already, by means of calling the constructor that takes a <strong>const char*</strong>. This is because that the constructor is also a conversion operator that can convert a <strong>const char*</strong> to a <strong>Str</strong>. Let’s see how exactly the <strong>Str</strong> deal with this statement:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="function">Str <span class="title">temp1</span><span class="params">(<span class="string">"Hello, "</span>)</span></span>;        <span class="comment">// call Str::Str(const char*)</span></span><br><span class="line"><span class="number">2.</span> Str temp2 = temp1 + name;    <span class="comment">// call operator+(const Str&amp;, const Str&amp;)</span></span><br><span class="line"><span class="number">3.</span> <span class="function">Str <span class="title">temp3</span><span class="params">(<span class="string">"!"</span>)</span></span>;              <span class="comment">// call Str::Str(const char*)</span></span><br><span class="line"><span class="number">4.</span> Str greeting = temp2 + temp3;<span class="comment">// call operator+(const Str&amp;, const Str&amp;)</span></span><br></pre></td></tr></table></figure>
<p>The implied conversion operations may be expensive due to multiple temporaries. But certainly, we still can explicitly define two additional versions o the <strong>operator+</strong> to deal with this case. </p>
<h2 id="Designing-binary-operators"><a href="#Designing-binary-operators" class="headerlink" title="Designing binary operators"></a>Designing binary operators</h2><p>There are some rules in defining binary operators(Koening and Moo 2000):</p>
<p><em>1. If a class supports type conversions, then it is usually good practice to define binary operators as nonmember functions. By doing so, we preserve symmetry between the operands.</em></p>
<p><em>2. If an operator is a member of a class, then that operator’s left operand cannot be the result of an automatic conversion.</em></p>
<p><em>3. The left operand of a nonmember operator, and the right operand of any operator, follow the same rules as any ordinary function argument: the operand can be any type that can be converted to the parameter type.</em></p>
<p><em>4. like the assignment operator itself, all the compound-assignment operators (e.g. +=) should be members of the class.</em></p>
<h2 id="Some-conversions-are-hazardous"><a href="#Some-conversions-are-hazardous" class="headerlink" title="Some conversions are hazardous"></a>Some conversions are hazardous</h2><p>Recalling the <strong>Vec</strong> class designed in last chapter, it contains a constructor that takes a size (and a value if supplied) (as shown below). </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Vec</span><span class="params">(size_type n, <span class="keyword">const</span> T&amp; t = T())</span> </span>&#123; create(n, t); &#125;</span><br></pre></td></tr></table></figure>
<p>The <strong>explicit</strong> specifies that the constructor can only construct an object explicitly. If we don’t declare the <strong>Vec</strong> constructor as <strong>explicit</strong>, then we could implicitly create a Vec of a given size. To illustrate how useful the <strong>explicit</strong> is, let’s see an example:<br>. It is crucial that consider about the type conversion when defining a single parameter constructor for a class.</p>
<h1 id="Conversion-operators"><a href="#Conversion-operators" class="headerlink" title="Conversion operators"></a>Conversion operators</h1><p>We have known that we can implicitly define conversion operations through defining constructors. Those cases typically involve that a class defines how to convert an object from a different type to the type of the class itself. In fact, class authors can also explicitly define <strong>conversion operators</strong>, which determines how to convert an object from its type to a target type.  </p>
<p>A <strong>conversion operator</strong> must be defined as a member of a class, begining with the keyword <strong>operator</strong> followed by the target type name. For example, </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">class <span class="title">Student_info</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>The <strong>conversion operator</strong> above defines that a <strong>Student_info</strong> can be converted to a <strong>double</strong> type object. The definition of <strong>operator</strong> would say how exactly create a <strong>double</strong> from a <strong>Student_info</strong>. For example, we can convert the class object to its corresponding final grade, and then use this property in calculating an average grade for a class.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;Student_info&gt; vs;</span><br><span class="line"><span class="comment">// fill up vs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> d = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> = <span class="number">0</span>; i != vs.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    d += vs[i]; <span class="comment">// vs[i] is automatically converted to double</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Average grade: "</span> &lt;&lt; d/vs.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>In fact, we use this kind conversion operator everytime when we write a loop that implicitly tests the value of an <strong>istream</strong>. See the example</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">cin</span> &gt;&gt; x) &#123; <span class="comment">/*...*/</span> &#125;</span><br></pre></td></tr></table></figure>
<p>is equivalent to</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">cin</span>) &#123; <span class="comment">/*...*/</span> &#125;</span><br></pre></td></tr></table></figure>
<p>It is known that the condition should be an expression that yields a value that is convertible to type <strong>bool</strong>. Using a value of any arithmetic or pointer type automatically converts the value to type <strong>bool</strong>, thus we can uses values of these type in the expression. But a <strong>iostream</strong> object neither an arithmetic type object nor a pointer type object. To makes the <strong>if condition</strong> works in above case, the standard library defines a conversion from type <strong>istream</strong> to <strong>void*</strong>, i.e. a pointer to <strong>void</strong>. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">istream::<span class="keyword">operator</span> <span class="keyword">void</span>* &#123;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The <strong>operator</strong> tests various status flags to to determine whether the <strong>istream</strong> is valid and return either 0 or an implementation-defined non-zero <strong>void*</strong> value to indicate the state of the stream. </p>
<p>It is necessary to explain the use of <strong>void*</strong>. A pointer to <strong>void</strong> is known as a <strong>universal pointer</strong> which can point to any type of object. We cannot deference such pointer because the type of the object to yield is unknown. But we can convert a <strong>void*</strong> to <strong>bool</strong>. </p>
<p>One might wonder why don’t the <strong>istream</strong> define conversion operator to <strong>bool</strong> directly. The reason is that doing so allows the compiler to detect the following erroneous usage:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">cin</span> &lt;&lt; x; <span class="comment">// we should have to written cin &gt;&gt; x</span></span><br></pre></td></tr></table></figure>
<p>If the conversion operator converts a <strong>istream</strong> object to <strong>bool</strong>, this expression would convert <strong>cin</strong> to a <strong>bool</strong>, and thereby converts the bool to <strong>int</strong> again. As a result, the converted value is shifted left by a number of bits equal to the value of <strong>x</strong>. </p>
<h1 id="Conversions-and-memory-management"><a href="#Conversions-and-memory-management" class="headerlink" title="Conversions and memory management"></a>Conversions and memory management</h1><p>In this section, we think about the conversion that from a string type to a null-terminated arrays of characters. If we can successfully convert a string to an array of characters, we then can pass the string to a functions that requires and operates on null-terminated arrays. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Str</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// plausible, but problematic conversion operations</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="keyword">char</span>*();</span><br><span class="line">    <span class="keyword">operator</span> <span class="keyword">const</span> <span class="keyword">char</span>*() <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// as before</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Vec&lt;<span class="keyword">char</span>&gt; data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>If above code works, we then can write code such as</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Str S;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="function">ifstream <span class="title">in</span><span class="params">(s)</span></span>; <span class="comment">// wishful thinking: converts s and then open the stream named s</span></span><br></pre></td></tr></table></figure>
<p><em>(Noting that since c++11, <strong>ifstream</strong> allows us to open a file using either a string type name or a c-stype(i.e. null-termintated array) name.)</em></p>
<p>There are several difficulties in defining such operator: </p>
<ol>
<li>we can’t simply return <strong>data</strong> as <strong>data</strong> is a <strong>Vec<char></strong> while we need an array of <strong>char</strong>.</li>
<li>if we design our <strong>Vec</strong> based on an array of <strong>char</strong>, we could return it as the converted result. However, doing so exposes the private data member, which violates the class <strong>Str</strong>‘s encapsulation. If users obtained a pointer to <strong>data</strong>, they could change the value of the string. In addition, if the string is destroyed, then the pointer becomes invalid and any related operations would be dengerous. </li>
</ol>
<p>To solve the encapsulation problem, we may provide only one conversion to <strong>const char*</strong>. To solve the dangling pointer problem, we may allocate a new space for a copy of the characters from data, and returning a pointer to this newly allocated space. By doing so, users can manage the allocated storage properly. However, this design probably doesn’t work either because the conversion happens implicitly and hence no pointer is provided explicitly. </p>
<p>The standard <strong>string</strong> class takes a different approach that allows us to get a copy of the <strong>string</strong> in a character array but also makes them do explicitly. It defines three member functions to get a character array from a <strong>string</strong>. The first is <strong>c_str()</strong> which copies the contents of the <strong>string</strong> into a null-terminated <strong>char</strong> array. The <strong>string</strong> owns the array and users are expected not to delete the pointer. The data in the array are ephemeral and is only valid until the next call of a member function that might change the <strong>string</strong>. The second <strong>data()</strong> is like <strong>c_str</strong> except that it returns an array that is not null-terminated (c++11 releases this condition and hence data() and c_str() are synonym and return the same value). Finally, the <strong>copy</strong> function takes a <strong>char*</strong> and an integer as arguments, and copies as many characters as indicated by the integer into space pointed by the <strong>char*</strong>, which soace the user must allocate and free. These functions work as we expected. However, this type of <strong>coversions</strong> seems explicitly rather than implicitly. </p>
<hr>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Notes</tag>
      </tags>
  </entry>
  <entry>
    <title>Implementing the C++ STL Algorithms-Part 1: Simple Find Algorithms</title>
    <url>/2018/04/15/Implementing-the-C-STL-Algorithms-Part-1-Simple-Find-Algorithms/</url>
    <content><![CDATA[<h1 id="find-beg-end-val"><a href="#find-beg-end-val" class="headerlink" title="find(beg, end, val)"></a><strong>find(beg, end, val)</strong></h1><h2 id="Possible-implementation"><a href="#Possible-implementation" class="headerlink" title="Possible implementation"></a>Possible implementation</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">InputIterator</span> <span class="title">find</span>(<span class="title">InputIterator</span> <span class="title">beg</span>, <span class="title">InputIterator</span> <span class="title">end</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">val</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">while</span>(beg != <span class="built_in">end</span> &amp;&amp; *beg != val)</span><br><span class="line">        ++beg;</span><br><span class="line">    <span class="keyword">return</span> beg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Key-points"><a href="#Key-points" class="headerlink" title="Key points"></a>Key points</h2><ol>
<li>parameters <strong>beg</strong> and <strong>end</strong> are two <strong>Input iterators</strong>,denoting that the range searched is [beg, end). <strong>val</strong> is the value to search for in the range. </li>
<li>the algorithm returns an iterator to the first element in the range [beg, end) equal to <strong>val</strong>. If no such element is found, the function returns <strong>end</strong>. </li>
<li><strong>pointer</strong>s are random access iterators and hence are also valid input iterators. Therefore, the algorithm can also be applied to the built-in <strong>array</strong>. </li>
<li>complexity: linear</li>
</ol>
<h2 id="Test-program"><a href="#Test-program" class="headerlink" title="Test program"></a>Test program</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test my find algorithm</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;			// cout, endl</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;			// vector</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;			// strlen</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"my_algorithms.h"</span>	        <span class="comment">// my_find</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>; 	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">find</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">strlen</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// to find an int type element in a vector</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec&#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">87</span>, <span class="number">9</span>, <span class="number">35</span>, <span class="number">77</span>, <span class="number">60</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = my_find(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">60</span>);</span><br><span class="line">    <span class="keyword">if</span>(it != vec.<span class="built_in">end</span>())</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Element is found in vec: "</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Element is not found in vec"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// to find an char type element in an array</span></span><br><span class="line">    <span class="keyword">char</span> arr[] = <span class="string">"computational"</span>;</span><br><span class="line">    <span class="keyword">char</span>* p = my_find(arr, arr+<span class="built_in">strlen</span>(arr), <span class="string">'u'</span>);</span><br><span class="line">    <span class="keyword">if</span>(p != arr+<span class="built_in">strlen</span>(arr))</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Element is found in arr: "</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Element is not found in arr"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Outputs</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Element is found in vec: 60</span><br><span class="line">Element is found in arr: u</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="find-if-beg-end-UnaryPred"><a href="#find-if-beg-end-UnaryPred" class="headerlink" title="find_if(beg, end, UnaryPred)"></a><strong>find_if(beg, end, UnaryPred)</strong></h1><h2 id="Possible-implementation-1"><a href="#Possible-implementation-1" class="headerlink" title="Possible implementation"></a>Possible implementation</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">UnaryPred</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">InputIterator</span> <span class="title">my_find_if</span>(<span class="title">InputIterator</span> <span class="title">beg</span>, <span class="title">InputIterator</span> <span class="title">end</span>, <span class="title">UnaryPred</span> <span class="title">pred</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">while</span>(beg != <span class="built_in">end</span> &amp;&amp; !pred(*beg))</span><br><span class="line">        ++beg;</span><br><span class="line">    <span class="keyword">return</span> beg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Key-points-1"><a href="#Key-points-1" class="headerlink" title="Key points"></a>Key points</h2><ol>
<li><strong>beg</strong> and <strong>end</strong> are two <strong>Input iterators</strong> denoting that the range searched is [beg, end). <strong>UnaryPred</strong> is a predicate on elements in the range. Each time it takes one of the elements, and then returns a value convertible to <strong>bool</strong>. </li>
<li>the algorithm returns an iterator to the first element in the range for which the <strong>pred</strong> returns <strong>true</strong>. If there is no such element, the function returns <strong>end</strong>. </li>
<li>there is no way to copy, assign, or pass a function as an argument directly due to a function is not an object. In fact, when we pass a function, the compiler uses the pointer to function instead of using the function directly. In addition, we can call a pointer to a function with or withour deferencing the pointer. Therefore, in this function template, the argument can either be a function “object”, that is, <strong>UnaryPred pred</strong>; or a function pointer, that is, <strong>UnaryPred* pred</strong>; or a function reference, that is, <strong>UnaryPred&amp; pred</strong>. All these three cases allows us to call the function through <strong>pred(*beg)</strong>.</li>
<li>complexity: linear </li>
</ol>
<h2 id="Test-program-1"><a href="#Test-program-1" class="headerlink" title="Test program"></a>Test program</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;			// cout, endl</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;			// vector</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;			// strlen</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;			// isupper</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"my_algorithms.h"</span>	        <span class="comment">// my_find_if</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>; 	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">find</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">strlen</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">isupper</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the predication 1</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsEven</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the predication 2</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Isupper</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> &amp;c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">isupper</span>(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// find the first even number in vec</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec&#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">87</span>, <span class="number">9</span>, <span class="number">35</span>, <span class="number">77</span>, <span class="number">60</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = my_find_if(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), IsEven);</span><br><span class="line">    <span class="keyword">if</span>(it != vec.<span class="built_in">end</span>())</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"The first even number in vec is: "</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"There is no even number in vec"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find the first upper-case letter in arr</span></span><br><span class="line">    <span class="keyword">char</span> arr[] = <span class="string">"abceFghI"</span>;</span><br><span class="line">    <span class="keyword">char</span>* p = my_find_if(arr, arr + <span class="built_in">strlen</span>(arr), Isupper);</span><br><span class="line">    <span class="keyword">if</span>(p != arr + <span class="built_in">strlen</span>(arr))</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"The first upper-case letter in arr is: "</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"There is no upper-case letter in arr"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Outputs</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The first even number in vec is: 2</span><br><span class="line">The first upper-case letter in arr is: F</span><br></pre></td></tr></table></figure>

<h1 id="find-if-not-beg-end-UnaryPred"><a href="#find-if-not-beg-end-UnaryPred" class="headerlink" title="find_if_not(beg, end, UnaryPred)"></a><strong>find_if_not(beg, end, UnaryPred)</strong></h1><h2 id="Possible-implementation-2"><a href="#Possible-implementation-2" class="headerlink" title="Possible implementation"></a>Possible implementation</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">UnaryPred</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">InputIterator</span> <span class="title">my_find_if_not</span>(<span class="title">InputIterator</span> <span class="title">beg</span>, <span class="title">InputIterator</span> <span class="title">end</span>, <span class="title">UnaryPred</span> <span class="title">pred</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">while</span>(beg != <span class="built_in">end</span> &amp;&amp; pred(*beg))</span><br><span class="line">        ++beg;</span><br><span class="line">    <span class="keyword">return</span> beg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In contrary to the <strong>find_if</strong> algorithm, this function returns an iterator to the first element in the range for which <strong>pred</strong> returns <strong>false</strong>. If <strong>pred</strong> returns <strong>true</strong> for all elements, the function returns <strong>end</strong>. </p>
<h2 id="Test-program-2"><a href="#Test-program-2" class="headerlink" title="Test program"></a>Test program</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;			// cout, endl</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;			// vector</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"my_algorithms.h"</span>	        <span class="comment">// my_find_if_not</span></span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsEven</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> i % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// find the first even number in vec</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec&#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">87</span>, <span class="number">9</span>, <span class="number">35</span>, <span class="number">77</span>, <span class="number">60</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = my_find_if_not(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), IsEven);</span><br><span class="line">    <span class="keyword">if</span>(it != vec.<span class="built_in">end</span>())</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"The first odd number in vec is: "</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"There is no odd number in vec"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Outputs</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The first odd number in vec is: 87</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="count-beg-end-UnaryPred"><a href="#count-beg-end-UnaryPred" class="headerlink" title="count(beg, end, UnaryPred)"></a><strong>count(beg, end, UnaryPred)</strong></h1>]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Algorithms</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ - Defining abstract data types (Part 1)</title>
    <url>/2018/04/14/C-Defining-abstract-data-types/</url>
    <content><![CDATA[<h1 id="The-vector-class"><a href="#The-vector-class" class="headerlink" title="The vector class"></a>The vector class</h1><p>This chapter mainly teaches us about how to define our own “vec” class follwing the standard library <strong>vector</strong> class template. Specifically, our vec class will provide an interface that allows following operations:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// construct a vector of T type</span></span><br><span class="line"><span class="built_in">vector</span>&lt;T&gt; v;        <span class="comment">// empty vector</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;T&gt; <span class="title">v</span><span class="params">(<span class="number">100</span>)</span></span>;   <span class="comment">// vector with 100 elements</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// obtain the names of the types used by the vector</span></span><br><span class="line"><span class="built_in">vector</span>&lt;T&gt;::const_iterator b, e;</span><br><span class="line"><span class="built_in">vector</span>&lt;T&gt;::size_type i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// use size and the index operator to look at each element in the vector</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i != v.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; v[i].name();   <span class="comment">// if T has a member name</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// return iterators positioned on the first and one past the last element</span></span><br><span class="line">b = v.<span class="built_in">begin</span>();</span><br><span class="line">e = v.<span class="built_in">end</span>();</span><br></pre></td></tr></table></figure>
<h1 id="Implementing-the-Vec-class"><a href="#Implementing-the-Vec-class" class="headerlink" title="Implementing the Vec class"></a>Implementing the Vec class</h1><p>The standard library <strong>vector</strong> is a class template. Similarly, we define a class template to represent our vector to hold various types. We are familar with how to define a function template, now let’s see how to define a class template.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">Vec</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// interface</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// implementation</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Similar to the definition of a function template, a class template begins with the keyword <strong>template</strong> follwed by the template parameters list. In this case, there is one type parameter named <strong>T</strong>. Then we define the class as we did before, assuming that there will be <strong>public</strong> and <strong>private</strong> parts to write our interface and implementation respectively. </p>
<p>Now we consider the data members for our vector class. Vector is a container that can hold multiple elements. A natural solution goes to a dynamically allocated array. So what information we need for the implementation of our <strong>Vec</strong> class? The functions <strong>begin, end</strong> and <strong>size</strong> imply that we might need to store the address of the initial element, one past the address of the last element  and the number of elements. But once we know the address of the first element and one past the last element, we could compute the size easily. Let’s add two data members:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">Vec</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// interface</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* data;    <span class="comment">// first element in the Vec</span></span><br><span class="line">    T* limit;   <span class="comment">// one past the last element in the Vec</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Constructors"><a href="#Constructors" class="headerlink" title="Constructors"></a>Constructors</h2><p>From the interface we intend to provide, we know we need to define at least two constructors, </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// construct a vector of T type</span></span><br><span class="line">Vec&lt;T&gt; v;        <span class="comment">// using default constructor</span></span><br><span class="line"><span class="function">Vec&lt;T&gt; <span class="title">v</span><span class="params">(<span class="number">100</span>)</span></span>;   <span class="comment">// using constructor that takes a size</span></span><br></pre></td></tr></table></figure>
<p>The default constructor leads to an empty <strong>Vec</strong> and hence there is no need to allocate space to hold the elements. Two data members can be initialized to null pointers. For the constructor that takes a size, we should allocate certain amount of storage for holding the elements. Two data members will be initialized to the corresponding addresses of that space. Each element will be initialized to a value given by the default constructor of Type <strong>T</strong>. There is also a case that users provide the initial values for the elements, for example</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Vec&lt;T&gt; <span class="title">v</span><span class="params">(<span class="number">100</span>, <span class="number">1</span>)</span></span>;   <span class="comment">// using constructor that takes a size and an initial value</span></span><br></pre></td></tr></table></figure>
<p>If so, we would initialize each element with the provided value. The constructor that takes a size and an initial value can be regarded as the special case of the constructor that only takes a size. The code below shows the definition of the constructors:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">Vec</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    Vec() &#123; create() &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Vec</span><span class="params">(size_type n, <span class="keyword">const</span> T&amp; val = T())</span> </span>&#123; create(n, val); &#125;</span><br><span class="line">    <span class="comment">// remaining interface</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* data</span><br><span class="line">    T* limit;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>As we haven’t talk about how to dynamically allocate space for our object, the details of implementations of each constructor will be discussed later. What we need to know here is that the constructors call another function <strong>create</strong> to initialize our data members and the elements. For the default constructor, <strong>create()</strong> initializes all data members to null pointers. For the second constructor, <strong>create(n, val)</strong> allocates enough space, and initializes all data members as well as each element with size <strong>n</strong> and value <strong>val</strong>. The second constructor takes two arguments, one is the size <strong>n</strong> and another is the value that to use in initializing the elements. </p>
<p>If there is no user-supplied value, <strong>val</strong> is assigned with an default value given by the default constructor of type <strong>T</strong>. One may speculate that if <strong>T</strong> is built-in type and the vector is allocated at local scope, then the elements are uninitialized as default-initializing an built-in object gives it an undefined value. However, we also know that when we create a standard vector<int> with size only, the compiler initializes each element to 0. So, where there might be problems? Let’s do a simple experiment first.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>; 	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="keyword">int</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> m;</span><br><span class="line">    <span class="keyword">double</span> n = <span class="keyword">double</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">'\n'</span> &lt;&lt; y &lt;&lt; <span class="string">'\n'</span>  &lt;&lt; m &lt;&lt; <span class="string">'\n'</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Outputs</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1954310794</span><br><span class="line">0</span><br><span class="line">-2.2854e+251</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>From above example, we observe that a built-in type local variable is undefined in the case of default initialization. In contrast, <strong>int()</strong> and <strong>double()</strong> doesn’t default initialize the corresponding objects, but performs <strong>value-initialization</strong>. This means that <strong>T()</strong> only invokes default constructor if it is user-declared and otherwise it performs value-initialization. If <strong>T</strong> is built-in type, objects are zero initialized. </p>
<p>It also has been observed that we use a keyword <strong>explicit</strong> as the begining of the definition of the second constructor. This keyword only makes sence when the constructor takes a single argument, that is, the size. It indicates that the compiler will use the constructor only in the case that the user expressly invokes the constructor. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Vec&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">100</span>)</span></span>; <span class="comment">// ok, explicitly construct the Vec from an int</span></span><br><span class="line">Vec&lt;<span class="keyword">int</span>&gt; v = <span class="number">100</span>; <span class="comment">// error: implicitly comstruct the Vec and copy</span></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">More about the **<span class="keyword">explicit</span>** will be discussed in chapter <span class="number">12.</span> </span><br><span class="line"></span><br><span class="line">## Type definitions</span><br><span class="line">This section defines types <span class="keyword">for</span> our **Vec** <span class="class"><span class="keyword">class</span> <span class="title">including</span> **<span class="title">const_iterator</span>, <span class="title">iterator</span>, <span class="title">size_type</span>** <span class="title">and</span> **<span class="title">value_type</span>**. <span class="title">It</span> <span class="title">is</span> <span class="title">known</span> <span class="title">that</span> <span class="title">our</span> **<span class="title">Vec</span>** <span class="title">class</span> <span class="title">is</span> <span class="title">build</span> <span class="title">upon</span> <span class="title">the</span> <span class="title">dynamic</span> <span class="title">allocated</span> <span class="title">array</span>. <span class="title">In</span> <span class="title">addition</span>, <span class="title">pointers</span> <span class="title">supports</span> <span class="title">the</span> <span class="title">random</span>-<span class="title">access</span>-<span class="title">iterator</span> <span class="title">operations</span>. <span class="title">Therefore</span>, <span class="title">we</span> <span class="title">can</span> <span class="title">define</span> <span class="title">the</span> <span class="title">types</span> **<span class="title">iterator</span>** <span class="title">and</span> **<span class="title">const_iterator</span>** <span class="title">based</span> <span class="title">on</span> <span class="title">pointers</span>. <span class="title">For</span> **<span class="title">size_type</span>**, <span class="title">we</span> <span class="title">can</span> <span class="title">define</span> <span class="title">based</span> <span class="title">on</span> **<span class="title">size_t</span>**. <span class="title">Apparently</span>, <span class="title">The</span> **<span class="title">value_type</span>** <span class="title">is</span> **<span class="title">T</span>**. <span class="title">Now</span> <span class="title">let</span>'<span class="title">s</span> <span class="title">see</span> <span class="title">the</span> <span class="title">code</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">```<span class="title">c</span>++</span></span><br><span class="line"><span class="class"><span class="title">template</span> &lt;class T&gt; <span class="title">class</span> <span class="title">Vec</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> T* iterator;                </span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">const</span> T* const_iterator;   </span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line"></span><br><span class="line">    Vec() &#123; create(); &#125; </span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Vec</span><span class="params">(size_type n, <span class="keyword">const</span> T&amp; val = T())</span> </span>&#123; create(n, val); &#125;</span><br><span class="line">    <span class="comment">// remaining interface</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    iterator data;</span><br><span class="line">    iterator limit;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Index-and-size"><a href="#Index-and-size" class="headerlink" title="Index and size"></a>Index and size</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i != v.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; v[i].name();   <span class="comment">// if T has a member name</span></span><br></pre></td></tr></table></figure>
<p>The <strong>size</strong> function returns a value that represents the number of elements in a <strong>Vec</strong>. </p>
<p>The indexing operation is supported through the subscript operator <strong>[]</strong> and hence we should define an overloaded operator as we define other function: it has a name, takes arguments, and specifies a return type. </p>
<p>The name of such operator is obtained by appending the symbol <strong>[]</strong> to the word <strong>operator</strong>, that is, <strong>operator[]</strong>. </p>
<p>If the operator is a function that is not a member function, then the function has as many arguments as the operator has operands. The first argument is bound to the left bound and the second is bound to the right operand. If the operator is defined as a member function, its left operand is implicitly bound to the object on which the operator invoked. In this case, the subscript operator is typically a member function. We can call it with <strong>v[i]</strong>, meaning that <strong>v</strong> is the object on which it operates and <strong>i</strong> is an argument that should has type <strong>Vec::size_type</strong>.</p>
<p>As for the return type, the operator function ought to return a reference to the element in the <strong>Vec</strong>. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">Vec</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> T* iterator;                </span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">const</span> T* const_iterator;   </span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line"></span><br><span class="line">    Vec() &#123; create(); &#125; </span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Vec</span><span class="params">(size_type n, <span class="keyword">const</span> T&amp; val = T())</span> </span>&#123; create(n, val); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// operations: size and index</span></span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> limit - data; &#125;</span><br><span class="line"></span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](size_type i) &#123; <span class="keyword">return</span> data[i]; &#125;</span><br><span class="line">    <span class="keyword">const</span> T&amp; <span class="keyword">operator</span>[](size_type i) <span class="keyword">const</span> &#123; <span class="keyword">return</span> data[i] &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    iterator data;</span><br><span class="line">    iterator limit;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>There are sevral key points here:</p>
<ol>
<li>the result of (limit - data) has type <strong>ptrdiff_T</strong>, which is converted to <strong>size_type</strong>.</li>
<li>taking the <strong>size</strong> of a <strong>Vec</strong> doesn’t change the <strong>Vec</strong> and hence we define it as a <strong>const</strong> member. </li>
<li>we define two version of the operator function: one for <strong>const Vec</strong> objects and the other for nonconst <strong>Vec</strong>. It seems impossible to overload the operator function as both version have same parameter list. However, as mentioned above, the object itself is also an implicit argument to the function. Therefore, one function takes the <strong>const Vec</strong> object as an argument while the other one takes the nonconst <strong>Vec</strong> object as an argument.</li>
</ol>
<h2 id="Operations-that-return-iterators"><a href="#Operations-that-return-iterators" class="headerlink" title="Operations that return iterators"></a>Operations that return iterators</h2><p>Next is to define member functions <strong>begin()</strong> and <strong>end()</strong>. Similar to the operator function, we need to define two versions for both functions, one version returns <strong>const_iterator</strong> so that users cannot modify the <strong>Vec</strong> by operating on the iterator; another one returns an iterator that is not restricted by qualifier <strong>const</strong>, so that users can write elements into the <strong>Vec</strong> through the iterator if they want to. The improved code is shown below.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">Vec</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> T* iterator;                </span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">const</span> T* const_iterator;   </span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line"></span><br><span class="line">    Vec() &#123; create(); &#125; </span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Vec</span><span class="params">(size_type n, <span class="keyword">const</span> T&amp; val = T())</span> </span>&#123; create(n, val); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// operations: size and index</span></span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> limit - data; &#125;</span><br><span class="line"></span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](size_type i) &#123; <span class="keyword">return</span> data[i]; &#125;</span><br><span class="line">    <span class="keyword">const</span> T&amp; <span class="keyword">operator</span>[](size_type i) <span class="keyword">const</span> &#123; <span class="keyword">return</span> data[i] &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// function to return iterators</span></span><br><span class="line">    iterator <span class="built_in">begin</span>() &#123; <span class="keyword">return</span> data; &#125;</span><br><span class="line">    <span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> data; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> limit; &#125;</span><br><span class="line">    <span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> limit; &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    iterator data;</span><br><span class="line">    iterator limit;</span><br><span class="line">&#125;;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"># Copy control</span><br><span class="line">In chapter <span class="number">9</span>, we have learned how to initialize a <span class="class"><span class="keyword">class</span> <span class="title">object</span> <span class="title">when</span> <span class="title">it</span> <span class="title">is</span> <span class="title">created</span>. <span class="title">But</span> <span class="title">we</span> <span class="title">haven</span>'<span class="title">t</span> <span class="title">talked</span> <span class="title">about</span> <span class="title">what</span> <span class="title">happens</span> <span class="title">when</span> <span class="title">a</span> <span class="title">class</span> <span class="title">object</span> <span class="title">is</span> <span class="title">copied</span>, <span class="title">assigned</span> <span class="title">and</span> <span class="title">destroyed</span>. <span class="title">When</span> <span class="title">we</span> <span class="title">define</span> <span class="title">the</span> **<span class="title">Student_info</span>** <span class="title">class</span>, <span class="title">we</span> <span class="title">didn</span>'<span class="title">t</span> <span class="title">define</span> <span class="title">these</span> <span class="title">operations</span> <span class="title">as</span> <span class="title">well</span>. <span class="title">We</span> <span class="title">can</span> <span class="title">presume</span> <span class="title">that</span> <span class="title">the</span> <span class="title">compiler</span> <span class="title">will</span> <span class="title">synthesize</span> <span class="title">definitions</span> <span class="title">for</span> <span class="title">us</span>. <span class="title">Now</span> <span class="title">this</span> <span class="title">section</span> <span class="title">focus</span> <span class="title">on</span> <span class="title">how</span> <span class="title">can</span> <span class="title">we</span> <span class="title">define</span> <span class="title">these</span> <span class="title">operations</span> <span class="title">and</span> <span class="title">how</span> <span class="title">the</span> <span class="title">synthesized</span> <span class="title">operations</span> <span class="title">exactly</span> <span class="title">work</span>.</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">## <span class="title">Copy</span> <span class="title">constructor</span></span></span><br><span class="line"><span class="class"><span class="title">Two</span> <span class="title">ways</span> <span class="title">to</span> <span class="title">implicitly</span> <span class="title">copy</span> <span class="title">a</span> <span class="title">class</span> <span class="title">object</span>:</span> one is that passing an object by value to a function; the other way is that returning an object by value. For example</span><br><span class="line">```c++</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">double</span> d;</span><br><span class="line">d = median(v);  <span class="comment">// copy v into the parameter in median</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> <span class="built_in">line</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; words = split(<span class="built_in">line</span>); <span class="comment">// copy the return from split into words</span></span><br></pre></td></tr></table></figure>
<p>Sometimes we also explicitly copy an object, for example using it to initialize another object.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;Student_info&gt; vs;</span><br><span class="line"><span class="built_in">vector</span>&lt;Student_info&gt; vs_copy = vs;  <span class="comment">// copy vs into vs_copy</span></span><br></pre></td></tr></table></figure>

<p>Both above copy behaviors are controlled by a special constructor called the <strong>copy constructor</strong>. </p>
<p><strong>copy constructor</strong> is also a member function that has the same name as the name of class. It takes a single argument that has the same type as the class itself. In addition, the parameter is a const reference to the object to pass due to that the <strong>copy constructor</strong> should not change the object being copied from. Therefore, we can declare the <strong>copy constructor</strong> as shown below</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">Vec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Vec (<span class="keyword">const</span> Vec&amp; v); <span class="comment">// copy constructor</span></span><br><span class="line">    <span class="comment">// as before</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>When we copy a class object, we’ll need to allocate new space and then copy the contents from the source into the newly allocated storage. This is because we do not intend to change the object being copied from. For example, if we simple copy two data members, we may change the value of the elements due to the fact that the copied pointers still points to the elements contained in the object being copied from. As with the constructors, we will ask the overloaded <strong>create</strong> function to manage the memory and the details of the copy operations.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">Vec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Vec (<span class="keyword">const</span> Vec&amp; v) &#123; create(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>()); &#125;; </span><br><span class="line">    <span class="comment">// as before</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Assignment"><a href="#Assignment" class="headerlink" title="Assignment"></a>Assignment</h2><p>Like the <strong>subscript operator</strong>, the <strong>assignment operator =</strong> needs to be defined for providing us the assignment operations. The name of the <strong>assignment operator</strong> function is <strong>operator=</strong>. The argument taken by such operator function is as same as the argument taken by copy constructor above. What about the return type? We return a reference to the left operand. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">Vec</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    Vec&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> Vec&amp;);</span><br><span class="line">    <span class="comment">// as before</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>It is worth noting the difference between <strong>assignment</strong> and the copy constructor. <strong>assignment</strong> always involves obliterating an existing value of the left-hand side, and then replacing it with a new value, i.e. the right-side hand. What they have in common is that both of them need to assign each of the data values. As mentioned above, we cannot assign the value of pointers to the left-hand side because that doing so would bring potential change for the right-hand side. </p>
<p>There might be another problem when using the assignment operator, that is how to handle self-assignment. For example:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">x</span><span class="params">(<span class="number">100</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">x = x;</span><br></pre></td></tr></table></figure>
<p>The assignment operator function will firstly obliterate the value of left-hand side then assign the value of right-hand side to the left-hand side. However, once we destroy the elements and free the space, we cannot create a new object that has the same value as the right-hand side due to both sides operands refer to the same space. To avoid this case, we add a if statement before implemeting the assignment. The code below gives the implementation of the assignment operator function:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Vec</span>&lt;T&gt;&amp; <span class="title">Vec</span>&lt;T&gt;:</span>:<span class="keyword">operator</span>= (<span class="keyword">const</span> Vec&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// check for self-assignment</span></span><br><span class="line">    <span class="keyword">if</span>(&amp;rhs != <span class="keyword">this</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// free the array in the left-hand side</span></span><br><span class="line">        uncreate();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// copy elements from the right-hand to the left-hand side</span></span><br><span class="line">        create(rhs.<span class="built_in">begin</span>(), rhs.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The code above introduces several new ideas:</p>
<p>First, the <strong>operator=</strong> is defined as a function template and the type parameter infers from the type parameter of the class template <strong>Vec</strong>. </p>
<p>Second, the return type as well as the function name are defined explicitly due to that this member function is defined outside the class. The declaration uses <strong>Vec&amp;</strong> rather than <strong>Vec<T>&amp;</strong> is due to that the type parameter is implicit when we are within the scope of the template. This also explains why we use the function name <strong>Vec<T>::operator=</strong>. Once we specifies that the function is a member of class <strong>Vec<T></strong>, we can omit the type parameter when defines its parameter <strong>const Vec&amp; rhs</strong>.</p>
<p>Third, the if condition uses a keyword <strong>this</strong> to test whether the assigment happens between two same objects. <strong>this</strong> is a pointer that points to the object of which <strong>operator=</strong> is a member. It is valid only inside a member function. Hence, the condition means that if the address of the object (left-hand side) is as same as the address (denoted by &amp;rhs) of the right-hand object, the assignment behavior won’t be executed.</p>
<p>Forth, if the leff-hand operand and the right-hand operand are not the same object, we destroy the elements and free the space first through <strong>uncreate()</strong> and then allocate new space and copy values from <strong>rhs</strong> like what the <strong>copy constructor</strong> does. </p>
<p>Finally, it is necessary to explain why we intend to return a reference to the left-side object. Why not return <strong>void</strong> directly? Why don’t we return a value? <a href="https://stackoverflow.com/questions/3105798/why-must-the-copy-assignment-operator-return-a-reference-const-reference?utm_medium=organic&utm_source=google_rich_qa&utm_campaign=google_rich_qa" target="_blank" rel="noopener">Move to see more discussion</a>. </p>
<p>One reason is that to keep consistent with the default setting of the C++ compiler in regarding to the built-assignment operator. Another reason is that setting the return type to <strong>void</strong> doesn’t allow continues assignment. For example,</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">x</span><span class="params">(<span class="number">100</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; y, z;</span><br><span class="line">y = z = x;  <span class="comment">// continues assignment</span></span><br></pre></td></tr></table></figure>

<p>Apparently, we don’t have to return a reference, instead we can return a value. Let’s take an example, </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Vec&lt;<span class="keyword">int</span>&gt; <span class="title">x</span><span class="params">(<span class="number">100</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; y;</span><br><span class="line">y = x; <span class="comment">// calls assignment operator once, calls copy constructor once, calls destructor once</span></span><br></pre></td></tr></table></figure>
<p>It can be presumed that returning an object involves calling three functions: first, assignment operator function is called and a temporary object is created, then, the return statement calls copy constructor to create a new object, finally, the destructor is called to destroy the temporary value and free the space. We’ll introduce the destructor later and will pose an experiment to verify these expectations. </p>
<h3 id="Assignment-is-not-initialization"><a href="#Assignment-is-not-initialization" class="headerlink" title="Assignment is not initialization"></a>Assignment is not initialization</h3><p>Now we can summarize the difference between <strong>initialization</strong> and <strong>assignment</strong>. It can be observed that the operator <strong>=</strong> has different effect in various contexts. The default setting of <strong>=</strong> invokes <strong>copy constructor</strong> and then creating a new object,which is another form of <strong>initialization</strong>. The <strong>operator=</strong> described above invokes assignment that always obliterates the privious value first. </p>
<p>Initialization happens</p>
<ol>
<li>In variable declaration<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> y;  <span class="comment">// default initialization</span></span><br></pre></td></tr></table></figure></li>
<li>For function parameters on entry to a function<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">median(v);  <span class="comment">// the parameter is copy-initialized</span></span><br></pre></td></tr></table></figure></li>
<li>For the return value of a function on return from the function<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> <span class="built_in">line</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; words = split(<span class="built_in">line</span>); <span class="comment">// the return value is copy-initialized, the variable is then copy-initialized</span></span><br></pre></td></tr></table></figure></li>
<li>In constructor initializers<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> url_ch = <span class="string">"@#$%^&amp;**(("</span>;   <span class="comment">// copy initialization</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">spaces</span><span class="params">(url_ch.<span class="built_in">size</span>(), <span class="string">' '</span>)</span></span>; <span class="comment">// direct initialization</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>Let’s see another example</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">split</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;)</span></span>; <span class="comment">// function declaration</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v;   <span class="comment">// default initialization</span></span><br><span class="line"></span><br><span class="line">v = split(<span class="built_in">line</span>); <span class="comment">// on entry, initialization of split's parameter from line; on exit, both initialization of the return value and assignment to v</span></span><br></pre></td></tr></table></figure>

<p>The <strong>split</strong> function returns an object of type <strong>vector<string></strong>. As analysed above, it involves calling both copy constructor (at the call site) and the assignment operator function.</p>
<h2 id="Destructor"><a href="#Destructor" class="headerlink" title="Destructor"></a>Destructor</h2><p>It is known that when we allocate a space with <strong>new</strong>, we should destroy the values and free the space with <strong>delete</strong>. Therefore, it is necessary to define a member function to do the same job. In general, the destructor will be called automatically when:</p>
<ol>
<li>a local variable go out of scope.</li>
<li>members of an object are destryoed when the object of which they are a part is destroyed.</li>
<li>elements in a container are destoryed when the container is destroyed.</li>
<li>the delete operator applied to an object.</li>
<li>temporary objects are destroyed. </li>
</ol>
<p>Taking an example, </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">split</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ret;</span><br><span class="line">    <span class="comment">// split str into words and store in ret</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The variable <strong>ret</strong> is destroyed when the implementation encounters the return statement because it goes out of the scope. Now let’s see how to define a destructor:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">Vec</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    ~Vec() &#123; uncreate() &#125;;</span><br><span class="line">    <span class="comment">// as before</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The name of the <strong>destructor</strong> is as same as the name of the class itself, but prefixed by a tilde(~). There is no arguments taken by the <strong>destructor</strong>. To destroy the object and free the space, the <strong>destructor</strong> calls the <strong>uncreate()</strong> function, which is similar to the behavior of the <strong>assignment operator</strong> in obliterating the previous value. </p>
<h1 id="Default-operations"><a href="#Default-operations" class="headerlink" title="Default operations"></a>Default operations</h1><p>What happens if we do not explicitly define a <strong>copy constructor, assignment operator, or destructor</strong>? In such case, the compiler will synthesizes default versions of the unspecified operation. Some general rules(koening and Moo 2000):</p>
<p><em>1. the default version are defined to operate recursively-copying, assigning or destroying each data element according to the appropriate rules for the type of that data element.</em><br><em>2. Members that are of class type are copied, assigned, or destoryed by calling the constructor, assignment operator, and destructor for the data element</em>.<br><em>3. Members that are of built-in type are copied and assigned by copying or assigning their value. The destructor for built-in types has no work to do-even if the type is a pointer. Destoring a pointer through the default constructor doesn’t free the space at which the pointer points, resulting a memory leak as the occupied space is impossible to free.</em></p>
<p>Recalling the <strong>Student_info</strong> class defined in chapter 9:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student_info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student_info ();						<span class="comment">// default constructor</span></span><br><span class="line">    Student_info (<span class="built_in">std</span>::istream &amp;);				<span class="comment">// constructor with argument</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> n; &#125;			<span class="comment">// inline member function return name</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">valid</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> !homework.empty(); &#125;            <span class="comment">// inline member function check state</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::istream &amp; <span class="title">read</span><span class="params">(<span class="built_in">std</span>::istream &amp;)</span></span>;			<span class="comment">// member function read in data</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">()</span> <span class="keyword">const</span></span>;					<span class="comment">// member function calculate final grade</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> n;</span><br><span class="line">    <span class="keyword">double</span> midterm, <span class="keyword">final</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; homework;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>If we copy an object of <strong>Student_info</strong>, the synthesized copy constructor copies four data members. It invokes the <strong>string, vector</strong> copy constructors to copy the member <strong>name</strong> and <strong>homework</strong>s respectively. It copies the two <strong>double</strong> values, <strong>midterm, final</strong>, directly. Similar procedures happen when we do assignment. </p>
<p>Noting that if a class defines any constructor explicitly, either a constructor or a copy constructor, the compiler will not synthesize a default constructor for that class. It is wise to provide a default constructor for the data type that to be used as a data member of a class that relies on the synthsized default constructor. We explicitly provide the default constructor in above class <strong>Student_info</strong>.</p>
<p>If a class needs a destructor, it almost surely needs a copy constructor as well as assignment operator. To control every copy of object of class T, we should define:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">T::T(); <span class="comment">// one or more constructors, perhaps with arguments</span></span><br><span class="line">T::~T(); <span class="comment">// the destructor</span></span><br><span class="line">T::T(<span class="keyword">const</span> T&amp;); <span class="comment">// the copy constructor</span></span><br><span class="line">T::<span class="keyword">operator</span>= (<span class="keyword">const</span> T&amp;); <span class="comment">// the assignment operator</span></span><br></pre></td></tr></table></figure>

<h1 id="Dynamic-Vecs"><a href="#Dynamic-Vecs" class="headerlink" title="Dynamic Vecs"></a>Dynamic Vecs</h1><p>This section focus on designing a dynamic <strong>Vec</strong> class through providing the <strong>push_back</strong> function which we are familiar with when using the standard <strong>vector</strong>. Theoretically, the <strong>push_back</strong> function can allocate new space to hold one more element and then we copy all elements into the new space while constructing a new last element from the argument to <strong>push_back</strong>. However, doing so would be inefficient when we call the <strong>push_back</strong> many times. One strategy is to allocate more storage than we need when necessary, that is, when we exhaust the preallocate storage. Specifically, each time the <strong>push_back</strong> allocate new space, it allocate twice as much as the current space. </p>
<p>For example, if we create a <strong>Vec</strong> with 100 elements, then call the <strong>push_back</strong> function for the first time, it will allocate a new space that can hold 200 elements. It then copies the original 100 elements into the new space with constructing the last element from the argument. There are still more space left for holding 99 elements more and hence the function do not need to allocate more space in next 99 calls. Moreover, the extral space keep uninitialized. </p>
<p>What we need to track is the address of the first element, the one past of the last constructed element, and the end of the new allocate storage(i.e. one past the available element). We’ll denote these address with three pointers, <strong>data, avail, limit</strong> respectively. The range [data, avail) contains all elements while the range [avail, limit) is the uninitialized storage. Now let’s write the <strong>push_back</strong> function:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">Vec</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T&amp; val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(avail == limit)      <span class="comment">// get space if needed</span></span><br><span class="line">            grow();</span><br><span class="line">        unchecked_append(val);  <span class="comment">// append the new element</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        iterator data;  <span class="comment">// as before, the pointer to the first element in the Vec</span></span><br><span class="line">        iterator avail; <span class="comment">// pointer to one past the last constructed element</span></span><br><span class="line">        iterator limit; <span class="comment">// now points to one past the available element</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// rest of the class interface and implementation as before</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>grow()</strong> will double the space for us. <strong>unchecked_append(val)</strong> constructs the last element from the argument to <strong>push_back</strong> function. Correspondingly, we refresh the data members.</p>
<h1 id="Flexible-memory-management"><a href="#Flexible-memory-management" class="headerlink" title="Flexible memory management"></a>Flexible memory management</h1><p>We have basically completed the design of our <strong>Vec</strong> class template. However, we haven’t talked about the real implementation, that is, how exactly allocate new space. As memtioned in chapter 10, we can dynamically manage memory through built-in operators <strong>new</strong> and <strong>delete</strong> (or <strong>new[]</strong> and <strong>delete[]</strong>). However, there are several shortcomings if we use such operators to manage memory for our <strong>Vec</strong> class.</p>
<ol>
<li>if we use <strong>new[]</strong>, it always initialize every element of a <strong>T</strong> array by using <strong>T::T()</strong>. If we want to initialize ourselves, we would have to initialize each element twice. </li>
<li>if <strong>push_back</strong> allocates new space, we want to keep the range [avail, limit) uninitialized. However, if we use <strong>new[]</strong>, we cannot control this anymore. </li>
</ol>
<p>The standard header <memory> provides a class named <strong>allocator<T></strong>, that allocates a block of uninitialized memory that intended to contain objects of type <strong>T</strong> and returns a pointer to the initial element of that memory. In addition, <strong>allocator<T></strong> also defines members including functions to construct objects, destroy obejcts and deallocate the memory. Therefore, programmers can manage the allocated space directly and determine the unitialized space. Here introduces four member functions and two non-member functions of the <strong>allocator</strong> class:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">allocator</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">T* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deallocator</span><span class="params">(T*, <span class="keyword">size_t</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">construct</span><span class="params">(T*, <span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(T*)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line">template&lt;class Out, class T&gt; void uninitialized_fill(Out, Out, const T&amp;);</span><br><span class="line">template&lt;class In, class Out&gt; Out uninitialized_copy(In, In, Out);</span><br></pre></td></tr></table></figure>
<ol>
<li><p>the <strong>allocate</strong> member allocates typed but uninitialized storage to hold the requested number of elements. It returns a pointer that has type <strong>T</strong> and denotes the initial address of the storage. </p>
</li>
<li><p>the <strong>deallocator</strong> frees this uninitialized storage with taking the pointer given by <strong>allocate</strong> and the size.</p>
</li>
<li><p><strong>construct</strong> and <strong>destroy</strong>  construct or destroy a single object in the uninitialized space. </p>
</li>
<li><p>the first algorithm <strong>uninitialized_fill</strong> fills this uninitialized space with value from the third argument. The first two arguments denote the range of the space that to be filled. </p>
</li>
<li><p>the second algorithm <strong>uninitialized_copy</strong> copies values from a sequence specified by the first two arguments into a target sequence denoted by the third argument. The range pointed by the third argument should large enough to hold all elements contained in the range specified by the first two arguments. It finally returns a pointer to one past the last constructed element. </p>
</li>
<li><p>both two algorithms assumes that the target range contains raw storage rather than elements that already hold values. </p>
</li>
</ol>
<p>To obtain an <strong>allocator</strong> of the right type at the compiler time, we’ll add to our <strong>Vec</strong> class an <strong>allocator<T></strong> member. By doing so, we can use above member functions to provide efficient and flexible memory management for our <strong>Vec</strong> class. </p>
<h1 id="The-final-Vec-class"><a href="#The-final-Vec-class" class="headerlink" title="The final Vec class"></a>The final Vec class</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">Vec</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// member types</span></span><br><span class="line">    <span class="keyword">typedef</span> T* iterator;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">const</span> T* const_iterator;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// constructors</span></span><br><span class="line">    Vec() &#123; create(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Vec</span><span class="params">(size_type n, <span class="keyword">const</span> T&amp; t = T())</span> </span>&#123; create(n, t); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// copy constructor, assignment operator, destructor</span></span><br><span class="line">    Vec(<span class="keyword">const</span> Vec&amp; v) &#123; create(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>()); &#125;</span><br><span class="line">    Vec&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Vec&amp;); </span><br><span class="line">    ~Vec() &#123; uncreate(); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// indexing operator</span></span><br><span class="line">    <span class="keyword">const</span> T&amp; <span class="keyword">operator</span>[](size_type i) <span class="keyword">const</span> &#123; <span class="keyword">return</span> data[i]; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// push_back function</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T&amp; t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(avail == limit)</span><br><span class="line">            grow();</span><br><span class="line">        unchecked_append(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// size function</span></span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> avail - data; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// begin(), end() function</span></span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> data; &#125;</span><br><span class="line">    <span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> data; &#125;</span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> avail; &#125;</span><br><span class="line">    <span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> avail; &#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    iterator data;  <span class="comment">// first element in the Vec</span></span><br><span class="line">    iterator avail; <span class="comment">// (one past) the last element in the Vec</span></span><br><span class="line">    iterator limit; <span class="comment">// (one past) the allocated memory</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// facilities for memory allocation</span></span><br><span class="line">    allocator&lt;T&gt; alloc; <span class="comment">// object to handle memory allocation</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// allocate and initialize the underlying array</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">(size_type, <span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">(const_iterator, <span class="keyword">const</span> iterator)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// destroy the elements in the array and free the memory</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">uncreate</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// support functions for push_back</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">grow</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unchecked_append</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>We should note that there are four conditions (aka. <strong>class invariants</strong>) that guarantees a valid <strong>Vec</strong>:</p>
<ol>
<li><strong>data</strong> points at our initial element, if we have any, and is zero otherwise.</li>
<li><strong>data &lt;= avail &lt;= limit</strong>.</li>
<li>Elements  have been constructed in the range[data, avail).</li>
<li>Elements have not been constructed in the range[avail, limit).</li>
</ol>
<p>Now the next is to write the implementation of different version of <strong>create</strong> functions while maintaining above <strong>class invariants</strong>. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">Vec</span>&lt;T&gt;:</span>:create()</span><br><span class="line">&#123;</span><br><span class="line">    data = avail = limit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">Vec</span>&lt;T&gt;:</span>:create(size_type n, <span class="keyword">const</span> T&amp; val)</span><br><span class="line">&#123;</span><br><span class="line">    data = alloc.allocate(n);</span><br><span class="line">    limit = avail = data + n;</span><br><span class="line">    uninitialized_fill(data, limit, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">Vec</span>&lt;T&gt;:</span>:create(const_iterator i, const_iterator, j)</span><br><span class="line">&#123;</span><br><span class="line">    data = alloc.allocate(j - i);</span><br><span class="line">    limit = avail = uninitialized_copy(i, j, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The first version of <strong>create</strong> is used for initializing an empty <strong>Vec</strong>. The second one that takes a size and a value creates a Vec by allocating enough memory to hold <strong>n</strong> elements through <strong>alloc.allocate(n)</strong>, and initializes all elements with <strong>val</strong> by applying the algorithm <strong>uninitialized_fill</strong>. The third version is used for <strong>copy-initialization</strong>, which takes two iterators that denote the sequence from which to copy. It calls <strong>uninitialized_copy</strong> algorithm to copy all values of the elements in [i, j) into [data, avail).</p>
<p>The <strong>destructor</strong> calls the <strong>uncreate</strong> member to destroy the elements and free the space that allocated by <strong>create</strong>. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">Vec</span>&lt;T&gt;:</span>:uncreate()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!data)&#123;</span><br><span class="line">        <span class="comment">// destroy the elements in reverse order</span></span><br><span class="line">        iterator it = avail;</span><br><span class="line">        <span class="keyword">while</span>(it != data)</span><br><span class="line">            alloc.destroy(--it);</span><br><span class="line">        alloc.deallocate(data, limit - data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// reset pointers to indicate that Vec is empty again</span></span><br><span class="line">    data = limit = avail = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The <strong>uncreate</strong> function first checks whether the <strong>data</strong> is 0. This is because that <strong>alloc.deallocate</strong> requires a non-zero pointer. There are two steps to destruct the <strong>Vec</strong>: the first step is that calling the <strong>destroy</strong> function to destroy each object contained in the Vec; the second step is that calling <strong>deallocate</strong> function to free the previous allocated storage. As <strong>deallocate</strong> doesn’t destroy elements in an array, it is crucial to call <strong>destroy</strong> function first which calls the <strong>destructor</strong> of the target element to release resource that might be occupied by the target element. It is known that there is no destructor for built-in types, so how does the <strong>destroy</strong> function work? It is presumed that the destroy function treats <strong>built-in</strong> objects and other objects in different manner. It still needs further research. </p>
<p>Finally, we write functions to support our <strong>push_back</strong> member.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">Vec</span>&lt;T&gt;:</span>:grow()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// when growing, allocate twice as much as space as currently in use</span></span><br><span class="line">    size_type new_size = <span class="built_in">max</span>(<span class="number">2</span>*(limit-data), <span class="keyword">ptrdiff_t</span>(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// allocate new space and copy existing elements to the new space</span></span><br><span class="line">    iterator new_data = alloc.allocate(new_size);</span><br><span class="line">    iterator new_avail = uninitialized_copy(data, avail, new_data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// return the old space</span></span><br><span class="line">    uncreate();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reset pointers to point to the newly allocated space</span></span><br><span class="line">    data = new_data;</span><br><span class="line">    avail = new_avail;</span><br><span class="line">    limit = data + new_size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// assumes avail points at allocated, but uninitialized space</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">Vec</span>&lt;T&gt;:</span>:unchecked_append(<span class="keyword">const</span> T&amp; val)</span><br><span class="line">&#123;</span><br><span class="line">    alloc.construct(avail++, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we have really completed our <strong>Vec</strong> class. The next post presents some tests on our <strong>Vec</strong> type from different perspectives. </p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Notes</tag>
      </tags>
  </entry>
  <entry>
    <title>Accelerated C++ Solutions to Exercises(Chapter 10)</title>
    <url>/2018/04/12/Accelerated-C-Solutions-to-Exercises-Chapter-10/</url>
    <content><![CDATA[<h1 id="Exercise-10-0"><a href="#Exercise-10-0" class="headerlink" title="Exercise 10-0"></a>Exercise 10-0</h1><p>Compile, execute, and test the programs in this chapter.</p>
<h2 id="Solution-amp-Results"><a href="#Solution-amp-Results" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>Please click here <a href="http://quanttour.com/10/04/2018/C-Managing-memory-and-low-level-data-structures/" target="_blank" rel="noopener">Managing memory and low-level data structures</a> for codes and analysis.</p>
<hr>
<h1 id="Exercise-10-1"><a href="#Exercise-10-1" class="headerlink" title="Exercise 10-1"></a>Exercise 10-1</h1><p>Rewrite the student-grading program from §9.6/166 to generate letter grades.</p>
<h2 id="Solution-amp-Results-1"><a href="#Solution-amp-Results-1" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>Since the letter grades function computes a letter grade based on a numerical grade, I would like to add it as a non-member function of the <strong>Student_info</strong> class to avoid repetitively computing the final grade. When need calculate the letter grades, we simply call the function as follows:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> final_grade = it-&gt;grade(); <span class="comment">// it is a pointer to the Student_info object</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; letter_grade(final_grade); <span class="comment">// print the letter grade</span></span><br></pre></td></tr></table></figure>
<p>or</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; letter_grade(it-&gt;grade());</span><br></pre></td></tr></table></figure>

<p>All files are presented at below including <strong>mainfunction.cpp, Student_info.h, Student_info.cpp, grade.h, grade.cpp</strong>. </p>
<p><strong>mainfunction.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Accelerated C++ Solutions Exercises 10-1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;		// to get the declaration of max, sort</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;		// to get the declaration of setprecision</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;		// to get the declaration of streamsize</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;    	// to get the declatation of domain_error</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;		// to get the declaration of string</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;		// to get the declaration of vector</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span>	<span class="comment">// to get the declaration of Student_info</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;					<span class="keyword">using</span> <span class="built_in">std</span>::setprecision;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;				<span class="keyword">using</span> <span class="built_in">std</span>::sort;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;				<span class="keyword">using</span> <span class="built_in">std</span>::streamsize;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::domain_error;   		        <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">max</span>;					<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::fixed;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Student_info&gt; students;</span><br><span class="line">    Student_info record;</span><br><span class="line">    <span class="built_in">string</span>::size_type maxlen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read and store all the records, and find the length of the longest name</span></span><br><span class="line">    <span class="keyword">while</span>(record.<span class="built_in">read</span>(<span class="built_in">cin</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        maxlen = <span class="built_in">max</span>(maxlen, record.name().<span class="built_in">size</span>());</span><br><span class="line">        students.push_back(record);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// alphabetize the records</span></span><br><span class="line">    sort(students.<span class="built_in">begin</span>(), students.<span class="built_in">end</span>(), compare);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write each line of outpurs</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Student_info&gt;::const_iterator it = students.<span class="built_in">begin</span>();</span><br><span class="line">            it != students.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// write the name, blanks</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (*it).name() &lt;&lt; <span class="built_in">string</span>(maxlen + <span class="number">1</span> - (*it).name().<span class="built_in">size</span>(), <span class="string">' '</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// compute and write the final grade</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">double</span> final_grade = (*it).grade();</span><br><span class="line">            streamsize prec = <span class="built_in">cout</span>.precision();</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">1</span>) &lt;&lt; final_grade &lt;&lt; setprecision(prec);</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">'\t'</span> &lt;&lt; letter_grade(final_grade); <span class="comment">// new added</span></span><br><span class="line">        &#125; <span class="keyword">catch</span>(domain_error e)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; e.what();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Student_info.h</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_STUDENT_INFO</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_STUDENT_INFO</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student_info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Student_info ();				<span class="comment">// default constructor</span></span><br><span class="line">	Student_info (<span class="built_in">std</span>::istream &amp;);			<span class="comment">// constructor with argument</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> n; &#125;		<span class="comment">// inline member function return name</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">valid</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> !homework.empty(); &#125;    <span class="comment">// inline member function check state</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::istream &amp; <span class="title">read</span><span class="params">(<span class="built_in">std</span>::istream &amp;)</span></span>;		<span class="comment">// member function read in data</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">()</span> <span class="keyword">const</span></span>;				<span class="comment">// member function calculate final grade</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> n;</span><br><span class="line">    <span class="keyword">double</span> midterm, <span class="keyword">final</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; homework;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::istream &amp; <span class="title">read_hw</span><span class="params">(<span class="built_in">std</span>::istream &amp;, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;)</span></span>;  <span class="comment">// nonmember function read data into a vector</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> Student_info &amp;, <span class="keyword">const</span> Student_info &amp;)</span></span>;       <span class="comment">// nonmember function compare two string</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">letter_grade</span><span class="params">(<span class="keyword">double</span>)</span></span>; <span class="comment">// new added: nonmember function gives a letter grade</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>Student_info.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"grade.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::istream;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// construct an empty Student_info object</span></span><br><span class="line">Student_info::Student_info (): midterm(<span class="number">0</span>), <span class="keyword">final</span>(<span class="number">0</span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// construct one by reading from input stream</span></span><br><span class="line">Student_info::Student_info (<span class="built_in">std</span>::istream &amp; in) &#123; <span class="built_in">read</span>(in); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// member function read data from input stream</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::istream &amp; <span class="title">Student_info::read</span><span class="params">(<span class="built_in">std</span>::istream &amp;in)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// reads and store the student's name, midterm and final exam grades</span></span><br><span class="line">    in &gt;&gt; n &gt;&gt; midterm &gt;&gt; <span class="keyword">final</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reads and store all homework grades</span></span><br><span class="line">    read_hw(in, homework);</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// member function grade</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Student_info::grade</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ::grade(midterm, <span class="keyword">final</span>, homework);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// nonmember function compare</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> Student_info &amp;x, <span class="keyword">const</span> Student_info &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.name() &lt; y.name();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// nonmember function read_hw</span></span><br><span class="line"><span class="function">istream &amp; <span class="title">read_hw</span><span class="params">(istream &amp;in, <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;hw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (in)&#123;</span><br><span class="line">        <span class="comment">//get rid of previous contents</span></span><br><span class="line">        hw.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// read homework grades</span></span><br><span class="line">        <span class="keyword">double</span> x;</span><br><span class="line">        <span class="keyword">while</span>(in &gt;&gt; x)</span><br><span class="line">            hw.push_back(x);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// clear the stream so that input will work for the next student</span></span><br><span class="line">        in.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// new added: non-member function to calculate the letter grade</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">letter_grade</span><span class="params">(<span class="keyword">double</span> grade)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// range posts for numberic grades</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">double</span> numbers[] = &#123;<span class="number">97</span>, <span class="number">94</span>, <span class="number">90</span>, <span class="number">87</span>, <span class="number">84</span>, <span class="number">80</span>, <span class="number">77</span>, <span class="number">74</span>, <span class="number">70</span>, <span class="number">60</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// name for the letter grades</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> letters[] = &#123;<span class="string">"A+"</span>, <span class="string">"A"</span>, <span class="string">"A-"</span>, <span class="string">"B+"</span>,</span><br><span class="line">                                          <span class="string">"B"</span>, <span class="string">"B-"</span>, <span class="string">"C+"</span>, <span class="string">"C"</span>, <span class="string">"C-"</span>, <span class="string">"D"</span>, <span class="string">"F"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// compute the number of grades given the size of the array</span></span><br><span class="line">    <span class="comment">// and the size of a single element</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> ngrades = <span class="keyword">sizeof</span>(numbers)/<span class="keyword">sizeof</span>(*numbers);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// given a numberic grade, find the associated letter grade</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; ngrades; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (grade &gt;= numbers[i])</span><br><span class="line">            <span class="keyword">return</span> letters[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"?\?\?"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>grade.h</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_GRADE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_GRADE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">median</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>grade.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"grade.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::domain_error;  <span class="keyword">using</span> <span class="built_in">std</span>::istream;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;        <span class="keyword">using</span> <span class="built_in">std</span>::sort;</span><br><span class="line"></span><br><span class="line"><span class="comment">// grade function 1</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">double</span> midterm, <span class="keyword">double</span> <span class="keyword">final</span>, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;hw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hw.empty())</span><br><span class="line">        <span class="keyword">throw</span> domain_error(<span class="string">"student has done no homework"</span>);</span><br><span class="line">    <span class="keyword">return</span> grade(midterm, <span class="keyword">final</span>, median(hw));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// grade function 2</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">double</span> midterm, <span class="keyword">double</span> <span class="keyword">final</span>, <span class="keyword">double</span> homework)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.2</span>*midterm + <span class="number">0.4</span>*<span class="keyword">final</span> + <span class="number">0.4</span>*homework;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compute the median of vector&lt;double&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">median</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// check whether the vec is empty</span></span><br><span class="line">    <span class="keyword">if</span> (vec.<span class="built_in">begin</span>() == vec.<span class="built_in">end</span>())</span><br><span class="line">        <span class="keyword">throw</span> domain_error(<span class="string">"median of an empty vector"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sort the grades</span></span><br><span class="line">    sort(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// compute the median homework grade</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;::difference_type <span class="built_in">size</span> = vec.<span class="built_in">end</span>() - vec.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;::const_iterator mid = vec.<span class="built_in">begin</span>() + <span class="built_in">size</span>/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">size</span> % <span class="number">2</span> == <span class="number">0</span> ? (*mid + *(mid - <span class="number">1</span>))/<span class="number">2</span> : *mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Test</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Inputs:</span><br><span class="line"></span><br><span class="line">Robin 90 87 79 88 81 73 45</span><br><span class="line">Brendan 70 69 88 100 91 75 66</span><br><span class="line">Arsenii 99 87 89 88 74 90 70</span><br><span class="line">Liam 83 66 100 76 87 91 78</span><br><span class="line"></span><br><span class="line">Outputs:</span><br><span class="line"></span><br><span class="line">Arsenii 89.8	B+</span><br><span class="line">Brendan 76.8	C</span><br><span class="line">Liam    77.8	C+</span><br><span class="line">Robin   84.4	B</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Exercise-10-2-10-3"><a href="#Exercise-10-2-10-3" class="headerlink" title="Exercise 10-2, 10-3"></a>Exercise 10-2, 10-3</h1><p>10-2: Rewrite the median function from §8.1.1/140 so that we can call it with either a vector or a built-in array. The function should allow containers of any arithmetic type.</p>
<p>10-3: Write a test program to verify that the median function operates correctly. Ensure that calling median does not change the order of the elements in the container.</p>
<h2 id="Solution-amp-Results-2"><a href="#Solution-amp-Results-2" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>There are two requirements: first is that, the median function can calculate the median value by taking either a vector or built-in array; second is that, the container can be container of any arithmetic type. </p>
<p>Apparently, our median function should be a function template. The first condition implies that the parameters should be two pointers that denote the range of inputs. Unlike the standard vector, built-in array doesn’t provide member functions like <strong>begin()</strong> and <strong>end()</strong>. We cannot simply pass the name of the built-in array to the median function as the name of the array is mere the pointer to the initial element. Alternatively, we can denote its range with [arr, arr+n), where <strong>arr</strong> is the name of the array and <strong>n</strong> is the size of the array. The first type parameter of our tempalte represents the type of supplied pointers and will be inferred from the supplied pointers in the process of instantiation. </p>
<p>The second condition implies that the type of the elements contained in the container should be supplied as we cannot infer the value type from pointers. Therefore, another type parameter of the function template represents the value type of the container and will be infered from the third function parameter, which is defined as any element of the container. As the following declaration shows, <strong>Pointer</strong> and <strong>T</strong> represents the pointer type and value type. The function defines three parameters, first two of which denotes the range of inputs while the third is a <strong>const reference</strong> to the first element contained in the container. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Pointer</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">median</span>(<span class="title">Pointer</span> <span class="title">begin</span>, <span class="title">Pointer</span> <span class="title">end</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">initialElement</span>);</span></span><br></pre></td></tr></table></figure>

<p>Once we have the pointers, we can implement the algorithm as with the previous version. But to avoid changing the original sequence, we’d better construct a new vector to hold the input sequence. The code below gives the full program. I test it by calling the function template with a standard vector and a built-in array that contains the same elements as the vector. As expected, they yield same median value. If changing the value type to <strong>int</strong>, the function template works as well. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;	// std::vector</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;	// std::cout, std::endl</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;	// std::domain_error</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;	// copy</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;	// size_t</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;			<span class="keyword">using</span> <span class="built_in">std</span>::<span class="keyword">size_t</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;			<span class="keyword">using</span> <span class="built_in">std</span>::copy;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::domain_error;	        <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Pointer</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">median</span>(<span class="title">Pointer</span> <span class="title">begin</span>, <span class="title">Pointer</span> <span class="title">end</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">initialElement</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">begin</span> == <span class="built_in">end</span>)</span><br><span class="line">        <span class="keyword">throw</span> domain_error(<span class="string">"median of an empty container"</span>);</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;T&gt; <span class="title">v</span><span class="params">(<span class="built_in">begin</span>, <span class="built_in">end</span>)</span></span>;</span><br><span class="line">    <span class="keyword">typename</span> <span class="built_in">vector</span>&lt;T&gt;::difference_type <span class="built_in">size</span> = v.<span class="built_in">end</span>() - v.<span class="built_in">begin</span>();</span><br><span class="line">    sort(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">typename</span> <span class="built_in">vector</span>&lt;T&gt;::const_iterator mid = v.<span class="built_in">begin</span>() + <span class="built_in">size</span>/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">size</span> % <span class="number">2</span> == <span class="number">0</span> ? (*mid + *(mid<span class="number">-1</span>)) / <span class="number">2</span> : *mid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; vec&#123;<span class="number">53</span>, <span class="number">56</span>, <span class="number">23</span>, <span class="number">78</span>, <span class="number">90</span>, <span class="number">89</span>, <span class="number">34</span>, <span class="number">12</span>, <span class="number">41</span>, <span class="number">48</span>&#125;;</span><br><span class="line">    <span class="keyword">size_t</span> n = vec.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">double</span> arr[n];</span><br><span class="line">    copy(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), arr);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; median(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), vec[<span class="number">0</span>]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; median(arr, arr + n, arr[<span class="number">0</span>]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Test Results</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">50.5</span><br><span class="line">50.5</span><br></pre></td></tr></table></figure>


<hr>
<h1 id="Exercise-10-4-10-5-10-6"><a href="#Exercise-10-4-10-5-10-6" class="headerlink" title="Exercise 10-4, 10-5, 10-6"></a>Exercise 10-4, 10-5, 10-6</h1><p>10-4: Write a class that implements a list that holds strings.</p>
<p>10-5: Write a bidirectional iterator for your String_list class.</p>
<p>10-6: Test the class by rewriting the split function to put its output into a String_list.</p>
<h2 id="Solution-amp-Results-3"><a href="#Solution-amp-Results-3" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><h3 id="define-the-String-list-class"><a href="#define-the-String-list-class" class="headerlink" title="define the String_list class"></a>define the <strong>String_list</strong> class</h3><p>The standard <strong>list</strong> provides all the possible operations and what we need to do is merely to encapsulate our data, a <strong>list<string></strong>, by hiding the data and instead providing an appropriate interface. I intend to implement a subset of the <strong>list<string></strong> class. Specifically, we can use the <strong>String_list</strong> class as follows:</p>
<p><strong>Interface</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; construct an empty container</span><br><span class="line">String_list s;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; construct a container with a size and a value</span><br><span class="line">String_list s1(10, &quot;Hello&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; return iterator to begining and end</span><br><span class="line">s1.begin();</span><br><span class="line">s1.end();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; construct a container with a range</span><br><span class="line">String_list s2(s1.begin(), s1.end());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; copy construct a container</span><br><span class="line">String_list s3(s2);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; assignment</span><br><span class="line">s &#x3D; s1;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; check the status of the container</span><br><span class="line">s1.empty();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; check the size</span><br><span class="line">s1.size();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; clear</span><br><span class="line">s1.chear();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; add one element to end</span><br><span class="line">s1.push_back(&quot;Hello&quot;);</span><br></pre></td></tr></table></figure>
<p>All these operations are obvious and we can directly work with <strong>list<string></strong> in our implementations. You can add more operations to this <strong>String_list</strong> class as long as the operations are supported by the standard <strong>list</strong> class. Let’s see how our <strong>String_list</strong> class is implemented:</p>
<p><strong>String_list.h</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> STRING_LIST_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STRING_LIST_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String_list</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; container;</span><br><span class="line">    container SL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> container::iterator iterator;</span><br><span class="line">    <span class="keyword">typedef</span> container::const_iterator const_iterator;</span><br><span class="line">    <span class="keyword">typedef</span> container::value_type value_type;</span><br><span class="line">    <span class="keyword">typedef</span> container::size_type size_type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// default constructor: construct an empty String_list</span></span><br><span class="line">    String_list() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// constructor that takes a size and a value</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">String_list</span><span class="params">(size_type n, <span class="keyword">const</span> value_type&amp; val = value_type())</span>: <span class="title">SL</span><span class="params">(n, val)</span> </span>&#123;&#125;</span><br><span class="line">    String_list(const_iterator beg, const_iterator <span class="built_in">end</span>): SL(beg, <span class="built_in">end</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bidirectional iterator and const bidirectional iterator</span></span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> SL.<span class="built_in">begin</span>(); &#125;</span><br><span class="line">    <span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> SL.cbegin(); &#125;</span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> SL.<span class="built_in">end</span>(); &#125;</span><br><span class="line">    <span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> SL.cend(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// empty</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> SL.empty(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// size</span></span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> SL.<span class="built_in">size</span>(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clear</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; SL.<span class="built_in">clear</span>(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// push_back</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> value_type&amp; v)</span> </span>&#123; SL.push_back(v); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* STRING_LIST_H_ */</span></span></span><br></pre></td></tr></table></figure>
<p>It is worth noting that the class defines three constructors but ignores the copy constructor, assignment operator and the destructor. As a result, the compiler will synthesize copy constructor, assignment operator and destructor for us. The synthesized operations depend on the definition of the data member. For example, the compiler will synthesize the copy constructor by calling the default copy constructor of the <strong>list<string></strong> class. Therefore, we do not need to worry about that. The synthesized operations also work on the default constructor. I explicitly define the default constructor because that we need other constructors. If we didn’t explicitly define the default constructor, the compiler won’t synthesize for us due to the existence of other constructors. </p>
<p>Another point is that the class implicitly supports the conversion from a string literal to a string type. This property is inherent in the standard <strong>string</strong> class and is further explained in chapter 12. </p>
<p>The last point is that the iterator returned by <strong>begin()</strong> and <strong>end()</strong> are all bidirectional iterator. This has been defined in the standard <strong>list</strong> class. We can traverse forward or backward the container and access or rewrite the elements using the returned iterators. </p>
<h3 id="rewrite-the-split-function"><a href="#rewrite-the-split-function" class="headerlink" title="rewrite the split function"></a>rewrite the split function</h3><p>The original split function copies its output into the output stream directly. We can replace the outstream object with our <strong>String_list</strong>. Rather than passing an <strong>ostream_iterator<string></strong> as the argument to the split function, we can pass a reference to the container as the argument.<br>Therefore, the declaration of the revisied split function is:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">container</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">split</span>(<span class="title">const</span> <span class="title">std</span>:</span>:<span class="built_in">string</span> &amp;, container&amp;);</span><br></pre></td></tr></table></figure>
<p>Then we can store each seperated word into the container by calling its <strong>push_back</strong> function. Please see the code below:</p>
<p><strong>Split.h</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_SPLIT_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_SPLIT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"String_list.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// true if the argument is whitespace, false otherwise</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">space</span><span class="params">(<span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">isspace</span>(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// false is the argument is whitespace, true otherwise</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">not_space</span><span class="params">(<span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !<span class="built_in">isspace</span>(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// template declaration and definition</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">container</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">split</span>(<span class="title">const</span> <span class="title">std</span>:</span>:<span class="built_in">string</span> &amp;str, container&amp; c)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">string</span>::const_iterator iter;</span><br><span class="line"></span><br><span class="line">    iter i = str.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span>(i != str.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ignore leading spaces</span></span><br><span class="line">        i = <span class="built_in">std</span>::find_if(i, str.<span class="built_in">end</span>(), not_space);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// find end of next word</span></span><br><span class="line">        iter j = <span class="built_in">std</span>::find_if(i, str.<span class="built_in">end</span>(), space);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// copy the characters in [i,j) and store into container</span></span><br><span class="line">        <span class="keyword">if</span>(i != str.<span class="built_in">end</span>())</span><br><span class="line">            c.push_back(<span class="built_in">std</span>::<span class="built_in">string</span>(i, j));</span><br><span class="line">        i = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* GUARD_SPLIT_H */</span></span></span><br></pre></td></tr></table></figure>

<h3 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h3><p>I wrote a test program to test each members of our <strong>String_list</strong> class and the revised <strong>split</strong> function.</p>
<p><strong>main.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;		// std::cin, endl, cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;		// std::string</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"String_list.h"</span>        <span class="comment">// String_list</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"split.h"</span>		<span class="comment">// split</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// construct an empty container</span></span><br><span class="line">    String_list words;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// test the empty function</span></span><br><span class="line">    <span class="keyword">if</span>(words.empty())</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"This is an empty container\n"</span></span><br><span class="line">                <span class="string">"Please enter a sentence: "</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// test the split function, and the push_back member of the String_list</span></span><br><span class="line">    <span class="built_in">string</span> <span class="built_in">line</span>;</span><br><span class="line">    <span class="keyword">while</span> (getline(<span class="built_in">cin</span>, <span class="built_in">line</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        split(<span class="built_in">line</span>, words);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"There are "</span> &lt;&lt; words.<span class="built_in">size</span>() &lt;&lt; <span class="string">" word(s) in total: "</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i: words) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// test bidirectional iterators</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\nprint all words in reverse order: "</span>;</span><br><span class="line">    String_list::iterator rbeg = --words.<span class="built_in">end</span>();</span><br><span class="line">    String_list::iterator rend = --words.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span>(rbeg != rend)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *rbeg-- &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// test the constructor that takes two input iterators</span></span><br><span class="line">    <span class="function">String_list <span class="title">words_copy</span><span class="params">(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>())</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(!words_copy.empty())&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"\nThe size of the container is: "</span> &lt;&lt; words_copy.<span class="built_in">size</span>();</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"\nThe elements contained in the String_list are: "</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> i: words_copy)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// test the clear function</span></span><br><span class="line">    words.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">if</span>(words.empty())</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"\nThe container now is empty again"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// test the constructor that takes a size and a value</span></span><br><span class="line">    <span class="function">String_list <span class="title">words_new</span><span class="params">(<span class="number">10</span>, <span class="string">"Hello"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// test the default copy constructor</span></span><br><span class="line">    <span class="function">String_list <span class="title">words_new_copy</span><span class="params">(words_new)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\nThe container contains: "</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i: words_new_copy) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// test the default assignment operator</span></span><br><span class="line">    words = words_new;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\nNow the container words contains: "</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i: words) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The program above is pretty straightforward and gives following results as expected:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">This is an empty container</span><br><span class="line">Please enter a sentence: Stack is one of the rudimentary data structures that use pointers</span><br><span class="line">There are 11 word(s) in total: Stack is one of the rudimentary data structures that use pointers </span><br><span class="line">print all words in reverse order: pointers use that structures data rudimentary the of one is Stack </span><br><span class="line">The size of the container is: 11</span><br><span class="line">The elements contained in the String_list are: Stack is one of the rudimentary data structures that use pointers </span><br><span class="line">The container now is empty again</span><br><span class="line">The container contains: Hello Hello Hello Hello Hello Hello Hello </span><br><span class="line">Now the container words contains: Hello Hello Hello Hello Hello Hello Hello</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>Koenig, A. and Moo, B.E., 2000. Accelerated C++.</p>
<p>Lippman, S.B., Lajoie, J. and Moo, B.E., 2013. C++ Primer, 5th edt.</p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Accelerated C++ Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ - Managing memory and low-level data structures</title>
    <url>/2018/04/10/C-Managing-memory-and-low-level-data-structures/</url>
    <content><![CDATA[<h1 id="Pointers"><a href="#Pointers" class="headerlink" title="Pointers"></a>Pointers</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p><strong>pointer</strong> is a compound type that points to another base type object. <strong>A pointer</strong> is a value that represents the address of the object that it points to. What is the address of an object? The address of an object denotes the part of the computer’s memory that contains the object. For example, if <strong>x</strong> is an object, then <strong>&amp;x</strong> is the address of <strong>x</strong> and <strong>&amp;</strong> is the <strong>address operator</strong>. Further, if <strong>p</strong> is a pointer, then <strong>*p</strong> is the value of the object that <strong>p</strong> points to and * is the <strong>deference operator</strong>. </p>
<p>We are familar with these two operators<strong>&amp;</strong> and *, however, may feel comfused about their meanings. Generally, these rules can be summarized as follows:</p>
<ol>
<li><p>when the <strong>&amp;</strong> is used as part of a declaration, e.g.</p>
<pre><code>int i = 10;
int &amp;x = i;</code></pre><p> <strong>&amp;</strong> follows a type and <strong>x</strong> is a reference.</p>
</li>
<li><p>when the <strong>&amp;</strong> is used as in an expression, e.g.</p>
<pre><code>int *p = &amp;i;</code></pre><p> <strong>&amp;</strong> acts as an <strong>address operator</strong>.</p>
</li>
<li><p>when the <strong><em>*</em></strong> is used as part of a declaration, e.g.</p>
<pre><code>int *p = &amp;i;</code></pre><p> <strong><em>*</em></strong> follows a type and <strong>p</strong> is a pointer.</p>
</li>
<li><p>when the <strong><em>*</em></strong> is used in an expression, e.g.</p>
<pre><code>int i = *p;
*p = i;</code></pre><p> it acts as an <strong>deference operator</strong> and yields the value of the object that <strong>p</strong> points to.</p>
</li>
</ol>
<p>It can be observed that a <strong>pointer</strong> can indirect access the value an object like a <strong>reference</strong>. However, a <strong>reference</strong> itself is not an object while a <strong>pointer</strong> itself is an object. From the third rule above, we know how to define a <strong>pointer</strong>. For example</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p;</span><br></pre></td></tr></table></figure>
<p><strong>p</strong> is a <strong>pointer</strong> that points to <strong>int</strong> type object. In other words, <strong>p</strong> has type <strong>int*</strong>. As other built-in types, a <strong>pointer</strong> might point to an unknown object unless we initialize it. Typically,we can initialize a pointer as a <strong>null pointer</strong> which means that the pointer does’t point to any object. There are several ways to do this:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="number">0</span>;         <span class="comment">// the constant 0 can be converted to a pointer type</span></span><br><span class="line"><span class="keyword">int</span> *p = <span class="literal">nullptr</span>;   <span class="comment">// c++11 supports</span></span><br><span class="line"><span class="keyword">int</span> *p = <span class="literal">NULL</span>;      <span class="comment">// must include header &lt;cstdlib&gt;</span></span><br></pre></td></tr></table></figure>
<p>These three statements lead to an equivalent result. If we want to assign other values to a pointer, typically we uses the address-of operator:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;i; <span class="comment">// p points to i</span></span><br><span class="line"><span class="keyword">int</span> *q = &amp;j; <span class="comment">// q points to j</span></span><br><span class="line">p = q;       <span class="comment">// p points to j now</span></span><br></pre></td></tr></table></figure>

<h2 id="Pointers-to-functions"><a href="#Pointers-to-functions" class="headerlink" title="Pointers to functions"></a>Pointers to functions</h2><p>It is known that functions are not objects and hence there is no way to copy or assign them, or to pass them as arguments directly. But we do “pass” functions as arguments in previous chapter, for example, the <a href="http://quanttour.com/22/03/2018/C-Using-library-algorithms-Part-2/" target="_blank" rel="noopener">write_analysis</a> function (see declaration below) takes function as its second parameter. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_analysis</span><span class="params">(<span class="built_in">std</span>::ostream &amp;out, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">double</span> analysis(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Student_info&gt; &amp;),</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Student_info&gt; &amp;did,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Student_info&gt; &amp;didnt)</span></span>;</span><br></pre></td></tr></table></figure>
<p>In fact this is achieved by taking the address of a function, that is, the pointer to the function. Let’s go into some details about the <strong>pointers</strong> to functions.</p>
<p>The syntax to define a pointer to function is, for example</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> (*fp)(<span class="keyword">int</span>);</span><br></pre></td></tr></table></figure>
<p>Then, if we deference <strong>fp</strong> and call it with <strong>int</strong> argument, the result is an <strong>int</strong> type value.<br>Another fact is that what we can do with a function is to take its address or call it. Therefore, when we use a function but is not to call it, we are assumed to be take its address, either using <strong>&amp;</strong> or not. For example,</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">next</span> <span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// these two statements are equivalent</span></span><br><span class="line">fp = next;</span><br><span class="line">fp = &amp;next;</span><br></pre></td></tr></table></figure>
<p>Further, when we call the next function with an int variable i, </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// these two statements are equivalent</span></span><br><span class="line"><span class="keyword">int</span> x = fp(i);</span><br><span class="line"><span class="keyword">int</span> x = (*fp)(i);</span><br></pre></td></tr></table></figure>
<p>Finally, when we have a function that takes another function as a parameter, the compiler will translate the parameter to be a pointer. Taking the <strong>write_analysis</strong> as an example, the parameter</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">analysis</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Student_info&gt; &amp;)</span></span></span><br></pre></td></tr></table></figure>
<p>is in fact equivalent to </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> (*analysis)(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Student_info&gt; &amp;)</span><br></pre></td></tr></table></figure>
<p>As shown below, when we “pass” another function as an argument, <strong>analysis</strong> points to a function named <strong>median_analysis</strong>. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">analysis = median_analysis; <span class="comment">// == analysis = &amp;median_analysis</span></span><br></pre></td></tr></table></figure>

<p>What if we want to write a function that returns a function pointer?<br>The simplest way is to use type alias</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">double</span> <span class="params">(*analysis_fp)</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;Student_info&gt;&amp;)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>analysis_fp</strong> is the name of the type of a pointer to function. Then</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// get_analysis_ptr returns a pointer to an analysis function</span></span><br><span class="line"><span class="function">analysis_fp <span class="title">get_analysis_ptr</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>declares a function <strong>get_analysis_ptr()</strong> that returns a pointer to an analysis function. This statement is equivalent to</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> (*get_analysis_ptr()) (<span class="keyword">const</span> <span class="built_in">vector</span>&lt;Student_info&gt; &amp;);</span><br></pre></td></tr></table></figure>
<p>From this, we can see that <strong>get_analysis_ptr</strong> has a parameter list and hence it is a function. In addition, there is an <strong><em>*</em></strong> before it, which indicates that the function returns a pointer. Furthermore, the returned pointer also has a parameter list and hence the returned pointer points to a function that takes parameter <strong>const vector<Student_info> &amp;</strong> and returns a <strong>double</strong> type value. </p>
<p>Now let’s look at an example</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">In</span>, <span class="title">class</span> <span class="title">Pred</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">In</span> <span class="title">find_if</span>(<span class="title">In</span> <span class="title">begin</span>, <span class="title">In</span> <span class="title">end</span>, <span class="title">Pred</span> <span class="title">f</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">begin</span> != <span class="built_in">end</span> &amp;&amp; !f(*<span class="built_in">begin</span>))</span><br><span class="line">        ++<span class="built_in">begin</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">begin</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Suppose we have a predicate function</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_negative</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Let’s instanitialize the template with a vector named <strong>v</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator i = find_if(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), is_negative)</span><br></pre></td></tr></table></figure>
<p>We use <strong>is_negative</strong> instead of <strong>&amp;is_negative</strong> due to that the name of the function turns into a pointer to the function autimatially. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># Arrays</span><br><span class="line">**Array** is part of the core language rather than part of the standard library. An **array** is a kind of container that similar to a **vector**, but has fixed length. When we create an **array** object, we should specify the length of the array. For example, we can create an array that contains three elements</span><br><span class="line">&#96;&#96;&#96;c++</span><br><span class="line">double coords[3];</span><br></pre></td></tr></table></figure>
<p>Alternatively, we can use a <strong>const</strong> object to denote the size of the array</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> NDim = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">double</span> coords[NDim];</span><br></pre></td></tr></table></figure>
<p><strong>size_t</strong> is a fundamental unsigned integer type that can be used to represent the size of an array. It is defined in the header <strong><cstddef></strong>. The reason to use <strong>size_t</strong> is that <strong>array</strong> is not a class type and has no member function like <strong>size_type</strong>. It is worth noting that we use <strong>const</strong> to ensure <strong>Ndim</strong> is fixed and known at compilation time. </p>
<p><strong>coords</strong> is the name of the array, and in fact it is a pointer that points to the first element of the array. Hence, we can assign a value to the first element through</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">*coords = <span class="number">1.5</span>; <span class="comment">// set the initial element of coords to 1.5</span></span><br></pre></td></tr></table></figure>

<h2 id="Pointer-arithmetic"><a href="#Pointer-arithmetic" class="headerlink" title="Pointer arithmetic"></a>Pointer arithmetic</h2><p>Another fact is that a <strong>pointer</strong> is a random access iterator. Therefore, we can access the <strong>m</strong>th element (if available) through </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">*(coords + m)</span><br></pre></td></tr></table></figure>
<p>The pointer that points to one past the last element is <strong>coords + NDim</strong>. In other words, [coords, coords + NDim) denotes the range of address of the array. </p>
<p>Now, if we want to copy all elements of the array into a vector named <strong>v</strong>, we can use the copy algorithm as shown as follows</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; v;</span><br><span class="line">copy(coords, coords + NDim, back_inserter(v));</span><br></pre></td></tr></table></figure>
<p>Alternatively, we can construct <strong>v</strong> directly as a copy of the elements in <strong>coords</strong> using </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">v</span><span class="params">(coords, coords + NDim)</span></span>;</span><br></pre></td></tr></table></figure>
<p>C++ 2011 library provides <strong>begin</strong> and <strong>end</strong> functions to get the initial pointer and the off-the-end pointer:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *beg = <span class="built_in">begin</span>(coords);   <span class="comment">// points to the initial elements</span></span><br><span class="line"><span class="keyword">int</span> *last = <span class="built_in">end</span>(coords);    <span class="comment">// points to one past the last element</span></span><br><span class="line">···</span><br><span class="line"></span><br><span class="line">Similar to **difference_type**, **<span class="keyword">ptrdiff_t</span>** is an <span class="keyword">signed</span> itegeral type that represents the distance between two **pointers**. **<span class="keyword">ptrdiff_t</span>** is also defined in the header &lt;cstddef&gt;. </span><br><span class="line"></span><br><span class="line">## Indexing</span><br><span class="line">It is known now that **array** supports random access iterators and naturally supports indexing. Therefore, the **n**th emelent (if available) is **coords[n]** and ***coords = coords[0]**.</span><br><span class="line"></span><br><span class="line">## Array initialization</span><br><span class="line">Array supports <span class="built_in">list</span> initialization, <span class="keyword">for</span> example</span><br><span class="line">```c++</span><br><span class="line"><span class="comment">// these two statements have same effect</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>If we don’t specify the number of elements contained in the array, compiler will infer the number from the number of the supplied the initializers. But if we specify the number exactly, the number of initializers must not exceed the specified size. So, what if we specifies the size but provides initializers less than the specified number?</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>Then, the compiler will value initialize the rest elements. In this case, the elements have built-in type <strong>int</strong> and hence are set to 0. </p>
<h1 id="String-literals-revisited"><a href="#String-literals-revisited" class="headerlink" title="String literals revisited"></a>String literals revisited</h1><p>As we mentioned earlier, String literals are not <strong>string</strong>s. In fact, a string literal is an array of <strong>const char</strong> with one more element, i.e. ‘\0’ ,than the number of characters in the literal. <strong>‘\0’</strong> is a null character. Therefore, when we create a string literal, we should specify the size one larger than it should be for the purpose of holding the extral null character. For example, a string literal <strong>Hello</strong> is created through</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// two ways to initialize a string literal</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> hello[] = &#123;<span class="string">'H'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>, <span class="string">'\0'</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> hello[<span class="number">6</span>] = <span class="string">"Hello"</span>;</span><br></pre></td></tr></table></figure>
<p>The null character marks the end of the literal. When we want to get the number of characters excluding the null character, we can use the function <strong>strlen</strong> defined in <cstring>. The <strong>strlen</strong> might has following implementation</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Exanple implementation of standard-library function</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">strlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> <span class="built_in">size</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (*p++ != <span class="string">'\0'</span>)</span><br><span class="line">        ++<span class="built_in">size</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">size</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Now, if we want to copy the string literal <strong>Hello</strong> into a string type object, we can use</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// three equivalent ways to copy the string literal into a string</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(hello)</span></span>; <span class="comment">// variable hello represents "Hello"</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"Hello"</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(hello, hello + <span class="built_in">strlen</span>(hello))</span></span>; <span class="comment">// treats hello as the begin iterator</span></span><br></pre></td></tr></table></figure>

<h2 id="Initializing-arrays-of-character-pointer"><a href="#Initializing-arrays-of-character-pointer" class="headerlink" title="Initializing arrays of character pointer"></a>Initializing arrays of character pointer</h2><p><em>Essentially, a string literal is just a convenient way of writing the address of the initial character of a null-terminated sequence of characters</em>. Now let’s look at an example that shows how to generate an appropriate letter grade according to a numeric grade. The letter grades and numeric grades have following mapping relations:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">If the grade is at least  97  94  90  87  84  80  77  74  70  60  0</span><br><span class="line">then the letter grade is  A+  A   A-  B+  B   B-  C+  C   C-  D   F</span><br></pre></td></tr></table></figure>
<p>The program is shown below and let’s analyse it step by step.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">letter_grade</span><span class="params">(<span class="keyword">double</span> grade)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// range posts for numberic grades</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">double</span> numbers[] = &#123;<span class="number">97</span>, <span class="number">94</span>, <span class="number">90</span>, <span class="number">87</span>, <span class="number">84</span>, <span class="number">80</span>, <span class="number">77</span>, <span class="number">74</span>, <span class="number">70</span>, <span class="number">60</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// name for the letter grades</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> letters[] = &#123;<span class="string">"A+"</span>, <span class="string">"A"</span>, <span class="string">"A-"</span>, <span class="string">"B+"</span></span><br><span class="line">                                          <span class="string">"B"</span>, <span class="string">"B-"</span>, <span class="string">"C+"</span>, <span class="string">"C"</span>, <span class="string">"C-"</span>, <span class="string">"D"</span>, <span class="string">"F"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// compute the number of grades given the size of the array</span></span><br><span class="line">    <span class="comment">// and the size of a single element</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> ngrades = <span class="keyword">sizeof</span>(numbers)/<span class="keyword">sizeof</span>(*numbers);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// given a numberic grade, find the associated letter grade</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; ngrades; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (grade &gt;= numbers[i])</span><br><span class="line">            <span class="keyword">return</span> letters[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"?\?\?"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The function itself takes a double type value (i.e. a numeric grade), and returns a string (i.e. a letter grade). The first step is to construct two objects that hold the numeric grades and the letter grades, respectively. It is simple if we use <strong>vector</strong> or <strong>list</strong> or <strong>map</strong> as we know the numeric grade <strong>int</strong> type and the letter grade is <strong>string</strong> type. What if we use <strong>array</strong>? There is nothing new if we use <strong>string</strong> type, for example,</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">string</span> letters[] = &#123;<span class="string">"A+"</span>, <span class="string">"A"</span>, <span class="string">"A-"</span>, <span class="string">"B+"</span>, <span class="string">"B"</span>, <span class="string">"B-"</span>, <span class="string">"C+"</span>, <span class="string">"C"</span>, <span class="string">"C-"</span>, <span class="string">"D"</span>, <span class="string">"F"</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>But if we treat each letter grade as a a sequence of characters, we can store them as the program shows</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> letters[] = &#123;<span class="string">"A+"</span>, <span class="string">"A"</span>, <span class="string">"A-"</span>, <span class="string">"B+"</span>, <span class="string">"B"</span>, <span class="string">"B-"</span>, <span class="string">"C+"</span>, <span class="string">"C"</span>, <span class="string">"C-"</span>, <span class="string">"D"</span>, <span class="string">"F"</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>It can be observed that:</p>
<ol>
<li>the <strong>static</strong> means that the object is initialized only once and exists in the whole process till the program terminates. </li>
<li>the <strong>letters</strong> is an array of <strong>const pointers</strong> to <strong>const char</strong>. Each element is a string literal, i.e. an alternative way of writing the address of the initial character. Therefore, each element is in fact can be regarded as a pointer that points to the initial letter of the string literal. For example, <strong>letters[0]</strong> gives the first letter grade <strong>A+</strong> while <strong>*(letters[0])</strong> gives the initial letter of the first letter grade as <strong>letters[0]</strong> is a pointer as well. </li>
<li>The first <strong>const</strong> means that the array elements are constant. The second <strong>const</strong> means that the address are constant. </li>
<li>the next statement introduces <strong>sizeof</strong> which is a function that returns a <strong>size_t</strong> type value indicating how much memory an object occupied. Therefore, <strong>sizeof(numbers)</strong> gives the number of bytes that the object <strong>numbers</strong> while <strong>sizeof(*numbers)</strong> yields the number of bytes that each element consumes. The result of the division yields a value that is the number of elements contained in the object (i.e. array numbers). </li>
<li>finally, using a for statement a corresponding letter grade according to the input. If there exists such a grade, return it, otherwise, return <strong>???</strong>. </li>
</ol>
<h1 id="Arguments-to-main"><a href="#Arguments-to-main" class="headerlink" title="Arguments to main"></a>Arguments to main</h1><p>As mentioned in chapter 0, the main function can take arguments like other functions if it defines parameters. A conventional way is to pass a sequence of stings to <strong>main</strong> as an argument. For example, when we pass <strong>say Hello, world</strong> as an argument, the program give outputs</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hello, world</span><br></pre></td></tr></table></figure>
<p>How to achieve this? This is done by giving two parameters: </p>
<ol>
<li>an <strong>int</strong> type parameter named <strong>argc</strong> which is a value that denotes the number of pointers that pointed by <strong>argv</strong>.</li>
<li>another one is named as <strong>argv</strong> which is a pointer to a pointer to char.  For example, the pointer <strong>letters</strong> described above. <strong>letters</strong> points to the initial element, that is, the pointer to char <strong>A</strong> as the pointer to a string literal points to the initial char of the sequence. Therefore, we can define this parameter as</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>* argv[]</span><br></pre></td></tr></table></figure>
<p>or</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char** argv</span><br></pre></td></tr></table></figure>
<p>These two expression are equivalent. Now, let’s look at the <strong>main</strong> with arguments <strong>argc</strong> and <strong>argv</strong>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// if there are arguments, write them</span></span><br><span class="line">    <span class="keyword">if</span>(argv &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// declare i outside the for because we need it after the loop </span></span><br><span class="line">        <span class="keyword">int</span> i;  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// write all but the last entry and argv[i] is a char* </span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; argc - <span class="number">1</span>; ++i)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; argv[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// write the last entry but not a space</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; argv[i] &lt;&lt; <span class="built_in">endl</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Assuming we pass <strong>Hello, world</strong> as an argument, <strong>argc</strong> will be 3 (why ?) and <strong>argv</strong> points to the first element, that is, another pointer to “Hello,” that is, character <strong>‘H’</strong>. <strong>argv[0]</strong> can be regarded as the name (i.e. pointer again) of the first string literal, and hence we can access each string literal through <strong>argv[i]</strong>, where <strong>i &lt; argc</strong>. </p>
<p>You might wonder that why <strong>argc</strong> is 3 and why we use range [1, argv) rather than [0, argv) as we did before? This is because when we pass arguments, the program name will be automatically passed as one element. Specifically, if we pass sequence <strong>please give me a number</strong>, there will be 5 string literal in total, but <strong>argc = 6</strong> because: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">argv points to pointer argv[0] points to &quot;program name&quot;</span><br><span class="line">                       argv[1] points to &quot;please&quot; </span><br><span class="line">                       argv[2] points to &quot;give&quot; </span><br><span class="line">                       argv[3] points to &quot;me&quot; </span><br><span class="line">                       argv[4] points to &quot;a&quot; </span><br><span class="line">                       argv[5] points to &quot;number&quot;</span><br></pre></td></tr></table></figure>
<p>This shows why we use the range [1, argv) to access each element. </p>
<h1 id="Reading-and-writing-files"><a href="#Reading-and-writing-files" class="headerlink" title="Reading and writing files"></a>Reading and writing files</h1><p>By now, we are familar with four <strong>iostream</strong> class objects <strong>cin, cout, clog,</strong> and <strong>cerr</strong>. This part introduces another <strong>IO</strong> facilitiy <strong>ifstream</strong> and <strong>ofstream</strong> class to deal with multiple input and output files. Specifically, the <strong>ofstream</strong> class object allows us to write data into a file, while <strong>iftream</strong> allows us to read data from a file. We can use these objects like what we operate on <strong>cin</strong> and <strong>cout</strong> such as that they also support <strong>&lt;&lt;</strong> and <strong>&gt;&gt;</strong> operators as well as <strong>getline</strong>. </p>
<p>When defining an <strong>ifstream</strong> or <strong>oftream</strong> object, we can associate the object with a file that we intend to write or read. Naturally we supply the file name which can be a <strong>string</strong> (C++11) or a <strong>string literal</strong>. This can be done either on construction or by calling member function <strong>open</strong>. For example,</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// two ways to open a file named s</span></span><br><span class="line"><span class="function">ifstream <span class="title">in</span><span class="params">(s)</span></span>;</span><br><span class="line">ifstream.<span class="built_in">open</span>(s);</span><br></pre></td></tr></table></figure>

<p>The below program shows how to copy the contents of a file named <strong>in</strong> to a file named <strong>out</strong>.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">infile</span><span class="params">(<span class="string">"in"</span>)</span></span>;</span><br><span class="line">    <span class="function">ofstream <span class="title">outfile</span><span class="params">(<span class="string">"out"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">while</span> (getline(infile, s))</span><br><span class="line">        outfile &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The first statement creates an <strong>ifstream</strong> object <strong>infile</strong> and associates it with a file named <strong>in</strong>. Similarly, the second statement creates an <strong>ofstream</strong> object <strong>outfile</strong> and associates it with a file named <strong>out</strong>. Both file names are string literals, i.e. pointers to the initial character of null-terminated array. If file <strong>in</strong> doesn’t exist, there won’t be a file <strong>in</strong> being created. However, if <strong>out</strong> doesn’t exist, it will be create to hold the outputs. </p>
<p>If we don’t want to use string literal as name, one solution is to store the name in a <strong>string</strong> and use member function <strong>c_str</strong> to get the pointer to the array that contains a null-terminated sequence of characters (i.e., a C-string) representing the current value of the string object_ <a href="http://www.cplusplus.com/reference/string/string/c_str/" target="_blank" rel="noopener">Reference to std::string::c_str</a>. For example, <strong>file</strong> is a string variable that contains the name of a file to be read, we then associate the file with a <strong>ifstream</strong> object through</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">infile</span><span class="params">(file.c_str())</span></span>;</span><br></pre></td></tr></table></figure>

<p>Finally, let’s look at another program that produces a copy of all files whose names are given as arguments to main.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fail_count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// for each file in the input list</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; argc; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">ifstream <span class="title">in</span><span class="params">(argv[i])</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if it exits, write its contents, otherwise generate an error message</span></span><br><span class="line">        <span class="keyword">if</span>(in)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> s;</span><br><span class="line">            <span class="keyword">while</span>(getline(in, s))</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cerr</span> &lt;&lt; <span class="string">"cannot open file "</span> &lt;&lt; argv[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            ++fail_count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fail_count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The program logic is simple: first get a name from the arguments <strong>argv</strong>, then open a same name file; if the file exists, the contents of it will be written on the output device, but if there is no such file, count and record such case with a variable <strong>fail_count</strong>; finally, returns <strong>fail_count</strong>, by then, the value of <strong>fail_count</strong> represents the number of non-existent files; if <strong>fail_count</strong> is not 0, it indicates that the program terminates abnormally.</p>
<p>It is worth noting that when a <strong>ifstream</strong> object fails to associate the corresponding file, the state of the input stream is set to fail. Therefore, the if condition <strong>if(in)</strong> is very useful and helpful for us to check whether our operations on the file are valid.  </p>
<h1 id="Three-kinds-of-memory-management"><a href="#Three-kinds-of-memory-management" class="headerlink" title="Three kinds of memory management"></a>Three kinds of memory management</h1><p>The first kind is called <strong>automatic</strong> memory management: the system allocates memory for a local variable when it executes the variable’s definition, and deallocates that memory automatically at the end of the block that contains the definition. Therefore, we should note that once a variable has been dealloated, any pointers to it are invalid. For example,</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// this function deliberately yields an invalid pointer</span></span><br><span class="line"><span class="comment">// it is intended as a negative example-don't do this!</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">invalid_pointer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">return</span> &amp;x;  <span class="comment">// instant disaster</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This function intends to return the address of local variable <strong>x</strong>. However, the return statement ends the execution of the block and hence deallocates the memory of <strong>x</strong>, resulting that <strong>&amp;x</strong> is invalid. To solve this problem, we can use another kine memory management, i.e. statically allocated.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// This function is completely legitimate</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">pointer_to_static</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">return</span> &amp;x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>When a local object is specified as <strong>static</strong>, it is created only the first time when its definition is executed and won’t be destroied until meet the end of the program. Therefore, the function returns a valid pointer of object <strong>x</strong>.</p>
<p>The shortcoming of this kind memory management is that each call of such function obtains the same pointer. If we want to get a different pointer each time, we can choose an alternative memory management, the <strong>dynamic allocation</strong>. </p>
<p>If <strong>T</strong> is an object type, then <strong>new T</strong> is an expression that</p>
<ol>
<li>allocates an <strong>T</strong> type object </li>
<li>default-initializes the object</li>
<li>yields a pointer to this newly allocated object</li>
<li>the object exists since it is created till either the end of the program or the execution of <strong>delete p</strong>, where <strong>p</strong> is a copy of the pointer returned by the expression. </li>
</ol>
<p>For example,</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// allocate an unnamed object of type int, and initialize it to 42</span></span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">42</span>);</span><br></pre></td></tr></table></figure>
<p>We can change the value of the object by manipulating the <strong>pointer p</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// change the object to 43</span></span><br><span class="line">++*p;</span><br></pre></td></tr></table></figure>
<p>If we want to delete it, we do</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// after this execution, the occupied memory is freed and p becomes an invalid pointer</span></span><br><span class="line"><span class="keyword">delete</span> p;</span><br></pre></td></tr></table></figure>

<p>Now let’s revisit the problem we met above and write a function that can return different pointer each time</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">pointer_to_dynamic</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This function returns a brand new pointer each time. But do not forget to release the memory through <strong>delete p</strong>. </p>
<h2 id="Allocating-and-deallocating-an-array"><a href="#Allocating-and-deallocating-an-array" class="headerlink" title="Allocating and deallocating an array"></a>Allocating and deallocating an array</h2><p>By analogy, we can allocate an array that contains <strong>T</strong> type values. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">T* p = <span class="keyword">new</span> T[n];</span><br></pre></td></tr></table></figure>
<p><strong>n</strong> is a non-negative integral value and <strong>new T[n]</strong> allocates an array of <strong>n</strong> objects of type <strong>T</strong>. There is also a returned <strong>pointer</strong> that points to the initial element of the array. Each object of the array is default-initialized. This means that if <strong>T</strong> is a built-in type, then the elements are undefined while if <strong>T</strong> is a class type, then the elements are initialized by the default constructor defined in that class type. </p>
<p>If <strong>n</strong> equals to 0, then the <strong>new</strong> return a valid <strong>off-the-end</strong> pointer as there is no element contained in the array. To deallocate the memory, we use <strong>delete[] p</strong>. Here is an example</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">T* p = <span class="keyword">new</span> T[n];</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;T&gt; <span class="title">v</span><span class="params">(p, p + n)</span></span>; <span class="comment">// copy elements in the array to vector</span></span><br><span class="line"><span class="keyword">delete</span>[] p;</span><br></pre></td></tr></table></figure>

<p>The <strong>new</strong> allocates an array and stay around until that the program terminates or executes the <strong>delete[]</strong>. Before deallocating the array, the system destroys each element in reverse order. Let’s look at a function</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">duplicate_share</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// allocate enough space; remember to add one for the null</span></span><br><span class="line">    <span class="keyword">size_t</span> length = <span class="built_in">strlen</span>(p) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span>* result = <span class="keyword">new</span> <span class="keyword">char</span>[length];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// copy into our newly allocated space and return pointer to first element</span></span><br><span class="line">    copy(p, p + length, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This function takes a pointer to char as an argument and returns a point to char. It actually copy all chars from one string literal into a new string literal. Firstly, it allocates memory for the new array of chars, then apply copy algorithm to copy each char in the original array into the newly created array. Noting that <strong>strlen</strong> gives the number of non-null characters contained in a string literal. However, when we allocate the memory for a new string literal, we need to add one position more for holding the null-character. As for the deallocation of dynamic allocation, we will discuss more in next chapter. </p>
<hr>
<h1 id="Test-examples"><a href="#Test-examples" class="headerlink" title="Test examples"></a>Test examples</h1><p>Now I test severl programs analysed above. The first program tests <strong>arguments to main</strong> and <strong>letter_grade</strong> function.</p>
<p><strong>Test_1.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;		// to get the declaration of cout, endl</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;		// to get the declaration of string</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;		// to get the declaration of size_t</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>; 	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;  <span class="keyword">using</span> <span class="built_in">std</span>::<span class="keyword">size_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// function declaration</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">letter_grade</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main function with non-empty parameter list</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// if there are arguments, write them</span></span><br><span class="line">    <span class="keyword">if</span>(argc &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// declare i outside the for because we need it after the loop</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// write all but the last entry and argv[i] is a char*</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; argc - <span class="number">1</span>; ++i)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; argv[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// write the last entry but not a space</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; argv[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"my letter grade is: "</span> &lt;&lt; letter_grade(<span class="number">75</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">letter_grade</span><span class="params">(<span class="keyword">double</span> grade)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// range posts for numberic grades</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">double</span> numbers[] = &#123;<span class="number">97</span>, <span class="number">94</span>, <span class="number">90</span>, <span class="number">87</span>, <span class="number">84</span>, <span class="number">80</span>, <span class="number">77</span>, <span class="number">74</span>, <span class="number">70</span>, <span class="number">60</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// name for the letter grades</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> letters[] = &#123;<span class="string">"A+"</span>, <span class="string">"A"</span>, <span class="string">"A-"</span>, <span class="string">"B+"</span>,</span><br><span class="line">                                            <span class="string">"B"</span>, <span class="string">"B-"</span>, <span class="string">"C+"</span>, <span class="string">"C"</span>, <span class="string">"C-"</span>, <span class="string">"D"</span>, <span class="string">"F"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// compute the number of grades given the size of the array</span></span><br><span class="line">    <span class="comment">// and the size of a single element</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> ngrades = <span class="keyword">sizeof</span>(numbers)/<span class="keyword">sizeof</span>(*numbers);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// given a numberic grade, find the associated letter grade</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; ngrades; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (grade &gt;= numbers[i])</span><br><span class="line">            <span class="keyword">return</span> letters[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"?\?\?"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Test Results</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Inputs</span><br><span class="line"></span><br><span class="line">command line arguments: please tell me the true</span><br><span class="line">numeric grade: 75</span><br><span class="line"></span><br><span class="line">Outputs</span><br><span class="line"></span><br><span class="line">please tell me the truth</span><br><span class="line">my letter grade is: C-</span><br></pre></td></tr></table></figure>

<p>The second program produces a copy of all files whose names are given as arguments to main. </p>
<p><strong>test_2.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;		// to get the declaration of cout, endl, cerr</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;		// to get the declaration string getline</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;		// to get the declaration of ifstream</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cerr</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::getline; <span class="keyword">using</span> <span class="built_in">std</span>::ifstream;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fail_count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// for each file in the input list</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; argc; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">ifstream <span class="title">in</span><span class="params">(argv[i])</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if it exits, write its contents, otherwise generate an error message</span></span><br><span class="line">        <span class="keyword">if</span>(in)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> s;</span><br><span class="line">            <span class="keyword">while</span>(getline(in, s))</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cerr</span> &lt;&lt; <span class="string">"cannot open file "</span> &lt;&lt; argv[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            ++fail_count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fail_count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>I firstly create a file named <strong>in</strong> and write following sequences into it</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">what are you going to do</span><br><span class="line">to be or not to be</span><br><span class="line">that is a question</span><br></pre></td></tr></table></figure>

<p>Then I set the commond line arguments as: please tell me the truth in<br>Once I click the run button, the program below gives following results</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cannot open file please</span><br><span class="line">cannot open file tell</span><br><span class="line">cannot open file me</span><br><span class="line">cannot open file the</span><br><span class="line">cannot open file truth</span><br><span class="line">what are you going to do</span><br><span class="line">to be or not to be</span><br><span class="line">that is a question</span><br></pre></td></tr></table></figure>

<p>The last program tests that we can use the <strong>duplicate_share</strong> function to produce a copy of a sequence of characters. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;	// to get the declaration of cout,</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;	// to get the declaration of strlen</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;	// to get the declaration of size_t</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;// to get the declaration of copy</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>; 	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">strlen</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="keyword">size_t</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::copy;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">duplicate_share</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// allocate enough space; remember to add one for the null</span></span><br><span class="line">    <span class="keyword">size_t</span> length = <span class="built_in">strlen</span>(p) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span>* result = <span class="keyword">new</span> <span class="keyword">char</span>[length];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// copy into our newly allocated space and return pointer to first element</span></span><br><span class="line">    copy(p, p + length, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// constructe an array</span></span><br><span class="line">	<span class="keyword">char</span> s[] = <span class="string">"computational"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get a copy</span></span><br><span class="line">	<span class="keyword">char</span>* s_copy = duplicate_share(s);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// verify the copy</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; s_copy &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The program works as we expected and gives results</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">computational</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Notes</tag>
      </tags>
  </entry>
  <entry>
    <title>Accelerated C++ Solutions to Exercises(Chapter 9)</title>
    <url>/2018/04/08/Accelerated-C-Solutions-to-Exercises-Chapter-9/</url>
    <content><![CDATA[<h1 id="Exercise-9-0"><a href="#Exercise-9-0" class="headerlink" title="Exercise 9-0"></a>Exercise 9-0</h1><p>Compile, execute, and test the programs in this chapter.</p>
<h2 id="Solution-amp-Results"><a href="#Solution-amp-Results" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>Please find the solution and analysis in <a href="http://quanttour.com/06/04/2018/C-Defining-new-types/" target="_blank" rel="noopener">Defining new types</a>.</p>
<h1 id="Exercise-9-1"><a href="#Exercise-9-1" class="headerlink" title="Exercise 9-1"></a>Exercise 9-1</h1><p>Reimplement the Student_info class so that it calculates the final grade when reading the student’s record, and stores that grade in the object. Reimplement the grade function to use this precomputed value.</p>
<h2 id="Solution-amp-Results-1"><a href="#Solution-amp-Results-1" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>A similar program has been completed in <a href="http://quanttour.com/11/03/2018/Accelerated-C-Solutions-to-Exercises-Chapter-4-Part-2/" target="_blank" rel="noopener">exercise 4-6</a>. Now I’ll write a new grading program based on class type. The strategy can be logically divided into three parts:</p>
<ol>
<li>abstract data members</li>
<li>design interface and write member functions</li>
<li>access Control </li>
</ol>
<h3 id="data-members-and-constructors"><a href="#data-members-and-constructors" class="headerlink" title="data members and constructors"></a>data members and constructors</h3><p>The original program uses a class type that has four data members: <strong>name, midterm, final and homework</strong>. This exercise requires us to store the final grade in the class object, which implies that we need another data member <strong>grade</strong> representing the final grade. There seems no need to store <strong>midterm, fina and homework</strong> anymore due to that the final grade is computed when reading the student’s record. I didn’t remove them merely as theoretically these information should be kept for a student. Now, we have part of our new class type</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student_info</span>&#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> n;</span><br><span class="line">    <span class="keyword">double</span> midterm, <span class="keyword">final</span>, g;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; homework;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// to be filled by defining/declaring member functions </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>The first I considered was to define <strong>constructors</strong> when desigining an proper interface. The purpose is to allow us to initialize the class object through:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Student_info record;        <span class="comment">// create an empty object</span></span><br><span class="line"><span class="function">Student_info <span class="title">record</span><span class="params">(<span class="built_in">cin</span>)</span></span>;   <span class="comment">// create and initialize an object by reading from input stream</span></span><br></pre></td></tr></table></figure>
<p>The first one needs a default constructor that is responsible for initializing data members. Following code shows their declarations and definitions that are put outside the class. </p>
<p><strong>declaring constructors</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Student_info ();        <span class="comment">// construct an empty object </span></span><br><span class="line">Student_info (<span class="built_in">std</span>::istream &amp;); <span class="comment">// construct an object by reading from istream</span></span><br></pre></td></tr></table></figure>
<p><strong>defining constructors</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Student_info::Student_info(): midterm(<span class="number">0</span>), <span class="keyword">final</span>(<span class="number">0</span>), g(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">Student_info::Student_info (<span class="built_in">std</span>::istream &amp; in) &#123; <span class="built_in">read</span>(in); &#125;</span><br><span class="line">``` </span><br><span class="line">Nothing that all three **<span class="keyword">double</span>** type variables are value-initialized to <span class="number">0</span> <span class="keyword">while</span> **homework** is initialized by <span class="keyword">default</span> constructor of **<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;** type, leading to an empty **homework**.</span><br><span class="line"></span><br><span class="line">##<span class="meta"># other member functions and protection</span></span><br><span class="line">The next is to define a member function to <span class="built_in">read</span> data into the <span class="class"><span class="keyword">class</span> <span class="title">object</span>. <span class="title">The</span> <span class="title">declaration</span> <span class="title">is</span> <span class="title">as</span> <span class="title">same</span> <span class="title">as</span> <span class="title">the</span> <span class="title">previous</span> <span class="title">one</span>:</span></span><br><span class="line">```c++</span><br><span class="line"><span class="function"><span class="built_in">std</span>::istream &amp; <span class="title">read</span><span class="params">(<span class="built_in">std</span>::istream &amp;)</span></span>;</span><br></pre></td></tr></table></figure>
<p>When we define the <strong>read</strong> member, we should meet the requirement that computing the final grade in the process of reading. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">istream &amp; <span class="title">Student_info::read</span><span class="params">(istream &amp;is)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// reads and store the student's name, midterm and final exam grades</span></span><br><span class="line">    is &gt;&gt; n &gt;&gt; midterm &gt;&gt; <span class="keyword">final</span>;</span><br><span class="line">    <span class="keyword">if</span> (is)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// reads and store all homework grades</span></span><br><span class="line">        read_hw(is, homework);</span><br><span class="line">        g = !homework.empty() ? ::grade(midterm, <span class="keyword">final</span>, homework) : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Noting that I deal with the case of empty homework with an <strong>if</strong> statement which computes the final grade if the homwork is not empty and otherwise sets the final grade to 0. The purpose is to avoid the exception when reading data. Alternatively, I define extra two functions to check the validity of final grade and “catch” the state of the object. These two functions are defined inside the class</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">valid</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> !homework.empty(); &#125;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">state</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> valid() ? <span class="string">"valid"</span> : <span class="string">"invalid: student has done no homework"</span>; &#125;</span><br></pre></td></tr></table></figure>
<p>This allows users to seperate valid records and invalid records. </p>
<p>Finally, we define members to get the <strong>name</strong> and <strong>grade</strong> for the purpose that prevents users access data members directly. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> n; &#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> g; &#125;</span><br></pre></td></tr></table></figure>
<p>All member functions except <strong>read</strong> and <strong>constructors</strong> are not allowed to change data members by adding qualifier <strong>const</strong> after the parameter list. To seperate the data abstraction and interface, we control access using specifier <strong>public</strong> and <strong>private</strong>. </p>
<h3 id="Organize-files"><a href="#Organize-files" class="headerlink" title="Organize files"></a>Organize files</h3><p>Now let’s complete the header file <strong>Student_info.h</strong> and the corresponding source file.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_STUDENT_INFO</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_STUDENT_INFO</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student_info</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// constructors</span></span><br><span class="line">    Student_info ();</span><br><span class="line">    Student_info (<span class="built_in">std</span>::istream &amp;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// member functions to check state</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">valid</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> !homework.empty(); &#125;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">state</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> valid() ? <span class="string">"valid"</span> : <span class="string">"invalid: student has done no homework"</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// member functions read and functions to get name, grade and</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> n; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> g; &#125;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::istream &amp; <span class="title">read</span><span class="params">(<span class="built_in">std</span>::istream &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> n;</span><br><span class="line">    <span class="keyword">double</span> midterm, <span class="keyword">final</span>, g;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; homework;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// nonmember functions</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> Student_info &amp;, <span class="keyword">const</span> Student_info &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::istream &amp; <span class="title">read_hw</span><span class="params">(<span class="built_in">std</span>::istream &amp;, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>Student_info.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"grade.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>; 		<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::istream;		<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::domain_error;</span><br><span class="line"></span><br><span class="line"><span class="comment">// construct one by reading from input stream</span></span><br><span class="line">Student_info::Student_info(): midterm(<span class="number">0</span>), <span class="keyword">final</span>(<span class="number">0</span>), g(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">Student_info::Student_info (<span class="built_in">std</span>::istream &amp; in) &#123; <span class="built_in">read</span>(in); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// member function read</span></span><br><span class="line"><span class="function">istream &amp; <span class="title">Student_info::read</span><span class="params">(istream &amp;is)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// reads and store the student's name, midterm and final exam grades</span></span><br><span class="line">    is &gt;&gt; n &gt;&gt; midterm &gt;&gt; <span class="keyword">final</span>;</span><br><span class="line">    <span class="keyword">if</span> (is)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// reads and store all homework grades</span></span><br><span class="line">        read_hw(is, homework);</span><br><span class="line">        g = !homework.empty() ? ::grade(midterm, <span class="keyword">final</span>, homework) : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// nonmember function compare two strings</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> Student_info &amp;x, <span class="keyword">const</span> Student_info &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.name() &lt; y.name();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// nonmember function read data into a vector</span></span><br><span class="line"><span class="function">istream &amp; <span class="title">read_hw</span><span class="params">(istream &amp;in, <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;hw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// read homework grades</span></span><br><span class="line">    hw.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">    <span class="keyword">while</span>(in &gt;&gt; x)</span><br><span class="line">        hw.push_back(x);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clear the stream so that input will work for the next student</span></span><br><span class="line">    in.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Now we can write the main function.</p>
<p><strong>mainfunction.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;		// to get the declaration of max, sort</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;		// to get the declaration of setprecision</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;		// to get the declaration of cin, cout, endl</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;		// to get the declaration of domain_error</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;		// to get the declaration of string</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;		// to get the declaration of vector</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span>	<span class="comment">// to get the declaration of Student_info</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;					<span class="keyword">using</span> <span class="built_in">std</span>::setprecision;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;				<span class="keyword">using</span> <span class="built_in">std</span>::sort;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;				<span class="keyword">using</span> <span class="built_in">std</span>::streamsize;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::domain_error;		        <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">max</span>;					<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Student_info&gt; students;</span><br><span class="line">    Student_info record;</span><br><span class="line">    <span class="built_in">string</span>::size_type maxlen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read and store all the records, and find the length of the longest name</span></span><br><span class="line">    <span class="keyword">while</span>(record.<span class="built_in">read</span>(<span class="built_in">cin</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        maxlen = <span class="built_in">max</span>(maxlen, record.name().<span class="built_in">size</span>());</span><br><span class="line">        students.push_back(record);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// alphabetize the records</span></span><br><span class="line">    sort(students.<span class="built_in">begin</span>(), students.<span class="built_in">end</span>(), compare);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write each line of outpurs</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Student_info&gt;::const_iterator it = students.<span class="built_in">begin</span>();</span><br><span class="line">            it != students.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// write the name, blanks</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (*it).name() &lt;&lt; <span class="built_in">string</span>(maxlen + <span class="number">1</span> - (*it).name().<span class="built_in">size</span>(), <span class="string">' '</span>);</span><br><span class="line">        <span class="comment">// compute and write the final grade</span></span><br><span class="line">        <span class="keyword">double</span> final_grade = (*it).grade();</span><br><span class="line">        streamsize prec = <span class="built_in">cout</span>.precision();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; setprecision(<span class="number">3</span>) &lt;&lt; final_grade &lt;&lt; setprecision(prec);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!(*it).valid())</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="built_in">string</span>(<span class="number">4</span>,<span class="string">' '</span>) &lt;&lt; (*it).state() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>There is nothing new except that I deal with exception with member functions <strong>valid()</strong> and <strong>state()</strong> instead the <strong>try</strong> block. </p>
<p>Finally, I present the header file and source file that contains overloaded grade function and median function. </p>
<p><strong>grade.h</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_GRADE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_GRADE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">median</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>grade.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"grade.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::domain_error;  <span class="keyword">using</span> <span class="built_in">std</span>::istream;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;        <span class="keyword">using</span> <span class="built_in">std</span>::sort;</span><br><span class="line"></span><br><span class="line"><span class="comment">// grade function 1</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">double</span> midterm, <span class="keyword">double</span> <span class="keyword">final</span>, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;hw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hw.empty())</span><br><span class="line">        <span class="keyword">throw</span> domain_error(<span class="string">"student has done no homework"</span>);</span><br><span class="line">    <span class="keyword">return</span> grade(midterm, <span class="keyword">final</span>, median(hw));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// grade function 2</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">double</span> midterm, <span class="keyword">double</span> <span class="keyword">final</span>, <span class="keyword">double</span> homework)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.2</span>*midterm + <span class="number">0.4</span>*<span class="keyword">final</span> + <span class="number">0.4</span>*homework;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compute the median of vector&lt;double&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">median</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// check whether the vec is empty</span></span><br><span class="line">    <span class="keyword">if</span> (vec.<span class="built_in">begin</span>() == vec.<span class="built_in">end</span>())</span><br><span class="line">        <span class="keyword">throw</span> domain_error(<span class="string">"median of an empty vector"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sort the grades</span></span><br><span class="line">    sort(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// compute the median homework grade</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;::difference_type <span class="built_in">size</span> = vec.<span class="built_in">end</span>() - vec.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;::const_iterator mid = vec.<span class="built_in">begin</span>() + <span class="built_in">size</span>/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">size</span> % <span class="number">2</span> == <span class="number">0</span> ? (*mid + *(mid - <span class="number">1</span>))/<span class="number">2</span> : *mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Inputs</span><br><span class="line"></span><br><span class="line">Nqacg 32.4444 16.3838 43</span><br><span class="line">Kmgsk 89.2525 14.7374 32</span><br><span class="line">Awhof 73.7071 73.8485 </span><br><span class="line">Thyyp 92.7172 47.5556 </span><br><span class="line">Zvxxc 66.9091 69.6162 0</span><br><span class="line">Asezo 67.8182 32.6364 10</span><br><span class="line">Evawh 77.798 54.9596 13</span><br><span class="line">Qhwir 75.4242 93.5758 </span><br><span class="line">Nbcpz 71.6263 75.8182 47</span><br><span class="line">Dbevs 67.4949 75.3434 31</span><br><span class="line"></span><br><span class="line">Outputs</span><br><span class="line"></span><br><span class="line">Asezo 30.6</span><br><span class="line">Awhof 0    invalid: student has done no homework</span><br><span class="line">Dbevs 56</span><br><span class="line">Evawh 42.7</span><br><span class="line">Kmgsk 36.5</span><br><span class="line">Nbcpz 63.5</span><br><span class="line">Nqacg 30.2</span><br><span class="line">Qhwir 0    invalid: student has done no homework</span><br><span class="line">Thyyp 0    invalid: student has done no homework</span><br><span class="line">Zvxxc 41.2</span><br></pre></td></tr></table></figure>

<p>Users can rewrite the main function to generate a better formatted report according to their own preference, using member functions <strong>valid()</strong> and <strong>state()</strong>.</p>
<hr>
<h1 id="Exercise-9-2"><a href="#Exercise-9-2" class="headerlink" title="Exercise 9-2"></a>Exercise 9-2</h1><p>If we define the name function as a plain, nonconst member function, what other functions in our system must change and why?</p>
<h2 id="Solution-amp-Results-2"><a href="#Solution-amp-Results-2" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>If we define the <strong>name</strong> function as a nonconst member function, we need to change the <strong>compare</strong> function as well.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> Student_info &amp;x, <span class="keyword">const</span> Student_info &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.name() &lt; y.name();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>See from the <strong>compare</strong> function above, the arguments are passed by reference to <strong>const</strong> objects. In other words, the <strong>compare</strong> function treats <strong>Student_info</strong> object as <strong>const</strong>. If it calls non-const member functions (i.e. name()), there is no guarantee that it doesn’t modify the object, which is a potential conflict with its definition. THerefore, this is not allowed by the compiler. To correct it, we can remove the qualifer <strong>const</strong> to release its restriction on arguments as shown below.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(Student_info &amp;x, Student_info &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.name() &lt; y.name();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Exercise-9-3-9-4"><a href="#Exercise-9-3-9-4" class="headerlink" title="Exercise 9-3, 9-4"></a>Exercise 9-3, 9-4</h1><p>9-3: Our grade function was written to throw an exception if a user tried to calculate agrade for a Student_info object whose values had not yet been read. Users who care are expected to catch this exception. Write a program that triggers the exception but does not catch it. Write a program that catches the exception.</p>
<p>9-4: Rewrite your program from the previous exercise to use the valid function, thereby avoiding the exception altogether.</p>
<h2 id="Solution-amp-Results-3"><a href="#Solution-amp-Results-3" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>The key is to use member function <strong>valid()</strong> to avoid the exception. This exercise is simple and hence no further analysis. I only write the main function here and please find other files in <a href="http://quanttour.com/06/04/2018/C-Defining-new-types/" target="_blank" rel="noopener">Defining new types</a>.</p>
<p><strong>Trigger the exception</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::domain_error;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Student_info record;</span><br><span class="line">	record.grade();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>catch the exception</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::domain_error;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Student_info record;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">    record.grade();</span><br><span class="line">    &#125;<span class="keyword">catch</span>(domain_error e)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; e.what();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>avoid the exception</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::domain_error;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Student_info <span class="title">record</span> <span class="params">(<span class="built_in">cin</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(record.valid())</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; record.grade();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Exercise-9-5"><a href="#Exercise-9-5" class="headerlink" title="Exercise 9-5"></a>Exercise 9-5</h1><p>Write a class and associated functions to generate grades for students who take thecourse for pass/fail credit. Assume that only the midterm and final grades matter, and that astudent passes with an average exam score greater than 60. The report should list the students in alphabetical order, and indicate P or F as the grade.</p>
<h2 id="Solution-amp-Results-4"><a href="#Solution-amp-Results-4" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>My strategy is to define a new <strong>grade</strong> function:</p>
<p><strong>declaration</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">grade</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>definition</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">Student_info::grade</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (midterm + <span class="keyword">final</span>)/<span class="number">2</span> &gt; <span class="number">60</span> ? <span class="string">"P"</span> : <span class="string">"F"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>So, when calling this member, it gives the letter grade <strong>P</strong> or <strong>F</strong>. The revised class type is defined as follows</p>
<p><strong>Student_info.h</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_STUDENT_INFO</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_STUDENT_INFO</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student_info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student_info ();						<span class="comment">// default constructor</span></span><br><span class="line">    Student_info (<span class="built_in">std</span>::istream &amp;);				<span class="comment">// constructor with argument</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> n; &#125;			<span class="comment">// inline member function return name</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::istream &amp; <span class="title">read</span><span class="params">(<span class="built_in">std</span>::istream &amp;)</span></span>;			<span class="comment">// member function read in data</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">grade</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> n;</span><br><span class="line">    <span class="keyword">double</span> midterm, <span class="keyword">final</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::istream &amp; <span class="title">read_hw</span><span class="params">(<span class="built_in">std</span>::istream &amp;, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;)</span></span>; <span class="comment">// nonmember function read data into a vector</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> Student_info &amp;, <span class="keyword">const</span> Student_info &amp;)</span></span>;	   <span class="comment">// nonmember function compare two string</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">**Student_info.cpp**</span><br><span class="line">```c++</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>; 		<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::istream;</span><br><span class="line"></span><br><span class="line"><span class="comment">// construct an empty Student_info object</span></span><br><span class="line">Student_info::Student_info (): midterm(<span class="number">0</span>), <span class="keyword">final</span>(<span class="number">0</span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// construct one by reading from input stream</span></span><br><span class="line">Student_info::Student_info (<span class="built_in">std</span>::istream &amp; in) &#123; <span class="built_in">read</span>(in); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// member function read data from input stream</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::istream &amp; <span class="title">Student_info::read</span><span class="params">(<span class="built_in">std</span>::istream &amp;in)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// reads and store the student's name, midterm and final exam grades</span></span><br><span class="line">    in &gt;&gt; n &gt;&gt; midterm &gt;&gt; <span class="keyword">final</span>;</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// member function grade</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">Student_info::grade</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (midterm + <span class="keyword">final</span>)/<span class="number">2</span> &gt; <span class="number">60</span> ? <span class="string">"P"</span> : <span class="string">"F"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// nonmember function compare</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> Student_info &amp;x, <span class="keyword">const</span> Student_info &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.name() &lt; y.name();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Noting that there is no computations as previous version. What we need to do is merely to remove the needless code.</p>
<p>Finally, I present the test function followed by the test results</p>
<p><strong>mainfunction.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;		// to get the declaration of max, sort</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;		// to get the declaration of string</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;		// to get the declaration of vector</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span>	<span class="comment">// to get the declaration of Student_info</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;				<span class="keyword">using</span> <span class="built_in">std</span>::sort;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;				<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">max</span>;					<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Student_info&gt; students;</span><br><span class="line">    Student_info record;</span><br><span class="line">    <span class="built_in">string</span>::size_type maxlen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read and store all the records, and find the length of the longest name</span></span><br><span class="line">    <span class="keyword">while</span>(record.<span class="built_in">read</span>(<span class="built_in">cin</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        maxlen = <span class="built_in">max</span>(maxlen, record.name().<span class="built_in">size</span>());</span><br><span class="line">        students.push_back(record);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// alphabetize the records</span></span><br><span class="line">    sort(students.<span class="built_in">begin</span>(), students.<span class="built_in">end</span>(), compare);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write each line of outpurs</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Student_info&gt;::const_iterator it = students.<span class="built_in">begin</span>();</span><br><span class="line">            it != students.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// write the name, blanks</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (*it).name() &lt;&lt; <span class="built_in">string</span>(maxlen + <span class="number">1</span> - (*it).name().<span class="built_in">size</span>(), <span class="string">' '</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// compute and write the final grade</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (*it).grade() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Test</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Inputs</span><br><span class="line"></span><br><span class="line">Xdvdr 55.404 28.7778</span><br><span class="line">Qlyys 91.9192 60.0404</span><br><span class="line">Iutlc 12.9697 61.202</span><br><span class="line">Jygsc 58.2424 99.5657</span><br><span class="line">Wxilm 85.0606 57.2424</span><br><span class="line">Lshfy 34.8687 65.9697</span><br><span class="line">Ujruj 41.8182 89.6364</span><br><span class="line">Orbac 3.58586 56.8788</span><br><span class="line">Fyhub 99 65.2828</span><br><span class="line"></span><br><span class="line">Outputs</span><br><span class="line"></span><br><span class="line">Fyhub P</span><br><span class="line">Iutlc F</span><br><span class="line">Jygsc P</span><br><span class="line">Lshfy F</span><br><span class="line">Orbac F</span><br><span class="line">Qlyys P</span><br><span class="line">Qzaen P</span><br><span class="line">Ujruj P</span><br><span class="line">Wxilm P</span><br><span class="line">Xdvdr F</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Exercise-9-6"><a href="#Exercise-9-6" class="headerlink" title="Exercise 9-6"></a>Exercise 9-6</h1><p>Rewrite the grading program for the pass/fail students so that the report shows all the students who passed, followed by all the students who failed.</p>
<h2 id="Solution-amp-Results-5"><a href="#Solution-amp-Results-5" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>One possible solution is that using ths standard library algorithm <strong>stable_partition</strong> to rearrange the elements (i.e. student records) such that all passing grades preceds all failing grades. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">stable_partition(students.<span class="built_in">begin</span>(), students.<span class="built_in">end</span>(), pgrade);</span><br></pre></td></tr></table></figure>
<p>The <strong>pgrade</strong> is defined as follows</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">fgrade</span><span class="params">(<span class="keyword">const</span> Student_info &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.grade() &lt; <span class="number">60</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">pgrade</span><span class="params">(<span class="keyword">const</span> Student_info &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !fgrade(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>These two function can be declared in the file <strong>Student_info.h</strong> as nonmember function( see <a href="http://quanttour.com/06/04/2018/C-Defining-new-types/" target="_blank" rel="noopener">Defining new types</a>). I’ll present the main function and a simple test in below part.</p>
<p><strong>mainfunction.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;		// to get the declaration of max, sort</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;			// to get the declaration of setprecision</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;			// to get the declaration of streamsize</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;		// to get the declaration of stable_partition</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;			// to get the declaration of string</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;			// to get the declaration of vector</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span>	<span class="comment">// to get the declaration of Student_info</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;				<span class="keyword">using</span> <span class="built_in">std</span>::setprecision;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;				<span class="keyword">using</span> <span class="built_in">std</span>::streamsize;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">max</span>;					<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::stable_partition;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Student_info&gt; students;</span><br><span class="line">    Student_info record;</span><br><span class="line">    <span class="built_in">string</span>::size_type maxlen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read and store all the records, and find the length of the longest name</span></span><br><span class="line">    <span class="keyword">while</span>(record.<span class="built_in">read</span>(<span class="built_in">cin</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        maxlen = <span class="built_in">max</span>(maxlen, record.name().<span class="built_in">size</span>());</span><br><span class="line">        students.push_back(record);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// students who passed followed by all student who failed</span></span><br><span class="line">    stable_partition(students.<span class="built_in">begin</span>(), students.<span class="built_in">end</span>(), pgrade);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write each line of outpurs</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Student_info&gt;::const_iterator it = students.<span class="built_in">begin</span>();</span><br><span class="line">            it != students.<span class="built_in">end</span>() ; ++it)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((*it).valid())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// write the name, blanks</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; (*it).name() &lt;&lt; <span class="built_in">string</span>(maxlen + <span class="number">1</span> - (*it).name().<span class="built_in">size</span>(), <span class="string">' '</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// compute and write the final grade</span></span><br><span class="line">            <span class="keyword">double</span> final_grade = (*it).grade();</span><br><span class="line">            streamsize prec = <span class="built_in">cout</span>.precision();</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; setprecision(<span class="number">3</span>) &lt;&lt; final_grade &lt;&lt; setprecision(prec) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Test</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Inputs</span><br><span class="line"></span><br><span class="line">Nmlox 42.3434 61.0808 66</span><br><span class="line">Mljwc 39.2727 80.3636 62</span><br><span class="line">Omzml 78.9596 39.8283 42</span><br><span class="line">Buvdm 20.7273 26.8384 35</span><br><span class="line">Lczfw 14.6162 72.1717 75</span><br><span class="line">Bloic 50.2525 60.798 44</span><br><span class="line">Hewvl 59.4646 98.4141 73</span><br><span class="line">Nunsg 95.1414 95.9596 8</span><br><span class="line">Gkaqw 97.7071 85.6263 93</span><br><span class="line">Isohi 49.3434 21.9293 63</span><br><span class="line">Tduzm 92.1111 18.4343 31</span><br><span class="line">Koede 82.404 36.0101 75</span><br><span class="line">Igfab 57.6061 90.9899 15</span><br><span class="line">Ejtaa 93.0404 27.8586 28</span><br><span class="line">Iwhgb 97.6364 44.3333 4</span><br><span class="line">Frbhw 40.7677 68.4747 19</span><br><span class="line">Hsskh 9.44444 90.2121 25</span><br><span class="line">Yvyel 2 20.6566 67</span><br><span class="line">Ktnaa 95.596 19.8586 84</span><br><span class="line">Pdjjb 37.5455 68.303 57</span><br><span class="line"></span><br><span class="line">Outputs</span><br><span class="line"></span><br><span class="line">Mljwc 64.8</span><br><span class="line">Lczfw 61.8</span><br><span class="line">Hewvl 80.5</span><br><span class="line">Nunsg 60.6</span><br><span class="line">Gkaqw 91</span><br><span class="line">Koede 60.9</span><br><span class="line">Ktnaa 60.7</span><br><span class="line">Nmlox 59.3</span><br><span class="line">Omzml 48.5</span><br><span class="line">Buvdm 28.9</span><br><span class="line">Bloic 52</span><br><span class="line">Isohi 43.8</span><br><span class="line">Tduzm 38.2</span><br><span class="line">Igfab 53.9</span><br><span class="line">Ejtaa 41</span><br><span class="line">Iwhgb 38.9</span><br><span class="line">Frbhw 43.1</span><br><span class="line">Hsskh 48</span><br><span class="line">Yvyel 35.5</span><br><span class="line">Pdjjb 57.6</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Exercise-9-7"><a href="#Exercise-9-7" class="headerlink" title="Exercise 9-7"></a>Exercise 9-7</h1><p>The read_hw function §4.1.3/57 solves a general problem (reading a sequence ofvalues into a vector) even though its name suggests that it should be part of theimplementation of Student_info. Of course, we could change its name—but suppose,instead, that you wanted to integrate it with the rest of the Student_info code, in order to clarify that it was not intended for public access despite its apparent generality? How would you do so?</p>
<h2 id="Solution-amp-Results-6"><a href="#Solution-amp-Results-6" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>My solution is to add the <strong>read_hw</strong> as the member function. To control the access, I specify the member as <strong>private</strong>. Accordingly, the revised <strong>Student_info.h</strong> is</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_STUDENT_INFO</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_STUDENT_INFO</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student_info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student_info ();				    <span class="comment">// default constructor</span></span><br><span class="line">    Student_info (<span class="built_in">std</span>::istream &amp;);		    <span class="comment">// constructor with argument</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> n; &#125;	    <span class="comment">// inline member function return name</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">valid</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> !homework.empty(); &#125;<span class="comment">// inline member function check state</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::istream &amp; <span class="title">read</span><span class="params">(<span class="built_in">std</span>::istream &amp;)</span></span>;	    <span class="comment">// member function read in data</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">()</span> <span class="keyword">const</span></span>;			    <span class="comment">// member function calculate final grade</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> n;</span><br><span class="line">    <span class="keyword">double</span> midterm, <span class="keyword">final</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; homework;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// private member function read data into a vector</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::istream &amp; <span class="title">read_hw</span><span class="params">(<span class="built_in">std</span>::istream &amp;, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// nonmember function compare two string</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> Student_info &amp;, <span class="keyword">const</span> Student_info &amp;)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>Correspondingly, when we define the <strong>read_hw</strong> outside the class, we need to specify the name scope using <strong>Student_info::read_hw</strong>. The new read_hw is given below</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">istream &amp; <span class="title">Student_info::read_hw</span><span class="params">(istream &amp;in, <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;hw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (in)&#123;</span><br><span class="line">        <span class="comment">//get rid of previous contents</span></span><br><span class="line">        hw.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// read homework grades</span></span><br><span class="line">        <span class="keyword">double</span> x;</span><br><span class="line">        <span class="keyword">while</span>(in &gt;&gt; x)</span><br><span class="line">            hw.push_back(x);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// clear the stream so that input will work for the next student</span></span><br><span class="line">        in.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>All other files keep unchanged and can be found in <a href="http://quanttour.com/06/04/2018/C-Defining-new-types/" target="_blank" rel="noopener">Defining new types</a>.</p>
<hr>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>Koenig, A. and Moo, B.E., 2000. Accelerated C++.</p>
<p>Lippman, S.B., Lajoie, J. and Moo, B.E., 2013. C++ Primer, 5th edt.</p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Accelerated C++ Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ - Defining new types</title>
    <url>/2018/04/06/C-Defining-new-types/</url>
    <content><![CDATA[<h1 id="Rewrite-Student-info-in-class-type"><a href="#Rewrite-Student-info-in-class-type" class="headerlink" title="Rewrite Student_info in class type"></a>Rewrite Student_info in class type</h1><p>In chapter 4, we learned how to organize data with a single data structure:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student_info</span>&#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">double</span> midterm, <span class="keyword">final</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; homework;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>The type <strong>Stuent_info</strong> holds information including <strong>name, midterm, final exam grades and a bunch of homework grades</strong> for a student. It help us to easily access the information of one student. Then, we wrote several functions to compute final grades based on the objects of such type. However, our program that uses such data type has several limitations</p>
<ol>
<li><p>users of our program have to follow some conventions. If we want to use a newly created object of <strong>Student_info</strong>, we need to ensure that we have read data into it. If one want to check whether the object contains information, he can only look at the actual data members in it. This requires users knowing well about the iternal structure of such type that the object belongs to. In other words, if I am a user but not a programmer, I need to learn each details about how to implement such type in a program. </p>
</li>
<li><p>there is no data protection mechanism. Users might want to keep students’ information unchanged once read in. However, we don’t provide such mechanism in the original program. </p>
</li>
<li><p>There is no universal interface for users. Function such as <strong>read**</strong> is closely connected with a <strong>Student_info</strong> object as they can change the state of an object. We might like to put them into a single header file for providing convenience for other users. However, we don’t have such structure that provids a universal interface for users. </p>
</li>
</ol>
<p>Now we learn how to deal with these problems with a new data type-class. <strong>class</strong> type is a mechanism that combines related data values into a data structure. It is an abstract data type that similar to <strong>Student_info</strong>. But it also provides an interface that allows us to operate an object, e.g. an <strong>Student_info</strong>, while hiding all deatils of the object. </p>
<p>For example, we are familar with <strong>vector<double></strong> which is a class that provides a set of operations, such as <strong>push_back, erase</strong> for users. But we don’t know how exactly these functions are implemented. </p>
<h2 id="Member-function"><a href="#Member-function" class="headerlink" title="Member function"></a>Member function</h2><p>As analysed above, we may don’t need some details of the students’ information as well as how <strong>read</strong> function deal with these information. What users need to know is how to use the relevant functions. Therefore, we need to design such interface.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student_info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">double</span> midterm, <span class="keyword">final</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; homework;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::istream &amp; <span class="title">read</span><span class="params">(<span class="built_in">std</span>::istream &amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Let’s say we have such an <strong>Student_info</strong> object named <strong>record</strong>. It has four data members <strong>name, midterm, final and homework</strong>. In addition, there are two member functions named <strong>read and grade</strong> which let us to read a record from an input stream and calculate the final grade for the object. Now, though we didn’t define any such structure before, we can presume how to use it. By the analogy of other class such as <strong>vector<double></strong>, I can store information for one student by calling its member function <strong>read</strong>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">record.<span class="built_in">read</span>(<span class="built_in">cin</span>);</span><br></pre></td></tr></table></figure>
<p>Again, we can calculate the final grade for <strong>record</strong> by calling member function <strong>grade()</strong>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">record.grade();</span><br></pre></td></tr></table></figure>
<p>Member functions can be defined inside or outside the class definition. Member functions defined inside are implicitly <strong>inline</strong> to avoid function call overhead. Apparently, member functions above are declared only and defined outside of the class. Let’s look at the <strong>read</strong> function:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">istream &amp; <span class="title">Student_info::read</span><span class="params">(istream &amp;in)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    in &gt;&gt; name &gt;&gt; midterm &gt;&gt; <span class="keyword">final</span>;</span><br><span class="line">    read_hw(in, homework);</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Comparing with the original version:</p>
<ol>
<li>the name of the function is <strong>Student_info::read</strong> because it is declared inside of and as a member of <strong>Student_info</strong>. </li>
<li>we don’t need to pass the <strong>Student_info</strong> object as an argument to the function as the function is a member of <strong>Student_info</strong>. </li>
<li>the member function can access data members directly using <strong>name, midterm etc.</strong> instead of <strong>record.name, record.midterm etc.</strong>.</li>
</ol>
<p>Now let’s look at the <strong>grade</strong> member:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Student_info::grade</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>  ::grade(midterm, <span class="keyword">final</span>, homework);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>It is similar to the <strong>read</strong> member in terms of putting <strong>::</strong> in front of the name and accessing data members without any qualification. But there are two differences:</p>
<p>First, putting <strong>::</strong> in front of <strong>grade</strong> when call it means that the <strong>grade</strong> function is a version that is not a member of class <strong>Student_info</strong>. Second, we put a qualifier <strong>const</strong> after the parameter list. What’s that mean? Recalling the original version</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">const</span> Student_info &amp;)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>We pass <strong>Student_info</strong> object by reference to const to avoid changing the argument to pass. In the new version, we don’t need to pass the <strong>Student_info* object any more as the function itself is a member function. Therefore, we add the **const</strong> after the parameter list for the same purpose, that is, to avoid changing the state of data members of the <strong>Student_info</strong> object. Noting that, the class object may not be created with <strong>const</strong> but is referenced to <strong>const</strong> in a function. Then, the function treat the object as if it were <strong>const</strong>. </p>
<h2 id="Protection"><a href="#Protection" class="headerlink" title="Protection"></a>Protection</h2><p>Though we provide interface for our class, users still can access data members directly and might meddle the implementation unintentionally. Therefore it is probably sensible to restrict users’ rights such that they can only access data members  through member functions. The idea behind this process (i.e. data hiding) is called <strong>encapsulation</strong>. C++ supports <strong>encapsulation</strong> with two <strong>access specifiers</strong>(aka. protection lables): </p>
<ol>
<li><strong>public specifier</strong>. Members defined after a keyword <strong>public</strong> are accessible to all parts of the program. This is typically used to specify members that define the interface to the class. </li>
<li><strong>private specifier</strong>. Members defined after a keyword <strong>private</strong> are accessible to the member functions of the class only. This is typically used to specify members that involves the implementation. </li>
</ol>
<p>Therefore, we can change our class as follows:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student_info</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// interface goes here</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::istream &amp; <span class="title">read</span><span class="params">(<span class="built_in">std</span>::istream &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// implementation goes here</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">double</span> midterm, <span class="keyword">final</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; homework;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>As explained above, We have specified member functions as public and data memmers as private. It has been noted that we use keyword <strong>class</strong> instead <strong>struct</strong> to define the <strong>class</strong> type. Both two keywords are ok for defining a <strong>class</strong> type. The only difference is the default access level. A class may define members before its first protection lable. if we use <strong>class</strong>, those members are default <strong>private</strong> while if we use <strong>struct</strong>, those members are default <strong>public</strong>. Accordingly, the class defined above is equivalent to</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student_info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">double</span> midterm, <span class="keyword">final</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; homework;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::istream &amp; <span class="title">read</span><span class="params">(<span class="built_in">std</span>::istream &amp;)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>In general, if we don’t intend to restrict data access, we use <strong>struct</strong>. But if we intend to have private members, we use <strong>class</strong>.</p>
<h2 id="Accessor-functions"><a href="#Accessor-functions" class="headerlink" title="Accessor functions"></a>Accessor functions</h2><p>Now we have successfully hidden data memebers but the problem next is that We fail to access <strong>name</strong> as well. We can set member <strong>name</strong> to <strong>public</strong>, however, what we really need is only the <strong>read access</strong> rather than <strong>write access</strong>. Alternatively, we can write another member function that returns the <strong>name</strong> but is not allowed to rewrite the <strong>name</strong> object.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student_info</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// interface goes here</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::istream &amp; <span class="title">read</span><span class="params">(<span class="built_in">std</span>::istream &amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> n; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// implementation goes here</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> n;</span><br><span class="line">    <span class="keyword">double</span> midterm, <span class="keyword">final</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; homework;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>As mentioned above, member functions defined inside are implicitly <strong>inline</strong> to avoid function call overhead. In this class, we define member <strong>name</strong> inside the class to imply compiler that this member function should be expanded inline at anywhere it is called. </p>
<p>Functions such as <strong>name</strong> are often called <strong>accessor functions</strong>. It seems that such function breaks the encapsulation that we were trying to achieve. Therefore, such function is privided only when <strong>accessor</strong>s are part of the abtract interface of the class. In this case, the abtraction is that of a student and a corresponding final grade. Obviously, <strong>name</strong> is part of the abstract interface. </p>
<p>Accordingly, the <strong>compare</strong> function changes to:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> Student_info &amp; x, Student_info &amp; y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.name() &lt; y.name();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Testing-for-empty"><a href="#Testing-for-empty" class="headerlink" title="Testing for empty"></a>Testing for empty</h2><p>There is another problem we may concern when using such <strong>class</strong> object. For example, if we call the member <strong>grade</strong> without calling <strong>read</strong> first, we would get an <strong>exception</strong> due to <strong>homework</strong> is empty. A traditional solution is to catch the exception and let users know what leads to the exception. But again, this may require users knowing about the iternal structure of the class object. Alternatively, we can provide a public member function named <strong>valid</strong>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">class <span class="title">Student_info</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">valid</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> !homework.empty(); &#125;</span><br><span class="line">    <span class="comment">// as before</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This member function tells the state of the object: if <strong>valid</strong> function returns true, it indicates that the object contains valid data, i.e. at least one homework grade; if <strong>valid</strong> returns false, it indicates the object is invalid for computing the final grades as there is no any homework grade. Users can check the state of the class object before the <strong>grade</strong> function call, thereby avoiding a potential exception. </p>
<h2 id="Constructors"><a href="#Constructors" class="headerlink" title="Constructors"></a>Constructors</h2><p>It is known that when we create an object, it should be default initialized or assigned with an appropriate value. For example, when we define a <strong>string</strong> without an initializer, we get an empty <strong>string</strong>. So, what happens when we create a class object?</p>
<p>The <strong>class</strong> type supports defining how to initialize an class onject through <strong>constructors</strong> which are special member functions. There is no way to explicitly call <strong>constructors</strong>. Instead creating an class object automatically calls an appropriate constructor as a side effect. </p>
<p><em>If we do not define any constructors, the compiler will synthesize one for us. The synthesized constructor initializes the data member to a value depending on how the object is created. Specifically, if a class object is created as a local variable, then the data members will be default initialized. If a class object is used to initialize a container element, either as a side effect of adding new element to a <strong>map</strong>, or as the elements of container defined to have a given size, then the member will be value-initialized determined by a class type itself.</em> </p>
<p>The rules below summarize how a class type initializes its data members:</p>
<ol>
<li><p><em>if an object is of a class type that defines one or more constructors, then the appropriate constructor determines how data memebers will be initialized.</em></p>
</li>
<li><p><em>if an object is of built-in type, then value-initializing it sets it to zero, and default-initializing it gives it an undefined value.</em> </p>
</li>
<li><p><em>In the case that an object is of a class type that doesn’t define any constructor, value- or default-initializing the object value, or default-initializes each of its data members. This process will be recursive if any data member is of a class type with its own constructor</em>.</p>
</li>
</ol>
<p>In our example, the <strong>Student_info</strong> class type is the case 3. If we define a local variable that is of such class type, <strong>n and homework</strong> are default-initialized and concequently yields an empty string and vector respectively. However, default-initializing <strong>midterm and final</strong> leads to undefined values. To ensure all data members have sensible values at all times, we should define constructors for our class type. Let’s look at two constructors:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student_info</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student_info ();     <span class="comment">// construct an empty Student_info object</span></span><br><span class="line">    Student_info (<span class="built_in">std</span>::istream);  <span class="comment">// construct one by reading from input stream</span></span><br><span class="line">    <span class="comment">// as before</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We add two public members functions that are both named <strong>Student_info</strong> , that is, the name of the class type itself, and both have no <strong>return type</strong>. These two features distinguish <strong>constructors</strong> from other member functions. It can also be observed that constructors has two different versions, the first constructor of which takes no argument while the second takes input stream object as argument. Corresponding, we can write our code like</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Student_info s;          <span class="comment">// an empty Student_info</span></span><br><span class="line"><span class="function">Student_info <span class="title">s2</span><span class="params">(<span class="built_in">cin</span>)</span></span>;    <span class="comment">// initialize s2 by reading from cin</span></span><br></pre></td></tr></table></figure>

<h3 id="The-default-constructor"><a href="#The-default-constructor" class="headerlink" title="The default constructor"></a>The default constructor</h3><p>The first constructor</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Student_info s;</span><br></pre></td></tr></table></figure>
<p>is known as <strong>default constructor</strong> which takes no arguments and ensures that all data members are normally initialized through:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Student_info::Student_info(): midterm(<span class="number">0</span>), <span class="keyword">final</span>(<span class="number">0</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>This definition uses new syntax: the contents between <strong>:</strong> and <strong>{</strong> are a sequence of initializers which initializes each given data member with the value that appears inside of the corresponding parenthese. This default constructor doesn’t explictly initialize <strong>n</strong> and <strong>homework</strong> members as they are initialized implicitly. In specific, <strong>n</strong> is initialized by the <strong>string</strong> default constructor and <strong>homework</strong> is initialized by the <strong>vector</strong> default constructor. </p>
<p>When we create a new class object, the implementation proceeds following steps:</p>
<ol>
<li>allocates memory to hold the object</li>
<li>initializes the object as the constructor defines</li>
<li>executes the constructor body</li>
</ol>
<p>The implementation initializes every data member of every object even if some members are not explicitly initialized with the constructor initializer list. </p>
<h3 id="Constructors-with-arguments"><a href="#Constructors-with-arguments" class="headerlink" title="Constructors with arguments"></a>Constructors with arguments</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Student_info::Student_info(istream &amp;is) &#123; <span class="built_in">read</span>(is); &#125;</span><br></pre></td></tr></table></figure>
<p>There is no initializer provided for each data member and hence <strong>n</strong> and <strong>homework</strong> will be initialized by the default constructors for <strong>string</strong> and <strong>vector</strong>, respectively. But <strong>midterm</strong> and <strong>fianl</strong> are undefined if the object is default-initialized otherwise are value-initialized to 0. Nevertheless, the function body gives new values to these data members by calling <strong>read</strong> function. </p>
<h2 id="Class-based-grading-program"><a href="#Class-based-grading-program" class="headerlink" title="Class-based grading program"></a>Class-based grading program</h2><p>Now we have successfully defined a class-based <strong>Student_info</strong> type. Apparently, using the class is different from using the original structure. Therefore, the last step is to rewrite the main function and organsize files.</p>
<p><strong>mainfunction.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;		// to get the declaration of max, sort</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;		// to get the declaration of setprecision</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;		// to get the declaration of streamsize</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;		// to get the declatation of domain_error</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;		// to get the declaration of string</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;		// to get the declaration of vector</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span>	<span class="comment">// to get the declaration of Student_info</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"grade.h"</span>		<span class="comment">// to get the declatation of grading functions</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;					<span class="keyword">using</span> <span class="built_in">std</span>::setprecision;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;				<span class="keyword">using</span> <span class="built_in">std</span>::sort;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;				<span class="keyword">using</span> <span class="built_in">std</span>::streamsize;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::domain_error;		        <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">max</span>;					<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Student_info&gt; students;</span><br><span class="line">    Student_info record;</span><br><span class="line">    <span class="built_in">string</span>::size_type maxlen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read and store all the records, and find the length of the longest name</span></span><br><span class="line">    <span class="keyword">while</span>(record.<span class="built_in">read</span>(<span class="built_in">cin</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        maxlen = <span class="built_in">max</span>(maxlen, record.name().<span class="built_in">size</span>());</span><br><span class="line">        students.push_back(record);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// alphabetize the records</span></span><br><span class="line">    sort(students.<span class="built_in">begin</span>(), students.<span class="built_in">end</span>(), compare);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write each line of outpurs</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Student_info&gt;::const_iterator it = students.<span class="built_in">begin</span>();</span><br><span class="line">    	it != students.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// write the name, blanks</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (*it).name() &lt;&lt; <span class="built_in">string</span>(maxlen + <span class="number">1</span> - (*it).name().<span class="built_in">size</span>(), <span class="string">' '</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// compute and write the final grade</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">double</span> final_grade = (*it).grade();</span><br><span class="line">            streamsize prec = <span class="built_in">cout</span>.precision();</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; setprecision(<span class="number">3</span>) &lt;&lt; final_grade &lt;&lt; setprecision(prec);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(domain_error e)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; e.what();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Student_info.h</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_STUDENT_INFO</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_STUDENT_INFO</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student_info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student_info ();						<span class="comment">// default constructor</span></span><br><span class="line">    Student_info (<span class="built_in">std</span>::istream &amp;);				<span class="comment">// constructor with argument</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> n; &#125;		        <span class="comment">// inline member function return name</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">valid</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> !homework.empty(); &#125;            <span class="comment">// inline member function check state</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::istream &amp; <span class="title">read</span><span class="params">(<span class="built_in">std</span>::istream &amp;)</span></span>;			<span class="comment">// member function read in data</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">()</span> <span class="keyword">const</span></span>;					<span class="comment">// member function calculate final grade</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> n;</span><br><span class="line">    <span class="keyword">double</span> midterm, <span class="keyword">final</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; homework;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::istream &amp; <span class="title">read_hw</span><span class="params">(<span class="built_in">std</span>::istream &amp;, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;)</span></span>; <span class="comment">// nonmember function read data into a vector</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> Student_info &amp;, <span class="keyword">const</span> Student_info &amp;)</span></span>;      <span class="comment">// nonmember function compare two string</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>Student_info.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"grade.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>; <span class="keyword">using</span> <span class="built_in">std</span>::istream;</span><br><span class="line"></span><br><span class="line"><span class="comment">// construct an empty Student_info object</span></span><br><span class="line">Student_info::Student_info (): midterm(<span class="number">0</span>), <span class="keyword">final</span>(<span class="number">0</span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// construct one by reading from input stream</span></span><br><span class="line">Student_info::Student_info (<span class="built_in">std</span>::istream &amp; in) &#123; <span class="built_in">read</span>(in); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// member function read data from input stream</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::istream &amp; <span class="title">Student_info::read</span><span class="params">(<span class="built_in">std</span>::istream &amp;in)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// reads and store the student's name, midterm and final exam grades</span></span><br><span class="line">    in &gt;&gt; n &gt;&gt; midterm &gt;&gt; <span class="keyword">final</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reads and store all homework grades</span></span><br><span class="line">    read_hw(in, homework);</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// member function grade</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Student_info::grade</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ::grade(midterm, <span class="keyword">final</span>, homework);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// nonmember function compare</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> Student_info &amp;x, <span class="keyword">const</span> Student_info &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.name() &lt; y.name();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// nonmember function read_hw</span></span><br><span class="line"><span class="function">istream &amp; <span class="title">read_hw</span><span class="params">(istream &amp;in, <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;hw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (in)&#123;</span><br><span class="line">        <span class="comment">//get rid of previous contents</span></span><br><span class="line">        hw.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// read homework grades</span></span><br><span class="line">        <span class="keyword">double</span> x;</span><br><span class="line">        <span class="keyword">while</span>(in &gt;&gt; x)</span><br><span class="line">            hw.push_back(x);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// clear the stream so that input will work for the next student</span></span><br><span class="line">        in.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>grade.h</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_GRADE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_GRADE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">median</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>grade.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"grade.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::domain_error;  <span class="keyword">using</span> <span class="built_in">std</span>::istream;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;        <span class="keyword">using</span> <span class="built_in">std</span>::sort;</span><br><span class="line"></span><br><span class="line"><span class="comment">// grade function 1</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">double</span> midterm, <span class="keyword">double</span> <span class="keyword">final</span>, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;hw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hw.empty())</span><br><span class="line">        <span class="keyword">throw</span> domain_error(<span class="string">"student has done no homework"</span>);</span><br><span class="line">    <span class="keyword">return</span> grade(midterm, <span class="keyword">final</span>, median(hw));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// grade function 2</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">double</span> midterm, <span class="keyword">double</span> <span class="keyword">final</span>, <span class="keyword">double</span> homework)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.2</span>*midterm + <span class="number">0.4</span>*<span class="keyword">final</span> + <span class="number">0.4</span>*homework;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compute the median of vector&lt;double&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">median</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// check whether the vec is empty</span></span><br><span class="line">    <span class="keyword">if</span> (vec.<span class="built_in">begin</span>() == vec.<span class="built_in">end</span>())</span><br><span class="line">        <span class="keyword">throw</span> domain_error(<span class="string">"median of an empty vector"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sort the grades</span></span><br><span class="line">    sort(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// compute the median homework grade</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;::difference_type <span class="built_in">size</span> = vec.<span class="built_in">end</span>() - vec.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;::const_iterator mid = vec.<span class="built_in">begin</span>() + <span class="built_in">size</span>/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">size</span> % <span class="number">2</span> == <span class="number">0</span> ? (*mid + *(mid - <span class="number">1</span>))/<span class="number">2</span> : *mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Inputs</span><br><span class="line"></span><br><span class="line">Robin 90 87 79 88 81 73 45</span><br><span class="line">Brendan 70 69 88 100 91 75 66</span><br><span class="line">Arsenii 99 87 89 88 74 90 70</span><br><span class="line">Liam 83 66 100 76 87 91 78</span><br><span class="line"></span><br><span class="line">Outputs</span><br><span class="line"></span><br><span class="line">Arsenii 89.8</span><br><span class="line">Brendan 76.8</span><br><span class="line">Liam    77.8</span><br><span class="line">Robin   84.4</span><br></pre></td></tr></table></figure>

<p>The program works as same as the original program and delivers same results. </p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Notes</tag>
      </tags>
  </entry>
  <entry>
    <title>Accelerated C++ Solutions to Exercises(Chapter 8 Part 2)</title>
    <url>/2018/04/04/Accelerated-C-Solutions-to-Exercises-Chapter-8-Part-2/</url>
    <content><![CDATA[<h1 id="Exercise-8-3"><a href="#Exercise-8-3" class="headerlink" title="Exercise 8-3"></a>Exercise 8-3</h1><p>As we learned in §4.1.4/58, it can be expensive to return (or pass) a container by value. Yet the median function that we wrote in §8.1.1/140 passes the vector by value. Could we rewrite the median function to operate on iterators instead of passing the vector? If we did so, what would you expect the performance impact to be?</p>
<h2 id="Solution-amp-Results"><a href="#Solution-amp-Results" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>Yes, we can rewrite the median function without passing the vector. See the median funtion template below</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// median function template</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">In</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">In</span>:</span>:<span class="function">value_type <span class="title">median</span><span class="params">(In <span class="built_in">begin</span>, In <span class="built_in">end</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">begin</span> == <span class="built_in">end</span>)</span><br><span class="line">        <span class="keyword">throw</span> domain_error(<span class="string">"median of an empty vector"</span>);</span><br><span class="line"></span><br><span class="line">    sort(<span class="built_in">begin</span>, <span class="built_in">end</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typename</span> In::difference_type <span class="built_in">size</span> = <span class="built_in">end</span> - <span class="built_in">begin</span>;</span><br><span class="line">    In mid = <span class="built_in">begin</span> + <span class="built_in">size</span>/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">size</span> % <span class="number">2</span> == <span class="number">0</span> ? (*mid + *(mid - <span class="number">1</span>))/<span class="number">2</span> : *mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The type parameter of the function template is <strong>In</strong> which will be infered from two arguments, i.e. two iterators that denote the range of a sequence. In addition, The <strong>Iterator::value_type</strong> gives the type of the element the iterator can point to. Therefore, we can set the return type using</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typename In::value_type</span><br></pre></td></tr></table></figure>
<p>If the container is <strong>vector<double></strong>, this expression is equivalent to</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vector&lt;double&gt;::iterator::value_type</span><br></pre></td></tr></table></figure>
<p>In the original version, all computations are based on values of type <strong>size_type</strong>. But now we don’t have such information anymore. Instead we can do computations with iterators. Firstly, we checks whether the container is empty using <strong>begin == end</strong>. The <strong>sort</strong> function is applied as same as that in the original version. Then we get the “size” of the container using <strong>end - begin</strong>, which gives the distance between the first element and one past the last elements. The result of such computation has type <strong>difference_type</strong> which is in fact a signed integer value. </p>
<p>Once we have the “size”, we can get the position of the mid point. Finally we can compute the median by accessing elements via dereference operation on iterators. One might wonder that why we get the position of the mid point using <strong>begin + size/2</strong> rather than <strong>(begin + end)/2</strong>? This is because iterators doesn’t support additive operation between two iterators, but they (random access iterators) do support additive operation between an iterator and an integer value. </p>
<p>Now let’s perform following test and check what happens:</p>
<p><strong>test program</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;	// to get the declaration of cout, endl</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;	// to get the declaration of vector</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;	// to get the declaration of domain_error</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;	// to get the declaration of sort</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::domain_error;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::sort;</span><br><span class="line"></span><br><span class="line"><span class="comment">// print function template</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">print</span>(<span class="title">T</span> &amp;<span class="title">contianer</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *(contianer.<span class="built_in">begin</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">typename</span> T::const_iterator i = contianer.<span class="built_in">begin</span>() + <span class="number">1</span>; i != contianer.<span class="built_in">end</span>(); ++i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; *i;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// median function template</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">In</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">In</span>:</span>:<span class="function">value_type <span class="title">median</span><span class="params">(In <span class="built_in">begin</span>, In <span class="built_in">end</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">begin</span> == <span class="built_in">end</span>)</span><br><span class="line">        <span class="keyword">throw</span> domain_error(<span class="string">"median of an empty vector"</span>);</span><br><span class="line"></span><br><span class="line">    sort(<span class="built_in">begin</span>, <span class="built_in">end</span>);</span><br><span class="line">    <span class="keyword">typename</span> In::difference_type <span class="built_in">size</span> = <span class="built_in">end</span> - <span class="built_in">begin</span>;</span><br><span class="line">    In mid = <span class="built_in">begin</span> + <span class="built_in">size</span>/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">size</span> % <span class="number">2</span> == <span class="number">0</span> ? (*mid + *(mid - <span class="number">1</span>))/<span class="number">2</span> : *mid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// print a sequence</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; vec&#123;<span class="number">9</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Original sequence: "</span>;</span><br><span class="line">    <span class="built_in">print</span>(vec);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get the median of the original sequence</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The median value is: "</span> &lt;&lt; median(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>()) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// print the new sequence</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Now the sequence becomes: "</span>;</span><br><span class="line">    <span class="built_in">print</span>(vec);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>results</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Original sequence: 9 6 8 3 5 7 1 2</span><br><span class="line">The median value is: 5.5</span><br><span class="line">Now the sequence becomes: 1 2 3 5 6 7 8 9</span><br></pre></td></tr></table></figure>
<p>The results show that we successfully compute the median value but change the original sequence due to operate on the original container directly. This is the cost that calling by reference instead of calling by value. </p>
<h1 id="Exercise-8-4"><a href="#Exercise-8-4" class="headerlink" title="Exercise 8-4"></a>Exercise 8-4</h1><p>Implement the swap function that we used in §8.2.5/148. Why did we call swap rather than exchange the values of *beg and *end directly? Hint: Try it and see.</p>
<h2 id="Solution-amp-Results-1"><a href="#Solution-amp-Results-1" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">swap(*<span class="built_in">begin</span>++, *<span class="built_in">end</span>);</span><br></pre></td></tr></table></figure>
<p>To swap two elements, generally we can write </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">T temp &#x3D; *begin;</span><br><span class="line">*begin &#x3D; *end;</span><br><span class="line">*end &#x3D; x;</span><br><span class="line">++begin;</span><br></pre></td></tr></table></figure>
<p>where <strong>T</strong> is the type of the elements <strong>begin</strong> refers to.<br>Clearly, the key to solution is how to determine <strong>T</strong>. One way is to deduce the type from the varaible automatically using <strong>auto</strong> (or decltype) specifier. Another way is to use <strong>value_type</strong> to get the type of the element the iterator can point to. I tried both two methods and the test program is shown below</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;		// to get the declaration of cout, endl</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;	        // to get the declaration of swap</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;		// to get the declaration of vector</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line"></span><br><span class="line"><span class="comment">// print function template</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">print</span>(<span class="title">T</span> &amp;<span class="title">t</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">typename</span> T::const_iterator i = t.<span class="built_in">begin</span>(); i != t.<span class="built_in">end</span>(); ++i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// original reverse function template</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Bi</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">reverse_ori</span>(<span class="title">Bi</span> <span class="title">begin</span>, <span class="title">Bi</span> <span class="title">end</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">begin</span> != <span class="built_in">end</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        --<span class="built_in">end</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">begin</span> != <span class="built_in">end</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            swap(*<span class="built_in">begin</span>++, *<span class="built_in">end</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// revised reverse function version 1: using auto</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Bi</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">reverse_v1</span>(<span class="title">Bi</span> <span class="title">begin</span>, <span class="title">Bi</span> <span class="title">end</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">begin</span> != <span class="built_in">end</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        --<span class="built_in">end</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">begin</span> != <span class="built_in">end</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> temp = *<span class="built_in">begin</span>;</span><br><span class="line">            *<span class="built_in">begin</span> = *<span class="built_in">end</span>;</span><br><span class="line">            *<span class="built_in">end</span> = temp;</span><br><span class="line">            ++<span class="built_in">begin</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// revised reverse function version 2: using value_type</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Bi</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">reverse_v2</span>(<span class="title">Bi</span> <span class="title">begin</span>, <span class="title">Bi</span> <span class="title">end</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Bi::value_type valueType;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">begin</span> != <span class="built_in">end</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        --<span class="built_in">end</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">begin</span> != <span class="built_in">end</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            valueType temp = *<span class="built_in">begin</span>;</span><br><span class="line">            *<span class="built_in">begin</span> = *<span class="built_in">end</span>;</span><br><span class="line">            *<span class="built_in">end</span> = temp;</span><br><span class="line">            ++<span class="built_in">begin</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reverse</span></span><br><span class="line">    reverse_ori(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">print</span>(vec);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reverse again</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    reverse_v1(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">print</span>(vec);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reverse again</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    reverse_v2(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">print</span>(vec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This program gives following outputs</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">9</span><br><span class="line">8</span><br><span class="line">7</span><br><span class="line">6</span><br><span class="line">5</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line"></span><br><span class="line">10</span><br><span class="line">9</span><br><span class="line">8</span><br><span class="line">7</span><br><span class="line">6</span><br><span class="line">5</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>We have seen that both three method works fine, but why we use <strong>swap</strong>? The major limitation of other two methods is that they both copies objects to and from a variable, which may be not allowed for some highlevel objects. Also, it is not inefficient to do if we can avoid performing copies. The sandard <strong>swap</strong> algorithm is also an template and hence can determine the elements type automatically. As far as I know, it doesn’t rely on such <strong>temp</strong> variable as other two methods. I’ll give more explanations about <strong>swap</strong> once I know how exactly it works. </p>
<h1 id="Exercise-8-5"><a href="#Exercise-8-5" class="headerlink" title="Exercise 8-5"></a>Exercise 8-5</h1><p>Reimplement the gen_sentence and xref functions from Chapter 7 to use output iterators rather than writing their output directly to a vector<string> . Test these new versions by writing programs that attach the output iterator directly to the standard output,and by storing the results in a list<string> and a vector<string>.</p>
<h2 id="Solution-amp-Results-2"><a href="#Solution-amp-Results-2" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>To be updated. </p>
<h1 id="Exercise-8-6"><a href="#Exercise-8-6" class="headerlink" title="Exercise 8-6"></a>Exercise 8-6</h1><p>Suppose that m has type map&lt;int, string&gt; , and that we encounter a call to copy(m.begin(), m.end(), back_inserter(x)). What can we say about the type of x ? What if the call were copy(x.begin(), x.end(), back_inserter(m)) instead?</p>
<h2 id="Solution-amp-Results-3"><a href="#Solution-amp-Results-3" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">copy(m.<span class="built_in">begin</span>(), m.<span class="built_in">end</span>(), back_inserter(x));</span><br></pre></td></tr></table></figure>
<p>This statement copy all elements of <strong>m</strong> into the destination sequence <strong>x</strong> via <strong>back_inserter</strong>. It is known that <strong>x</strong> should support <strong>push_back</strong> member function. In addition, the elements contained in <strong>m</strong> have type <strong>pair&lt;int, string&gt;</strong>. Therefore, <strong>x</strong> should be a container that has type <strong>c&lt;pair&lt;int, string&gt;&gt;</strong>. Standard contaniers that meet the first condition include <strong>vector, list, deque, string</strong>. But <strong>string</strong> can only store string literals. In summary, I presume that <strong>x</strong> can be</p>
<ol>
<li>vector&lt;pair&lt;int, string&gt;&gt;</li>
<li>list&lt;pair&lt;int, string&gt;&gt;</li>
<li>deque&lt;pair&lt;int, string&gt;&gt;</li>
</ol>
<p>To verify my expectation, I write a test program shown as below:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;		// to get the declaration of cout, endl</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;		// to get the declaration of vector</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;		// to get the declaration of string</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;			// to get the declaration of list</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;		// to get the declaration of deque</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;			// to get the declaration of map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;	        // to get the declaration of copy</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;		// to get the declaration of back_inserter</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;		// to get the declaration of pair</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::copy;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">map</span>;		<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">list</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::pair;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">deque</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::back_inserter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">print</span>(<span class="title">T</span> &amp;<span class="title">t</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">typename</span> T::const_iterator i = t.<span class="built_in">begin</span>(); i != t.<span class="built_in">end</span>(); ++i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i-&gt;first &lt;&lt; <span class="string">' '</span> &lt;&lt; i-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; element;</span><br><span class="line">    <span class="built_in">vector</span>&lt;element&gt; x;</span><br><span class="line">    <span class="built_in">list</span>&lt;element&gt; y;</span><br><span class="line">    <span class="built_in">deque</span>&lt;element&gt; z;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; m&#123;&#123;<span class="number">1</span>, <span class="string">"abc"</span>&#125;, &#123;<span class="number">2</span>, <span class="string">"bcd"</span>&#125;, &#123;<span class="number">3</span>, <span class="string">"def"</span>&#125;, &#123;<span class="number">4</span>, <span class="string">"hig"</span>&#125;, &#123;<span class="number">5</span>, <span class="string">"klm"</span>&#125;&#125;;</span><br><span class="line">    copy(m.<span class="built_in">begin</span>(), m.<span class="built_in">end</span>(), back_inserter(x));</span><br><span class="line">    copy(m.<span class="built_in">begin</span>(), m.<span class="built_in">end</span>(), back_inserter(y));</span><br><span class="line">    copy(m.<span class="built_in">begin</span>(), m.<span class="built_in">end</span>(), back_inserter(z));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(x);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">print</span>(y);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">print</span>(z);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The results show that all these three types of container work fine for the copy algorithm.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 abc</span><br><span class="line">2 bcd</span><br><span class="line">3 def</span><br><span class="line">4 hig</span><br><span class="line">5 klm</span><br><span class="line"></span><br><span class="line">1 abc</span><br><span class="line">2 bcd</span><br><span class="line">3 def</span><br><span class="line">4 hig</span><br><span class="line">5 klm</span><br><span class="line"></span><br><span class="line">1 abc</span><br><span class="line">2 bcd</span><br><span class="line">3 def</span><br><span class="line">4 hig</span><br><span class="line">5 klm</span><br></pre></td></tr></table></figure>

<p>For the second function call</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">copy(x.<span class="built_in">begin</span>(), x.<span class="built_in">end</span>(), back_inserter(m));</span><br></pre></td></tr></table></figure>
<p>I presume it doesn’t work because <strong>map</strong> doesn’t have member function <strong>push_back</strong>. We can correct this function call as</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">copy(x.<span class="built_in">begin</span>(), x.<span class="built_in">end</span>(), inserter(m, m.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>
<p>If we add follow statements to above program</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;element&gt; n&#123;&#123;<span class="number">10</span>, <span class="string">"abcd"</span>&#125;, &#123;<span class="number">20</span>, <span class="string">"bcde"</span>&#125;, &#123;<span class="number">30</span>, <span class="string">"defh"</span>&#125;&#125;;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::iterator it = m.<span class="built_in">end</span>();</span><br><span class="line">copy(n.<span class="built_in">begin</span>(), n.<span class="built_in">end</span>(), inserter(m, it));</span><br><span class="line"><span class="built_in">print</span>(m);</span><br></pre></td></tr></table></figure>
<p>The modified program gives results as expected</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 abc</span><br><span class="line">2 bcd</span><br><span class="line">3 def</span><br><span class="line">4 hig</span><br><span class="line">5 klm</span><br><span class="line">10 abcd</span><br><span class="line">20 bcde</span><br><span class="line">30 defh</span><br></pre></td></tr></table></figure>
<p>Noting that, though we insert at the position where <strong>m.end()</strong> denotes, the new element may not appear starting from the end of the map. This is because that the <strong>map</strong> automatically sorts elements according to the values of <strong>key</strong>s. </p>
<hr>
<h1 id="Exercise-8-7"><a href="#Exercise-8-7" class="headerlink" title="Exercise 8-7"></a>Exercise 8-7</h1><p>Why doesn’t the max function use two template parameters, one for each argument type?</p>
<h2 id="Solution-amp-Results-4"><a href="#Solution-amp-Results-4" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>Let’s write the max function using two template parameters:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">P</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">P</span> <span class="title">max</span>(<span class="title">const</span> <span class="title">T</span>&amp; <span class="title">left</span>, <span class="title">const</span> <span class="title">P</span>&amp; <span class="title">right</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">return</span> left &gt; right ? left : right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The biggest problem is how can we correctly set the return type. There are two types <strong>T</strong> and <strong>P</strong>. If we set return type as <strong>T</strong>, the value returned may has type <strong>P</strong>, and vice versa. Concequently, type coversion happens. However, the result of type conversion depends on the range of the values that the types permit. For example, we call the max function as follows</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">max</span>(<span class="number">3500.9</span>, <span class="string">'a'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>If we set return type <strong>P</strong>, what happens of this program is unknown. </p>
<p>Therefore, such function template is non-practical and may lead to fatal errors. </p>
<hr>
<h1 id="Exercise-8-8"><a href="#Exercise-8-8" class="headerlink" title="Exercise 8-8"></a>Exercise 8-8</h1><p>n the binary_search function in §8.2.6/148, why didn’t we write (begin + end)/ 2 instead of the more complicated begin + (end - begin) /2 ?</p>
<h2 id="Solution-amp-Results-5"><a href="#Solution-amp-Results-5" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>This is because that iterators doesn’t support additive operation between two iterators. For random access iterators, they do support arithmetic operator <strong>+</strong> and <strong>-</strong> between an iterator and an ineger value, e.g.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iterator_i + integer_j</span><br><span class="line">integer_j + iterator_i</span><br><span class="line">iterator_i - integer_j</span><br></pre></td></tr></table></figure>
<p>In addition, they support substracting an iterator from another, e.g.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iterator_i - iterator_j</span><br></pre></td></tr></table></figure>
<p>Such operation yields an value of type <strong>difference_type</strong>, which in fact is an signed integer. Therefore, it is legal to do</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">begin</span> + (<span class="built_in">end</span> - <span class="built_in">begin</span>) /<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>as such expression is in fact the additive operation between an iterator and an iteger value.</p>
<p>But it makes no sence to do</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(<span class="built_in">begin</span> + <span class="built_in">end</span>)/ <span class="number">2</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>Koenig, A. and Moo, B.E., 2000. Accelerated C++.</p>
<p>Lippman, S.B., Lajoie, J. and Moo, B.E., 2013. C++ Primer, 5th edt.</p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Accelerated C++ Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title>Accelerated C++ Solutions to Exercises(Chapter 8 Part 1)</title>
    <url>/2018/04/03/Accelerated-C-Solutions-to-Exercises-Chapter-8/</url>
    <content><![CDATA[<h1 id="Exercise-8-0"><a href="#Exercise-8-0" class="headerlink" title="Exercise 8-0"></a>Exercise 8-0</h1><p>Compile, execute, and test the programs in this chapter.</p>
<h2 id="Solution-amp-Results"><a href="#Solution-amp-Results" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>Please find the programs and analysis on <a href="http://quanttour.com/02/04/2018/C-Writing-generic-functions/" target="_blank" rel="noopener">Writing generic functions</a>. </p>
<h1 id="Exercise-8-1"><a href="#Exercise-8-1" class="headerlink" title="Exercise 8-1"></a>Exercise 8-1</h1><p>Note that the various analysis functions we wrote in §6.2/110 share the same behavior; they differ only in terms of the functions they call to calculate the final grade. Write a template function, parameterized by the type of the grading function, and use that function to evaluate the grading schemes.</p>
<h2 id="Solution-amp-Results-1"><a href="#Solution-amp-Results-1" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>To parameterize the type of the grading function, I define the type parameter of the analysis function template as <strong>Fun</strong>. Then what we need to do is replacing all revelant functions with <strong>f</strong> which is a variable that has type <strong>Fun</strong>. See the function template below:</p>
<p>New <strong>grades_analysis.h</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_GRADES_ANALYSIS_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_GRADES_ANALYSIS_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"gradingSchemes.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Fun</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">double</span> <span class="title">analysis</span>(<span class="title">const</span> <span class="title">std</span>:</span>:<span class="built_in">vector</span>&lt;Student_info&gt; &amp;students, Fun &amp;f)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; grades;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">std</span>::transform(students.<span class="built_in">begin</span>(), students.<span class="built_in">end</span>(), <span class="built_in">std</span>::back_inserter(grades), f);</span><br><span class="line">	<span class="keyword">return</span> median(grades);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* GUARD_GRADES_ANALYSIS_H */</span></span></span><br></pre></td></tr></table></figure>
<p>The next step is to rewrite the <strong>write_analysis</strong> function as the original one defines a parameter to take various analysis functions. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_WRITE_ANALYSIS_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_WRITE_ANALYSIS_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"grades_analysis.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Fun</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">write_analysis</span>(<span class="title">std</span>:</span>:ostream &amp;out, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name, Fun &amp;f,</span><br><span class="line">		<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Student_info&gt; &amp;did,</span><br><span class="line">		<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Student_info&gt; &amp;didnt)</span><br><span class="line">&#123;</span><br><span class="line">    out &lt;&lt; name &lt;&lt; <span class="string">": median(did) = "</span> &lt;&lt; analysis(did, f)</span><br><span class="line">        &lt;&lt; <span class="string">": median(didnt) = "</span> &lt;&lt; analysis(didnt, f) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* GUARD_WRITE_ANALYSIS_H */</span></span></span><br></pre></td></tr></table></figure>

<p>Its necessary to put both declaration and definition into the header file for both two function templates due to the fact that they are required to be visible to the compiler in the point of instantiation.</p>
<p>Now we can pass different grading functions directly to the <strong>write_analysis</strong> function to generate analysis reports. </p>
<p><strong>mainfunction.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;			// to get the declaration of cin, cout, endl</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;			// to get the declaration of vector</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span>		<span class="comment">// to get the declaration of Student_info</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"did_all_hw.h"</span>			<span class="comment">// to get the declatation of the predicate on students' records</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"write_analysis.h"</span>		<span class="comment">// to get the declaration of write_analysis function</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"gradingSchemes.h"</span>		<span class="comment">// to get the declarations of various grading functions</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;		<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// students who did and didn't do all their homework</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;Student_info&gt; did, didnt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read the student records and partition time</span></span><br><span class="line">    Student_info student;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">read</span>(<span class="built_in">cin</span>, student))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(did_all_hw(student))</span><br><span class="line">            did.push_back(student);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            didnt.push_back(student);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// verify thatthe analyses will show us something</span></span><br><span class="line">    <span class="keyword">if</span>(did.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"No student did all the homework!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(didnt.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Every student did all the homework!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// do the analysis</span></span><br><span class="line">    write_analysis(<span class="built_in">cout</span>, <span class="string">"median"</span>,  median_grade_aux, did, didnt);</span><br><span class="line">    write_analysis(<span class="built_in">cout</span>, <span class="string">"average"</span>, average_grade, did, didnt);</span><br><span class="line">    write_analysis(<span class="built_in">cout</span>, <span class="string">"median of homework turned in"</span>, optimistic_median, did, didnt);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Other files are keep unchanged and can be found below. </p>
<p><strong>did_all_hw.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;		// to get the declaration of find</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span>	<span class="comment">// to get the declaration of Student_info</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"did_all_hw.h"</span>		<span class="comment">// to get the declaration of did_all_hw itself</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">find</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">did_all_hw</span><span class="params">(<span class="keyword">const</span> Student_info &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="built_in">find</span>(s.homework.<span class="built_in">begin</span>(), s.homework.<span class="built_in">end</span>(), <span class="number">0</span>)) == s.homework.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>did_all_hw.h</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_DID_ALL_HW_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_DID_ALL_HW_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">did_all_hw</span><span class="params">(<span class="keyword">const</span> Student_info &amp;s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* GUARD_DID_ALL_HW_H */</span></span></span><br></pre></td></tr></table></figure>
<p><strong>gradingSchemes.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;		// to get the declaration of remove_copy</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;		// to get the declaration of accumulate</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;		// to get the declaration of domain_error</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;		// to get the declaration of vector</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span>	<span class="comment">// to get the declaration of Student_info</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"gradingSchemes.h"</span>     <span class="comment">// to get the declaration of all functions here to keep consistent</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::domain_error;  <span class="keyword">using</span> <span class="built_in">std</span>::istream;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;        <span class="keyword">using</span> <span class="built_in">std</span>::sort;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::accumulate;</span><br><span class="line"></span><br><span class="line"><span class="comment">// final grade function returns weighted average of midterm exam grade,</span></span><br><span class="line"><span class="comment">// final exam grade, and homework grade which will be computed</span></span><br><span class="line"><span class="comment">// using different methods depending on grading schemes</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">double</span> midterm, <span class="keyword">double</span> <span class="keyword">final</span>, <span class="keyword">double</span> homework)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.2</span>*midterm + <span class="number">0.4</span>*<span class="keyword">final</span> + <span class="number">0.4</span>*homework;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fundermental functions 1: returns the median value of vector&lt;double&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">median</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// get the size of the vector</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;::size_type vec_size;</span><br><span class="line">    vec_size <span class="built_in">size</span> = vec.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check whether the empty is empty</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span> == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> domain_error(<span class="string">"median of an empty vector"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sort the grades</span></span><br><span class="line">    sort(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// compute the median homework grade</span></span><br><span class="line">    vec_size mid = <span class="built_in">size</span>/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">size</span> % <span class="number">2</span> == <span class="number">0</span> ? (vec[mid] + vec[mid - <span class="number">1</span>])/<span class="number">2</span> : vec[mid];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fundermental functions 2: returns the average value of vector&lt;double&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">average</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// check whether the empty is empty</span></span><br><span class="line">    <span class="keyword">if</span> (v.empty())</span><br><span class="line">    &#123;   <span class="keyword">throw</span> domain_error(<span class="string">"average of an empty vector"</span>);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> accumulate(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">0.0</span>) / v.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// grading scheme 1: final grade is based on the median homework grade</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">median_grade</span><span class="params">(<span class="keyword">const</span> Student_info &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> median_grade(s.midterm, s.<span class="keyword">final</span>, s.homework);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// grading scheme 1: overloaded median_grade function</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">median_grade</span><span class="params">(<span class="keyword">double</span> midterm, <span class="keyword">double</span> <span class="keyword">final</span>, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;hw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hw.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> domain_error(<span class="string">"student has done no homework"</span>);</span><br><span class="line">    <span class="keyword">return</span> grade(midterm, <span class="keyword">final</span>, median(hw));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// grading scheme 1: auxiliary median_grade function</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">median_grade_aux</span><span class="params">(<span class="keyword">const</span> Student_info &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> median_grade(s);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (domain_error)&#123;</span><br><span class="line">        <span class="comment">// students who did no homework at all, get 0 homework grade</span></span><br><span class="line">        <span class="keyword">return</span> grade(s.midterm, s.<span class="keyword">final</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// grading scheme 2: final grade is based on average homework grades</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">average_grade</span><span class="params">(<span class="keyword">const</span> Student_info &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> grade(s.midterm, s.<span class="keyword">final</span>, average(s.homework));</span><br><span class="line">    &#125;<span class="keyword">catch</span> (domain_error)&#123;</span><br><span class="line">        <span class="comment">// students who did no homework at all, get 0 homework grade</span></span><br><span class="line">        <span class="keyword">return</span> grade(s.midterm, s.<span class="keyword">final</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// grading scheme 3: final grade is based on median of the completed homework grades,</span></span><br><span class="line"><span class="comment">// and students who did no homework at all will get 0 homework grade</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">optimistic_median</span><span class="params">(<span class="keyword">const</span> Student_info &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; nonzero;</span><br><span class="line">    remove_copy(s.homework.<span class="built_in">begin</span>(), s.homework.<span class="built_in">end</span>(), back_inserter(nonzero), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(nonzero.empty())</span><br><span class="line">        <span class="keyword">return</span> grade(s.midterm, s.<span class="keyword">final</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> grade(s.midterm, s.<span class="keyword">final</span>, median(nonzero));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>gradingSchemes.h</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_GRADING_SCHEMES_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_GRADING_SCHEMES_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">double</span> midterm, <span class="keyword">double</span> <span class="keyword">final</span>, <span class="keyword">double</span> homework)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">median</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; vec)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">average</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;v)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">median_grade</span><span class="params">(<span class="keyword">const</span> Student_info &amp;s)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">median_grade</span><span class="params">(<span class="keyword">double</span> midterm, <span class="keyword">double</span> <span class="keyword">final</span>, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;hw)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">median_grade_aux</span><span class="params">(<span class="keyword">const</span> Student_info &amp;s)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">average_grade</span><span class="params">(<span class="keyword">const</span> Student_info &amp;s)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">optimistic_median</span><span class="params">(<span class="keyword">const</span> Student_info &amp;s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* GUARD_GRADING_SCHEMES_H */</span></span></span><br></pre></td></tr></table></figure>

<p><strong>Student_info.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>; 	<span class="keyword">using</span> <span class="built_in">std</span>::istream;</span><br><span class="line"></span><br><span class="line"><span class="comment">// argument to the function sort</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> Student_info &amp;x, <span class="keyword">const</span> Student_info &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.name &lt; y.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// read the info</span></span><br><span class="line"><span class="function">istream &amp; <span class="title">read</span><span class="params">(istream &amp;is, Student_info &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// reads and store the student's name, midterm and final exam grades</span></span><br><span class="line">    is &gt;&gt; s.name &gt;&gt; s.midterm &gt;&gt; s.<span class="keyword">final</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reads and store all homework grades</span></span><br><span class="line">    read_hw(is, s.homework);</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// read all homework grades</span></span><br><span class="line"><span class="function">istream &amp; <span class="title">read_hw</span><span class="params">(istream &amp;in, <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;hw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (in)&#123;</span><br><span class="line">        <span class="comment">//get rid of previous contents</span></span><br><span class="line">        hw.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// read homework grades</span></span><br><span class="line">        <span class="keyword">double</span> x;</span><br><span class="line">        <span class="keyword">while</span>(in &gt;&gt; x)</span><br><span class="line">            hw.push_back(x);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// clear the stream so that input will work for the next student</span></span><br><span class="line">        in.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Student_info.h</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_Student_info</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_Student_info</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student_info</span>&#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">double</span> midterm, <span class="keyword">final</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; homework;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> Student_info &amp;, <span class="keyword">const</span> Student_info &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::istream &amp; <span class="title">read</span><span class="params">(<span class="built_in">std</span>::istream &amp;, Student_info &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::istream &amp; <span class="title">read_hw</span><span class="params">(<span class="built_in">std</span>::istream &amp;, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>I tested this program using the same inputs as we did in <a href="http://quanttour.com/22/03/2018/C-Using-library-algorithms-Part-2/" target="_blank" rel="noopener">A simple test</a>.  It gives the same results as the original progam</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">median: median(did) &#x3D; 46.1475: median(didnt) &#x3D; 42.9273</span><br><span class="line">average: median(did) &#x3D; 45.4202: median(didnt) &#x3D; 44.3273</span><br><span class="line">median of homework turned in: median(did) &#x3D; 46.1475: median(didnt) &#x3D; 52.1273</span><br><span class="line">&#96;&#96;&#96;  </span><br><span class="line"></span><br><span class="line"># Exercise 8-2</span><br><span class="line">Implement the following library algorithms, which we used in Chapter 6 and describedin §6.5&#x2F;121. Specify what kinds of iterators they require. Try to minimize the number of distinct iterator operations that each function requires. After you have finished your implementation, see §B.3&#x2F;321 to see how well you did.</span><br></pre></td></tr></table></figure>
<p>equal(b, e, d)                 search(b, e, b2, e2)<br>find(b, e, t)                  find_if(b, e, p)<br>copy(b, e, d)                  remove_copy(b, e, d, t)<br>remove_copy_if(b, e, d, p)     remove(b, e, t)<br>transform(b, e, d, f)          partition(b, e, p)<br>accumulate(b, e, t)</p>
<pre><code>
## Solution &amp; Results
To be updated. 


</code></pre>]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Accelerated C++ Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ - Writing generic functions</title>
    <url>/2018/04/02/C-Writing-generic-functions/</url>
    <content><![CDATA[<h1 id="Generic-function-an-example"><a href="#Generic-function-an-example" class="headerlink" title="Generic function - an example"></a>Generic function - an example</h1><p><em>Generic functions are functions written in a way that is independent of any particular type. When we use a generic program, we supply the type(s) or value(s) on which that instance of the program will operate</em>(Lippman etc. 2012). In C++, we can create generic functions by defining <strong>template function</strong>s, allowing writing a single definition for a family of functions or types that behave similarly but have different types of paratmters. The only difference can be summarized as parameters, namely, <strong>template parameters</strong>. Take the median function as an example, its template can be defined as follows.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">median</span>(<span class="title">vector</span>&lt;T&gt; <span class="title">v</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="built_in">vector</span>&lt;T&gt;::size_type vec_sz;</span><br><span class="line"></span><br><span class="line">    vec_sz <span class="built_in">size</span> = v.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">size</span> == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> domain_error(<span class="string">"median of an empty vector"</span>);</span><br><span class="line"></span><br><span class="line">    sort(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    vec_sz mid = <span class="built_in">size</span>/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">size</span> % <span class="number">2</span> ? (v[mid] + v[mid - <span class="number">1</span>])/<span class="number">2</span> : v[mid];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>From the definition, we observe</p>
<ol>
<li>A <strong>template</strong> starts with keyword <strong>template</strong> followed by <strong>type parameter(s)</strong> enclosed by a pair of angle brackets. </li>
<li><strong>type parameter(s)</strong> define the names that can be used within the scope of the function. They refer to types, not variables. In other words, the types of template parameters can be regarded as variables that have types specified by <strong>type parameters(s)</strong>. </li>
<li><strong>type parameter(s)</strong> are specified following the keyword <strong>class</strong> or <strong>typename</strong>. </li>
<li>the <strong>template</strong> tells implementation that <strong>vector<T>::size_type</strong> is the name of a type by adding keyword <strong>typename</strong> before. </li>
</ol>
<p>When we call <strong>median</strong> and pass a <strong>template argument</strong> vector<int>, the implementation will create and compile an instance of the function as if the function <strong>median(vector<int>)</strong>. This is so called <strong>template instantiation</strong>. But how is the template compiled?</p>
<p>When the compiler encounters the definition of a template, it doesn’t generate code. It generates only when the template is instantiated. Remembering that when we call a function, we need to supply only its declaration. But if we want to call the template, we need to supply not only its declaration but also its definition in order to instantiate it. Therefore, the header file of a template generally includes the source file also via a <strong>#include</strong> or directly. I found an article <a href="https://www.codeproject.com/Articles/3515/How-To-Organize-Template-Source-Code" target="_blank" rel="noopener">How To Organize Template Source Code</a>, where gives detailed explinations on how to organize template source code and three solutions.</p>
<p>Due to the feature of generating code during instantiation, compilation errors may occur during three stages:</p>
<ol>
<li>the first stage is when we compile the template itself. But the compiler can only detect some syntax errors like forgetting a semicolon, misspelling a variable name etc..</li>
<li>the second stage is when we use a template, before it is instantiated. The compiler typically will check that whether the number of the arguments is appropriate, whether two arguments that are supposed to have the same type do so.</li>
<li>the type-related errors mostly occurs during the third stage when the template is instantiated. Though implementations manage instantiation on their own ways, the type-related errors may be reported at link time due to that implementations assume the type is possibly defined in other unit and hence leave it to linker to resolve. </li>
</ol>
<p>In fact, we have applied many templates in previous programs, such as <strong>vector</strong> and <strong>list</strong>, and all standard library algorithms. </p>
<h1 id="Algorithms-and-iterators"><a href="#Algorithms-and-iterators" class="headerlink" title="Algorithms and iterators"></a>Algorithms and iterators</h1><p>As shown in above example, the template is type independent. However, it is also clear that the function to instantiate requires its argument supporting all operations included in the function. In above case, the types stored in the vectors that are passed to the median function must support addition and division. </p>
<p>The standard algorithms are not limited by the type of containers and obviously are data-structure independent function templates. It is known that the parameters taken by algorithms includes iterators and others. This implies that iterators to pass should support certain operations used inside of the algorithms. But we also know that some containers may support operations that others do not. For example, <strong>vector</strong> support random access elements via iterators while <strong>list</strong> doesn’t. Therefore, it is important  to restrict the right of iterators depending on operations that an algorithm include and operations different containers support. For this reason, the library defines five <strong>iterator categories</strong> with specifying the collection of iterator operations for each category. By doing so, we know exactly what effect of an algorithm can have on an container and which container can use which algorithms. </p>
<h2 id="Sequential-read-only-access"><a href="#Sequential-read-only-access" class="headerlink" title="Sequential read-only access"></a>Sequential read-only access</h2><p>Some algorithms only require iterators that can access elements sequentially. For example, the <strong>find</strong> algorithm:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">In</span>, <span class="title">class</span> <span class="title">X</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">In</span> <span class="title">find</span>(<span class="title">In</span> <span class="title">beg</span>, <span class="title">In</span> <span class="title">end</span>, <span class="title">const</span> <span class="title">X</span> &amp;<span class="title">x</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">begin</span> != <span class="built_in">end</span> &amp;&amp; *<span class="built_in">begin</span> != x)</span><br><span class="line">        ++<span class="built_in">begin</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">begin</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The iterators of type <strong>In</strong> access elements sequentially via<br>operations <strong><em>*</em></strong>, <strong>++</strong>. Also, they can be compared using <strong>!=</strong>. Alternatively,</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">In</span>, <span class="title">class</span> <span class="title">X</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">In</span> <span class="title">find</span>(<span class="title">In</span> <span class="title">begin</span>, <span class="title">In</span> <span class="title">end</span>, <span class="title">const</span> <span class="title">X</span> &amp;<span class="title">x</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">begin</span> == <span class="built_in">end</span> || *<span class="built_in">begin</span> == x)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">begin</span>;</span><br><span class="line">    <span class="built_in">begin</span>++;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">find</span>(<span class="built_in">begin</span>, <span class="built_in">end</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This version of <strong>find</strong> uses another strategy, recursively calling itself. We have observed that the iterators may also need to support operations <strong>++</strong>(postfix) and <strong>==</strong>. </p>
<p>Furthermore, the iterators ought to support member access via <strong>-&gt;</strong>, e.g. it-&gt;first. It has the same effect as <strong>(*it).first</strong>. </p>
<p>In summary, iterators that offers sequential read-only access to elements of a container should supports <strong>++</strong>(both prefix and postfix), <strong>==</strong> and <strong>!=</strong>, <strong><em>*</em></strong> and <strong>-&gt;</strong>. Such iterators are named as <strong>input iterators</strong>. All standard container meet the requirements of <strong>input iterator</strong>.</p>
<h2 id="Sequential-write-only-access"><a href="#Sequential-write-only-access" class="headerlink" title="Sequential write-only access"></a>Sequential write-only access</h2><p>Some algorithms may require write elements of a sequence via iterators, for example</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">In</span>, <span class="title">class</span> <span class="title">Out</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Out</span> <span class="title">copy</span>(<span class="title">In</span> <span class="title">begin</span>, <span class="title">In</span> <span class="title">end</span>, <span class="title">Out</span> <span class="title">dest</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">begin</span> != <span class="built_in">end</span>)</span><br><span class="line">        *dest++ = *<span class="built_in">begin</span>++;</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The <strong>copy</strong> algorithm takes three iterators, the first two of which denote the range of a sequence to copy while the third iterator denotes the initial position of the destination. The iterators of type <strong>In</strong> offer sequential read-only access to elements and hence are input iterators. The type <strong>Out</strong> gives the third iterator the ability to write elements via <strong>*dest =</strong> and <strong>dest++</strong>. As with the <strong>find</strong> algorithm above, such iterators should also support <strong>++dest</strong>. </p>
<p>The fact that iterators of type <strong>Out</strong> are used for output only also implies that </p>
<ol>
<li><p>each element pointed by the iterator is written a value only once and then the iterator is incremented.</p>
</li>
<li><p>the iterator can not be incremented twice without assignments to the elements that it refers to. </p>
</li>
</ol>
<p>In summary, such iterators are <strong>output iterators</strong>. All standard containers as well as <strong>back_inserter</strong> meet the requirements of <strong>output iterator</strong>. Noting that in this function, the left side deference operator is used to write to the underlying elements while the right side deference operator is used to read the underlying elements only. </p>
<h2 id="Sequential-read-write-access"><a href="#Sequential-read-write-access" class="headerlink" title="Sequential read-write access"></a>Sequential read-write access</h2><p>There is another situation that we want to both read and write the elements of a sequence, but only sequentially. For example</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">For</span>, <span class="title">class</span> <span class="title">X</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">replace</span>(<span class="title">For</span> <span class="title">beg</span>, <span class="title">For</span> <span class="title">end</span>, <span class="title">const</span> <span class="title">X</span> &amp;<span class="title">x</span>, <span class="title">const</span> <span class="title">X</span> &amp;<span class="title">y</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">while</span> (beg != <span class="built_in">end</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (*beg == x)</span><br><span class="line">            *beg = y;</span><br><span class="line">        ++beg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The <strong>replace</strong> algorithm examines each element in the range [beg, end) and assigns value y to those elements that are equal to x. Apparently, iterators of type <strong>For</strong> should support all operations supported by an input operator as well as an output operator. Moreover, they can read and write the same elements multiple times. Such a type is a <strong>forward iterator</strong>. Some operations that such a type need to support are</p>
<ol>
<li><strong>*it</strong> (for both reading and writing)</li>
<li><strong>++</strong> (both prefix and postfix)</li>
<li><strong>== and !=</strong></li>
<li><strong>-&gt;</strong></li>
</ol>
<p>All standard containers meet the requirements of <strong>forward iterator</strong>.</p>
<h2 id="Reversible-access"><a href="#Reversible-access" class="headerlink" title="Reversible access"></a>Reversible access</h2><p>All above iterators access elements in a container in a forward sequence. But some functions may require get elements in reverse order, for example</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Bi</span>&gt; <span class="title">void</span> <span class="title">reverse</span>(<span class="title">Bi</span> <span class="title">begin</span>, <span class="title">Bi</span> <span class="title">end</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">begin</span> != <span class="built_in">end</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        --<span class="built_in">end</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">begin</span> != <span class="built_in">end</span>)</span><br><span class="line">            swap (*<span class="built_in">begin</span>++, *<span class="built_in">end</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The iterators of type <strong>Bi</strong> moves backward from <strong>end</strong> to <strong>begin</strong> via <strong>–</strong>. Then, the <strong>swap</strong> algorithm exchanges values of two elements. Such iterators meet all requirements of <strong>forward iterator</strong> and support <strong>–</strong> (both prefix and postfix). They are <strong>bidirectional iterators</strong>. All standard containers meet the requirements of <strong>bidirectional iterators</strong>.</p>
<h2 id="Random-access"><a href="#Random-access" class="headerlink" title="Random access"></a>Random access</h2><p>All above iterators access elements in a forward or backward sequence, however, some functions need to access elements starting from arbitrary positions. For example</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Ran</span>, <span class="title">class</span> <span class="title">X</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">binary_search</span>(<span class="title">Ran</span> <span class="title">begin</span>, <span class="title">Ran</span> <span class="title">end</span>, <span class="title">const</span> <span class="title">X</span> &amp;<span class="title">x</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">begin</span> &lt; <span class="built_in">end</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// find the midpoint of the range</span></span><br><span class="line">        Ran mid = <span class="built_in">begin</span> + (<span class="built_in">end</span> - <span class="built_in">begin</span>)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// see which part of the range contains x; keep looking only in that part</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt; *mid)</span><br><span class="line">            <span class="built_in">end</span> = mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (*mid &lt;x)</span><br><span class="line">            <span class="built_in">begin</span> = mid + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if we got here, then *mid == x so we are done</span></span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The <strong>binary search</strong> algorithm looks for a particular element in a sorted container. It always starts to search from the middle point of a sequence, which relies on the ability to do arithmetic on iterators. Such an iterator is called a <strong>random access iterator</strong>. Specifically, if <strong>p</strong> and <strong>q</strong> are random access iterators, they should support all operations that a <strong>bidirectional iterator</strong> supports, as well as following arithmetic operations</p>
<ol>
<li><strong>p + n, p - n, n + p</strong></li>
<li><strong>p-q</strong></li>
<li><strong>p[n]</strong> (equivalent to *(p + n)) </li>
<li><strong>p &gt; q, p &lt; q, p &lt;= q, p &gt;= q</strong></li>
</ol>
<p>Standard <strong>sort</strong> algorithm requires random-access iterators. Therefore, <strong>vector</strong> and <strong>string</strong> can use standard <strong>sort</strong> function as their iterators are <strong>random-access iterators</strong>. <strong>list</strong> iterators are not <strong>random-access iterators</strong> and hence <strong>list</strong> defines its own member <strong>sort</strong> instead of using the standard <strong>sort</strong>. </p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>From above analysis, we know that <strong>forward, bidirectional and random-access iterators</strong> are also valid <strong>input iterators</strong> as they all meet the requirements of <strong>input iterator</strong>. In addition, all <strong>forward, bidirectional and random-access iterators</strong> that are not constant iterators are also valid <strong>output iterators</strong>. </p>
<p>From the perspective of containers, different category of iterator makes some containers distinct, for example, <strong>list</strong> iterators are <strong>bidirectional iterators</strong>, <strong>forward_list</strong> iterators are <strong>forward_iterators</strong>, <strong>vector</strong> and <strong>string</strong> iterators are <strong>random access iterators</strong>.</p>
<p>But why we need <strong>input/output iterator</strong>? One reason is that not all iterators are assicoated with containers. For example, <strong>back_inserter()</strong> is an iterator that meet and only meet the requirements of <strong>output iterator</strong>. </p>
<p>Another typical example is that the standard library provides iterators that can be bound to input and output streams, namely, <strong>istream_iterator</strong> and <strong>ostream_iterator</strong>.<br>Apparently, <strong>istream_iterator</strong> is <strong>input iterator</strong> that allows us to read successive elements from an input stream.<br><strong>ostream_iterator</strong> is <strong>output iterator</strong> that allows us to write sequentially to an output stream.  </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="comment">// read ints from the standard input and append them to v</span></span><br><span class="line">copy(istream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cin</span>), istream_iterator&lt;<span class="keyword">int</span>&gt;(), back_insert(v));</span><br></pre></td></tr></table></figure>
<p>This example shows that the first <strong>istream_iterator</strong> is bound to <strong>cin</strong> and expects to read values of type <strong>int</strong>. But the second <strong>istream_iterator</strong> is not bound to any file.<br>This is because istream_iterator type has a default value with a sepcial property such that any <strong>istream_iterator</strong> that has reached end-of-file or is an error state will appear to be equal to the default value. Therefore, we can use the default value of a <strong>istream_iterator</strong> together with the first input iterator to denote the sequence in the input stream. </p>
<p>Similarly, we can use <strong>ostream_iterator</strong> to write elements to an output stream. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// write the elements of v each separated from the other by a space</span></span><br><span class="line">copy(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), ostream_iterator&lt;<span class="keyword">int</span>&gt; (<span class="built_in">cout</span>, <span class="string">" "</span>));</span><br></pre></td></tr></table></figure>
<p>This statement uses <strong>copy</strong> algorithm to copy the vector <strong>v</strong> onto the standard output. <strong>ostream_iterator</strong> is bound to <strong>cout</strong> with an additional argument, that is, a space in this case. This additional argument specifies a value to be written after each element and typically is a string literal. </p>
<h1 id="Rewrite-the-split-function"><a href="#Rewrite-the-split-function" class="headerlink" title="Rewrite the split function"></a>Rewrite the split function</h1><p>Now we apply the new knowledge learned above to rewrite the <strong>split</strong> function as a template such that it is data-structure independent. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Out</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">split</span>(<span class="title">const</span> <span class="title">string</span> &amp;<span class="title">str</span>, <span class="title">Out</span> <span class="title">os</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">string</span>::const_iterator iter;</span><br><span class="line"></span><br><span class="line">    iter i = str.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span>(i != str.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ignore leading spaces</span></span><br><span class="line">        i = find_if(i, str.<span class="built_in">end</span>(), not_space);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// find end of next word</span></span><br><span class="line">        iter j = find_if(i, str.<span class="built_in">end</span>(), space);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// copy the characters in [i,j)</span></span><br><span class="line">        <span class="keyword">if</span>(i != str.<span class="built_in">end</span>())</span><br><span class="line">            *os++ = <span class="built_in">string</span>(i, j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This function has return type <strong>void</strong>, i.e. nothing to return. If we want to store each word contained in a line of inputs into a vector<string>, we just need to pass an output iterator. This is also true for a list<string>. For example</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// list&lt;string&gt; words;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; words;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> <span class="built_in">line</span>;</span><br><span class="line">    <span class="keyword">while</span>(getline(<span class="built_in">cin</span>, <span class="built_in">line</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        split(<span class="built_in">line</span>, back_inserter(words));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::const_iterator it = words.<span class="built_in">begin</span>(); it != words.<span class="built_in">end</span>(); ++it)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Alternatively, we may write all words onto the standard output directly. I take this as an exercise and present a complete program below. </p>
<p><strong>mainfunction.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"split.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>; 		<span class="keyword">using</span> <span class="built_in">std</span>::ostream_iterator;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>; 		<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;		<span class="keyword">using</span> <span class="built_in">std</span>::back_inserter;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> <span class="built_in">line</span>;</span><br><span class="line">    <span class="keyword">while</span> (getline(<span class="built_in">cin</span>, <span class="built_in">line</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        split(<span class="built_in">line</span>, ostream_iterator&lt;<span class="built_in">string</span>&gt;(<span class="built_in">cout</span>, <span class="string">"\n"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>split.h</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_SPLIT_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_SPLIT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// true if the argument is whitespace, false otherwise</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">space</span><span class="params">(<span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">isspace</span>(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// false is the argument is whitespace, true otherwise</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">not_space</span><span class="params">(<span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !<span class="built_in">isspace</span>(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// template declaration and definition</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Out</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">split</span>(<span class="title">const</span> <span class="title">std</span>:</span>:<span class="built_in">string</span> &amp;str, Out os)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">string</span>::const_iterator iter;</span><br><span class="line"></span><br><span class="line">    iter i = str.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span>(i != str.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ignore leading spaces</span></span><br><span class="line">        i = <span class="built_in">std</span>::find_if(i, str.<span class="built_in">end</span>(), not_space);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// find end of next word</span></span><br><span class="line">        iter j = <span class="built_in">std</span>::find_if(i, str.<span class="built_in">end</span>(), space);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// copy the characters in [i,j)</span></span><br><span class="line">        <span class="keyword">if</span>(i != str.<span class="built_in">end</span>())</span><br><span class="line">            *os++ = <span class="built_in">std</span>::<span class="built_in">string</span>(i, j);</span><br><span class="line">    i = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* GUARD_SPLIT_H */</span></span></span><br></pre></td></tr></table></figure>

<p>Noting that I didn’t separate the definition and declaration of the split template to make them be visible to compiler in the point of instantiation.</p>
<p>Let’s type some words</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">what </span><br><span class="line">a </span><br><span class="line">beautiful </span><br><span class="line">name</span><br></pre></td></tr></table></figure>
<p>The results are as expected</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">what</span><br><span class="line">what</span><br><span class="line">a</span><br><span class="line">a</span><br><span class="line">beautiful</span><br><span class="line">beautiful</span><br><span class="line">name</span><br><span class="line">name</span><br></pre></td></tr></table></figure>
<p>Again type</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">what a beautiful name</span><br></pre></td></tr></table></figure>
<p>The program gives</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">what</span><br><span class="line">a</span><br><span class="line">beautiful</span><br><span class="line">name</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Notes</tag>
      </tags>
  </entry>
  <entry>
    <title>Accelerated C++ Solutions to Exercises(Chapter 7 Part 2)</title>
    <url>/2018/03/31/Accelerated-C-Solutions-to-Exercises-Chapter-7-Part-2/</url>
    <content><![CDATA[<h1 id="Exercise-7-5"><a href="#Exercise-7-5" class="headerlink" title="Exercise 7-5"></a>Exercise 7-5</h1><p>Reimplement the grammar program using a list as the data structure in which webuild the sentence.</p>
<h2 id="Solutions-amp-Results"><a href="#Solutions-amp-Results" class="headerlink" title="Solutions &amp; Results"></a>Solutions &amp; Results</h2><p>There is no any other differences between the list-based version and the vector-based version except that we replace <strong>vector</strong>s with <strong>list</strong>s literally, and hence No further discussion about this exercise. The original program can be found here <a href="http://quanttour.com/28/03/2018/C-Using-associative-containers-Part-2/" target="_blank" rel="noopener">Example 3</a>.</p>
<h1 id="Exercise-7-6"><a href="#Exercise-7-6" class="headerlink" title="Exercise 7-6"></a>Exercise 7-6</h1><p>Reimplement the gen_sentence program using two vectors: One will hold the fullyunwound, generated sentence, and the other will hold the rules and will be used as a stack.Do not use any recursive calls.</p>
<h2 id="Solution-amp-Results"><a href="#Solution-amp-Results" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>To be updated. </p>
<h1 id="Exercise-7-7"><a href="#Exercise-7-7" class="headerlink" title="Exercise 7-7"></a>Exercise 7-7</h1><p>Change the driver for the cross-reference program so that it writes line if there is only one line and lines otherwise.</p>
<h2 id="Solution-amp-Results-1"><a href="#Solution-amp-Results-1" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>The solution is to add and check a condition that whether the vector where holds line numbers only contain one line number. If there is only one line number, we use <strong>line</strong> else use <strong>lines</strong>. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((it-&gt;second).<span class="built_in">size</span>() == <span class="number">1</span>)</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"line:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"lines:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>I only present the revised file here and please find other file in <a href="http://quanttour.com/30/03/2018/Accelerated-C-Solutions-to-Exercises-Chapter-7/" target="_blank" rel="noopener">Exercise 7-4</a>.</p>
<p><strong>mainfunction.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;		// to get the declaration of map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;	// to get the declaration of string</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;	// to get the declaration of vector</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;	// to get the declaration of cin, cout, endl;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;	// to get the declaration of ostringstream</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;	// to get the declaration of isspace</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"split.h"</span>	<span class="comment">// to get the declaration of function split</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"xref.h"</span>	<span class="comment">// to get the declaration of xref</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">map</span>;				<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;				<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;			<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>:: <span class="built_in">ostringstream</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">isspace</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// call xret using split by default</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; ret = xref(<span class="built_in">cin</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set the length for each line of outputs</span></span><br><span class="line">    <span class="built_in">string</span>::size_type line_length = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write the result</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;::const_iterator it = ret.<span class="built_in">begin</span>(); it != ret.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// write the word</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">" occurs on "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((it-&gt;second).<span class="built_in">size</span>() == <span class="number">1</span>)</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"line:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"lines:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// followed by one or more line numbers</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator line_it = it-&gt;second.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *line_it;	<span class="comment">// write the first line number</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// scan the rest line numbers</span></span><br><span class="line">        ++line_it;</span><br><span class="line">        <span class="built_in">ostringstream</span> os;</span><br><span class="line">        <span class="keyword">while</span>(line_it != it-&gt;second.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// store line numbers into ostringstream object</span></span><br><span class="line">            os &lt;&lt; <span class="string">", "</span> &lt;&lt; *line_it;</span><br><span class="line">            ++line_it;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// get the contents from line_numbers</span></span><br><span class="line">        <span class="built_in">string</span> line_numbers = os.str();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// write each line of outputs</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">string</span>::size_type i = <span class="number">0</span>; i != line_numbers.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; line_numbers[i];</span><br><span class="line">            <span class="keyword">if</span>((i + <span class="number">1</span>) % line_length == <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// write a blank line to separate each words</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>I use the inputs as same as inputs used in exercise 7-4 and get following results, showing the effect of above changes.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ABC occurs on lines:</span><br><span class="line">1, 2, 3, 4, 5, 6, 7, </span><br><span class="line">8, 9, 10, 11, 12, 13</span><br><span class="line">, 14, 15, 16, 17, 18</span><br><span class="line">, 19, 20, 21</span><br><span class="line">DEF occurs on line:</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<h1 id="Exercise-7-8"><a href="#Exercise-7-8" class="headerlink" title="Exercise 7-8"></a>Exercise 7-8</h1><p>Change the cross-reference program to find all the URLs in a file, and write all the lines<br>on which each distinct URL occurs.</p>
<h2 id="Solution-amp-Results-2"><a href="#Solution-amp-Results-2" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>Please find the program and analysis in <a href="http://quanttour.com/27/03/2018/C-Using-associative-containers/" target="_blank" rel="noopener">Example 2-Test 2</a>. </p>
<h1 id="Exercise-7-9"><a href="#Exercise-7-9" class="headerlink" title="Exercise 7-9"></a>Exercise 7-9</h1><p>(difficult) The implementation of nrand in §7.4.4/135 will not work for arguments greater than RAND_MAX. Usually, this restriction is no problem, because RAND_MAX is often the largest possible integer anyway. Nevertheless, there are implementations under which RAND_MAX is much smaller than the largest possible integer. For example, it is not uncommon for RAND_MAX to be 32767 (2^15 -1) and the largest possible integer to be 2147483647 (2^31 -1). Reimplement nrand so that it works well for all values of n.</p>
<h2 id="Solution-amp-Results-3"><a href="#Solution-amp-Results-3" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>Recalling <strong>nrand</strong> function</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nrand</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span> || n &gt; RAND_MAX)</span><br><span class="line">        <span class="keyword">throw</span> domain_error(<span class="string">"Argument to nrand is out of range"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> bucket_size = RAND_MAX /n;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> r = rand() / bucket_size;</span><br><span class="line">    <span class="keyword">while</span>(r &gt;= n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>nrand</strong> generates a random numbers in the range [0, n). The idea behind this function is that we divide the range[0, n<em>(RAND_MAX/n)) into *</em>n** pieces of equal size. Assuming <strong>RAND_MAX = 32767</strong>, <strong>n = 1000</strong>, random numbers <strong>r</strong> and random numbers generated from <strong>rand()</strong> have following relationships:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">r (values)                   rand() (values of the range)</span><br><span class="line"></span><br><span class="line">0                            [0, 32)</span><br><span class="line">1                            [32, 64)</span><br><span class="line">2                            [64, 96)</span><br><span class="line">...                          ...</span><br><span class="line">999                          [31968, 32000)</span><br></pre></td></tr></table></figure>
<p>To be continued.</p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Accelerated C++ Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title>Accelerated C++ Solutions to Exercises(Chapter 7 Part 1)</title>
    <url>/2018/03/30/Accelerated-C-Solutions-to-Exercises-Chapter-7/</url>
    <content><![CDATA[<h1 id="Exercise-7-0"><a href="#Exercise-7-0" class="headerlink" title="Exercise 7-0"></a>Exercise 7-0</h1><p>Compile, execute, and test the programs in this chapter.</p>
<h2 id="Solution-amp-Results"><a href="#Solution-amp-Results" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>Please find the programs and detailed analysis in <a href="http://quanttour.com/27/03/2018/C-Using-associative-containers/" target="_blank" rel="noopener">Example 1, 2</a> and <a href="http://quanttour.com/27/03/2018/C-Using-associative-containers/" target="_blank" rel="noopener">Example 3</a>.</p>
<h1 id="Exercise-7-1"><a href="#Exercise-7-1" class="headerlink" title="Exercise 7-1"></a>Exercise 7-1</h1><p>Extend the program from §7.2/124 to produce its output sorted by occurrence count.That is, the output should group all the words that occur once, followed by those that occur twice, and so on.</p>
<h2 id="Solution-amp-Results-1"><a href="#Solution-amp-Results-1" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>The key to the solution is building a map from occurrence numbers to corresponding words. The original program builds a map from each distinct word to its occurrence numbers. Therefore, we can simply inverse the original map. But noting there may be more than one words have the same occurrence numbers. The revised program is shown below:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;		// to get the declaration of cin, cout, endl</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;		// to get the declaration of vector</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;		// to get the declaration of string</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;			// to get the declaration of map</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>; 	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">map</span>;		<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// store each word and an associated counter</span></span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; counters;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read the input, keeping track of each word and how often we see it</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; s)</span><br><span class="line">    &#123;</span><br><span class="line">        ++counters[s];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sort words stored in counters according to the occurence count</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt; sorted_counters;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::const_iterator it = counters.<span class="built_in">begin</span>(); it != counters.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    &#123;</span><br><span class="line">        sorted_counters[it-&gt;second].push_back(it-&gt;first);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write the words and associated counts</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Words and their associated counts:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::const_iterator it = counters.<span class="built_in">begin</span>(); it != counters.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">"\t"</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write a blank line to separate the outputs of two maps</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write occurrence count followed by the corresponding words</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Occurrence count and the  corresponding words:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt;::const_iterator it = sorted_counters.<span class="built_in">begin</span>(); it != sorted_counters.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; it-&gt;first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::const_iterator i = (it-&gt;second).<span class="built_in">begin</span>(); i != (it-&gt;second).<span class="built_in">end</span>(); ++i)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt;  <span class="string">' '</span> &lt;&lt; *i;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>It can be observed that the <strong>value</strong>s of the original map are stored into the new map as <strong>key</strong>s while the <strong>key</strong>s are stored as <strong>value</strong>s in the new map. In addition, we specify <strong>vector<string></strong> to hold more words that have same occurrence numbers. Now let’s type some words and check the results.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Inputs:</span><br><span class="line"></span><br><span class="line">a dog and a cat</span><br><span class="line">cat is good dog is bad</span><br><span class="line">human is ugly </span><br><span class="line"></span><br><span class="line">Outputs:</span><br><span class="line"></span><br><span class="line">Words and their associated counts:</span><br><span class="line">a	    2</span><br><span class="line">and	    1</span><br><span class="line">bad	    1</span><br><span class="line">cat	    2</span><br><span class="line">dog	    2</span><br><span class="line">good	1</span><br><span class="line">human	1</span><br><span class="line">is	    3</span><br><span class="line">ugly	1</span><br><span class="line"></span><br><span class="line">Occurrence count and the  corresponding words:</span><br><span class="line">1 and bad good human ugly</span><br><span class="line">2 a cat dog</span><br><span class="line">3 is</span><br></pre></td></tr></table></figure>
<p>Yeah, it correctly sorts the words according to their occurrence numbers. </p>
<hr>
<h1 id="Exercise-7-2"><a href="#Exercise-7-2" class="headerlink" title="Exercise 7-2"></a>Exercise 7-2</h1><p>Extend the program in §4.2.3/64 to assign letter grades by ranges:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A   90-100</span><br><span class="line">B   80-89.99...</span><br><span class="line">C   70-79.99...</span><br><span class="line">D   60-69.99...</span><br><span class="line">F   &lt; 60</span><br></pre></td></tr></table></figure>
<p>The output should list how many students fall into each category.</p>
<h2 id="Solution-amp-Results-2"><a href="#Solution-amp-Results-2" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>The key to solution is building a map from the letter grades, <strong>A, B, C, D, F</strong>, to the number of students who have the corresponding final grades. Therefore, the map can be defined as:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; grades_count;</span><br></pre></td></tr></table></figure>
<p>The strategy can be divided into four steps:</p>
<ol>
<li>read students’ information</li>
<li>calculate final grade for each student</li>
<li>check the range of each final grade and get a letter grade (i.e. the <strong>key</strong>)</li>
<li>increment the <strong>value</strong> associated with the <strong>key</strong> returned in step 3</li>
</ol>
<p>Step 1 and step 2 are familar. </p>
<p>Step 3 needs a function on the final grade. I uses a simple <strong>if-else</strong> statement to complete it:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">letter_grade</span><span class="params">(<span class="keyword">double</span> &amp;grade)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(grade &lt; <span class="number">0</span> || grade &gt; <span class="number">100</span>)</span><br><span class="line">        <span class="keyword">throw</span> domain_error(<span class="string">"grade is outside of[0, 100]"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (grade &gt;= <span class="number">90</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"A"</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(grade &gt;= <span class="number">80</span> &amp;&amp; grade &lt; <span class="number">90</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"B"</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(grade &gt;= <span class="number">70</span> &amp;&amp; grade &lt; <span class="number">80</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"C"</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(grade &gt;= <span class="number">60</span> &amp;&amp; grade &lt; <span class="number">70</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"D"</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"F"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step 4 is accomplished by the statement:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">++grades_count[letter_grade(final_grade)];</span><br></pre></td></tr></table></figure>
<p><strong>letter_grade(final_grade)</strong> returns a letter grade based on the function above. Then, the map <strong>grades_count</strong> stores (if it is new ) the letter as the key and returns the associated value. Finally, applies <strong>++</strong> operator to increment the associated value, showing the counting process. </p>
<h3 id="The-complete-program"><a href="#The-complete-program" class="headerlink" title="The complete program"></a>The complete program</h3><p>The complete program is displayed below including files: <strong>mainfunction.cpp, grade.cpp, grade.h, Student_info.cpp and Student_info.h</strong>.</p>
<p><strong>mainfunction.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;		// to get the declaration of cin, cout, endl</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;		// to get the declaration of domain_error</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;		// to get the declaration of string</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;		// to get the declaration of vector</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;			// to get the declaration of map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span>	<span class="comment">// to get the declaration of Student_info</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"grade.h"</span>		<span class="comment">// to get the declaration of grade</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;			<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;			<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::domain_error;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">map</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">letter_grade</span><span class="params">(<span class="keyword">double</span> &amp;grade)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(grade &lt; <span class="number">0</span> || grade &gt; <span class="number">100</span>)</span><br><span class="line">        <span class="keyword">throw</span> domain_error(<span class="string">"grade is outside of[0, 100]"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (grade &gt;= <span class="number">90</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"A"</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(grade &gt;= <span class="number">80</span> &amp;&amp; grade &lt; <span class="number">90</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"B"</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(grade &gt;= <span class="number">70</span> &amp;&amp; grade &lt; <span class="number">80</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"C"</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(grade &gt;= <span class="number">60</span> &amp;&amp; grade &lt; <span class="number">70</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"D"</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"F"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// read and store all the records</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;Student_info&gt; students;</span><br><span class="line">    Student_info record;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">read</span>(<span class="built_in">cin</span>, record))</span><br><span class="line">    &#123;</span><br><span class="line">        students.push_back(record);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; grades_count;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Student_info&gt;::size_type i = <span class="number">0</span>; i != students.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// compute each final grade letter grades and counting the letter grades</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">double</span> final_grade = grade(students[i]);</span><br><span class="line">            ++grades_count[letter_grade(final_grade)];</span><br><span class="line">        &#125; <span class="keyword">catch</span>(domain_error e)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; e.what();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::const_iterator it = grades_count.<span class="built_in">begin</span>();</span><br><span class="line">            it != grades_count.<span class="built_in">end</span>(); ++it)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">'\t'</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>grade.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"grade.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::domain_error;  <span class="keyword">using</span> <span class="built_in">std</span>::istream;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;        <span class="keyword">using</span> <span class="built_in">std</span>::sort;</span><br><span class="line"></span><br><span class="line"><span class="comment">// grade function 1</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">const</span> Student_info &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> grade(s.midterm, s.<span class="keyword">final</span>, s.homework);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// grade function 2</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">double</span> midterm, <span class="keyword">double</span> <span class="keyword">final</span>, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;hw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hw.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> domain_error(<span class="string">"student has done no homework"</span>);</span><br><span class="line">    <span class="keyword">return</span> grade(midterm, <span class="keyword">final</span>, median(hw));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// grade function 3</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">double</span> midterm, <span class="keyword">double</span> <span class="keyword">final</span>, <span class="keyword">double</span> homework)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.2</span>*midterm + <span class="number">0.4</span>*<span class="keyword">final</span> + <span class="number">0.4</span>*homework;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compute the median of vector&lt;double&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">median</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// get the size of the vector</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;::size_type vec_size;</span><br><span class="line">    vec_size <span class="built_in">size</span> = vec.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check whether the empty is empty</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span> == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> domain_error(<span class="string">"median of an empty vector"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sort the grades</span></span><br><span class="line">    sort(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// compute the median homework grade</span></span><br><span class="line">    vec_size mid = <span class="built_in">size</span>/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">size</span> % <span class="number">2</span> == <span class="number">0</span> ? (vec[mid] + vec[mid - <span class="number">1</span>])/<span class="number">2</span> : vec[mid];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>grade.h</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_grade_h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_grade_h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// grade.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">const</span> Student_info &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">median</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>Student.info</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>; <span class="keyword">using</span> <span class="built_in">std</span>::istream;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> Student_info &amp;x, <span class="keyword">const</span> Student_info &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.name &lt; y.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">istream &amp; <span class="title">read</span><span class="params">(istream &amp;is, Student_info &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// reads and store the student's name, midterm and final exam grades</span></span><br><span class="line">    is &gt;&gt; s.name &gt;&gt; s.midterm &gt;&gt; s.<span class="keyword">final</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reads and store all homework grades</span></span><br><span class="line">    read_hw(is, s.homework);</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">istream &amp; <span class="title">read_hw</span><span class="params">(istream &amp;in, <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;hw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (in)&#123;</span><br><span class="line">        <span class="comment">//get rid of previous contents</span></span><br><span class="line">        hw.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// read homework grades</span></span><br><span class="line">        <span class="keyword">double</span> x;</span><br><span class="line">        <span class="keyword">while</span>(in &gt;&gt; x)</span><br><span class="line">            hw.push_back(x);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// clear the stream so that input will work for the next student</span></span><br><span class="line">        in.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Student_info.h</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_Student_info</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_Student_info</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student_info</span>&#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">double</span> midterm, <span class="keyword">final</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; homework;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> Student_info &amp;, <span class="keyword">const</span> Student_info &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::istream &amp; <span class="title">read</span><span class="params">(<span class="built_in">std</span>::istream &amp;, Student_info &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::istream &amp; <span class="title">read_hw</span><span class="params">(<span class="built_in">std</span>::istream &amp;, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="Performance-Test"><a href="#Performance-Test" class="headerlink" title="Performance Test"></a>Performance Test</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Inputs:</span><br><span class="line"></span><br><span class="line">Phqgh 24.7879 58.6263 64.0505</span><br><span class="line">Nlfdx 95.4242 27.3636 91.0404</span><br><span class="line">Cxggb 16.1818 95.4747 26.7172</span><br><span class="line">Uxwfn 35.9495 3.11111 22.3333</span><br><span class="line">Tkjpr 68.4747 44.6263 57.3737</span><br><span class="line">Pnrvy 16.3535 90.4242 88.0606</span><br><span class="line">Syycq 5.90909 29.7071 50.0606</span><br><span class="line">Ffmzn 84.5455 56.404 66.7677</span><br><span class="line">Vwsre 23.3737 38.1818 82.2929</span><br><span class="line">Fxtls 4.30303 77.0606 73.8687</span><br><span class="line">Dpooe 29.7778 73.9798 12.8687</span><br><span class="line">Ejuvp 55.7475 31.5253 50.5051</span><br><span class="line">Poeyl 91.0707 37.5758 87.5354</span><br><span class="line">Jvrvi 21.8889 22.4646 6.30303</span><br><span class="line">Hwqnq 55.101 59.2424 37.4848</span><br><span class="line">Jjloo 91.3636 74.202 96.2121</span><br><span class="line">Whmsn 34.5354 99.1818 38</span><br><span class="line">Sfzkv 48.8384 7.21212 10.1717</span><br><span class="line">Lyjyh 51 49.1919 56.9899</span><br><span class="line">Nkkuf 89.0202 95.8586 93.4343</span><br><span class="line"></span><br><span class="line">Outputs:</span><br><span class="line"></span><br><span class="line">A	1</span><br><span class="line">B	1</span><br><span class="line">C	1</span><br><span class="line">D	5</span><br><span class="line">F	12</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Exercise-7-3"><a href="#Exercise-7-3" class="headerlink" title="Exercise 7-3"></a>Exercise 7-3</h1><p>The cross-reference program from §7.3/126 could be improved: As it stands, if a word occurs more than once on the same input line, the program will report that line multiple times. Change the code so that it detects multiple occurrences of the same line number and inserts the line number only once. </p>
<h2 id="Solution-amp-Results-3"><a href="#Solution-amp-Results-3" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>In the original program, we built a map from each distinct word to the line numbers in which the word appears. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">map&lt;string, vector&lt;int&gt; &gt; xref(istream &amp;in,</span><br><span class="line">        vector&lt;string&gt; find_words(const string &amp;))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> <span class="built_in">line</span>;</span><br><span class="line">    <span class="keyword">int</span> line_number = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read the next line</span></span><br><span class="line">    <span class="keyword">while</span>(getline(in, <span class="built_in">line</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        ++line_number;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// break the input line into words</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; words = find_words(<span class="built_in">line</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// remember that each word occurs on the current line</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::const_iterator it = words.<span class="built_in">begin</span>(); it != words.<span class="built_in">end</span>();</span><br><span class="line">                ++it)</span><br><span class="line">        &#123;</span><br><span class="line">            ret[*it].push_back(line_number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>However, the line numbers for each word may repeatedly recorded. To avoid this problem, one solution is to check whether the line number has already been recorded. If the line number has been recorded, we ignore it, otherwise, we store it into the vector. We do not need to check all elements in the vector instead we only check the last stored line number. This is because that if a line number is repeatedly recorded, two elements (i.e. same line numbers) must be adjacent. Therefore, I add <strong>if</strong> statement as follows:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(ret[*it].empty() || *(ret[*it].<span class="built_in">end</span>() - <span class="number">1</span>) != line_number)</span><br><span class="line">    ret[*it].push_back(line_number);</span><br></pre></td></tr></table></figure>
<p>I’ll give the complete program as well as test results in next exercise.</p>
<h1 id="Exercise-7-4"><a href="#Exercise-7-4" class="headerlink" title="Exercise 7-4"></a>Exercise 7-4</h1><p>The output produced by the cross-reference program will be ungainly if the input file is large. Rewrite the program to break up the output if the lines get too long.</p>
<h2 id="Solution-amp-Results-4"><a href="#Solution-amp-Results-4" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>The key to the solution is managing the length of each line of outputs. Theoretically, the strategy can be divided into three steps:</p>
<ol>
<li>convert all line numbers (except the first one) associated with a word into <strong>string</strong>s. </li>
<li>count the number of characters that have been written.</li>
<li>when the predetermined length of a line is reached, write a new line. </li>
</ol>
<p>The first two steps seems tedious to us. Fortunately, we can use <strong>stringstream</strong> objects to accomplish these easily.</p>
<p><strong>stringstream</strong> is a stream class defined standard library. It provides <strong>IO</strong> facilities that operate on strings. For example, <strong>ostringstream</strong> object uses a string buffer to hold a sequences of characters for printing all outputs together. In addition, the sequence of characters can be accessed directly as a string object, using member function str. In this case, I define such an object <strong>os</strong> to hold all line numbers as well as additional spaces between two line numbers. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">os &lt;&lt; <span class="string">", "</span> &lt;&lt; *line_it;</span><br></pre></td></tr></table></figure>
<p><strong>line_it</strong> is an iterator that refers to one of line numbers stored in a vector.</p>
<p>Once all line numbers have been stored into <strong>os</strong>, we can access all contents to be written as a string object.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> line_numbers = os.str();</span><br></pre></td></tr></table></figure>

<p>Now, the next is to print all line numbers in one or more lines depending on the predetermined length of one line. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="built_in">string</span>::size_type i = <span class="number">0</span>; i != line_numbers.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; line_numbers[i];</span><br><span class="line">    <span class="keyword">if</span>((i + <span class="number">1</span>) % line_length == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>When <strong>i+1</strong>th element (i.e. <strong>line_number[i]</strong>)<br>is written, the <strong>if statement</strong> check that if the number of characters that have been written equals to the length (or multiple lengths) of a line, a newline character is inserted into the output stream.</p>
<h3 id="A-complete-program"><a href="#A-complete-program" class="headerlink" title="A complete program"></a>A complete program</h3><p>I integerated the changes described in exercise 7-3 and this exercise into a new program including files: <strong>mainfunction.cpp, xref.cpp, xref.h, split.cpp, split.h</strong>.</p>
<p><strong>mainfunction.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;		// to get the declaration of map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;	// to get the declaration of string</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;	// to get the declaration of vector</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;	// to get the declaration of cin, cout, endl;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;	// to get the declaration of ostringstream</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;	// to get the declaration of isspace</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"split.h"</span>	<span class="comment">// to get the declaration of function split</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"xref.h"</span>	<span class="comment">// to get the declaration of xref</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">map</span>;				<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;				<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;			<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>:: <span class="built_in">ostringstream</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">isspace</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// call xret using split by default</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; ret = xref(<span class="built_in">cin</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set the length for each line of outputs</span></span><br><span class="line">    <span class="built_in">string</span>::size_type line_length = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write the result</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;::const_iterator it = ret.<span class="built_in">begin</span>(); it != ret.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// write the word</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">" occurs on line(s):"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// followed by one or more line numbers</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator line_it = it-&gt;second.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *line_it;	<span class="comment">// write the first line number</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// scan the rest line numbers</span></span><br><span class="line">        ++line_it;</span><br><span class="line">        <span class="built_in">ostringstream</span> os;</span><br><span class="line">        <span class="keyword">while</span>(line_it != it-&gt;second.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// store line numbers into ostringstream object</span></span><br><span class="line">            os &lt;&lt; <span class="string">", "</span> &lt;&lt; *line_it;</span><br><span class="line">            ++line_it;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// get the contents from line_numbers</span></span><br><span class="line">        <span class="built_in">string</span> line_numbers = os.str();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// write each line of outputs</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">string</span>::size_type i = <span class="number">0</span>; i != line_numbers.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; line_numbers[i];</span><br><span class="line">            <span class="keyword">if</span>((i + <span class="number">1</span>) % line_length == <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// write a blank line to separate each words</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>xref.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;	// to get the decalration of istream</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;		// to get the declaration of map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;	// to get the declaration of vector</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;	// to get the declaration of string</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"split.h"</span>	<span class="comment">// to get the declaration of split</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"xref.h"</span>	<span class="comment">// to get the declatation of xref</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">map</span>;		<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::istream;</span><br><span class="line"></span><br><span class="line">map&lt;string, vector&lt;int&gt; &gt; xref(istream &amp;in,</span><br><span class="line">        vector&lt;string&gt; find_words(const string &amp;))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> <span class="built_in">line</span>;</span><br><span class="line">    <span class="keyword">int</span> line_number = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read the next line</span></span><br><span class="line">    <span class="keyword">while</span>(getline(in, <span class="built_in">line</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        ++line_number;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// break the input line into words</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; words = find_words(<span class="built_in">line</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// remember that each word occurs on the current line</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::const_iterator it = words.<span class="built_in">begin</span>(); it != words.<span class="built_in">end</span>();</span><br><span class="line">                ++it)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ret[*it].empty() || *(ret[*it].<span class="built_in">end</span>() - <span class="number">1</span>) != line_number)</span><br><span class="line">                ret[*it].push_back(line_number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>xref.h</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_XREF_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_XREF_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"split.h"</span></span></span><br><span class="line"></span><br><span class="line">std::map&lt;std::string, std::vector&lt;int&gt; &gt; xref(std::istream &amp;,</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">find_words</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;)</span> </span>= split);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/*GUARD_XREF_H */</span></span></span><br></pre></td></tr></table></figure>

<p><strong>split.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;		// to get the declarartion of vector</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;		// to get the declaration of string</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;	// to get the declaration of find_if</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"split.h"</span>		<span class="comment">// to get the declaration of split</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::find_if;</span><br><span class="line"></span><br><span class="line"><span class="comment">// true if the argument is whitespace, false otherwise</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">space</span><span class="params">(<span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">isspace</span>(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// false if the argument is whitesapce, true otherwise</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">not_space</span><span class="params">(<span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !<span class="built_in">isspace</span>(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// function extracts words from a line of input</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">split</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">string</span>::const_iterator iter;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ret;</span><br><span class="line"></span><br><span class="line">    iter i = str.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span> (i != str.<span class="built_in">end</span>())&#123;</span><br><span class="line">        <span class="comment">// ignore leading blanks</span></span><br><span class="line">        i = find_if(i, str.<span class="built_in">end</span>(), not_space);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// find end of next word</span></span><br><span class="line">        iter j = find_if(i, str.<span class="built_in">end</span>(), space);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// copy the characters in [i,j)</span></span><br><span class="line">        <span class="keyword">if</span>(i != str.<span class="built_in">end</span>())</span><br><span class="line">            ret.push_back(<span class="built_in">string</span>(i, j));</span><br><span class="line">        i = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>split.h</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_SPLIT_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_SPLIT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">space</span><span class="params">(<span class="keyword">char</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">not_space</span><span class="params">(<span class="keyword">char</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">split</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* GUARD_SPLIT_H */</span></span></span><br></pre></td></tr></table></figure>

<h3 id="Performance-test"><a href="#Performance-test" class="headerlink" title="Performance test"></a>Performance test</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Inputs:</span><br><span class="line"></span><br><span class="line">ABC</span><br><span class="line">ABC DEF DEF</span><br><span class="line">ABC</span><br><span class="line">ABC ABC</span><br><span class="line">ABC</span><br><span class="line">ABC</span><br><span class="line">ABC</span><br><span class="line">ABC</span><br><span class="line">ABC</span><br><span class="line">ABC</span><br><span class="line">ABC</span><br><span class="line">ABC</span><br><span class="line">ABC</span><br><span class="line">ABC</span><br><span class="line">ABC</span><br><span class="line">ABC</span><br><span class="line">ABC</span><br><span class="line">ABC</span><br><span class="line">ABC</span><br><span class="line">ABC</span><br><span class="line">ABC</span><br><span class="line"></span><br><span class="line">Outputs:</span><br><span class="line"></span><br><span class="line">ABC occurs on line(s):</span><br><span class="line">1, 2, 3, 4, 5, 6, 7, </span><br><span class="line">8, 9, 10, 11, 12, 13</span><br><span class="line">, 14, 15, 16, 17, 18</span><br><span class="line">, 19, 20, 21</span><br><span class="line">DEF occurs on line(s):</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p>From this test, we observe that</p>
<ol>
<li>if one word appears more than one times in the same line, the line number is only recorded once. This shows the change described in exercise 7-3 works well.</li>
<li>once a line of outputs exceeds 20 characters, it wraps. This verifies the solution given above. </li>
</ol>
<p>Noting that I also change the program such that it always writes line numbers starting from a new line. </p>
<hr>
<p>To be continued.</p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Accelerated C++ Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ - Using associative containers (Part 2)</title>
    <url>/2018/03/28/C-Using-associative-containers-Part-2/</url>
    <content><![CDATA[<h1 id="Example-3-Generating-sentences"><a href="#Example-3-Generating-sentences" class="headerlink" title="Example 3 - Generating sentences"></a>Example 3 - Generating sentences</h1><p>This section introduces how to write a program that can randomly generate a sentence given certain grammar rules. For example, given following input</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Categories        Rules</span><br><span class="line"></span><br><span class="line">&lt;noun&gt;            cat</span><br><span class="line">&lt;noun&gt;            dog</span><br><span class="line">&lt;noun&gt;            table</span><br><span class="line">&lt;noun-phrase&gt;     &lt;noun&gt;</span><br><span class="line">&lt;noun-phrase&gt;     &lt;adjective&gt; &lt;noun-phrase&gt;</span><br><span class="line">&lt;adjective&gt;       large</span><br><span class="line">&lt;adjective&gt;       brown</span><br><span class="line">&lt;adjective&gt;       absurd</span><br><span class="line">&lt;verb&gt;            jumps</span><br><span class="line">&lt;verb&gt;            sits</span><br><span class="line">&lt;location&gt;        on the stairs</span><br><span class="line">&lt;location&gt;        under the sky</span><br><span class="line">&lt;location&gt;        wherever it wants</span><br><span class="line">&lt;sentence&gt;        the &lt;noun-phrase&gt; &lt;verb&gt; &lt;location&gt;</span><br></pre></td></tr></table></figure>

<p>The program might generate such a sentence:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">the cat sits on the stairs</span><br></pre></td></tr></table></figure>
<p>Some stylized facts can be observed:</p>
<ol>
<li><p>There are two types of element in the inputs, one type contains a string enclosed by a pair of angle brackets and the other type contains one or more strings. We can always find direct or indirect mapping relations from each first type element to the second type elements. </p>
</li>
<li><p>The first type represents categories of the components that constitute a sentence. One or more categories can construct compound categories. The second type represents the smallest building blocks of a sentence. </p>
</li>
<li><p>The sentence structure is determined by the <strong>Rule</strong> associated with the category <strong><sentence></strong>. A <strong>Rule</strong> may contain either categories or most basic building blocks or mixed. </p>
</li>
</ol>
<p>Therefore, to construct a sentence, we need to</p>
<ol>
<li>find <strong><sentence></strong>, and then find the associated <strong>Rule</strong>.</li>
<li>start to find each element of a sentence follow the instructions of the <strong>Rule</strong>. </li>
<li>if the element is already the most basic building block, then we just store it into a vector for the final output. If the element is a category (i.e. the first type of element), we’ll find the associated <strong>Rule</strong> recursively, until that we find any of the most basic building blocks (i.e. the second type of element).</li>
</ol>
<p>Now, the soluction strategy can be logically divided into three parts:</p>
<ul>
<li>part 1: read and store the grammar including categories and rules into a map</li>
<li>part 2: applying above steps to find all needed elements for a sentence </li>
<li>part 3: write the sentence on the output device. </li>
</ul>
<h2 id="Read-the-grammar"><a href="#Read-the-grammar" class="headerlink" title="Read the grammar"></a>Read the grammar</h2><p>Seen from above example, we can built a map from the first colunm to the second column, two elements of which in each row construct a key-value pair. The elements in the first column have data type <strong>string</strong>. But what’s the data type for the elements of the second column? We know that each rule may contains one or more strings and hence each rule can be stored into a vector<string>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; Rule;</span><br></pre></td></tr></table></figure>
<p>Also, the mapping from the first column to the second column has one-to-many relations,for example, one <strong><noun></strong> maps to several rules such as <strong>cat</strong>, <strong>dog</strong> and <strong>table</strong>. Therefore, we can store each rule into a high-level vector:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; Rule_collection;</span><br></pre></td></tr></table></figure>
<p>For the sake of brevity, we can use type alias in declaring such a map:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; Rule;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;Rule&gt; Rule_collection;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">map</span>&lt;<span class="built_in">string</span>, Rule_collection&gt; Grammar;</span><br></pre></td></tr></table></figure>
<p>Let’s see how to read the grammar into such a map:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Grammar <span class="title">read_grammar</span><span class="params">(istream &amp;in)</span></span></span><br><span class="line"><span class="function">    Grammar ret</span>;</span><br><span class="line">    <span class="built_in">string</span> <span class="built_in">line</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read the input</span></span><br><span class="line">    <span class="keyword">while</span> (getline(in, <span class="built_in">line</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// split the input into words</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; entry = split(<span class="built_in">line</span>);</span><br><span class="line">        <span class="keyword">if</span>(!entry.empty())</span><br><span class="line">            <span class="comment">// use the category to store the associated rule</span></span><br><span class="line">            ret[entry[<span class="number">0</span>]].push_back(Rule(entry.<span class="built_in">begin</span>() + <span class="number">1</span>, entry.<span class="built_in">end</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The function returns a map <strong>Grammar</strong> that contains all grammar rules to be applied to generate a sentence in the next step. There is only one argument, an input stream object, to be passed. </p>
<p>Inside of the function body, the first statement defines an empty map <strong>ret</strong> for holding the grammar, and the second statement defines an empty string for holding each row of input containing the key (i.e. one category) and the value (i.e. one rule). The next is a <strong>while</strong> loop to read the input repeatedly and read one line once. When the first line is read in, we need to extract all words contained in the line. Then, for the first word (i.e. the category represented by a string enclosed by a pair of angle brackets), we store it into the map as the key, while for the following words, we store them as the value that associates with the key. The core statement is</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ret[entry[<span class="number">0</span>]].push_back(Rule(entry.<span class="built_in">begin</span>() + <span class="number">1</span>, entry.<span class="built_in">end</span>()));</span><br></pre></td></tr></table></figure>
<p>It seems complex but actually there is noting new in it. <strong>entry</strong> is the vector returned by the <strong>split</strong> function and hence contains all words extracted from the line of inputs. <strong>ret[entry[0]]</strong> stores the first word (if the word is new for the key), i.e. the category, and returns its associated value, i.e. <strong>Rule_collection</strong>. Then, we uses <strong>push_back</strong> to store the associated <strong>Rule</strong> which is a vector<string> . The <strong>Rule</strong> is filled with values from the range [entry.begin() + 1, entry.end()) using </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;(iterator_first, iterator_last);</span><br></pre></td></tr></table></figure>
<p>The last statement is to return the <strong>Grammar ret</strong>.</p>
<h2 id="Generate-a-sentence"><a href="#Generate-a-sentence" class="headerlink" title="Generate a sentence"></a>Generate a sentence</h2><p>Let’s consider the function that generate a sentence. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// generating the sentence</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">gen_sentence</span><span class="params">(<span class="keyword">const</span> Grammar &amp;g)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ret;</span><br><span class="line">	gen_aux(g, <span class="string">"&lt;sentence&gt;"</span>, ret);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Apparently, we need a vector<string> to hold the generated sentence. The only argument to be passed is the value returned by the function <strong>read_grammar</strong>. </p>
<p>The function that really deals with generating a sentence is named as <strong>gen_aux</strong>. It has three parameters, the first one is the grammar produced by <strong>read_grammar</strong>, the second one is a keyword “<sentence>“ to be searched, the third one is a <strong>vector<string></strong> to hold the final results. </p>
<p>The function is defined below:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gen_aux</span><span class="params">(<span class="keyword">const</span> Grammar &amp;g, <span class="keyword">const</span> <span class="built_in">string</span> &amp;<span class="keyword">word</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;ret)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!bracketed(<span class="keyword">word</span>))&#123;</span><br><span class="line">		ret.push_back(<span class="keyword">word</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// locate the rule that corresponds to word</span></span><br><span class="line">		Grammar::const_iterator it = g.<span class="built_in">find</span>(<span class="keyword">word</span>);</span><br><span class="line">		<span class="keyword">if</span>(it == g.<span class="built_in">end</span>())</span><br><span class="line">			<span class="keyword">throw</span> logic_error(<span class="string">"empty rule"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// fetch the set of possible rules</span></span><br><span class="line">		<span class="keyword">const</span> Rule_collection &amp;c = it-&gt;second;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// from which we select one at random</span></span><br><span class="line">		<span class="keyword">const</span> Rule  &amp;r = c[nrand(c.<span class="built_in">size</span>())];</span><br><span class="line"></span><br><span class="line">		<span class="comment">// recursively expand teh selected rule</span></span><br><span class="line">		<span class="keyword">for</span> (Rule::const_iterator i = r.<span class="built_in">begin</span>(); i != r.<span class="built_in">end</span>(); ++i)</span><br><span class="line">			gen_aux(g, *i, ret);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The logic of this function is exactly as same as we described above. Ignoring the <strong>if-else</strong> statement first, the first step is to find the category <strong><sentence></strong>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Grammar::const_iterator it = g.<span class="built_in">find</span>(<span class="keyword">word</span>);</span><br></pre></td></tr></table></figure>
<p>The member function <strong>find</strong> finds and returns an iterator that refers to the element with <em>the key</em> equivalent to the given <strong>k</strong>. If such element doesn’t exist in the map, the <strong>find</strong> function returns iterator <strong>g.end()</strong>. Therefore, if there exists such an iterator, getting the associated <strong>Rule_collection</strong>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(it == g.<span class="built_in">end</span>())</span><br><span class="line">    <span class="keyword">throw</span> logic_error(<span class="string">"empty rule"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// fetch the set of possible rules</span></span><br><span class="line"><span class="keyword">const</span> Rule_collection &amp;c = it-&gt;second;</span><br></pre></td></tr></table></figure>
<p>By now, there exists two problems to be solved: </p>
<ol>
<li>how to randomly pick one rule from <strong>Rule_collection</strong></li>
<li>if one rule is picked, how to deal with the case that its elements are still categories. </li>
</ol>
<p>Let’s put question 1 last and solve question 2 first. Assuming we have picked one rule from the <strong>Rule_collection</strong>, we then scan each element of it and store the element if the element is the most basic building block. But if the element is still one of the categories, what we need to do is to find the lower level rule (i.e. its associated value). Therefore, we just repeat above processes until the element is not a category.<br>The <strong>if-else</strong> statement controls the recursive process while the condition that ceases the recursion is a predicate which returns true if the element is not a category:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bracketed</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> s.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; s[<span class="number">0</span>] == <span class="string">'&lt;'</span> &amp;&amp; s[s.<span class="built_in">size</span>() - <span class="number">1</span>] == <span class="string">'&gt;'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The function <strong>gen_sentence</strong> is recursively called in the <strong>for</strong> loop:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// recursively expand teh selected rule</span></span><br><span class="line"><span class="keyword">for</span> (Rule::const_iterator i = r.<span class="built_in">begin</span>(); i != r.<span class="built_in">end</span>(); ++i)</span><br><span class="line">    gen_aux(g, *i, ret);</span><br></pre></td></tr></table></figure>

<h2 id="Random-drawing"><a href="#Random-drawing" class="headerlink" title="Random drawing"></a>Random drawing</h2><p>Now the last piece is to randomly pick a rule from <strong>Rule_collection</strong>.<br>One possible solution is using <strong>rand() % n</strong>. <strong>rand()</strong> is an algorithm defined in standard header <strong><cstdlib></strong> and gives a random integer in the range [0, RAND_MAX]. The upper bound is a large number defined in <strong><cstdlib></strong>. <strong>rand() % n</strong>, computes the remainder when deviding the random number by <strong>n</strong> and hence gives a random integer in the range [0, n). If we set <strong>n = c.size()</strong>, we can then obtain an random index that yields a <strong>rule</strong> via <strong>c[rand() % c.size]</strong>. However, this solution is not a good choice due to(Koenig and Moo 2000):</p>
<ol>
<li><p><em><strong>rand()</strong> returns pseudo-random numbers. Many C++ implementations’ pseudo-random numbers give remainders that aren’t very random when the quotients are small integers</em>.</p>
</li>
<li><p><em>if <strong>n</strong> is large and <strong>RAND_MAX</strong> is not evenly divisible by <strong>n</strong>,some remainder will appear more often than others</em>.</p>
</li>
</ol>
<p>To circumvent these issues, we can divide the range of available numbers into buckets of exactly equal size:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> bucket_size = RAND_MAX /n;</span><br></pre></td></tr></table></figure>
<p>Then, bucket 0 has values from [0, bucket_size), bucket 1 has values from [bucket_size, bucket_size*2)…..</p>
<p>Then we can random draw a number and get the bucket number where the random number is located in via:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> r = rand() / bucket_size;</span><br></pre></td></tr></table></figure>
<p>But there exist situations that the random number does not fall into any bucket due to the fact that <strong>RAND_MAX</strong> may be not evenly divisible by <strong>n</strong>. Therefore, we uses a <strong>do while</strong> statement to repeat above statement until it finds a random number that locates in the range of one of buckets.  </p>
<p>The function <strong>nrand</strong> is shown below:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// return a random integer in the range [0, n)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nrand</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n &lt;= <span class="number">0</span> || n &gt; RAND_MAX)</span><br><span class="line">		<span class="keyword">throw</span> domain_error(<span class="string">"Argument to nrand is out of range"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> bucket_size = RAND_MAX /n;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> r = rand() / bucket_size;</span><br><span class="line">	<span class="keyword">while</span>(r &gt;= n);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Noting that <strong>rand()</strong> uses a seed to generate the sequence, which should be initialized to some distinctive value using <strong>void srand(unsigned int seed)</strong>. A common practice is to use distinctive runtime value, like the value returned by function time. For example</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">srand (time(<span class="literal">NULL</span>));</span><br></pre></td></tr></table></figure>
<p>In addition, <strong>srand()</strong> is in fact has global effect on <strong>rand()</strong> and hence can be stated at the very begining of the main function. </p>
<h2 id="A-complete-program"><a href="#A-complete-program" class="headerlink" title="A complete program"></a>A complete program</h2><p>Now I files all functions and code discussed above and present the compete program below. The main function easy to understand and hence no further analysis here. </p>
<p><strong>mainfunction.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;		// to get the declaration of srand</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;		// to get the declaration of time</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;		// to get the declaration of vector</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;		// to get the declaration of string</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"read_grammar.h"</span>	<span class="comment">// to get the declaration of read_grammar</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"gen_sentence.h"</span>	<span class="comment">// to get the declaration of gen_sentence</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;		<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::srand;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::time;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// initialize random number generator with distinctive runtime value</span></span><br><span class="line">	srand (time(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// generate the sentence</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; sentence = gen_sentence(read_grammar(<span class="built_in">cin</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// write the first word, if any</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::const_iterator it = sentence.<span class="built_in">begin</span>();</span><br><span class="line">	<span class="keyword">if</span>(!sentence.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *it;</span><br><span class="line">		++it;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// write the rest of the words, each preceded by a space</span></span><br><span class="line">	<span class="keyword">while</span>(it != sentence.<span class="built_in">end</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; *it;</span><br><span class="line">		++it;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>type_alias.h</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_TYPE_ALIAS_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_TYPE_ALIAS_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; Rule;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Rule&gt; Rule_collection;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, Rule_collection&gt; Grammar;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* GUARD_TYPE_ALIAS_H */</span></span></span><br></pre></td></tr></table></figure>

<p><strong>read_grammar.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;		// to get the declaration of istream</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;		// to get the declaration of vector</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;		// to get the declaration of string</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"split.h"</span>		<span class="comment">// to get the declaration of split</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"type_alias.h"</span>		<span class="comment">// to get the declaration of type alias</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"read_grammar.h"</span>	<span class="comment">// to get the declaration of read_grammar</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::istream;		<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// read a grammar from a given input stream</span></span><br><span class="line"><span class="function">Grammar <span class="title">read_grammar</span><span class="params">(istream &amp;in)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Grammar ret;</span><br><span class="line">    <span class="built_in">string</span> <span class="built_in">line</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read the input</span></span><br><span class="line">    <span class="keyword">while</span> (getline(in, <span class="built_in">line</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// split the input into words</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; entry = split(<span class="built_in">line</span>);</span><br><span class="line">        <span class="keyword">if</span>(!entry.empty())</span><br><span class="line">            <span class="comment">// use the category to store the associated rule</span></span><br><span class="line">            ret[entry[<span class="number">0</span>]].push_back(Rule(entry.<span class="built_in">begin</span>() + <span class="number">1</span>, entry.<span class="built_in">end</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>read_grammar.h</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_READ_GRAMMAR_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_READ_GRAMMAR_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"type_alias.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">Grammar <span class="title">read_grammar</span><span class="params">(<span class="built_in">std</span>::istream &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* GUARD_READ_GRAMMAR_H */</span></span></span><br></pre></td></tr></table></figure>

<p><strong>gen_sentence.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;		// to get the declaration of vector</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;		// to get the declaration of string</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;		// to get the declaration of domain_error, logic_error</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;		// to get the declaration of rand</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"type_alias.h"</span>		<span class="comment">// to get the declaration of type_alias</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"gen_sentence.h"</span>	<span class="comment">// to get the declatation of gen_sentence</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;			<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::domain_error;	<span class="keyword">using</span> <span class="built_in">std</span>::logic_error;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::rand;</span><br><span class="line"></span><br><span class="line"><span class="comment">// generating the sentence</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">gen_sentence</span><span class="params">(<span class="keyword">const</span> Grammar &amp;g)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ret;</span><br><span class="line">    gen_aux(g, <span class="string">"&lt;sentence&gt;"</span>, ret);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// auxillary gen function</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gen_aux</span><span class="params">(<span class="keyword">const</span> Grammar &amp;g, <span class="keyword">const</span> <span class="built_in">string</span> &amp;<span class="keyword">word</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;ret)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!bracketed(<span class="keyword">word</span>))&#123;</span><br><span class="line">        ret.push_back(<span class="keyword">word</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">// locate the rule that corresponds to word</span></span><br><span class="line">        Grammar::const_iterator it = g.<span class="built_in">find</span>(<span class="keyword">word</span>);</span><br><span class="line">        <span class="keyword">if</span>(it == g.<span class="built_in">end</span>())</span><br><span class="line">            <span class="keyword">throw</span> logic_error(<span class="string">"empty rule"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// fetch the set of possible rules</span></span><br><span class="line">        <span class="keyword">const</span> Rule_collection &amp;c = it-&gt;second;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// from which we select one at random</span></span><br><span class="line">        <span class="keyword">const</span> Rule  &amp;r = c[nrand(c.<span class="built_in">size</span>())];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// recursively expand teh selected rule</span></span><br><span class="line">        <span class="keyword">for</span> (Rule::const_iterator i = r.<span class="built_in">begin</span>(); i != r.<span class="built_in">end</span>(); ++i)</span><br><span class="line">            gen_aux(g, *i, ret);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the predicate </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bracketed</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; s[<span class="number">0</span>] == <span class="string">'&lt;'</span> &amp;&amp; s[s.<span class="built_in">size</span>() - <span class="number">1</span>] == <span class="string">'&gt;'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// return a random integer in the range [0, n)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nrand</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span> || n &gt; RAND_MAX)</span><br><span class="line">        <span class="keyword">throw</span> domain_error(<span class="string">"Argument to nrand is out of range"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> bucket_size = RAND_MAX /n;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> r = rand() / bucket_size;</span><br><span class="line">    <span class="keyword">while</span>(r &gt;= n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>split.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;	// to get the declarartion of vector</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;	// to get the declaration of string</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;	// to get the declaration of find_if</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"split.h"</span>	<span class="comment">// to get the declaration of split</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::find_if;</span><br><span class="line"></span><br><span class="line"><span class="comment">// true if the argument is whitespace, false otherwise</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">space</span><span class="params">(<span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">isspace</span>(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// false if the argument is whitesapce, true otherwise</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">not_space</span><span class="params">(<span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !<span class="built_in">isspace</span>(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// function extracts words from a line of input</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">split</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">string</span>::const_iterator iter;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ret;</span><br><span class="line"></span><br><span class="line">    iter i = str.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span> (i != str.<span class="built_in">end</span>())&#123;</span><br><span class="line">        <span class="comment">// ignore leading blanks</span></span><br><span class="line">        i = find_if(i, str.<span class="built_in">end</span>(), not_space);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// find end of next word</span></span><br><span class="line">        iter j = find_if(i, str.<span class="built_in">end</span>(), space);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// copy the characters in [i,j)</span></span><br><span class="line">        <span class="keyword">if</span>(i != str.<span class="built_in">end</span>())</span><br><span class="line">            ret.push_back(<span class="built_in">string</span>(i, j));</span><br><span class="line">        i = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>split.h</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_SPLIT_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_SPLIT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">space</span><span class="params">(<span class="keyword">char</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">not_space</span><span class="params">(<span class="keyword">char</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">split</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* GUARD_SPLIT_H */</span></span></span><br></pre></td></tr></table></figure>

<h2 id="Test-performance"><a href="#Test-performance" class="headerlink" title="Test performance"></a>Test performance</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Inputs:</span><br><span class="line"></span><br><span class="line">&lt;noun&gt;            cat</span><br><span class="line">&lt;noun&gt;            dog</span><br><span class="line">&lt;noun&gt;            table</span><br><span class="line">&lt;noun-phrase&gt;     &lt;noun&gt;</span><br><span class="line">&lt;noun-phrase&gt;     &lt;adjective&gt; &lt;noun-phrase&gt;</span><br><span class="line">&lt;adjective&gt;       large</span><br><span class="line">&lt;adjective&gt;       brown</span><br><span class="line">&lt;adjective&gt;       absurd</span><br><span class="line">&lt;verb&gt;            jumps</span><br><span class="line">&lt;verb&gt;            sits</span><br><span class="line">&lt;location&gt;        on the stairs</span><br><span class="line">&lt;location&gt;        under the sky</span><br><span class="line">&lt;location&gt;        wherever it wants</span><br><span class="line">&lt;sentence&gt;        the &lt;noun-phrase&gt; &lt;verb&gt; &lt;location&gt;</span><br><span class="line"></span><br><span class="line">Outputs:</span><br><span class="line"></span><br><span class="line">the large brown dog sits wherever it wants</span><br></pre></td></tr></table></figure>
<p>The program works as expected.</p>
<hr>
]]></content>
  </entry>
  <entry>
    <title>C++ - Using associative containers (Part 1)</title>
    <url>/2018/03/27/C-Using-associative-containers/</url>
    <content><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>Unlike <strong>sequential containers</strong>, <strong>associative containers</strong> store data into a sequence depending on the values of the elements themselves rather than the sequence where we inserted them. An <strong>associative container</strong> supports efficient lookup and retrieval by a <strong>key</strong> which is the part of each element. The most common kind of assiciative data structure, namely the <strong>associative array</strong>, is one that stores key-value pairs, associating a value with each each key. In C++, such an associative array is called a <strong>map</strong>.</p>
<p>The <strong>key</strong>s in fact plays a role as an index for the <strong>value</strong>s, which are similar to the index of a vector. But the difference is that the <strong>key</strong>s can be <em>int*</em> type or <strong>string</strong> type or any other types that allows ordering. </p>
<h1 id="Example-1-counting-words"><a href="#Example-1-counting-words" class="headerlink" title="Example 1 - counting words"></a>Example 1 - counting words</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; counters; <span class="comment">// store each word and an associated counter</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// read the input, keeping track of each word and how often we see it</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; s)</span><br><span class="line">    &#123;</span><br><span class="line">        ++counters[s];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// write the words and associated counts</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::const_iterator it = counters.<span class="built_in">begin</span>(); it != counters.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">"\t"</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Key points</strong></p>
<ol>
<li><p>when we define a <strong>map</strong>, we need to specify the types for both <strong>key</strong> and <strong>value</strong>, i.e. a key-value pair. In this case, the <strong>key</strong> has type of <strong>string</strong> while the <strong>value</strong> has type of <strong>int</strong>. Such a container can be described as a <strong>map</strong> from <strong>string</strong> to <strong>int</strong>. </p>
</li>
<li><p>from above, we know that each element in a map has type <strong>pair</strong> which is a data structure that holds two elements named <strong>first</strong> and <strong>second</strong>. For a map that has a key of type K, and a value of type V, the asociated <strong>pair</strong> type is <strong>pair&lt;const K, V&gt;</strong>. In this case, the elements of <strong>counters</strong> have type of <strong>pair&lt;const string, int&gt;</strong>. </p>
</li>
<li><p>the map <strong>counters</strong> is constructed with default initialization, leading to an empty <strong>map</strong>.</p>
</li>
<li><p>when we start to store words, the element <strong>pair&lt;string, int&gt;</strong> is <strong>value-initialized</strong>, that is, the <strong>key</strong> is initialized as an empty string and the value is initialized as 0.</p>
</li>
<li><p><strong>map</strong> supports operations via subscripting.</p>
<pre><code>c[k] returns the **k**-associated value; if **k** doesn&apos;t exist, it adds **k** to the container, initialize and returns its associated value.</code></pre><p> In this case, when a word appears for the first time, <strong>counters[s]</strong> returns the associated value which is initialized with value 0. Then we increment the value via <strong>++counters[s]</strong>. </p>
</li>
<li><p>the <strong>for</strong> loop shows how to access elements in a <strong>map</strong> using iterators. The operations are similar to those on a vactor. When we deference a <strong>map&lt;string, int&gt;</strong> iterator, we get a pair&lt;const string, int&gt;. Therefore, <strong>it-&gt;first</strong> extracts the value of the first element in the pair, that is, the <strong>key</strong>, while <strong>it-&gt;second</strong> gives the value of the second element in the pair, that is, the <strong>value</strong> associated with the key.</p>
</li>
</ol>
<p>We can also access the <strong>value</strong> via subscripting as described at key point 5. For example, </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; counters[it-&gt;first];</span><br></pre></td></tr></table></figure>
<p>has the same effect as</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; it-&gt;second;</span><br></pre></td></tr></table></figure>

<h1 id="Example-2-Generating-a-cross-reference-table"><a href="#Example-2-Generating-a-cross-reference-table" class="headerlink" title="Example 2 - Generating a cross-reference table"></a>Example 2 - Generating a cross-reference table</h1><p>This example extends above program such that the new program can generate a cross-reference table that indicates where each word occurs in the input. It requires:</p>
<ol>
<li>read a line at a time for the purpose of obtaining the associated line number.</li>
<li>To separate each word from a line, we need a function like <strong>split</strong> described in <a href="http://quanttour.com/21/03/2018/C-Using-library-algorithms/" target="_blank" rel="noopener">Chpter 6</a>. But rather than calling the function independently, we will pass it as an argument to the cross-reference function (denoted by <strong>xref</strong>). </li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// find all the lines that refer to each word in the input</span></span><br><span class="line">map&lt;string, vector&lt;int&gt; &gt; xref(istream &amp; in, </span><br><span class="line">                                <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">find_words</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;)</span> </span>= split)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> <span class="built_in">line</span>;     </span><br><span class="line">    <span class="keyword">int</span> line_number = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read the next line</span></span><br><span class="line">    <span class="keyword">while</span>(getline(in, <span class="built_in">line</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        ++line_number;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// break the input line into words</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; words = find_words(<span class="built_in">line</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// remember that each word occurs on the current line</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::const_iterator it = words.<span class="built_in">begin</span>(); it != words.<span class="built_in">end</span>(); ++it)</span><br><span class="line">        &#123;</span><br><span class="line">            ret[*it].push_back(line_number);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Let’s analyse this function:</p>
<ol>
<li><p>what <strong>xref</strong> should return is a <strong>map&lt;string, vector<int> &gt;</strong> as in fact we aims to build a map from the word to its line number. The <strong>key</strong>, representing each distinct word, has type <strong>string</strong>. The <strong>value</strong>, representing line numbers associated with each <strong>key</strong>, has type <strong>vector<int></strong> due to the fact that one word may appears in different lines. </p>
</li>
<li><p><strong>xref</strong> takes two arguments, one is an input stream object; another one is a function to extract words from a line. We are familar with how to define a function parameter. But what’ new here is to use ** = split** in defining such a function parameter.This indicates that this parameter has a <strong>default argument</strong>, i.e. split. It means that if <strong>xref</strong> is called without passing this argument, it uses the default argument. If <strong>xref</strong> is called with passing a new argument, it uses the new argument. For example</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">xref(<span class="built_in">cin</span>); <span class="comment">// uses split to find words in the input stream</span></span><br><span class="line">xref(<span class="built_in">cin</span>, find_urls); <span class="comment">// uses the function named find_urls to find words</span></span><br></pre></td></tr></table></figure></li>
<li><p>the function begins with defining three varaibles: the first is a string named <strong>line</strong> to hold each line of input; the second is a integer that denotes the line number; the third is a <strong>map&lt;string, vector<int> &gt;</strong> to hold each pair of word and line numbers. </p>
</li>
<li><p>every iteration of the <strong>while</strong> statement, one line of input is read and broken into words. Then, each word is accessed via iterator and stored into the map together its line number. The core statement is:</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ret[*it].push_back(line_number);</span><br></pre></td></tr></table></figure>
<p> As mentioned earlier, if <strong>*it</strong>, a word, doesn’t appear before, it will be stored and ret[<em>it] returns an default initialized associated value, i.e. an empty vector<int>. Then, we use *</em>push_back** to append the line number to the end of the vector. If <strong>*it</strong> has already appeared before, ret[*it] returned the associated value (i.e. vector<int>) and the new line number will be appended to the end of the vector.</p>
</li>
</ol>
<h2 id="A-complete-program"><a href="#A-complete-program" class="headerlink" title="A complete program"></a>A complete program</h2><p>Now, I add <strong>#include</strong> directives and present all files including: <strong>mainfunction.cpp, xref.cpp, xref.h, split.cpp, split.h</strong>. This program uses the default <strong>split</strong> function. </p>
<p><strong>mainfunction.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// call xref using split by default</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; ret = xref(<span class="built_in">cin</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write the results</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;::const_iterator it = ret.<span class="built_in">begin</span>(); </span><br><span class="line">        it != ret.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// write the word</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">" occurs on line(s): "</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// followed by one or more line_numbers</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator line_it = it-&gt;second.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *line_it; <span class="comment">// write the first line number</span></span><br><span class="line"></span><br><span class="line">        ++line_it;</span><br><span class="line">        <span class="keyword">while</span> (line_it != it-&gt;second.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">", "</span> &lt;&lt; *line_it;</span><br><span class="line">            ++line_it;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// write a new line to separate each word from the next</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>There is nothing new in above code. The program writes the first line number and the rest(if there exist) separately for the purpose of separating line numbers with a comma followed by a space. </p>
<p><strong>xref.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;	// to get the decalration of istream</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;		// to get the declaration of map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;	// to get the declaration of vector</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;	// to get the declaration of string</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"split.h"</span>	<span class="comment">// to get the declaration of split</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"xref.h"</span>	<span class="comment">// to get the declatation of xref</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">map</span>;		<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::istream;</span><br><span class="line"></span><br><span class="line">map&lt;string, vector&lt;int&gt; &gt; xref(istream &amp;in,</span><br><span class="line">        vector&lt;string&gt; find_words(const string &amp;))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> <span class="built_in">line</span>;</span><br><span class="line">    <span class="keyword">int</span> line_number = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read the next line</span></span><br><span class="line">    <span class="keyword">while</span>(getline(in, <span class="built_in">line</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        ++line_number;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// break the input line into words</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; words = find_words(<span class="built_in">line</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// remember that each word occurs on the current line</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::const_iterator it = words.<span class="built_in">begin</span>(); it != words.<span class="built_in">end</span>();</span><br><span class="line">                ++it)</span><br><span class="line">        &#123;</span><br><span class="line">            ret[*it].push_back(line_number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>xref.h</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_XREF_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_XREF_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"split.h"</span></span></span><br><span class="line"></span><br><span class="line">std::map&lt;std::string, std::vector&lt;int&gt; &gt; xref(std::istream &amp;,</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">find_words</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;)</span> </span>= split);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/*GUARD_XREF_H */</span></span></span><br></pre></td></tr></table></figure>
<p>It is worth noting that if <strong>xref</strong> is separated from the main function file, the default argument for the parameter (i.e. split in this case) should be put into its header file only. This is becasue that the default argument for a given parameter can only be specified once. (more discussion can be found on this page <a href="https://stackoverflow.com/questions/2842928/default-value-of-function-parameter" target="_blank" rel="noopener">Default value of function parameter
</a>).</p>
<p><strong>split.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;	// to get the declarartion of vector</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;	// to get the declaration of string</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;	// to get the declaration of find_if</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"split.h"</span>	<span class="comment">// to get the declaration of split</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::find_if;</span><br><span class="line"></span><br><span class="line"><span class="comment">// true if the argument is whitespace, false otherwise</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">space</span><span class="params">(<span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">isspace</span>(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// false if the argument is whitesapce, true otherwise</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">not_space</span><span class="params">(<span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !<span class="built_in">isspace</span>(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// function extracts words from a line of input</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">split</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">string</span>::const_iterator iter;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ret;</span><br><span class="line"></span><br><span class="line">    iter i = str.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span> (i != str.<span class="built_in">end</span>())&#123;</span><br><span class="line">        <span class="comment">// ignore leading blanks</span></span><br><span class="line">        i = find_if(i, str.<span class="built_in">end</span>(), not_space);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// find end of next word</span></span><br><span class="line">        iter j = find_if(i, str.<span class="built_in">end</span>(), space);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// copy the characters in [i,j)</span></span><br><span class="line">        <span class="keyword">if</span>(i != str.<span class="built_in">end</span>())</span><br><span class="line">            ret.push_back(<span class="built_in">string</span>(i, j));</span><br><span class="line">        i = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>split.h</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_SPLIT_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_SPLIT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">space</span><span class="params">(<span class="keyword">char</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">not_space</span><span class="params">(<span class="keyword">char</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">split</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* GUARD_SPLIT_H */</span></span></span><br></pre></td></tr></table></figure>

<h2 id="Test-1"><a href="#Test-1" class="headerlink" title="Test 1"></a>Test 1</h2><p>From a simple test shown below, it can be seen that the program works as expected.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Inputs:</span><br><span class="line"></span><br><span class="line">do you like me</span><br><span class="line">no I do not like you</span><br><span class="line"></span><br><span class="line">Outputs:</span><br><span class="line"></span><br><span class="line">I occurs on line(s): 2</span><br><span class="line">do occurs on line(s): 1 2</span><br><span class="line">like occurs on line(s): 1 2</span><br><span class="line">me occurs on line(s): 1</span><br><span class="line">no occurs on line(s): 2</span><br><span class="line">not occurs on line(s): 2</span><br><span class="line">you occurs on line(s): 1 2</span><br></pre></td></tr></table></figure>

<h2 id="Test-2"><a href="#Test-2" class="headerlink" title="Test 2"></a>Test 2</h2><p>Sometimes we may want to use another strategy to extract words, for example, when extracting URLs like we did in <a href="http://quanttour.com/21/03/2018/C-Using-library-algorithms/" target="_blank" rel="noopener">Finding URLs</a>. I add revelent files first.</p>
<p><strong>find_urls.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// function that finds and returns an URL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"find_urls.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"delimit.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">find_urls</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ret;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">string</span>::const_iterator iter;</span><br><span class="line">    iter b = s.<span class="built_in">begin</span>(), e = s.<span class="built_in">end</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// look through the entire input</span></span><br><span class="line">    <span class="keyword">while</span> (b != e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// look for one or more letters followed by ://</span></span><br><span class="line">        b = url_beg(b, e);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if we found it</span></span><br><span class="line">        <span class="keyword">if</span>(b != e)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// get the rest of the URL</span></span><br><span class="line">            iter after = url_end(b, e);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// remember the URL</span></span><br><span class="line">            ret.push_back(<span class="built_in">string</span>(b, after));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// advance b and check for more URLs on this line</span></span><br><span class="line">            b = after;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>find_urls.h</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_FINDINGURLS_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_FINDINGURLS_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">find_urls</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* GUARD_FINDINGURLS_H */</span></span></span><br></pre></td></tr></table></figure>

<p><strong>dilimit.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// contains three functions: not_url_char, url_beg, url_end</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"delimit.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">find</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::find_if;	<span class="keyword">using</span> <span class="built_in">std</span>::search;</span><br><span class="line"></span><br><span class="line"><span class="comment">// predicate on a char, check whether it is a char that can appear in a URL</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">not_url_char</span><span class="params">(<span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// characters, in addition to alphanumerics, that can appear in a URL</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">string</span> url_ch = <span class="string">"~;/?:@=&amp;$-_.+!*'(),"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// see whether c can appear in a URL and return the negative</span></span><br><span class="line">    <span class="keyword">return</span> !(<span class="built_in">isalnum</span>(c) || <span class="built_in">find</span>(url_ch.<span class="built_in">begin</span>(), url_ch.<span class="built_in">end</span>(), c) != url_ch.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// function that returns an iterator that refers to the first element of a URL</span></span><br><span class="line"><span class="function"><span class="built_in">string</span>::const_iterator <span class="title">url_beg</span><span class="params">(<span class="built_in">string</span>::const_iterator b, <span class="built_in">string</span>::const_iterator e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">string</span> sep = <span class="string">"://"</span>;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">string</span>::const_iterator iter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// i marks where the separator was found</span></span><br><span class="line">    iter i = b;</span><br><span class="line">    <span class="keyword">while</span>((i = search(i, e, sep.<span class="built_in">begin</span>(), sep.<span class="built_in">end</span>())) != e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// make sure the seperator isn't at the begining of the proticol-name</span></span><br><span class="line">        <span class="keyword">if</span>(i != b &amp;&amp; i + sep.<span class="built_in">size</span>() != e)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// beg marks the begining of the protocol-name</span></span><br><span class="line">            iter beg = i;</span><br><span class="line">            <span class="keyword">while</span>(beg != b &amp;&amp; <span class="built_in">isalpha</span>(beg[<span class="number">-1</span>]))</span><br><span class="line">                --beg;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// is there at least one appropriate character before and after the sep</span></span><br><span class="line">            <span class="keyword">if</span> (beg != i &amp;&amp; !not_url_char(i[sep.<span class="built_in">size</span>()]))</span><br><span class="line">                <span class="keyword">return</span> beg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// the seperator we found wasn't part of a URL advance i past this separator</span></span><br><span class="line">        i += sep.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// function that returns an iterator that denotes the postion one past the last element</span></span><br><span class="line"><span class="function"><span class="built_in">string</span>::const_iterator  <span class="title">url_end</span><span class="params">(<span class="built_in">string</span>::const_iterator b, <span class="built_in">string</span>::const_iterator e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> find_if(b, e, not_url_char);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>delimit.h</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_DELIMIT_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_DELIMIT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">not_url_char</span><span class="params">(<span class="keyword">char</span>)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span>::const_iterator <span class="title">url_beg</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>::const_iterator, <span class="built_in">std</span>::<span class="built_in">string</span>::const_iterator)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span>::const_iterator <span class="title">url_end</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>::const_iterator, <span class="built_in">std</span>::<span class="built_in">string</span>::const_iterator)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* GUARD_DELIMIT_H */</span></span></span><br></pre></td></tr></table></figure>

<p>Now, let’s call <strong>xref</strong> with passing argument <strong>find_urls</strong>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// call xref using split by default</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; ret = xref(<span class="built_in">cin</span>, find_urls);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write the results</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;::const_iterator it = ret.<span class="built_in">begin</span>(); </span><br><span class="line">        it != ret.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// write the word</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">" occurs on line(s): "</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// followed by one or more line_numbers</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator line_it = it-&gt;second.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *line_it; <span class="comment">// write the first line number</span></span><br><span class="line"></span><br><span class="line">        ++line_it;</span><br><span class="line">        <span class="keyword">while</span> (line_it != it-&gt;second.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">", "</span> &lt;&lt; *line_it;</span><br><span class="line">            ++line_it;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// write a new line to separate each word from the next</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Then, we type following inputs:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A typical URL could have the form https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;URL, </span><br><span class="line">which indicates a protocol (http), a hostname (www.example.com), </span><br><span class="line">and a file name (index.html). http:&#x2F;&#x2F;www.cplusplus.com&#x2F;reference&#x2F;algorithm&#x2F;search&#x2F;?kw&#x3D;search</span><br></pre></td></tr></table></figure>

<p>The program give results as expected:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;www.cplusplus.com&#x2F;reference&#x2F;algorithm&#x2F;search&#x2F;?kw&#x3D;search occurs on line(s): 3</span><br><span class="line">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;URL, occurs on line(s): 1</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Notes</tag>
      </tags>
  </entry>
  <entry>
    <title>Accelerated C++ Solutions to Exercises(Chapter 6)</title>
    <url>/2018/03/25/Accelerated-C-Solutions-to-Exercises-Chapter-6/</url>
    <content><![CDATA[<h1 id="Exercise-6-0"><a href="#Exercise-6-0" class="headerlink" title="Exercise 6-0"></a>Exercise 6-0</h1><p>Compile, execute, and test the programs in this chapter.</p>
<h2 id="Solution-amp-Results"><a href="#Solution-amp-Results" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>Please find all programs and detailed analysis on <a href="http://quanttour.com/21/03/2018/C-Using-library-algorithms/" target="_blank" rel="noopener">Using library algorithms (Part 1)</a>, <a href="http://quanttour.com/22/03/2018/C-Using-library-algorithms-Part-2/" target="_blank" rel="noopener">Using library algorithms (Part 2)</a> and <a href="http://quanttour.com/25/03/2018/C-Using-library-algorithms-Part-3/" target="_blank" rel="noopener">Using library algorithms (Part 3)</a>.</p>
<h1 id="Exercise-6-1"><a href="#Exercise-6-1" class="headerlink" title="Exercise 6-1"></a>Exercise 6-1</h1><p>Reimplement the frame and hcat operations from §5.8.1/93 and §5.8.3/94 to use iterators.</p>
<h2 id="Solution-amp-Results-1"><a href="#Solution-amp-Results-1" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>This exercise has been completed here <a href="http://quanttour.com/14/03/2018/C-Sequential-Containers-Part-2/" target="_blank" rel="noopener">Putting strings together</a>. </p>
<h1 id="Exercise-6-2"><a href="#Exercise-6-2" class="headerlink" title="Exercise 6-2"></a>Exercise 6-2</h1><p>Write a program to test the find_urls function.</p>
<h2 id="Solution-amp-Results-2"><a href="#Solution-amp-Results-2" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>Please find the program and analysis on <a href="http://quanttour.com/21/03/2018/C-Using-library-algorithms/" target="_blank" rel="noopener">Using library algorithms (Part 1)</a>. </p>
<h1 id="Exercise-6-3-6-4"><a href="#Exercise-6-3-6-4" class="headerlink" title="Exercise 6-3, 6-4"></a>Exercise 6-3, 6-4</h1><p>6-3: What does this program fragment do?</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">u</span><span class="params">(<span class="number">10</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">copy(u.<span class="built_in">begin</span>(), u.<span class="built_in">end</span>(), v.<span class="built_in">begin</span>());</span><br></pre></td></tr></table></figure>
<p>Write a program that contains this fragment, and compile and execute it.</p>
<p>6-4: Correct the program you wrote in the previous exercise to copy from u into v. Thereare at least two possible ways to correct the program. Implement both, and describe the relative advantages and disadvantages of each approach.</p>
<h2 id="Soltion-amp-Results"><a href="#Soltion-amp-Results" class="headerlink" title="Soltion &amp; Results"></a>Soltion &amp; Results</h2><p>The first statement creates an object of <strong>vector<int></strong> and initializes it with 10 elements that all equals to 100. The second statement creates an empty (i.e. due to default initialization) <strong>vector<int> v</strong> . The third statement calls an algorithm <strong>copy</strong> to copy values in the range [u.begin(), u.end()) into the destination denoted by the third argument <strong>v.begin()</strong>. However, the destination sequence should be at least as large as the input range. Therefore, the fragment will lead to compilation errors.</p>
<h3 id="Method-1"><a href="#Method-1" class="headerlink" title="Method 1"></a>Method 1</h3><p>To correct this, we can initialize the <strong>v</strong> as an vector that has the same size as <strong>u</strong>. For example</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>This statement means that <strong>v</strong> contains 10 elements that all equals to 0. Then, the program should work fine. </p>
<h3 id="Method-2"><a href="#Method-2" class="headerlink" title="Method 2"></a>Method 2</h3><p>Alternatively, we can use <strong>back_inserter</strong> to append the copied elements to <strong>v</strong>. It naturelly increases the size of <strong>v</strong> and hence ensures enough space for holding those elements. The third statement is replaced by:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">copy(u.<span class="built_in">begin</span>(), u.<span class="built_in">end</span>(), back_inserter(v));</span><br></pre></td></tr></table></figure>

<h3 id="Method-3"><a href="#Method-3" class="headerlink" title="Method 3"></a>Method 3</h3><p>There is also an iterator adaptor <strong>inserter</strong> that creates an <strong>insert iterator</strong> for successive insertion into a container. Therefore, we can replace the <strong>back_inserter</strong> with <strong>inserter</strong> shown as follows</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">copy(u.<span class="built_in">begin</span>(), u.<span class="built_in">end</span>(), inserter(v, v.<span class="built_in">begin</span>()));</span><br></pre></td></tr></table></figure>
<p>This statement means that the elements of <strong>u</strong> are copied and inserted into <strong>v</strong> starting from the begining position of <strong>v</strong>. </p>
<h3 id="comparison"><a href="#comparison" class="headerlink" title="comparison"></a>comparison</h3><p>All three methods can correct the original program. The first method is not practical as in most cases we probably don’t know the number of elements to copy. Contrarily, method 2 and method 3 ensures enough space for holding elements to copy. However, two iterator adaptors works differently:</p>
<ol>
<li><p><strong>back_inserter</strong> constructs a back-insert iterator that inserts new elements at the end of a container. The container should have member function <strong>push_back</strong>.</p>
</li>
<li><p><strong>inserter</strong> constructs an insert iterator that inserts new elements into a container successively starting from a specified position. The container should have member function <strong>insert</strong>.</p>
</li>
</ol>
<p>Apparently, <strong>inserter</strong> provides more flexibility in inserting elements while <strong>back_inserter</strong> has more limitations. But more research should be done on their performances when dealing with massive data. I present a simple program to show that all three methods work fine and lead to same results.</p>
<h3 id="A-complete-test-program"><a href="#A-complete-test-program" class="headerlink" title="A complete test program"></a>A complete test program</h3><p><strong>Test Program</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>; 	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::copy;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::inserter;<span class="keyword">using</span> <span class="built_in">std</span>::back_inserter;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator iter = vec.<span class="built_in">begin</span>(); iter != vec.<span class="built_in">end</span>(); ++iter)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *iter &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">u</span><span class="params">(<span class="number">10</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// method 1: let v has the same size as u</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    copy(u.<span class="built_in">begin</span>(), u.<span class="built_in">end</span>(), v1.<span class="built_in">begin</span>());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The results of method 1:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">print</span>(v1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// method 2: back_inserter</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">    copy(u.<span class="built_in">begin</span>(), u.<span class="built_in">end</span>(), back_inserter(v2));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The results of method 2:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">print</span>(v1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// method 3: inserter</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v3;</span><br><span class="line">    copy(u.<span class="built_in">begin</span>(), u.<span class="built_in">end</span>(), inserter(v3, v3.<span class="built_in">begin</span>()));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The results of method 3:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">print</span>(v3);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Test Results</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The results of method 1:</span><br><span class="line">100</span><br><span class="line">100</span><br><span class="line">100</span><br><span class="line">100</span><br><span class="line">100</span><br><span class="line">100</span><br><span class="line">100</span><br><span class="line">100</span><br><span class="line">100</span><br><span class="line">100</span><br><span class="line"></span><br><span class="line">The results of method 2:</span><br><span class="line">100</span><br><span class="line">100</span><br><span class="line">100</span><br><span class="line">100</span><br><span class="line">100</span><br><span class="line">100</span><br><span class="line">100</span><br><span class="line">100</span><br><span class="line">100</span><br><span class="line">100</span><br><span class="line"></span><br><span class="line">The results of method 3:</span><br><span class="line">100</span><br><span class="line">100</span><br><span class="line">100</span><br><span class="line">100</span><br><span class="line">100</span><br><span class="line">100</span><br><span class="line">100</span><br><span class="line">100</span><br><span class="line">100</span><br><span class="line">100</span><br></pre></td></tr></table></figure>

<h1 id="Exercise-6-5"><a href="#Exercise-6-5" class="headerlink" title="Exercise 6-5"></a>Exercise 6-5</h1><p>Write an analysis function to call optimistic_median.</p>
<h2 id="Solution-amp-Results-3"><a href="#Solution-amp-Results-3" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>Please find the analysis function here <a href="http://quanttour.com/22/03/2018/C-Using-library-algorithms-Part-2/" target="_blank" rel="noopener">Using library algorithms (Part 2)</a>.</p>
<h1 id="Exercise-6-6"><a href="#Exercise-6-6" class="headerlink" title="Exercise 6-6"></a>Exercise 6-6</h1><p>Note that the function from the previous exercise and the functions from §6.2.2/113and §6.2.3/115 do the same task. Merge these three analysis functions into a singlefunction.</p>
<h2 id="Solution-amp-Results-4"><a href="#Solution-amp-Results-4" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>Please find the solution strategy and analysis here <a href="http://quanttour.com/22/03/2018/C-Using-library-algorithms-Part-2/" target="_blank" rel="noopener">Using library algorithms (Part 2)</a>.</p>
<h1 id="Exercise-6-7"><a href="#Exercise-6-7" class="headerlink" title="Exercise 6-7"></a>Exercise 6-7</h1><p>The portion of the grading analysis program from §6.2.1/110 that read and classified student records depending on whether they did (or did not) do all the homework is similar to the problem we solved in extract_fails. Write a function to handle this subproblem.</p>
<h2 id="Solution-amp-Results-5"><a href="#Solution-amp-Results-5" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>This exercise requires us to seperate the students’ records into two groups: one group contains records that did all homeworks while the other one contains records that did not complete all homeworks. Specifically, we rewrite the main function such that all records will be stored into a <strong>vector<Student_info> did</strong> first, and then we extract and store the other group records into <strong>didnt</strong> via a function named <strong>extract_didnt</strong>. This function can be written exactly the same as the <strong>extract_fails</strong> function developed using the single-pass solution (see <a href="http://quanttour.com/25/03/2018/C-Using-library-algorithms-Part-3/" target="_blank" rel="noopener">Using library algorithms (Part 3)</a>). </p>
<p>I revised the original program described on <a href="http://quanttour.com/22/03/2018/C-Using-library-algorithms-Part-2/" target="_blank" rel="noopener">Using library algorithms (Part 2)</a> by creating a file contains <strong>extract_didnt</strong> function and the predicate <strong>did_all_hw</strong>:</p>
<p><strong>extract_didnt.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;		// to get the declaration of vector</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;		// to get the declaration of stable_partition</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span>	<span class="comment">// to get the declaration of Student_info</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"extract_didnt.h"</span>	<span class="comment">// to get the declaration of extract_didnt</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::stable_partition;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">did_all_hw</span><span class="params">(<span class="keyword">const</span> Student_info &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="built_in">find</span>(s.homework.<span class="built_in">begin</span>(), s.homework.<span class="built_in">end</span>(), <span class="number">0</span>)) == s.homework.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;Student_info&gt; <span class="title">extract_didnt</span><span class="params">(<span class="built_in">vector</span>&lt;Student_info&gt; &amp;did)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Student_info&gt;::iterator iter = stable_partition(did.<span class="built_in">begin</span>(), did.<span class="built_in">end</span>(), did_all_hw);</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;Student_info&gt; <span class="title">didnt</span><span class="params">(iter, did.<span class="built_in">end</span>())</span></span>;</span><br><span class="line">    did.erase(iter, did.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> didnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>extract_didnt.h</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_EXTRACT_DIDNT_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_EXTRACT_DIDNT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">did_all_hw</span><span class="params">(<span class="keyword">const</span> Student_info &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Student_info&gt; <span class="title">extract_didnt</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Student_info&gt; &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* GUARD_EXTRACT_DIDNT_H */</span></span></span><br></pre></td></tr></table></figure>

<p>Correspondingly, the main function becomes</p>
<p><strong>mainfunction.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;			// to get the declaration of cin, cout, endl</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;			// to get the declaration of vector</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span>		<span class="comment">// to get the declaration of Student_inf"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"grades_analysis.h"</span>	        <span class="comment">// to get the declaration of three analysis function</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"write_analysis.h"</span>		<span class="comment">// to get the declaration of write_analysis function</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"extract_didnt.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;		<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Student_info&gt; did;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read the student records</span></span><br><span class="line">    Student_info student;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">read</span>(<span class="built_in">cin</span>, student))</span><br><span class="line">    &#123;</span><br><span class="line">        did.push_back(student);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// extract records that don't complete all the homeworks</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;Student_info&gt; didnt = extract_didnt(did);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// verify thatthe analyses will show us something</span></span><br><span class="line">    <span class="keyword">if</span>(did.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"No student did all the homework!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(didnt.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Every student did all the homework!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do the analysis</span></span><br><span class="line">    write_analysis(<span class="built_in">cout</span>, <span class="string">"median"</span>, median_analysis, did, didnt);</span><br><span class="line">    write_analysis(<span class="built_in">cout</span>, <span class="string">"average"</span>, average_analysis, did, didnt);</span><br><span class="line">    write_analysis(<span class="built_in">cout</span>, <span class="string">"median of homework turned in"</span>, optimistic_median_analysis, did, didnt);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Exercise-6-8"><a href="#Exercise-6-8" class="headerlink" title="Exercise 6-8"></a>Exercise 6-8</h1><p>Write a single function that can be used to classify students based on criteria of your choice. Test this function by using it in place of the extract_fails program, and use it in the program to analyze student grades.</p>
<h2 id="Solution-amp-Results-6"><a href="#Solution-amp-Results-6" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>This exercise asks us to generalize the program in exercise 6-7 such that the program can deal with various kinds of criteria. A possible solution is to pass the <strong>criteria</strong> as arguments to the more generalized function <strong>classify</strong> which will classifies an input sequence according to the <strong>criteria</strong>. By doing so, we can pass different <strong>criteria</strong> to classify the students’ records based on our own preference.<br>Let’s define such <strong>classify</strong> function and put it in a sparate file. </p>
<p><strong>classify.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::stable_partition;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;Student_info&gt; <span class="title">classify</span><span class="params">(<span class="built_in">vector</span>&lt;Student_info&gt; &amp;v, <span class="keyword">bool</span> criteria(<span class="keyword">const</span> Student_info &amp;s))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Student_info&gt;::iterator iter = stable_partition(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), criteria);</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;Student_info&gt; <span class="title">criteria_false</span><span class="params">(iter, v.<span class="built_in">end</span>())</span></span>;</span><br><span class="line">    v.erase(iter, v.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> criteria_false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>classify.h</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_CLASSIFY_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_CLASSIFY_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Student_info&gt; <span class="title">classify</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Student_info&gt; &amp;,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">bool</span> criteria(<span class="keyword">const</span> Student_info &amp;))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* GUARD_CLASSIFY_H */</span></span></span><br></pre></td></tr></table></figure>

<p>Simialr to the <strong>extract_didnt</strong> function defined in exercise 6-7, this function returns a <strong>vector<Student_info></strong> that contains all records that do not satisfy the criteria. The input sequence has also been modified and consequently contains only the records that statisfy the criteria. </p>
<p>To test the new function, the test program is designed to classify the students’ records as three groups (if available): </p>
<ol>
<li>students who fail the final grade</li>
<li>students who pass the grade, and are awarded the first class honours</li>
<li>students who pass the grade, and are awarded the second class honours</li>
</ol>
<p>Firstly, we classify <strong>students</strong> according to criteria <strong>pgrade</strong>, as a result, the records are divided into two groups. By then, <strong>students</strong> contains only the passing records. Secondly, we further classify <strong>students</strong> according to another criterion which allowing us to extract students who are awarded the first class honours.</p>
<p>The test program includes following files:</p>
<ol>
<li><strong>classify.cpp, classify.h</strong>(as shown above)</li>
<li><strong>mainfunction.cpp</strong> </li>
<li><strong>criteria.cpp, criteria.h</strong></li>
<li><strong>grade.cpp, grade.h</strong></li>
<li><strong>Student_info.cpp, Student_info.h</strong></li>
<li><strong>print.cpp, print.h</strong></li>
</ol>
<p>I present ecah file according to above order in below followed by the test results.</p>
<h3 id="A-complete-program"><a href="#A-complete-program" class="headerlink" title="A complete program"></a>A complete program</h3><p><strong>mainfunction.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;			// to get the declaration of cin, cout, endl</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;			// to get the declaration of max</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;			// to get the declaration of vector</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;			// to get the declaration of string</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span>		<span class="comment">// to get the declaration of Student_info</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"criteria.h"</span>			<span class="comment">// to get the declaration of criteria</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"classify.h"</span>			<span class="comment">// to get the declaration of classify</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"print.h"</span>			<span class="comment">// to get the declaration of print</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;		<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">max</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Student_info&gt; students;</span><br><span class="line">    Student_info record;</span><br><span class="line">    <span class="built_in">string</span>::size_type maxlen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read and store all the records, and find the length of the longest name</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">read</span>(<span class="built_in">cin</span>, record))</span><br><span class="line">    &#123;</span><br><span class="line">        maxlen = <span class="built_in">max</span>(maxlen, record.name.<span class="built_in">size</span>());</span><br><span class="line">        students.push_back(record);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// classfiy students according to the criteria: fail and pass</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;Student_info&gt; fails = classify(students, pgrade);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// verify that the analyses will show us something</span></span><br><span class="line">    <span class="keyword">if</span>(fails.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"All students pass the grade!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(students.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"All students fail the grade!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// classfiy students according to the criteria: first class and second class</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;Student_info&gt; first_class_honours = classify(students, second_class_honours);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write lines of outputs</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Students who fails the grade include:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">print</span>(fails, maxlen);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span>(!first_class_honours.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Students who are awarded first class honours include:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">print</span>(first_class_honours, maxlen);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"None of students is awarded first class honours."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span>(!students.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Students who are awarded second class honours include:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">print</span>(students, maxlen);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"congratulations, all the students who "</span></span><br><span class="line">		<span class="string">"pass the grade are awarded first class honours."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>criteria.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"grade.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">fgrade</span><span class="params">(<span class="keyword">const</span> Student_info &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> grade(s) &lt; <span class="number">60</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">pgrade</span><span class="params">(<span class="keyword">const</span> Student_info &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !fgrade(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">first_class_honours</span><span class="params">(<span class="keyword">const</span> Student_info &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> grade(s) &gt;= <span class="number">85</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">second_class_honours</span><span class="params">(<span class="keyword">const</span> Student_info &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (!fgrade(s) &amp;&amp; !first_class_honours(s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>criteria.h</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_CRITERIA_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_CRITERIA_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">fgrade</span><span class="params">(<span class="keyword">const</span> Student_info &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">pgrade</span><span class="params">(<span class="keyword">const</span> Student_info &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">first_class_honours</span><span class="params">(<span class="keyword">const</span> Student_info &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">second_class_honours</span><span class="params">(<span class="keyword">const</span> Student_info &amp;s)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* GUARD_CRITERIA_H */</span></span></span><br></pre></td></tr></table></figure>

<p><strong>grade.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"grade.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::domain_error;  <span class="keyword">using</span> <span class="built_in">std</span>::istream;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;        <span class="keyword">using</span> <span class="built_in">std</span>::sort;</span><br><span class="line"></span><br><span class="line"><span class="comment">// grade function 1</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">const</span> Student_info &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> grade(s.midterm, s.<span class="keyword">final</span>, s.homework);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// grade function 2</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">double</span> midterm, <span class="keyword">double</span> <span class="keyword">final</span>, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;hw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hw.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> domain_error(<span class="string">"student has done no homework"</span>);</span><br><span class="line">    <span class="keyword">return</span> grade(midterm, <span class="keyword">final</span>, median(hw));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// grade function 3</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">double</span> midterm, <span class="keyword">double</span> <span class="keyword">final</span>, <span class="keyword">double</span> homework)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.2</span>*midterm + <span class="number">0.4</span>*<span class="keyword">final</span> + <span class="number">0.4</span>*homework;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compute the median of vector&lt;double&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">median</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// get the size of the vector</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;::size_type vec_size;</span><br><span class="line">    vec_size <span class="built_in">size</span> = vec.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check whether the empty is empty</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span> == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> domain_error(<span class="string">"median of an empty vector"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sort the grades</span></span><br><span class="line">    sort(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// compute the median homework grade</span></span><br><span class="line">    vec_size mid = <span class="built_in">size</span>/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">size</span> % <span class="number">2</span> == <span class="number">0</span> ? (vec[mid] + vec[mid - <span class="number">1</span>])/<span class="number">2</span> : vec[mid];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>grade.h</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_grade_h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_grade_h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// grade.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">const</span> Student_info &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">median</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>Student_info.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>; 	<span class="keyword">using</span> <span class="built_in">std</span>::istream;</span><br><span class="line"></span><br><span class="line"><span class="comment">// argument to the function sort</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> Student_info &amp;x, <span class="keyword">const</span> Student_info &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.name &lt; y.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// read the info</span></span><br><span class="line"><span class="function">istream &amp; <span class="title">read</span><span class="params">(istream &amp;is, Student_info &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// reads and store the student's name, midterm and final exam grades</span></span><br><span class="line">    is &gt;&gt; s.name &gt;&gt; s.midterm &gt;&gt; s.<span class="keyword">final</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reads and store all homework grades</span></span><br><span class="line">    read_hw(is, s.homework);</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// read all homework grades</span></span><br><span class="line"><span class="function">istream &amp; <span class="title">read_hw</span><span class="params">(istream &amp;in, <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;hw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (in)&#123;</span><br><span class="line">        <span class="comment">//get rid of previous contents</span></span><br><span class="line">        hw.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// read homework grades</span></span><br><span class="line">        <span class="keyword">double</span> x;</span><br><span class="line">        <span class="keyword">while</span>(in &gt;&gt; x)</span><br><span class="line">            hw.push_back(x);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// clear the stream so that input will work for the next student</span></span><br><span class="line">        in.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Student_info.h</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_Student_info</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_Student_info</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student_info</span>&#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">double</span> midterm, <span class="keyword">final</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; homework;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> Student_info &amp;, <span class="keyword">const</span> Student_info &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::istream &amp; <span class="title">read</span><span class="params">(<span class="built_in">std</span>::istream &amp;, Student_info &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::istream &amp; <span class="title">read_hw</span><span class="params">(<span class="built_in">std</span>::istream &amp;, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>print.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"grade.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"print.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;		 <span class="keyword">using</span> <span class="built_in">std</span>::setprecision;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;		 <span class="keyword">using</span> <span class="built_in">std</span>::streamsize;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;		 <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;Student_info&gt; &amp;records, <span class="keyword">const</span> <span class="built_in">string</span>::size_type &amp;maxlen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Student_info&gt;::const_iterator iter = records.<span class="built_in">begin</span>(); iter != records.<span class="built_in">end</span>(); ++iter)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// write the name, blanks</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (*iter).name &lt;&lt; <span class="built_in">string</span>(maxlen + <span class="number">1</span> - (*iter).name.<span class="built_in">size</span>(), <span class="string">' '</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// compute and write the final grade</span></span><br><span class="line">        <span class="keyword">double</span> final_grade = grade(*iter);</span><br><span class="line">        streamsize prec = <span class="built_in">cout</span>.precision();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; setprecision(<span class="number">3</span>) &lt;&lt; final_grade &lt;&lt; setprecision(prec) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>print.h</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_PRINT_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_PRINT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Student_info&gt; &amp;records, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>::size_type &amp;maxlen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* GUARD_PRINT_H */</span></span></span><br></pre></td></tr></table></figure>

<h3 id="Test-results"><a href="#Test-results" class="headerlink" title="Test results"></a>Test results</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Inputs:</span><br><span class="line"></span><br><span class="line">Phqgh 24.7879 58.6263 64.0505</span><br><span class="line">Nlfdx 95.4242 27.3636 91.0404</span><br><span class="line">Cxggb 16.1818 95.4747 26.7172</span><br><span class="line">Uxwfn 35.9495 3.11111 22.3333</span><br><span class="line">Tkjpr 68.4747 44.6263 57.3737</span><br><span class="line">Pnrvy 16.3535 90.4242 88.0606</span><br><span class="line">Syycq 5.90909 29.7071 50.0606</span><br><span class="line">Ffmzn 84.5455 56.404 66.7677</span><br><span class="line">Vwsre 23.3737 38.1818 82.2929</span><br><span class="line">Fxtls 4.30303 77.0606 73.8687</span><br><span class="line">Dpooe 29.7778 73.9798 12.8687</span><br><span class="line">Ejuvp 55.7475 31.5253 50.5051</span><br><span class="line">Poeyl 91.0707 37.5758 87.5354</span><br><span class="line">Jvrvi 21.8889 22.4646 6.30303</span><br><span class="line">Hwqnq 55.101 59.2424 37.4848</span><br><span class="line">Jjloo 91.3636 74.202 96.2121</span><br><span class="line">Whmsn 34.5354 99.1818 38</span><br><span class="line">Sfzkv 48.8384 7.21212 10.1717</span><br><span class="line">Lyjyh 51 49.1919 56.9899</span><br><span class="line">Nkkuf 89.0202 95.8586 93.4343</span><br><span class="line"></span><br><span class="line">Outputs:</span><br><span class="line"></span><br><span class="line">Students who fails the grade include:</span><br><span class="line">Phqgh 54</span><br><span class="line">Cxggb 52.1</span><br><span class="line">Uxwfn 17.4</span><br><span class="line">Tkjpr 54.5</span><br><span class="line">Syycq 33.1</span><br><span class="line">Vwsre 52.9</span><br><span class="line">Dpooe 40.7</span><br><span class="line">Ejuvp 44</span><br><span class="line">Jvrvi 15.9</span><br><span class="line">Hwqnq 49.7</span><br><span class="line">Sfzkv 16.7</span><br><span class="line">Lyjyh 52.7</span><br><span class="line"></span><br><span class="line">Students who are awarded first class honours include:</span><br><span class="line">Jjloo 86.4</span><br><span class="line">Nkkuf 93.5</span><br><span class="line"></span><br><span class="line">Students who are awarded second class honours include:</span><br><span class="line">Nlfdx 66.4</span><br><span class="line">Pnrvy 74.7</span><br><span class="line">Ffmzn 66.2</span><br><span class="line">Fxtls 61.2</span><br><span class="line">Poeyl 68.3</span><br><span class="line">Whmsn 61.8</span><br></pre></td></tr></table></figure>

<p>The test program shows our function works perfectly. </p>
<hr>
<h1 id="Exercise-6-9"><a href="#Exercise-6-9" class="headerlink" title="Exercise 6-9"></a>Exercise 6-9</h1><p>Use a library algorithm to concatenate all the elements of a vector<string>.</p>
<h2 id="Solution-amp-Results-7"><a href="#Solution-amp-Results-7" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>The complete program below gives two possible solutions.</p>
<p>The logic of the first solution is that</p>
<ol>
<li>take each element in <strong>vector<string> vec</strong> as an independent container (i.e. a string). </li>
<li>apply <strong>copy</strong> to each independent string and copy all characters from it into a new string to hold the final result. </li>
<li>loop thru the <strong>vector<string> vec</strong> and repeat step 2.</li>
</ol>
<p>Finally, each character contained in each element of the <strong>vector<string> vec</strong> is copied and stored into the new string, which has the same effect as concatenating all the elements of <strong>vec</strong>. </p>
<p>The first solution should works fine but is not a better solution. Because if we don’t use <strong>copy</strong>, we can simply concatenate each element of <strong>vec</strong> without accessing each character. </p>
<p>The second solution applies <strong>accumulate</strong> algorithm to concatenate each element from <strong>vec</strong> directly. <strong>accumulate</strong> returns the sum of all elements of a sequence denoted by its first two arguments. The third argument provides the initial value for the summation and determines the type of the returned value. In this case, the initial value is set to an empty string. </p>
<p><strong>A complete program</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;	// to get the declaration of cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;	// to get the declaration of copy</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;	// to get the declaration of back_inserter</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;	// to get the declaration of vector</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;	// to get the declaration of string</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;      // to get the declaration of accumulate</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;			<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;			<span class="keyword">using</span> <span class="built_in">std</span>::copy;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;			<span class="keyword">using</span> <span class="built_in">std</span>::back_inserter;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::accumulate;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vec&#123;<span class="string">"Please"</span>, <span class="string">"write"</span>, <span class="string">"an"</span>, <span class="string">"analysis"</span>, <span class="string">"function"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// method 1</span></span><br><span class="line">    <span class="built_in">string</span> vecCopy1;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::const_iterator iter = vec.<span class="built_in">begin</span>(); iter != vec.<span class="built_in">end</span>(); ++iter)</span><br><span class="line">    &#123;</span><br><span class="line">        copy((*iter).<span class="built_in">begin</span>(), (*iter).<span class="built_in">end</span>(), back_inserter(vecCopy1));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; vecCopy1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// method 2</span></span><br><span class="line">    <span class="built_in">string</span> vecCopy2;</span><br><span class="line">    vecCopy2 = accumulate(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), vecCopy2);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; vecCopy2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The results below show that both two methods work fine and give correct results.</p>
<p><strong>Results</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Pleasewriteananalysisfunction</span><br><span class="line">Pleasewriteananalysisfunction</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>Koenig, A. and Moo, B.E., 2000. Accelerated C++.</p>
<p>Lippman, S.B., Lajoie, J. and Moo, B.E., 2013. C++ Primer, 5th edt.</p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Accelerated C++ Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ - Using library algorithms (Part 3)</title>
    <url>/2018/03/25/C-Using-library-algorithms-Part-3/</url>
    <content><![CDATA[<h1 id="Revisit-the-classifying-program"><a href="#Revisit-the-classifying-program" class="headerlink" title="Revisit the classifying program"></a>Revisit the classifying program</h1><p>Recalling the <strong>extract_fails</strong> function developed in last chapter:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;Student_info&gt; <span class="title">extract_fails</span><span class="params">(<span class="built_in">vector</span>&lt;Student_info&gt;&amp; students)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="built_in">vector</span>&lt;Student_info&gt; fail;    </span><br><span class="line">    <span class="built_in">vector</span>&lt;Student_info&gt;::size_type i = <span class="number">0</span>;    </span><br><span class="line">    <span class="comment">// invariant:elements [0, i) of students represent passing grades     </span></span><br><span class="line">    <span class="keyword">while</span> (i != students.<span class="built_in">size</span>()) </span><br><span class="line">    &#123;         </span><br><span class="line">        <span class="keyword">if</span> (fgrade(students[i]))</span><br><span class="line">        &#123;            </span><br><span class="line">            fail.push_back(students[i]);            </span><br><span class="line">            students.erase(students.<span class="built_in">begin</span>() + i);        </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span>            </span><br><span class="line">            ++i;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> fail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Instead of using member functions like <strong>push_back</strong> and <strong>erase</strong>, we can also apply library algorithms to accomplish the task that extracts failing records. Following parts introduce two algorithmic solutions.</p>
<h2 id="A-two-pass-solution"><a href="#A-two-pass-solution" class="headerlink" title="A two-pass solution"></a>A two-pass solution</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;Student_info&gt; <span class="title">extract_fails</span><span class="params">(<span class="built_in">vector</span>&lt;Student_info&gt; &amp;students)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Student_info&gt; fails;</span><br><span class="line">    remove_copy_if(students.<span class="built_in">begin</span>(), students.<span class="built_in">end</span>(), back_inserter(fails), pgrade);</span><br><span class="line"></span><br><span class="line">    students.erase(remove_if(students.<span class="built_in">begin</span>(), students.<span class="built_in">end</span>(), fgrade), students.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> fails;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This function uses <strong>remove_copy_if</strong> algorithm to copy all failing records from <strong>students</strong> into a new <strong>vector<Student_info> fails</strong>. <strong>remove_copy_if</strong> finds and “removes”(i.e. not copy) all values that satisfy the predicate <strong>pgrade</strong>. Apparently, <strong>pgrade</strong> is a predicate on grades and returns true if the final grade is equal or greater than 60. In other words, it is a predicate that reverts the results of calling <strong>fgrade</strong>.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">pgrade</span><span class="params">(<span class="keyword">const</span> Student_info &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !fgrade(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>However, <strong>remove_copy_if</strong> works similar to <strong>remove_copy</strong>. Both two algorithms won’t change the input sequence instead they copy the remaining values into a new vector. Therefore, we need one step more to modify <strong>students</strong>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">students.erase(remove_if(students.<span class="built_in">begin</span>(), students.<span class="built_in">end</span>(), fgrade), students.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>
<p>In this statements, <strong>remove_if</strong> finds and “removes” all values that satisfies the predicate <strong>fgrade</strong>. However, the tricky point is that how does it remove those faling records？</p>
<p><em>The removal is done by replacing the elements for which pred returns true by the next element for which it does not, and signaling the new size of the shortened range by returning an iterator to the element that should be considered its new past-the-end element. The relative order of the elements not removed is preserved, while the elements between the returned iterator and last are left in a valid but unspecified state</em> (see <a href="http://www.cplusplus.com/reference/algorithm/remove_if/" target="_blank" rel="noopener">remove_if</a>).</p>
<p>For example, we have a sequence of final grades:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s0(pass), s1(fail), s2(fail), s3(pass), s4(pass), s5(fail)</span><br></pre></td></tr></table></figure>
<p>After the execution of <strong>remove_if</strong> function like above, the sequence becomes</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s0(pass), ns1(pass), ns2(pass), s3(pass), s4(pass), s5(fail)</span><br></pre></td></tr></table></figure>
<p>It copies passing records, s3 and s4, and replacing the faling records, s1 and s2. Then, it returns an iterator that refers to s3. The elements beteen s3 and s.end() (i.e. one past s5) are still there. Therefore, we need to erase them using <strong>erase</strong> function, resulting that only passing grades are left. The <strong>erase</strong> function here takes two arguments which denote a range of elements to be erased. It returns the new <strong>students.end()</strong>. </p>
<h2 id="A-single-pass-solution"><a href="#A-single-pass-solution" class="headerlink" title="A single pass solution"></a>A single pass solution</h2><p>The two pass solution seems not very ideal as it computes each final grade twice. Another algorithm <strong>stable_partition</strong> solves this by seperating a sequence into two pieces using a predicate. For example,</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">stable_partition(students.<span class="built_in">begin</span>(), students.<span class="built_in">end</span>(), pgrade);</span><br></pre></td></tr></table></figure>
<p>This algorithm rearranges the sequence and put all elements that satisfy <strong>pgrade</strong> ahead of the elements that do not satisfy <strong>pgrade</strong>. Then, it returns an iterator that denotes the first element of the second group (i.e. one past the last element of the first group). If all values do not satisfy the <strong>pgrade</strong>, the returned iterator refers to the first element of the sequence. </p>
<p>Now we can rewrite the extract_fail function applying <strong>stable_partition</strong> algorithm. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;Student_info&gt; <span class="title">extract_fails</span><span class="params">(<span class="built_in">vector</span>&lt;Student_info&gt; &amp;students)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Student_info&gt;::iterator iter = stable_partition(students.<span class="built_in">begin</span>(), students.<span class="built_in">end</span>(), pgrade);</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;Student_info&gt; <span class="title">fails</span><span class="params">(iter, students.<span class="built_in">end</span>())</span></span>;</span><br><span class="line">    students.erase(iter, students.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> fails;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="A-complete-program"><a href="#A-complete-program" class="headerlink" title="A complete program"></a>A complete program</h2><p>I revised the program that developed in <a href="http://quanttour.com/19/03/2018/Accelerated-C-Solutions-to-Exercises-Chapter-5-Part-3/" target="_blank" rel="noopener">Exercise 5-6</a> by replacing the original <strong>extract_fails</strong> function with above two functions. The new program accomplishes a simple comparison of the two alternatives. All files and the test results can be found in the remainder of this post. </p>
<p><strong>file list</strong></p>
<ol>
<li><strong>mainfunction.cpp</strong>.</li>
<li><strong>extract_fails.cpp, extract_fails.h</strong>: declares and defines functions including <strong>fgrade, pgrade, extract_fails_m1, extract_fails_m2</strong>.</li>
<li><strong>grade.cpp, grade.h</strong>: declares and defines functions including <strong>grade, median</strong>.</li>
<li><strong>Student_info.cpp, Student_info.h</strong>: declares and defines functions including <strong>compare, read, read_hw</strong>, and <strong>Student_info</strong> type struct.</li>
<li><strong>print.cpp, print.h</strong>: declares and defines functions including <strong>print</strong>.</li>
</ol>
<hr>
<p><strong>mainfunction.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Accelerated C++ Solutions Exercises 6-0: the revised extract_fails</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;        </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"grade.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"print.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"extract_fails.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;				<span class="keyword">using</span> <span class="built_in">std</span>::sort;			<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">max</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>; 			<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;			<span class="keyword">using</span> <span class="built_in">std</span>::domain_error;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;			<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">max</span>;				<span class="keyword">using</span> <span class="built_in">std</span>::stable_partition;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;			<span class="keyword">using</span> <span class="built_in">std</span>::remove_copy;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::remove_copy_if;  <span class="keyword">using</span> <span class="built_in">std</span>::back_inserter;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Student_info&gt; students;</span><br><span class="line">    Student_info record;</span><br><span class="line">    <span class="built_in">string</span>::size_type maxlen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read and store all the records, and find the length of the longest name</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">read</span>(<span class="built_in">cin</span>, record))</span><br><span class="line">    &#123;</span><br><span class="line">        maxlen = <span class="built_in">max</span>(maxlen, record.name.<span class="built_in">size</span>());</span><br><span class="line">        students.push_back(record);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">// measure the performance for two pass solution</span></span><br><span class="line">        <span class="keyword">typedef</span> <span class="built_in">std</span>::chrono::high_resolution_clock Clock;</span><br><span class="line">        Clock::time_point startTime = Clock::now();				 <span class="comment">// get current time</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;Student_info&gt; fails = extract_fails_m1(students); <span class="comment">// extract records for failing students</span></span><br><span class="line">        Clock::time_point endTime = Clock::now();				 <span class="comment">// get current time</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"The two pass solution took me "</span></span><br><span class="line">             &lt;&lt;	<span class="built_in">std</span>::chrono::duration_cast&lt;<span class="built_in">std</span>::chrono::duration&lt;<span class="keyword">double</span>&gt;&gt;(endTime - startTime).count() &lt;&lt; <span class="string">" seconds"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// measure the performance for one pass solution</span></span><br><span class="line">        startTime = Clock::now();								 <span class="comment">// get current time</span></span><br><span class="line">        fails = extract_fails_m2(students); <span class="comment">// extract records for failing students</span></span><br><span class="line">        endTime = Clock::now();									 <span class="comment">// get current time</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"The one pass solution took me "</span></span><br><span class="line">             &lt;&lt;	<span class="built_in">std</span>::chrono::duration_cast&lt;<span class="built_in">std</span>::chrono::duration&lt;<span class="keyword">double</span>&gt;&gt;(endTime - startTime).count() &lt;&lt; <span class="string">" seconds"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// write each line of outputs for passing students</span></span><br><span class="line">        <span class="keyword">if</span> (!students.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//alphabetize the records</span></span><br><span class="line"></span><br><span class="line">            sort(students.<span class="built_in">begin</span>(), students.<span class="built_in">end</span>(), compare);</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Students who passed: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="built_in">print</span>(students, maxlen);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"What a pity! all students failed."</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// write a blank line</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// // write each line of outputs for failing students</span></span><br><span class="line">        <span class="keyword">if</span>(!fails.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//alphabetize the records</span></span><br><span class="line"></span><br><span class="line">            sort(fails.<span class="built_in">begin</span>(), fails.<span class="built_in">end</span>(), compare);</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Students who failed: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="built_in">print</span>(fails, maxlen);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Congratulations! all students passed."</span>;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span>(domain_error e)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; e.what();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>extract_fails.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;			</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;		</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;			</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span>	</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"grade.h"</span>			</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"extract_fails.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;		<span class="keyword">using</span> <span class="built_in">std</span>::stable_partition;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::remove_if;	<span class="keyword">using</span> <span class="built_in">std</span>::remove_copy_if;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::back_inserter;</span><br><span class="line"></span><br><span class="line"><span class="comment">// predicate</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">fgrade</span><span class="params">(<span class="keyword">const</span> Student_info &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> grade(s) &lt; <span class="number">60</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// predicate</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">pgrade</span><span class="params">(<span class="keyword">const</span> Student_info &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !fgrade(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// two-pass solution</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;Student_info&gt; <span class="title">extract_fails_m1</span><span class="params">(<span class="built_in">vector</span>&lt;Student_info&gt; &amp;students)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Student_info&gt; fails;</span><br><span class="line">    remove_copy_if(students.<span class="built_in">begin</span>(), students.<span class="built_in">end</span>(), back_inserter(fails), pgrade);</span><br><span class="line"></span><br><span class="line">    students.erase(remove_if(students.<span class="built_in">begin</span>(), students.<span class="built_in">end</span>(), fgrade), students.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> fails;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// single-pass solution</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;Student_info&gt; <span class="title">extract_fails_m2</span><span class="params">(<span class="built_in">vector</span>&lt;Student_info&gt; &amp;students)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Student_info&gt;::iterator iter = stable_partition(students.<span class="built_in">begin</span>(), students.<span class="built_in">end</span>(), pgrade);</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;Student_info&gt; <span class="title">fails</span><span class="params">(iter, students.<span class="built_in">end</span>())</span></span>;</span><br><span class="line">    students.erase(iter, students.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> fails;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>extract_fails.h</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_EXTRACT_FAILS_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_EXTRACT_FAILS_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">fgrade</span><span class="params">(<span class="keyword">const</span> Student_info &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">pgrade</span><span class="params">(<span class="keyword">const</span> Student_info &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Student_info&gt; <span class="title">extract_fails_m1</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Student_info&gt; &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Student_info&gt; <span class="title">extract_fails_m2</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Student_info&gt; &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* GUARD_EXTRACT_FAILS_H */</span></span></span><br></pre></td></tr></table></figure>

<p><strong>grade.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"grade.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::domain_error;  <span class="keyword">using</span> <span class="built_in">std</span>::istream;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;        <span class="keyword">using</span> <span class="built_in">std</span>::sort;</span><br><span class="line"></span><br><span class="line"><span class="comment">// grade function 2</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">const</span> Student_info &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> grade(s.midterm, s.<span class="keyword">final</span>, s.homework);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// grade function 2</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">double</span> midterm, <span class="keyword">double</span> <span class="keyword">final</span>, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;hw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hw.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> domain_error(<span class="string">"student has done no homework"</span>);</span><br><span class="line">    <span class="keyword">return</span> grade(midterm, <span class="keyword">final</span>, median(hw));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// grade function 3</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">double</span> midterm, <span class="keyword">double</span> <span class="keyword">final</span>, <span class="keyword">double</span> homework)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.2</span>*midterm + <span class="number">0.4</span>*<span class="keyword">final</span> + <span class="number">0.4</span>*homework;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compute the median of vector&lt;double&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">median</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// get the size of the vector</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;::size_type vec_size;</span><br><span class="line">    vec_size <span class="built_in">size</span> = vec.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check whether the empty is empty</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span> == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> domain_error(<span class="string">"median of an empty vector"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sort the grades</span></span><br><span class="line">    sort(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// compute the median homework grade</span></span><br><span class="line">    vec_size mid = <span class="built_in">size</span>/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">size</span> % <span class="number">2</span> == <span class="number">0</span> ? (vec[mid] + vec[mid - <span class="number">1</span>])/<span class="number">2</span> : vec[mid];</span><br><span class="line">&#125;</span><br><span class="line">···</span><br><span class="line"></span><br><span class="line">**grade.h**</span><br><span class="line">```c++</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_grade_h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_grade_h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// grade.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">const</span> Student_info &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">median</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>Student_info.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>; <span class="keyword">using</span> <span class="built_in">std</span>::istream;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> Student_info &amp;x, <span class="keyword">const</span> Student_info &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.name &lt; y.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">istream &amp; <span class="title">read</span><span class="params">(istream &amp;is, Student_info &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// reads and store the student's name, midterm and final exam grades</span></span><br><span class="line">    is &gt;&gt; s.name &gt;&gt; s.midterm &gt;&gt; s.<span class="keyword">final</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reads and store all homework grades</span></span><br><span class="line">    read_hw(is, s.homework);</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">istream &amp; <span class="title">read_hw</span><span class="params">(istream &amp;in, <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;hw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (in)&#123;</span><br><span class="line">        <span class="comment">//get rid of previous contents</span></span><br><span class="line">        hw.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// read homework grades</span></span><br><span class="line">        <span class="keyword">double</span> x;</span><br><span class="line">        <span class="keyword">while</span>(in &gt;&gt; x)</span><br><span class="line">            hw.push_back(x);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// clear the stream so that input will work for the next student</span></span><br><span class="line">        in.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Student_info.h</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_Student_info</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_Student_info</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student_info</span>&#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">double</span> midterm, <span class="keyword">final</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; homework;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> Student_info &amp;, <span class="keyword">const</span> Student_info &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::istream &amp; <span class="title">read</span><span class="params">(<span class="built_in">std</span>::istream &amp;, Student_info &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::istream &amp; <span class="title">read_hw</span><span class="params">(<span class="built_in">std</span>::istream &amp;, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>print.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"grade.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"print.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;		 <span class="keyword">using</span> <span class="built_in">std</span>::setprecision;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;		 <span class="keyword">using</span> <span class="built_in">std</span>::streamsize;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;		 <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;Student_info&gt; &amp;records, <span class="keyword">const</span> <span class="built_in">string</span>::size_type &amp;maxlen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Student_info&gt;::const_iterator iter = records.<span class="built_in">begin</span>(); iter != records.<span class="built_in">end</span>(); ++iter)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">// write the name, blanks</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (*iter).name &lt;&lt; <span class="built_in">string</span>(maxlen + <span class="number">1</span> - (*iter).name.<span class="built_in">size</span>(), <span class="string">' '</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// compute and write the final grade</span></span><br><span class="line">        <span class="keyword">double</span> final_grade = grade(*iter);</span><br><span class="line">        streamsize prec = <span class="built_in">cout</span>.precision();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; setprecision(<span class="number">3</span>) &lt;&lt; final_grade &lt;&lt; setprecision(prec) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>print.h</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_PRINT_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_PRINT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Student_info&gt; &amp;, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>::size_type &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* GUARD_PRINT_H */</span></span></span><br></pre></td></tr></table></figure>

<h2 id="Performance-comparison"><a href="#Performance-comparison" class="headerlink" title="Performance comparison"></a>Performance comparison</h2><table>
<thead>
<tr>
<th align="left">Number of lines</th>
<th align="left">Two-pass solution</th>
<th align="left">Single-pass solution</th>
</tr>
</thead>
<tbody><tr>
<td align="left">10</td>
<td align="left">0.001035  seconds</td>
<td align="left">0.000000  seconds</td>
</tr>
<tr>
<td align="left">1000</td>
<td align="left">0.006006 seconds</td>
<td align="left">0.000993 seconds</td>
</tr>
<tr>
<td align="left">10000</td>
<td align="left">0.017035 seconds</td>
<td align="left">0.003023 seconds</td>
</tr>
</tbody></table>
<p>The results shows as expected that the single-pass solution has much better performance that the two-pass solution. </p>
<h1 id="A-simple-summary"><a href="#A-simple-summary" class="headerlink" title="A simple summary"></a>A simple summary</h1><p><em><strong>Algorithm act on container elements but do not act on containers and do not change the size of a container</strong></em>. </p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Notes</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ - Using library algorithms (Part 2)</title>
    <url>/2018/03/22/C-Using-library-algorithms-Part-2/</url>
    <content><![CDATA[<h1 id="Revisit-the-grading-program"><a href="#Revisit-the-grading-program" class="headerlink" title="Revisit the grading program"></a>Revisit the grading program</h1><p>This section redesigns the grading program described in <a href="http://quanttour.com/08/03/2018/Organizing-programs-and-data-Part-2/" target="_blank" rel="noopener">Organizing programs with data structures</a>. The new program is required to include extra two grading schemes(Koenig and Moo 2000):</p>
<p><em>1. using the average instead of the median, and treating those assignments that the student failed to turn in as zero.</em><br><em>2. using the median of only the assignments that the student actually submitted.</em></p>
<p>Further, the program should solve following problems based on these grading schemes:</p>
<p><em>1. reading all the student records, separating the students who did all the homework from the others.</em><br><em>2. apply each of the grading schemes to all the students in each group, and report the median grade of each group.</em></p>
<p>Now, let’s follow the instructions and finish this program step by step.</p>
<h2 id="Reading-and-Separating-the-students-records"><a href="#Reading-and-Separating-the-students-records" class="headerlink" title="Reading and Separating the students records"></a>Reading and Separating the students records</h2><p>According to the first problem, we need to read and separate the students records into two groups, one group of which includes students who did all homeworks, and another group includes students who didn’t submit all homeworks. The <strong>read</strong> function has been introduced before and hence no further analysis. What is the next is to use a predict on students’ records and store the records separately based on the check results.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">did_all_hw</span><span class="params">(<span class="keyword">const</span> Student_info &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="built_in">find</span>(s.homework.<span class="built_in">begin</span>(), s.homework.<span class="built_in">end</span>(), <span class="number">0</span>)) == s.homework.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The return statements in the function body means that if none of the homework grades equal to 0, the function returns <strong>true</strong>. The idea behind it is that overdue homeworks are given 0 grades. </p>
<p>Now this part can be accomplished with following code:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// to hold two groups of students records</span></span><br><span class="line"><span class="built_in">vector</span>&lt;Student_info&gt; did, didnt;   </span><br><span class="line">Student_info student;</span><br><span class="line"></span><br><span class="line"><span class="comment">// read all the records and separating them based on whether all homework was done</span></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">read</span>(<span class="built_in">cin</span>, student))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(did_all_hw(student))</span><br><span class="line">        did.push_back(student);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        didnt.push_back(student);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// check that both groups contain dada</span></span><br><span class="line"><span class="keyword">if</span> (did.empty())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"No student did all the homework!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (didnt.empty())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Every student did all the homework!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Three-grading-schemes"><a href="#Three-grading-schemes" class="headerlink" title="Three grading schemes"></a>Three grading schemes</h2><p>Before we go into the second problem, we need to solve three grading schemes first. All schemes compute the final grade as the weighted average of midterm exam grade, final exam grade, and homework grade. The grade function below returns the final grade if it is called. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">double</span> midterm, <span class="keyword">double</span> <span class="keyword">final</span>, <span class="keyword">double</span> homework)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.2</span>*midterm + <span class="number">0.4</span>*<span class="keyword">final</span> + <span class="number">0.4</span>*homework;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Midterm grade and final exam grade are fixed values once the information are read in. However, the homework grade can be computed using different methods depending on the grading schemes. Specifically:</p>
<ol>
<li>scheme 1: computes the homework grade as the median value of homework grades.</li>
<li>scheme 2: computes the homework grade as the average value of homework grades.</li>
<li>scheme 3: computes the homework grade as the median value of homework grades excluding the zero grades (i.e. grades for overdue homeworks). </li>
</ol>
<p>In addition, if one did not do homework at all, his homework grade would be set to 0. </p>
<p>Fundamentally, there are two types of homework grade, one is the median value and another is the average value. Here are the two functions that return the median value and average value of a sequence of double values stored in a <strong>vector<double></strong>,  respectively. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fundermental functions 1: returns the median value of vector&lt;double&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">median</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// get the size of the vector</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;::size_type vec_size;</span><br><span class="line">    vec_size <span class="built_in">size</span> = vec.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check whether the empty is empty</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span> == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> domain_error(<span class="string">"median of an empty vector"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sort the grades</span></span><br><span class="line">    sort(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// compute the median homework grade</span></span><br><span class="line">    vec_size mid = <span class="built_in">size</span>/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">size</span> % <span class="number">2</span> == <span class="number">0</span> ? (vec[mid] + vec[mid - <span class="number">1</span>])/<span class="number">2</span> : vec[mid];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fundermental functions 2: returns the average value of vector&lt;double&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">average</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// check whether the empty is empty</span></span><br><span class="line">    <span class="keyword">if</span> (v.empty())</span><br><span class="line">        <span class="keyword">throw</span> domain_error(<span class="string">"average of an empty vector"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> accumulate(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">0.0</span>) / v.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>What’s the new idea in above functions is that we compute the average using the <strong>accumulate</strong> algorithm. The <strong>accomulate</strong> is defined in the staandard header <numeric>. It takes three arguments, the first two of which denotes a range of values to be summed while the third arguments gives the initial value for the summation. It is worth noting that we uses <strong>0.0</strong> rather than <strong>0</strong> due to the fact the type of the resulted sum is the type of the third argument. </p>
<p>Note that I slightly changes the <strong>average</strong> function provided in the book for the purpose of avoiding the case that <strong>v.size() == 0</strong>. As mentioned earlier, if one did not submit one or more homeworks, he would get 0 grades for the corresponding homeworks. But, the program may encounter the case that there is no any inputs for the homeworks, e.g.  when someone did not do homeworks at all. To response this case, the homework grade is set to 0 directly. We need to catch the exception and handle the case in next step. </p>
<h3 id="The-median-grading-scheme"><a href="#The-median-grading-scheme" class="headerlink" title="The median grading scheme"></a>The <strong>median</strong> grading scheme</h3><p>We are familar with the first grading scheme, that is, the original scheme we used to compute the final grade, in previous chapters. For convenience sake, I renamed the original functions <strong>grade</strong> as <strong>median_grade</strong> (as shown below). </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">/ grading scheme <span class="number">1</span>: <span class="keyword">final</span> grade is based on the median homework grade</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">median_grade</span><span class="params">(<span class="keyword">const</span> Student_info &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> median_grade(s.midterm, s.<span class="keyword">final</span>, s.homework);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// grading scheme 1: overloaded median_grade function</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">median_grade</span><span class="params">(<span class="keyword">double</span> midterm, <span class="keyword">double</span> <span class="keyword">final</span>, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;hw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hw.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> domain_error(<span class="string">"student has done no homework"</span>);</span><br><span class="line">    <span class="keyword">return</span> grade(midterm, <span class="keyword">final</span>, median(hw));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// grading scheme 1: auxiliary median_grade function</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">median_grade_aux</span><span class="params">(<span class="keyword">const</span> Student_info &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> median_grade(s);</span><br><span class="line">	&#125;<span class="keyword">catch</span> (domain_error)&#123;</span><br><span class="line">		<span class="comment">// students who did no homework at all, get 0 homework grade</span></span><br><span class="line">		<span class="keyword">return</span> grade(s.midterm, s.<span class="keyword">final</span>, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>It can be observed that a new function, <strong>median_grade_aux</strong> ,is included for the <strong>median</strong> grading scheme. The reason is that we’ll pass the <strong>median_gade</strong> as an argument, however, we cann’t pass an overloaded function easily. Therefore, we define an auxiliary function and handle the exception in this function. As analysed above, the function return a <strong>0</strong> homework grade once catches an exception. </p>
<h3 id="The-average-grading-scheme"><a href="#The-average-grading-scheme" class="headerlink" title="The average grading scheme"></a>The <strong>average</strong> grading scheme</h3><p>The <strong>average</strong> based final grade is computed exactly the same as the <strong>median</strong> version as long as we replace the <strong>median</strong> value as the <strong>average</strong> value. The function handles the exception in the same manner.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// grading scheme 2: final grade is based on average homework grades</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">average_grade</span><span class="params">(<span class="keyword">const</span> Student_info &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> grade(s.midterm, s.<span class="keyword">final</span>, average(s.homework));</span><br><span class="line">    &#125;<span class="keyword">catch</span> (domain_error)&#123;</span><br><span class="line">        <span class="comment">// students who did no homework at all, get 0 homework grade</span></span><br><span class="line">        <span class="keyword">return</span> grade(s.midterm, s.<span class="keyword">final</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="The-optimistic-median-grading-scheme"><a href="#The-optimistic-median-grading-scheme" class="headerlink" title="The optimistic_median grading scheme"></a>The <strong>optimistic_median</strong> grading scheme</h3><p>The third grading scheme is named as <strong>optimistic median</strong> as it ignores the zero homework grades and consequently improves students’ overall performances. Following code shows how this function works.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// grading scheme 3: final grade is based on median of the completed homework grades,</span></span><br><span class="line"><span class="comment">// and students who did no homework at all will get 0 homework grade</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">optimistic_median</span><span class="params">(<span class="keyword">const</span> Student_info &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; nonzero;</span><br><span class="line">    remove_copy(s.homework.<span class="built_in">begin</span>(), s.homework.<span class="built_in">end</span>(), back_inserter(nonzero), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(nonzero.empty())</span><br><span class="line">        <span class="keyword">return</span> grade(s.midterm, s.<span class="keyword">final</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> grade(s.midterm, s.<span class="keyword">final</span>, median(nonzero));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>remove_copy</strong> algorithm takes four arguments. It searches from the range denoted by first two iterators, and finds all values that match a value given by its fourth argument. Then, these values are “removed” and the remaining elements are copied into a new <strong>vector<double> nonzero</strong>. It doesn’t change the input sequence. In addition, <strong>back_inserter</strong> is applied to append the copied values to the new vector, which ensures that the space is enough for holding all the elements.</p>
<h2 id="Analyze-the-grades"><a href="#Analyze-the-grades" class="headerlink" title="Analyze the grades"></a>Analyze the grades</h2><p>The next step is to apply each of above schemes to each group, that is, to compute the median of each group. Let’s have a look at the function that returns the median grade of a <strong>vector<Student_info> students</strong> based on the median homework grade. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">median_analysis</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;Student_info&gt; &amp;students)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; grades;</span><br><span class="line"></span><br><span class="line">	transform(students.<span class="built_in">begin</span>(), students.<span class="built_in">end</span>(), back_inserter(grades), median_grade_aux);</span><br><span class="line">	<span class="keyword">return</span> median(grades);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The function introduces a new algorithm <strong>transform</strong> which calls <strong>median_grade_aux</strong>, namely the transform function, and stores the result into a new vector. The first two iterators specify a range of elements to transform. <strong>back_inserter</strong> provides the destination and ensures that there is enough for the elements. Finally, the function returns the median value of the final grades.</p>
<p>Analogously, we can define another two functions that return average homework grade based median grade and optimistic median homework grade based median grade. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// average</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">average_analysis</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;Student_info&gt; &amp;students)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; grades;</span><br><span class="line"></span><br><span class="line">	transform(students.<span class="built_in">begin</span>(), students.<span class="built_in">end</span>(), back_inserter(grades), average_grade);</span><br><span class="line">	<span class="keyword">return</span> median(grades);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// median of the completed homework</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">optimistic_median_analysis</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;Student_info&gt; &amp;students)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; grades;</span><br><span class="line">	transform(students.<span class="built_in">begin</span>(), students.<span class="built_in">end</span>(), back_inserter(grades), optimistic_median);</span><br><span class="line">	<span class="keyword">return</span> median(grades);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Report-the-analysis"><a href="#Report-the-analysis" class="headerlink" title="Report the analysis"></a>Report the analysis</h2><p>As described above, we need to compute three types of median grade for both two groups. In addition, we would better to generate a report such that we can compare two groups regarding to one specific type of median grade. The code below shows how we incorporate these driven factors into a analysis function:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_analysis</span><span class="params">(ostream &amp;out, <span class="keyword">const</span> <span class="built_in">string</span> &amp;name,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">double</span> analysis(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;Student_info&gt; &amp;),</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">const</span> <span class="built_in">vector</span>&lt;Student_info&gt; &amp;did,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">const</span> <span class="built_in">vector</span>&lt;Student_info&gt; &amp;didnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	out &lt;&lt; name &lt;&lt; <span class="string">": median(did) = "</span> &lt;&lt; analysis(did)</span><br><span class="line">			&lt;&lt; <span class="string">": median(didnt) = "</span> &lt;&lt; analysis(didnt) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This function takes four arguments, of which: the first is an object of the <strong>outstream</strong>; the second is a function; the third and fourth arguments are two objects of <strong>vector<Student_info></strong>. What’ new here is that when passing a function as a parameter, we declare the parameter exactly as the same as ddeclare the function itself. Apparently, we’ll pass three analysis function defined above to this write analysis function. </p>
<h2 id="A-complete-program"><a href="#A-complete-program" class="headerlink" title="A complete program"></a>A complete program</h2><p>Now, we can complete the main function:</p>
<p><strong>mainfunction.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;	    // to get the declaration of cin, cout, endl</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;	    // to get the declaration of vector</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span>   <span class="comment">// to get the declaration of Student_info</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"did_all_hw.h"</span>	    <span class="comment">// to get the declatation of the predicate on students' records</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"grades_analysis.h"</span><span class="comment">// to get the declaration of three analysis function</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"write_analysis.h"</span> <span class="comment">// to get the declaration of write_analysis function</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;		<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// students who did and didn't do all their homework</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;Student_info&gt; did, didnt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read the student records and partition time</span></span><br><span class="line">    Student_info student;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">read</span>(<span class="built_in">cin</span>, student))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(did_all_hw(student))</span><br><span class="line">            did.push_back(student);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            didnt.push_back(student);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// verify thatthe analyses will show us something</span></span><br><span class="line">    <span class="keyword">if</span>(did.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"No student did all the homework!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(didnt.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Every student did all the homework!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do the analysis</span></span><br><span class="line">    write_analysis(<span class="built_in">cout</span>, <span class="string">"median"</span>, median_analysis, did, didnt);</span><br><span class="line">    write_analysis(<span class="built_in">cout</span>, <span class="string">"average"</span>, average_analysis, did, didnt);</span><br><span class="line">    write_analysis(<span class="built_in">cout</span>, <span class="string">"median of homework turned in"</span>, optimistic_median_analysis, did, didnt);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>I had seperate other functions into different files according to my own preference:</p>
<ol>
<li><p><strong>mainfunction.cpp</strong> (as shown above).</p>
</li>
<li><p><strong>did_all_hw.cpp</strong>, <strong>did_all_hw.h</strong>: including the function <strong>did_all_hw</strong>.</p>
</li>
<li><p><strong>gradingSchemes.cpp</strong>, <strong>gradingSchemes.h</strong>: covering following functions</p>
<ul>
<li><strong>grade, median, average, median_grade, median_grade_aux, average_grade, optimistic_median</strong>.</li>
</ul>
</li>
<li><p><strong>grades_analysis.cpp</strong>, <strong>grades_analysis.h</strong>: covering following functions</p>
<ul>
<li><strong>median_analysis, average_analysis, optimistic_grade_median</strong>.</li>
</ul>
</li>
<li><p><strong>write_analysis.cpp, write_analysis.h</strong>: including the function <strong>write_analysis</strong>.</p>
</li>
<li><p><strong>Student_info.cpp, Stuent_info.h</strong>: covering following functions</p>
<ul>
<li><strong>compare, read, read_hw</strong>.</li>
</ul>
</li>
</ol>
<p>All profiles are presented below in order.</p>
<p><strong>did_all_hw.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;		// to get the declaration of find</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span>	<span class="comment">// to get the declaration of Student_info</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"did_all_hw.h"</span>		<span class="comment">// to get the declaration of did_all_hw itself</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">find</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">did_all_hw</span><span class="params">(<span class="keyword">const</span> Student_info &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="built_in">find</span>(s.homework.<span class="built_in">begin</span>(), s.homework.<span class="built_in">end</span>(), <span class="number">0</span>)) == s.homework.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>did_all_hw.h</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_DID_ALL_HW_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_DID_ALL_HW_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">did_all_hw</span><span class="params">(<span class="keyword">const</span> Student_info &amp;s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* GUARD_DID_ALL_HW_H */</span></span></span><br></pre></td></tr></table></figure>

<p><strong>gradingSchemes.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;	    // to get the declaration of remove_copy</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;	    // to get the declaration of accumulate</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;	    // to get the declaration of domain_error</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;	    // to get the declaration of vector</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span>   <span class="comment">// to get the declaration of Student_info</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"gradingSchemes.h"</span> <span class="comment">// to get the declaration of all functions here to keep consistent</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::domain_error;  <span class="keyword">using</span> <span class="built_in">std</span>::istream;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;        <span class="keyword">using</span> <span class="built_in">std</span>::sort;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::accumulate;</span><br><span class="line"></span><br><span class="line"><span class="comment">// final grade function returns weighted average of midterm exam grade,</span></span><br><span class="line"><span class="comment">// final exam grade, and homework grade which will be computed</span></span><br><span class="line"><span class="comment">// using different methods depending on grading schemes</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">double</span> midterm, <span class="keyword">double</span> <span class="keyword">final</span>, <span class="keyword">double</span> homework)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.2</span>*midterm + <span class="number">0.4</span>*<span class="keyword">final</span> + <span class="number">0.4</span>*homework;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fundermental functions 1: returns the median value of vector&lt;double&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">median</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// get the size of the vector</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;::size_type vec_size;</span><br><span class="line">    vec_size <span class="built_in">size</span> = vec.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check whether the empty is empty</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span> == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> domain_error(<span class="string">"median of an empty vector"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sort the grades</span></span><br><span class="line">    sort(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// compute the median homework grade</span></span><br><span class="line">    vec_size mid = <span class="built_in">size</span>/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">size</span> % <span class="number">2</span> == <span class="number">0</span> ? (vec[mid] + vec[mid - <span class="number">1</span>])/<span class="number">2</span> : vec[mid];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fundermental functions 2: returns the average value of vector&lt;double&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">average</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// check whether the empty is empty</span></span><br><span class="line">    <span class="keyword">if</span> (v.empty())</span><br><span class="line">    &#123;   <span class="keyword">throw</span> domain_error(<span class="string">"average of an empty vector"</span>);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> accumulate(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">0.0</span>) / v.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// grading scheme 1: final grade is based on the median homework grade</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">median_grade</span><span class="params">(<span class="keyword">const</span> Student_info &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> median_grade(s.midterm, s.<span class="keyword">final</span>, s.homework);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// grading scheme 1: overloaded median_grade function</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">median_grade</span><span class="params">(<span class="keyword">double</span> midterm, <span class="keyword">double</span> <span class="keyword">final</span>, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;hw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hw.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> domain_error(<span class="string">"student has done no homework"</span>);</span><br><span class="line">    <span class="keyword">return</span> grade(midterm, <span class="keyword">final</span>, median(hw));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// grading scheme 1: auxiliary median_grade function</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">median_grade_aux</span><span class="params">(<span class="keyword">const</span> Student_info &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> median_grade(s);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (domain_error)&#123;</span><br><span class="line">        <span class="comment">// students who did no homework at all, get 0 homework grade</span></span><br><span class="line">        <span class="keyword">return</span> grade(s.midterm, s.<span class="keyword">final</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// grading scheme 2: final grade is based on average homework grades</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">average_grade</span><span class="params">(<span class="keyword">const</span> Student_info &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> grade(s.midterm, s.<span class="keyword">final</span>, average(s.homework));</span><br><span class="line">    &#125;<span class="keyword">catch</span> (domain_error)&#123;</span><br><span class="line">        <span class="comment">// students who did no homework at all, get 0 homework grade</span></span><br><span class="line">        <span class="keyword">return</span> grade(s.midterm, s.<span class="keyword">final</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// grading scheme 3: final grade is based on median of the completed homework grades,</span></span><br><span class="line"><span class="comment">// and students who did no homework at all will get 0 homework grade</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">optimistic_median</span><span class="params">(<span class="keyword">const</span> Student_info &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; nonzero;</span><br><span class="line">    remove_copy(s.homework.<span class="built_in">begin</span>(), s.homework.<span class="built_in">end</span>(), back_inserter(nonzero), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(nonzero.empty())</span><br><span class="line">        <span class="keyword">return</span> grade(s.midterm, s.<span class="keyword">final</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> grade(s.midterm, s.<span class="keyword">final</span>, median(nonzero));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>gradingScheme.h</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_GRADING_SCHEMES_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_GRADING_SCHEMES_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">double</span> midterm, <span class="keyword">double</span> <span class="keyword">final</span>, <span class="keyword">double</span> homework)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">median</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; vec)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">average</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;v)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">median_grade</span><span class="params">(<span class="keyword">const</span> Student_info &amp;s)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">median_grade</span><span class="params">(<span class="keyword">double</span> midterm, <span class="keyword">double</span> <span class="keyword">final</span>, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;hw)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">median_grade_aux</span><span class="params">(<span class="keyword">const</span> Student_info &amp;s)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">average_grade</span><span class="params">(<span class="keyword">const</span> Student_info &amp;s)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">optimistic_median</span><span class="params">(<span class="keyword">const</span> Student_info &amp;s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* GUARD_GRADING_SCHEMES_H */</span></span></span><br></pre></td></tr></table></figure>

<p><strong>grades_analysis.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;		// to get the declaration of vector</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;		// to get the declaration of back_inserter</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;		// to get the declaration of domain_error</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;		// to get the declaration of transform</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span>	<span class="comment">// to get the declaration of Student_info</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"grades_analysis.h"</span>    <span class="comment">// to get the declaration of all functions here to keep consistent</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"gradingSchemes.h"</span>     <span class="comment">// to get the declaration of median_grade_aux, average_grade, optimistic_median</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;			<span class="keyword">using</span> <span class="built_in">std</span>::transform;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::domain_error;	<span class="keyword">using</span> <span class="built_in">std</span>::back_inserter;</span><br><span class="line"></span><br><span class="line"><span class="comment">// median</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">median_analysis</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;Student_info&gt; &amp;students)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; grades;</span><br><span class="line"></span><br><span class="line">    transform(students.<span class="built_in">begin</span>(), students.<span class="built_in">end</span>(), back_inserter(grades), median_grade_aux);</span><br><span class="line">    <span class="keyword">return</span> median(grades);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// average</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">average_analysis</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;Student_info&gt; &amp;students)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; grades;</span><br><span class="line"></span><br><span class="line">    transform(students.<span class="built_in">begin</span>(), students.<span class="built_in">end</span>(), back_inserter(grades), average_grade);</span><br><span class="line">    <span class="keyword">return</span> median(grades);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// median of the completed homework</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">optimistic_median_analysis</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;Student_info&gt; &amp;students)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; grades;</span><br><span class="line">    transform(students.<span class="built_in">begin</span>(), students.<span class="built_in">end</span>(), back_inserter(grades), optimistic_median);</span><br><span class="line">    <span class="keyword">return</span> median(grades);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>grades_analysis.h</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_GRADES_ANALYSIS_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_GRADES_ANALYSIS_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">median_analysis</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Student_info&gt; &amp;students)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">average_analysis</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Student_info&gt; &amp;students)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">optimistic_median_analysis</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Student_info&gt; &amp;students)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* GUARD_GRADES_ANALYSIS_H */</span></span></span><br></pre></td></tr></table></figure>

<p><strong>write_analysis.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;		// to get the declaration of cout, endl, ostream</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;		// to get the declaration of string</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;		// to get the declaration of vector</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span>	<span class="comment">// to get the declatation of Student_info</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"write_analysis.h"</span>	<span class="comment">// to get the declatation of write_analysis itself</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::ostream;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_analysis</span><span class="params">(ostream &amp;out, <span class="keyword">const</span> <span class="built_in">string</span> &amp;name,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">double</span> analysis(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;Student_info&gt; &amp;),</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="built_in">vector</span>&lt;Student_info&gt; &amp;did,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="built_in">vector</span>&lt;Student_info&gt; &amp;didnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    out &lt;&lt; name &lt;&lt; <span class="string">": median(did) = "</span> &lt;&lt; analysis(did)</span><br><span class="line">            &lt;&lt; <span class="string">": median(didnt) = "</span> &lt;&lt; analysis(didnt) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>write_analysis.h</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_WRITE_ANALYSIS_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_WRITE_ANALYSIS_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_analysis</span><span class="params">(<span class="built_in">std</span>::ostream &amp;out, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">double</span> analysis(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Student_info&gt; &amp;),</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Student_info&gt; &amp;did,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Student_info&gt; &amp;didnt)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* GUARD_WRITE_ANALYSIS_H */</span></span></span><br></pre></td></tr></table></figure>

<p><strong>Student_info.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>; 	<span class="keyword">using</span> <span class="built_in">std</span>::istream;</span><br><span class="line"></span><br><span class="line"><span class="comment">// argument to the function sort</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> Student_info &amp;x, <span class="keyword">const</span> Student_info &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.name &lt; y.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// read the info</span></span><br><span class="line"><span class="function">istream &amp; <span class="title">read</span><span class="params">(istream &amp;is, Student_info &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// reads and store the student's name, midterm and final exam grades</span></span><br><span class="line">    is &gt;&gt; s.name &gt;&gt; s.midterm &gt;&gt; s.<span class="keyword">final</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reads and store all homework grades</span></span><br><span class="line">    read_hw(is, s.homework);</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// read all homework grades</span></span><br><span class="line"><span class="function">istream &amp; <span class="title">read_hw</span><span class="params">(istream &amp;in, <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;hw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (in)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//get rid of previous contents</span></span><br><span class="line">        hw.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// read homework grades</span></span><br><span class="line">        <span class="keyword">double</span> x;</span><br><span class="line">        <span class="keyword">while</span>(in &gt;&gt; x)</span><br><span class="line">            hw.push_back(x);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// clear the stream so that input will work for the next student</span></span><br><span class="line">        in.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Student_info.h</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_Student_info</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_Student_info</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student_info</span>&#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">double</span> midterm, <span class="keyword">final</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; homework;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> Student_info &amp;, <span class="keyword">const</span> Student_info &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::istream &amp; <span class="title">read</span><span class="params">(<span class="built_in">std</span>::istream &amp;, Student_info &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::istream &amp; <span class="title">read_hw</span><span class="params">(<span class="built_in">std</span>::istream &amp;, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h2 id="A-simple-Test"><a href="#A-simple-Test" class="headerlink" title="A simple Test"></a>A simple Test</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Inputs:</span><br><span class="line"></span><br><span class="line">Xxzrz 87.1414 3.48485 18 58 0</span><br><span class="line">Oketl 98.0909 57.7273 92 38 22</span><br><span class="line">Gzqrc 91.1515 88.5657 34 2 11</span><br><span class="line">Ojway 86.7576 33.697 16 44 42</span><br><span class="line">Psajl 99.5758 76.9293 12 75 89</span><br><span class="line">Aovlz 88.0101 89.5556 85 2 23</span><br><span class="line">Cpwsr 57.3232 32.697 89 21 54</span><br><span class="line">Izcob 55.3434 49.4141 60 45 12</span><br><span class="line">Ijtvd 96.8788 29.4949 49 66 37</span><br><span class="line">Ldvgy 5.88889 82.5556 1 14 34</span><br><span class="line">Mborx 55.8586 53.1212 45 32 8</span><br><span class="line">Xohgm 82.8182 44.9697 61 29 22</span><br><span class="line">Xotog 59.9293 39.5354 10 54 24</span><br><span class="line">Nfetc 22.6869 18.8788 91 58 5</span><br><span class="line">Kljug 24.3434 74.7273 70 33 59</span><br><span class="line">Zjenp 70.6364 68.9293 80 2 85</span><br><span class="line">Pjsrd 25.4343 24.2323 81 61 72</span><br><span class="line">Lchhb 31.9293 42.2222 0 64 86</span><br><span class="line">Zobiw 70.3535 33.1111 67 96 60</span><br><span class="line">Fsksr 24.1919 25.7677 2 58 94</span><br><span class="line">Dcyzj 84.1818 64.1919 87 0 52</span><br><span class="line">Qcozi 15.7677 27.4343 9 64 58</span><br><span class="line">Eeddp 74.2525 27.2929 20 23 28</span><br><span class="line">Mmtat 61.9596 25.6465 16 2 60</span><br><span class="line">Muvnp 47.5354 20.9091 63 88 24</span><br><span class="line">Azuxm 13.5859 78.6566 0 77 7</span><br><span class="line"></span><br><span class="line">Outputs:</span><br><span class="line">median: median(did) &#x3D; 46.1475: median(didnt) &#x3D; 42.9273</span><br><span class="line">average: median(did) &#x3D; 45.4202: median(didnt) &#x3D; 44.3273</span><br><span class="line">median of homework turned in: median(did) &#x3D; 46.1475: median(didnt) &#x3D; 52.1273</span><br></pre></td></tr></table></figure>

<h2 id="Merging-three-analysis-functions-into-one-single-function"><a href="#Merging-three-analysis-functions-into-one-single-function" class="headerlink" title="Merging three analysis functions into one single function"></a>Merging three analysis functions into one single function</h2><p>It has been observed that three analysis functions are in fact defined in the same manner. The only difference between them is the statements:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">transform(students.<span class="built_in">begin</span>(), students.<span class="built_in">end</span>(), back_inserter(grades), <span class="comment">//transform function to be passed);</span></span><br></pre></td></tr></table></figure>
<p>Therefore, we can redefine the analysis function such that the <strong>transform</strong> function can be passed to the analysis function as an argument. We have learned how to do this from the <strong>write_analysis</strong> function. Now let’s define it:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">analysis</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;Student_info&gt; &amp;students, <span class="keyword">double</span> grading_scheme(<span class="keyword">const</span> Student_info &amp;s))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; grades;</span><br><span class="line"></span><br><span class="line">	transform(students.<span class="built_in">begin</span>(), students.<span class="built_in">end</span>(), back_inserter(grades), grading_scheme);</span><br><span class="line">	<span class="keyword">return</span> median(grades);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>For example, if we want to compute the average based median grade, we would call this function like:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">analysis(did, average_grade);</span><br></pre></td></tr></table></figure>
<p>Correspondingly, we need to change the <strong>write_analysis</strong> function as well. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_analysis</span><span class="params">(ostream &amp;out, <span class="keyword">const</span> <span class="built_in">string</span> &amp;name,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">double</span> grading_scheme(<span class="keyword">const</span> Student_info &amp;s),</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="built_in">vector</span>&lt;Student_info&gt; &amp;did,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="built_in">vector</span>&lt;Student_info&gt; &amp;didnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    out &lt;&lt; name &lt;&lt; <span class="string">": median(did) = "</span> &lt;&lt; analysis(did, grading_scheme)</span><br><span class="line">            &lt;&lt; <span class="string">": median(didnt) = "</span> &lt;&lt; analysis(didnt, grading_scheme) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>I define the new <strong>write_analysis</strong> function such that it takes the <strong>grading_scheme</strong> functions as its second arguments. To qualify the use of the <strong>analysis</strong> function, I add <strong>#include “grade_analysis.h”</strong> into <strong>write_analysis.cpp</strong>. In addition, I add <strong>#include “gradingSchemes.h”</strong> into <strong>mainfunction.cpp</strong> for qualifing the use of three <strong>grading_scheme</strong> functions. Please find the revised files shown in below.</p>
<p><strong>modified file 1: grades_analysis.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;		// to get the declaration of vector</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;		// to get the declaration of back_inserter</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;		// to get the declaration of domain_error</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;		// to get the declaration of transform</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span>	<span class="comment">// to get the declaration of Student_info</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"grades_analysis.h"</span>    <span class="comment">// to get the declaration of all functions here to keep consistent</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"gradingSchemes.h"</span>     <span class="comment">// to get the declaration of the median function</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;			<span class="keyword">using</span> <span class="built_in">std</span>::transform;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::domain_error;	<span class="keyword">using</span> <span class="built_in">std</span>::back_inserter;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">analysis</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;Student_info&gt; &amp;students, <span class="keyword">double</span> grading_scheme(<span class="keyword">const</span> Student_info &amp;s))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; grades;</span><br><span class="line"></span><br><span class="line">    transform(students.<span class="built_in">begin</span>(), students.<span class="built_in">end</span>(), back_inserter(grades), grading_scheme);</span><br><span class="line">    <span class="keyword">return</span> median(grades);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>modified file 2: grades_analysis.h</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_GRADES_ANALYSIS_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_GRADES_ANALYSIS_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">analysis</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Student_info&gt; &amp;students,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">double</span> grading_scheme(<span class="keyword">const</span> Student_info &amp;s))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* GUARD_GRADES_ANALYSIS_H */</span></span></span><br></pre></td></tr></table></figure>

<p><strong>modified file 3: write_analysis.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;		// to get the declaration of cout, endl, ostream</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;		// to get the declaration of string</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;		// to get the declaration of vector</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span>	<span class="comment">// to get the declatation of Student_info</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"write_analysis.h"</span>	<span class="comment">// to get the declatation of write_analysis itself</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"grades_analysis.h"</span>    <span class="comment">// to get the declaration of analysis function</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::ostream;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_analysis</span><span class="params">(ostream &amp;out, <span class="keyword">const</span> <span class="built_in">string</span> &amp;name,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">double</span> grading_scheme(<span class="keyword">const</span> Student_info &amp;s),</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="built_in">vector</span>&lt;Student_info&gt; &amp;did,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="built_in">vector</span>&lt;Student_info&gt; &amp;didnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    out &lt;&lt; name &lt;&lt; <span class="string">": median(did) = "</span> &lt;&lt; analysis(did, grading_scheme)</span><br><span class="line">            &lt;&lt; <span class="string">": median(didnt) = "</span> &lt;&lt; analysis(didnt, grading_scheme) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>modified file 4: write_analysis.h</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_WRITE_ANALYSIS_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_WRITE_ANALYSIS_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_analysis</span><span class="params">(<span class="built_in">std</span>::ostream &amp;out, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">double</span> grading_scheme(<span class="keyword">const</span> Student_info &amp;s),</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Student_info&gt; &amp;did,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Student_info&gt; &amp;didnt)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* GUARD_WRITE_ANALYSIS_H */</span></span></span><br></pre></td></tr></table></figure>

<p><strong>modified file 5: mainfunction.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;		// to get the declaration of cin, cout, endl</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;		// to get the declaration of vector</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span>	<span class="comment">// to get the declaration of Student_info</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"did_all_hw.h"</span>		<span class="comment">// to get the declatation of the predicate on students' records</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"write_analysis.h"</span>	<span class="comment">// to get the declaration of write_analysis function</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"gradingSchemes.h"</span> <span class="comment">// to get the declaration of three grading functions</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;		<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// students who did and didn't do all their homework</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;Student_info&gt; did, didnt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read the student records and partition time</span></span><br><span class="line">    Student_info student;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">read</span>(<span class="built_in">cin</span>, student))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(did_all_hw(student))</span><br><span class="line">            did.push_back(student);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            didnt.push_back(student);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// verify thatthe analyses will show us something</span></span><br><span class="line">    <span class="keyword">if</span>(did.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"No student did all the homework!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(didnt.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Every student did all the homework!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do the analysis</span></span><br><span class="line">    write_analysis(<span class="built_in">cout</span>, <span class="string">"median"</span>, median_grade_aux, did, didnt);</span><br><span class="line">    write_analysis(<span class="built_in">cout</span>, <span class="string">"average"</span>, average_grade, did, didnt);</span><br><span class="line">    write_analysis(<span class="built_in">cout</span>, <span class="string">"median of homework turned in"</span>, optimistic_median, did, didnt);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>I tested this program using the same inputs as I used in the original program. They work exactly the same and yield same outputs. </p>
<hr>
<p>To be continued. </p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Notes</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ - Using library algorithms (Part 1)</title>
    <url>/2018/03/21/C-Using-library-algorithms/</url>
    <content><![CDATA[<h1 id="Generic-algorithms-for-operations-on-strings"><a href="#Generic-algorithms-for-operations-on-strings" class="headerlink" title="Generic algorithms for operations on strings"></a>Generic algorithms for operations on strings</h1><h2 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h2><p>Recalling the <strong>vcat</strong> function described in <a href="http://quanttour.com/14/03/2018/C-Sequential-Containers-Part-2/" target="_blank" rel="noopener">Vertical concatenation</a>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::const_iterator i = bottom.<span class="built_in">begin</span>(); i != bottom.<span class="built_in">end</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">    ret.push_back((*i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Using a <strong>for</strong> loop, all elements of <strong>vector<string> bottom</strong> are copied and appended to the end of the <strong>vector<string> ret</strong>.<br>An alternative method is to use the <strong>insert</strong> function: </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ret.insert(ret.<span class="built_in">end</span>(), bottom.<span class="built_in">begin</span>(), bottom.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>
<p>These two methods rely on the member functions of a specified container. A more general solution, using generic algorithm <strong>copy</strong>, to solve the same question,</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">copy(bottom.<span class="built_in">begin</span>(), bottom.<span class="built_in">end</span>(), back_inserter(ret));</span><br></pre></td></tr></table></figure>
<p>The generic algorithms provided in the standard library implement classic algorithms via iterator operations. They do not depend on any specific type of container. The <strong>copy</strong> algorithm is an algorithm that writes elements to a container. It takes three iterators, of which, the first two iterators indicates the input range while the third iterator denotes the starting point of the destination sequence. </p>
<p><strong>back_inserter()</strong> is a <strong>iterator adaptor</strong> which is a function that returns an appropriate iterator (has type of <strong>back_insert_iterator</strong>) according to the argument. All <strong>intertor adaptors</strong> are defined in header <iterator>. In this case, <strong>back_inserter()</strong> takes a container as its arguments and yields an <strong>iterator</strong> that, when used as a destination, appends values to the container. But noting that</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">copy(bottom.<span class="built_in">begin</span>(), bottom.<span class="built_in">end</span>(), ret.<span class="built_in">end</span>())</span><br></pre></td></tr></table></figure>
<p>is not allowed as there is no element at <strong>ret.end</strong>.</p>
<p>After this function completes, the size of <strong>ret</strong> increases by <strong>bottom.size()</strong>. The <strong>copy</strong> function returns an iterator ((has type of <strong>back_insert_iterator</strong>) that refers to the next postion of the last element of <strong>ret</strong>.</p>
<h2 id="find-if-algorithm"><a href="#find-if-algorithm" class="headerlink" title="find_if algorithm"></a>find_if algorithm</h2><p>Now, using another generic algorithm <strong>find_if</strong>, we can simplify the <strong>split</strong> function described in <a href="http://quanttour.com/13/03/2018/C-Sequential-Containers/" target="_blank" rel="noopener">Taking strings apart</a>.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// true if the argument is whitespace, false otherwise</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">space</span><span class="params">(<span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">isspace</span>(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// false is the argument is whitespace, true otherwise</span></span><br><span class="line"><span class="function">book <span class="title">not_space</span><span class="params">(<span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !<span class="built_in">isspace</span>(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">split</span><span class="params">(const_string &amp;str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">string</span>::const_iterator iter;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ret;</span><br><span class="line"></span><br><span class="line">    iter i = str.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span>(i != str.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ignore leading blanks</span></span><br><span class="line">        i = find_if(i, str.<span class="built_in">end</span>(), not_space)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// find end of next word</span></span><br><span class="line">        iter j = find_if(i, str.<span class="built_in">end</span>(), space);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// copy the characters in [i, j)</span></span><br><span class="line">        <span class="keyword">if</span>(i != str.<span class="built_in">end</span>())</span><br><span class="line">            ret.push_back(<span class="built_in">string</span>(i, j));</span><br><span class="line">        i = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>First, in this function, we use iterators instead of indices. The core algorithm is that use <strong>find_if</strong> to firstly find a nonwhiltespace character and a whitespace that closely follows, which determines the range of a word. </p>
<p><strong>find_if</strong> algorithm takes three arguments, of which, first two are iterators that denotes a sequence while the third one is a predicate on characters. The algorithm calls the predicate to test each element starting from <strong>*i</strong>, and stops when the predicate returns <strong>true</strong>, i.e. the character is not whitespace in this case. It returns an iterator that refers to the first element that satisfies the predicate. If <strong>find_if</strong> failed to find an element that satifies the predicate, it returns its second arguments, i.e. <strong>str.end()</strong> in this case.</p>
<p>It has been observed that we didn’t use <strong>isspace()</strong> directly instead we write our own functions. This is because that <strong>isspace()</strong> is overloaded depending on arguments and can’t be passed as an argument to a template function. </p>
<p>Another new usage is <strong>string(i,j)</strong>, which constructs a new string that copies the value from the range [i, j).</p>
<h2 id="equal-algorithm"><a href="#equal-algorithm" class="headerlink" title="equal algorithm"></a>equal algorithm</h2><p>Now we introduce another algorithm <strong>equal</strong>, which can simplify the <strong>isPalindromes</strong> function described in <a href="http://quanttour.com/20/03/2018/Accelerated-C-Solutions-to-Exercise-Chapter-5-Part-4/" target="_blank" rel="noopener">Exercise 5-10</a>.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_palindrome</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> equal(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>(), s.rbegin());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>It is consise enough compared with the one I wrote before. The <strong>equal</strong> algorithm takes three iterators, of which first two indicate the range of the first sequence while the third iterator denotes the inital position of the second sequence. It compares these two sequence and returns <strong>true</strong> otherwise returns <strong>false</strong>.</p>
<p>It is known that <strong>begin()</strong> returns an iterator that refers to the first element in a container. On the contrary, <strong>rbegin()</strong> returns an reverse iterator that refers to the last element in a container. Similarly, <strong>rend()</strong> returns to an iterator that refers to the position that before the first element. </p>
<h2 id="Finding-URLs"><a href="#Finding-URLs" class="headerlink" title="Finding URLs"></a>Finding URLs</h2><p><em>Considering that one or more <strong>URLs</strong> are embedded in a <strong>string</strong>, we are requested to write a function that finds each <strong>URL</strong>. A <strong>URL</strong> is a sequence of characters of the form</em>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protocol-name:&#x2F;&#x2F;resource-name</span><br></pre></td></tr></table></figure>
<p><em>where protocol-name contains only letters, and resource-name may consist of letters, digits, and certain punctuation characters</em>(Koenig and Moo 2000).</p>
<p>To some extent, this exercise is similar to the <strong>split</strong> function. Though determining the range of such a string is much complex than finding the range for a word, the idea is the same. The strategy can be divided into three steps:</p>
<ol>
<li>looking for the characters <strong>://</strong> that might be a part of a <strong>URL</strong>.</li>
<li>if we find these characters, then it looks backward to find the protocol-name and determines the begining position of the <strong>URL</strong>; then, it looks forward to find the resource-name and determines the ending position of the <strong>URL</strong>. </li>
<li>finally, we store the <strong>URL</strong> according the two positions and continue searching for next <strong>URL</strong> until we finishes the whole document held in the single string. </li>
</ol>
<p>We starts from the last step, providing the first two steps have been completed.</p>
<p><strong>function to find URLs</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">find_urls</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ret;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">string</span>::const_iterator iter;</span><br><span class="line">    iter b = s.<span class="built_in">begin</span>(), e = s.<span class="built_in">end</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// look through the entire input</span></span><br><span class="line">    <span class="keyword">while</span> (b != e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// look for one or more letters followed by ://</span></span><br><span class="line">        b = url_beg(b, e);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if we found it</span></span><br><span class="line">        <span class="keyword">if</span>(b != e)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// get the rest of the URL</span></span><br><span class="line">            iter after = url_end(b, e);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// remember the URL</span></span><br><span class="line">            ret.push_back(<span class="built_in">string</span>(b, after));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// advance b and check for more URLs on this line</span></span><br><span class="line">            b = after;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Function <strong>url_beg</strong> responsibles for finding the <strong>://</strong> and then finding the begining position of the <strong>URL</strong> accordingly. <strong>url_end</strong> responsibles for finding the end position of the <strong>URL</strong> based on the results of <strong>url_beg</strong>. </p>
<p>As mentioned earlier, <strong>string(b, after)</strong> constructs the <strong>URL</strong> with two iterators which denotes a range [b, after) of a sequence, i.e. the <strong>URL</strong>. In other words, <strong>b</strong> is the interator that denotes the first element of the <strong>URL</strong> while <strong>after</strong> denotes the position that one past the last element in the <strong>URL</strong>. After stores the <strong>URL</strong> into <strong>vector<string> ret</strong>, we set the initial position for finding next <strong>URL</strong> as the end of the previous <strong>URL</strong>, with setting <strong>b = after</strong>.</p>
<p>Now we consider <strong>url_end</strong> function first, providing that the begining position of a <strong>URL</strong> has been found. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span>::const_iterator  <span class="title">url_end</span><span class="params">(<span class="built_in">string</span>::const_iterator b, <span class="built_in">string</span>::const_iterator e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> find_if(b, e, not_url_char);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We have explained the <strong>find_if</strong> algorithm in above. It calls the precidate <strong>not_url_char</strong> and test each element starting from the position where <strong>b</strong> denotes, and stops until finds the element that makes the predicate returns <strong>true</strong>. It returns an iterator that refers to the first element that satifies the predicate, and returns its second arguments <strong>e</strong> if can’t find an element that satisfies the predicate. Now let’s write the predicate:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">not_url_char</span><span class="params">(<span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// characters, in addition to alphanumerics, that can appear in a URL</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">string</span> url_ch = <span class="string">"~;/?:@=&amp;$-_.+!*'(),"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// see whether c can appear in a URL and return the negative</span></span><br><span class="line">    <span class="keyword">return</span> !(<span class="built_in">isalnum</span>(c) || <span class="built_in">find</span>(url_ch.<span class="built_in">begin</span>(), url_ch.<span class="built_in">end</span>(), c) != url_ch.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Yeah, the statements in the function body seems to be both compact and informative. The first statement defines a <strong>const string</strong> that contains all punctuation characters that can appear in a <strong>URL</strong>. What’s new here is the <em>storage class specifier</em> <strong>static</strong>. Local variables that declaraed with specifier <strong>static</strong> have static storage duration and are initialized only the first time. On all other calls, the declarations are skipped. In other words, the variable exists starting from the first time declaration to when the program finishes. By doing so, the <strong>const string url_ch</strong> avoids being declared each time when the predicate is called.</p>
<p>The return statement contains three expressions:</p>
<ul>
<li>expression 1: <strong>isalnum(c)</strong>. It returns <strong>true</strong> is c is a letter or digits, otherwise returns false.</li>
<li>expression 2: <strong>find(url_ch.begin(), url_ch.end(), c) != url_ch.end()</strong>. <strong>find</strong> algorithm takes three arguments, of which the first two are interators that denote the input sequence while the third one is a value to search for in the range. It returns an iterator to the first element in the range that compares equal to the value. If no such element is found, it returns the second arguments. In this case, if any character that equals to <strong>c</strong>, the expression is evaluated to true. If no character that matches with <strong>c</strong>, the expression is evaluated to false. </li>
<li>expression 3: <strong>!(expression 1 || expression 2)</strong>. If and only if both expressions are evaluated to <strong>false</strong>, the expression 3 is evaluated to <strong>true</strong>.</li>
</ul>
<p>In brief, if the scanned character is not a letter, not a digit, and not any punctuation character that can appear in a <strong>URL</strong>, it is regarded as not a <strong>URL</strong> character and it is the element that one past the last element of the <strong>URL</strong>. </p>
<p>Finally, we return to the first step, writing the function <strong>url_beg</strong> to find the initial position of the <strong>URL</strong>. One concern we have is that <strong>://</strong> may not guaranntee a <strong>URL</strong>, for example, in the case that these characters appear at the end of a string. Therefore, we also need to make sure that there at least one or more letters before <strong>://</strong> and at lease one character follows it.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span>::const_iterator <span class="title">url_beg</span><span class="params">(<span class="built_in">string</span>::const_iterator b, <span class="built_in">string</span>::const_iterator e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">string</span> sep = <span class="string">"://"</span>;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">string</span>::const_iterator iter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// i marks where the separator was found</span></span><br><span class="line">    iter i = b;</span><br><span class="line">    <span class="keyword">while</span>((i = search(i, e, sep.<span class="built_in">begin</span>(), sep.<span class="built_in">end</span>())) != e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// make sure the seperator isn't at the begining of the proticol-name</span></span><br><span class="line">        <span class="keyword">if</span>(i != b &amp;&amp; i + sep.<span class="built_in">size</span>() != e)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// beg marks the begining of the protocol-name</span></span><br><span class="line">            iter beg = i;</span><br><span class="line">            <span class="keyword">while</span>(beg != b &amp;&amp; <span class="built_in">isalpha</span>(beg[<span class="number">-1</span>]))</span><br><span class="line">                --beg;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// is there at least one appropriate character before and after the sep</span></span><br><span class="line">            <span class="keyword">if</span> (beg != i &amp;&amp; !not_url_char(i[sep.<span class="built_in">size</span>()]))</span><br><span class="line">                <span class="keyword">return</span> beg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// the seperator we found wasn't part of a URL advance i past this separator</span></span><br><span class="line">        i += sep.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Let’s analyse from the <strong>while</strong> loop. There appears a new algorithm <strong>search</strong> in the condition:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(i &#x3D;&#x3D; search(i, e, sep.begin(), sep.end())) !&#x3D; e</span><br></pre></td></tr></table></figure>
<p>The <strong>search</strong> algorithm takes four iterators, of which the first two indicate the sequence while the last two denotes the initial and final positions of the sequence to be searched for. It returns an iterator the refers to the first element of [sep.begin(), sep.end()) if such sequence can be found in [i, e), otherwise it returns <strong>e</strong>. Now we know the condition is evaluated to <strong>true</strong> if <strong>://</strong> can be found in the range of [i, e). </p>
<p>Assuming that <strong>://</strong> is found in the first iteration, <strong>i</strong> is assigned the iterator that denotes <strong>:</strong>. To make sure <strong>://</strong> reveals a valid <strong>URL</strong>, we need to make sure it is neither the start of <strong>s</strong> nor the ending of <strong>s</strong>. This is managed by the first <strong>if statement</strong> inside of the <strong>while</strong> loop. The next is to find the begining position of the <strong>URL</strong> using following statements. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">iter beg = i;</span><br><span class="line"><span class="keyword">while</span>(beg != b &amp;&amp; <span class="built_in">isalpha</span>(beg[<span class="number">-1</span>]))</span><br><span class="line">    --beg;</span><br></pre></td></tr></table></figure>
<p><strong>beg[-1]</strong> accesses the element that before the one denoted by <strong>beg</strong>, it has the same effect as </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*(beg - 1)</span><br></pre></td></tr></table></figure>
<p>If the element denoted by <strong>beg</strong> is a letter within the range of [b, i), the loop continues with taking one position back each iteration. After the loop finishes, we got the initial position of the <strong>URL</strong>. However, the while body may fail to be executed even once, if the condition is evaluated to <strong>false</strong> the first time. Therefore, we need to verify another condition to make sure there exists at least one appropriate character before and after the sep.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (beg != i &amp;&amp; !not_url_char(i[sep.<span class="built_in">size</span>]))</span><br><span class="line">    <span class="keyword">return</span> beg;</span><br></pre></td></tr></table></figure>
<p>The first expression <strong>beg != i</strong> ensures that there is at least one letter before <strong>:</strong>. In other words, the <strong>while</strong> loop above is executed at least once. </p>
<p>The sencond expression <strong>!not_url_char(i[sep.size])</strong> ensures that there is at least one appropriate character follows <strong>://</strong>. <strong>i[sep.size()]</strong> has the same effect as</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">*(i + sep.<span class="built_in">size</span>())</span><br></pre></td></tr></table></figure>
<p>which denotes the first character after <strong>sep</strong> (i.e. “://“). </p>
<p>At this phase, if the condition is evaluated to <strong>true</strong>, then the function returns the “qualified” iterator to the function caller, otherwise, the function keeps looking untill the last character. </p>
<h2 id="A-complete-program"><a href="#A-complete-program" class="headerlink" title="A complete program"></a>A complete program</h2><p>The files below show the complete program. A simple test can also be found after the program. </p>
<p><strong>mainfunction.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"find_urls.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; urls;</span><br><span class="line">	<span class="built_in">string</span> doc&#123;<span class="string">"A typical URL could have the form https://en.wikipedia.org/wiki/URL, "</span></span><br><span class="line">			<span class="string">"which indicates a protocol (http), a hostname (www.example.com), "</span></span><br><span class="line">			<span class="string">"and a file name (index.html). http://www.cplusplus.com/reference/algorithm/search/?kw=search"</span>&#125;;</span><br><span class="line">	urls = find_urls(doc);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::const_iterator iter = urls.<span class="built_in">begin</span>(); iter != urls.<span class="built_in">end</span>(); ++iter)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *iter &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>find_urls.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// function that finds and returns an URL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"find_urls.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"delimit.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">find_urls</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ret;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">string</span>::const_iterator iter;</span><br><span class="line">    iter b = s.<span class="built_in">begin</span>(), e = s.<span class="built_in">end</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// look through the entire input</span></span><br><span class="line">    <span class="keyword">while</span> (b != e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// look for one or more letters followed by ://</span></span><br><span class="line">        b = url_beg(b, e);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if we found it</span></span><br><span class="line">        <span class="keyword">if</span>(b != e)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// get the rest of the URL</span></span><br><span class="line">            iter after = url_end(b, e);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// remember the URL</span></span><br><span class="line">            ret.push_back(<span class="built_in">string</span>(b, after));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// advance b and check for more URLs on this line</span></span><br><span class="line">            b = after;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>find_urls.h</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_FINDINGURLS_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_FINDINGURLS_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">find_urls</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* GUARD_FINDINGURLS_H */</span></span></span><br></pre></td></tr></table></figure>

<p><strong>delimit.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// contains three functions: not_url_char, url_beg, url_end</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"delimit.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">find</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::find_if;	<span class="keyword">using</span> <span class="built_in">std</span>::search;</span><br><span class="line"></span><br><span class="line"><span class="comment">// predicate on a char, check whether it is a char that can appear in a URL</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">not_url_char</span><span class="params">(<span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// characters, in addition to alphanumerics, that can appear in a URL</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">string</span> url_ch = <span class="string">"~;/?:@=&amp;$-_.+!*'(),"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// see whether c can appear in a URL and return the negative</span></span><br><span class="line">    <span class="keyword">return</span> !(<span class="built_in">isalnum</span>(c) || <span class="built_in">find</span>(url_ch.<span class="built_in">begin</span>(), url_ch.<span class="built_in">end</span>(), c) != url_ch.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// function that returns an iterator that refers to the first element of a URL</span></span><br><span class="line"><span class="function"><span class="built_in">string</span>::const_iterator <span class="title">url_beg</span><span class="params">(<span class="built_in">string</span>::const_iterator b, <span class="built_in">string</span>::const_iterator e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">string</span> sep = <span class="string">"://"</span>;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">string</span>::const_iterator iter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// i marks where the separator was found</span></span><br><span class="line">    iter i = b;</span><br><span class="line">    <span class="keyword">while</span>((i = search(i, e, sep.<span class="built_in">begin</span>(), sep.<span class="built_in">end</span>())) != e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// make sure the seperator isn't at the begining of the proticol-name</span></span><br><span class="line">        <span class="keyword">if</span>(i != b &amp;&amp; i + sep.<span class="built_in">size</span>() != e)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// beg marks the begining of the protocol-name</span></span><br><span class="line">            iter beg = i;</span><br><span class="line">            <span class="keyword">while</span>(beg != b &amp;&amp; <span class="built_in">isalpha</span>(beg[<span class="number">-1</span>]))</span><br><span class="line">                --beg;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// is there at least one appropriate character before and after the sep</span></span><br><span class="line">            <span class="keyword">if</span> (beg != i &amp;&amp; !not_url_char(i[sep.<span class="built_in">size</span>()]))</span><br><span class="line">                <span class="keyword">return</span> beg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// the seperator we found wasn't part of a URL advance i past this separator</span></span><br><span class="line">        i += sep.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// function that returns an iterator that denotes the postion one past the last element</span></span><br><span class="line"><span class="function"><span class="built_in">string</span>::const_iterator  <span class="title">url_end</span><span class="params">(<span class="built_in">string</span>::const_iterator b, <span class="built_in">string</span>::const_iterator e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> find_if(b, e, not_url_char);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>delimit.h</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_DELIMIT_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_DELIMIT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">not_url_char</span><span class="params">(<span class="keyword">char</span>)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span>::const_iterator <span class="title">url_beg</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>::const_iterator, <span class="built_in">std</span>::<span class="built_in">string</span>::const_iterator)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span>::const_iterator <span class="title">url_end</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>::const_iterator, <span class="built_in">std</span>::<span class="built_in">string</span>::const_iterator)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* GUARD_DELIMIT_H */</span></span></span><br></pre></td></tr></table></figure>

<p><strong>Test results</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;URL,</span><br><span class="line">http:&#x2F;&#x2F;www.cplusplus.com&#x2F;reference&#x2F;algorithm&#x2F;search&#x2F;?kw&#x3D;search</span><br></pre></td></tr></table></figure>
<p>The program just has function to roughly grab the URLs, but works as expected.</p>
<hr>
<p>To be continued.</p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Notes</tag>
      </tags>
  </entry>
  <entry>
    <title>Accelerated C++ Solutions to Exercises(Chapter 5 Part 4)</title>
    <url>/2018/03/20/Accelerated-C-Solutions-to-Exercise-Chapter-5-Part-4/</url>
    <content><![CDATA[<h1 id="Exercise-5-9"><a href="#Exercise-5-9" class="headerlink" title="Exercise 5-9"></a>Exercise 5-9</h1><p>Write a program to write the lowercase words in the input followed by the uppercase words.</p>
<h2 id="Solution-amp-Results"><a href="#Solution-amp-Results" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>The solution strategy is pretty straightforward: check each entered word to see whether it contains one or more uppercase letters, and store words into two containers according to the check results. I present the code and test performance in below. </p>
<p><strong>A complete program</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;		<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// function declaration</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">pureLowercaseWords</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;<span class="keyword">word</span>)</span></span>; <span class="comment">// a predicate on words</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;Words)</span></span>;     <span class="comment">// print elements in a vector one by one</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; lowercase_Words; <span class="comment">// for holding words that contains only lower case letters</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; uppercase_Words; <span class="comment">// for holding words that contains at lease one upper case letters</span></span><br><span class="line">	<span class="built_in">string</span> <span class="keyword">word</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; <span class="keyword">word</span>)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">word</span>.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pureLowercaseWords(<span class="keyword">word</span>))</span><br><span class="line">                lowercase_Words.push_back(<span class="keyword">word</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                uppercase_Words.push_back(<span class="keyword">word</span>);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Words that contain only lowercase letters: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">print</span>(lowercase_Words);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Words that contain at lease one uppercase letters: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">print</span>(uppercase_Words);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">pureLowercaseWords</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;<span class="keyword">word</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">string</span>::const_iterator iter = <span class="keyword">word</span>.<span class="built_in">begin</span>(); iter != <span class="keyword">word</span>.<span class="built_in">end</span>(); ++iter)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isupper</span>(*iter))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;Words)</span></span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::const_iterator iter = Words.<span class="built_in">begin</span>(); iter != Words.<span class="built_in">end</span>(); ++iter)</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; *iter &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Test</strong><br>with inputs: University of Oxford is one of best universities all over the world according to QS Ranking</p>
<p>The program works as expected:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Words that contain only lowercase letters: </span><br><span class="line">of</span><br><span class="line">is</span><br><span class="line">one</span><br><span class="line">of</span><br><span class="line">best</span><br><span class="line">universities</span><br><span class="line">all</span><br><span class="line">over</span><br><span class="line">the</span><br><span class="line">world</span><br><span class="line">according</span><br><span class="line">to</span><br><span class="line">Words that contain at lease one uppercase letters: </span><br><span class="line">University</span><br><span class="line">Oxford</span><br><span class="line">QS</span><br><span class="line">Ranking</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Exercise-5-10"><a href="#Exercise-5-10" class="headerlink" title="Exercise 5-10"></a>Exercise 5-10</h1><p>Palindromes are words that are spelled the same right to left as left to right. Write aprogram to find all the palindromes in a dictionary. Next, find the longest palindrome.</p>
<h2 id="Solution-amp-Results-1"><a href="#Solution-amp-Results-1" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>This project has two goals:</p>
<ol>
<li>telling whether a word is a palindrome.</li>
<li>find the longest palindrome.</li>
</ol>
<p>If a word is not a palindromes, we dicard it directly. On the contrary, if a word is a palindromes, we need to store it for generating a final report. To find the longest palindrome, we can compare the size of two words and keep the longer word, finally obtaining the longest palindrome(or the first observed longest one). </p>
<p>To determine whether a word is a palindrome, one key point is that whether the palindromes are case sensitive. I treat the palindromes as case insensitive in this program and hence the predicate on a word is based on the lowercase(or uppercase) version of a word. Another point is that whether a single character is a palindrome. I regard it as a palindrome and treat a single character as a one-letter word.</p>
<p>Apparently, the key is to find an algorithm that can identify a palindrome. According to the definition, palindromes are words that are spelled the same right to left as left to right. A possible solution is to divide the characters in a word into two groups, which are symmetrically located at two side of a mid point, and compare them one pair by one pair. If all pairs are same, the word is a palindromes.</p>
<p>Intuitively, if the number of characters in a word is odd, then, there exists one unique mid point, which splits two groups of characters. The graph below shows this case and illustrates the relationship of one pair of characters regarding to their corresponding iterators. </p>
<p><img src="/images/odditerator.png" alt="A word contains odd number characters"></p>
<p>Clearly, this process can be translated to a <strong>while</strong> loop and the stopping point is the mid point (i.e. the position that iterator <strong>word.begin() + size/2</strong> refers to).</p>
<p>Similarly, if the number of characters in a word is even, characters can be exactly splitted into two groups, i.e. <strong>word.size()/2</strong> pairs. </p>
<p><img src="/images/eveniterator.png" alt="A word contains even number characters"></p>
<p>It can be seen from above graph, the stopping point is also the position that <strong>word.begin() + size/2</strong> refers to. Before this point, the last pair of characters(i.e. two mid elements) are compared. </p>
<p>Now the predicate can be write as:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindromes</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;<span class="keyword">word</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="built_in">string</span>::const_iterator iter;</span><br><span class="line">	iter startPosition = <span class="keyword">word</span>.<span class="built_in">begin</span>();</span><br><span class="line">	iter endPosition = <span class="keyword">word</span>.<span class="built_in">end</span>() - <span class="number">1</span>;</span><br><span class="line">	iter midPosition = <span class="keyword">word</span>.<span class="built_in">begin</span>() + <span class="keyword">word</span>.<span class="built_in">size</span>()/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">while</span> (startPosition != midPosition)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">tolower</span>(*startPosition) != <span class="built_in">tolower</span>(*endPosition))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        ++startPosition;</span><br><span class="line">        --endPosition;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Firstly, I choose to compare two endpoints and then move both points 1 position forward to the middle in the following iteration. Finally, the <strong>while</strong> loop stops when all pairs of characters have been compared. </p>
<p>Once finishes this function, we can write the main function directly. The code below shows the complete program. Note that I seperate the condition <strong>word.size() == 1</strong> from <strong>isPalindromes(word)</strong> simply for the purpose of computational efficiency. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;		<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">max</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// function declarations</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindromes</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;<span class="keyword">word</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;palindromes)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; palindromes; <span class="comment">// hold all identified palindromes</span></span><br><span class="line">    <span class="built_in">string</span> longest;	<span class="comment">// hold the first observed longest palindrome</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// read words</span></span><br><span class="line">    <span class="built_in">string</span> <span class="keyword">word</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; <span class="keyword">word</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">word</span>.<span class="built_in">size</span>() == <span class="number">1</span> || isPalindromes(<span class="keyword">word</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(longest.<span class="built_in">size</span>() &lt; <span class="keyword">word</span>.<span class="built_in">size</span>())</span><br><span class="line">                longest = <span class="keyword">word</span>;</span><br><span class="line">            palindromes.push_back(<span class="keyword">word</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// print all palindromes</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Following words are palindromes:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">print</span>(palindromes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// print the longest</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The longest palindrome(first observed) is:\n"</span> &lt;&lt; longest &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;palindromes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::const_iterator iter = palindromes.<span class="built_in">begin</span>();</span><br><span class="line">        iter != palindromes.<span class="built_in">end</span>(); ++iter)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *iter &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// please add the predicate here</span></span><br></pre></td></tr></table></figure>
<p>Now let’s test how the program performs. I entered following words successively:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Rotator Anna Oxford Civic Sampling Kayak Level Madam Mom Noon shape racecar radar Redder Refer Repaper Please Rotor again Sagas impossible Solos distribution Stats Tenet Wow</span><br></pre></td></tr></table></figure>

<p>The results are displayed below:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Following words are palindromes:</span><br><span class="line">Rotator</span><br><span class="line">Anna</span><br><span class="line">Civic</span><br><span class="line">Kayak</span><br><span class="line">Level</span><br><span class="line">Madam</span><br><span class="line">Mom</span><br><span class="line">Noon</span><br><span class="line">racecar</span><br><span class="line">radar</span><br><span class="line">Redder</span><br><span class="line">Refer</span><br><span class="line">Repaper</span><br><span class="line">Rotor</span><br><span class="line">Sagas</span><br><span class="line">Solos</span><br><span class="line">Stats</span><br><span class="line">Tenet</span><br><span class="line">Wow</span><br><span class="line">The longest palindrome(first observed) is:</span><br><span class="line">Rotator</span><br></pre></td></tr></table></figure>
<p>Yeah, the program works perfectly.</p>
<h1 id="Exercise-5-11"><a href="#Exercise-5-11" class="headerlink" title="Exercise 5-11"></a>Exercise 5-11</h1><p>In text processing it is sometimes useful to know whether a word has any ascenders or descenders. Ascenders are the parts of lowercase letters that extend above the text line;in the English alphabet, the letters b, d, f, h, k, l, and t have ascenders. Similarly, the descenders are the parts of lowercase letters that descend below the line; In English,theletters g, j, p, q, and y have descenders. Write a program to determine whether a word has any ascenders or descenders. Extend that program to find the longest word in the dictionary that has neither ascenders nor descenders.</p>
<h2 id="Solution-amp-Results-2"><a href="#Solution-amp-Results-2" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>The idea to solve this exercise is similar to that described in above exercise. The first step is to check whether a word contains any ascenders or descenders, by means of comparing each character in the word to ascenders or descenders. The second step is to store the word into corresponding vector according to the check results in step 1. The longest word that has neither ascenders nor descenders can be found using the same method as above. </p>
<p>I present the complete program below followed by a performance test. Noting that I defined two global variables which can be accessed anywhere inside of the file. But they cannot be modified as I add <strong>const</strong> in defining them. The purpose is to avoid that these two objects will be created repeatedly if they are put into the precidate. This problem can be easily solved with specifier <strong>static</strong>, which will be introduced in chapter 6. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Accelerated C++ Solutions Exercises 5-11</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;		<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">max</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// global variables</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> ascenders = <span class="string">"bdfhlt"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> descenders = <span class="string">"gjpqy"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// function declarations</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">noAscDes</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;<span class="keyword">word</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;words)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; asc_des;		<span class="comment">// hold words that contain any ascenders or descenders</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; no_asc_des;	<span class="comment">// hold words that has neither ascenders nor descenders</span></span><br><span class="line">	<span class="built_in">string</span> longest_no;			<span class="comment">// find the longest word that has neither ascenders nor descenders</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// read words</span></span><br><span class="line">	<span class="built_in">string</span> <span class="keyword">word</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; <span class="keyword">word</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(noAscDes(<span class="keyword">word</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (longest_no.<span class="built_in">size</span>() &lt; <span class="keyword">word</span>.<span class="built_in">size</span>())</span><br><span class="line">				longest_no = <span class="keyword">word</span>;</span><br><span class="line">			no_asc_des.push_back(<span class="keyword">word</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			asc_des.push_back(<span class="keyword">word</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Following words contain either ascenders or descenders:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">print</span>(asc_des);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Following words contain neither ascenders nor descenders:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">print</span>(no_asc_des);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"The longest word that has neither ascenders nor descenders is:\n"</span> &lt;&lt; longest_no &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">noAscDes</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;<span class="keyword">word</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">string</span>::const_iterator iter;</span><br><span class="line">    <span class="keyword">for</span> (iter i = <span class="keyword">word</span>.<span class="built_in">begin</span>(); i != <span class="keyword">word</span>.<span class="built_in">end</span>(); ++i)</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">for</span>(iter j = ascenders.<span class="built_in">begin</span>(); j != ascenders.<span class="built_in">end</span>(); ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (*i == *j)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (iter k = descenders.<span class="built_in">begin</span>(); k != descenders.<span class="built_in">end</span>(); ++k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (*i == *k)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;words)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::const_iterator iter = words.<span class="built_in">begin</span>();</span><br><span class="line">        iter != words.<span class="built_in">end</span>(); ++iter)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *iter &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Test results</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Inputs:</span><br><span class="line">throughout the course of history there have been many famous speeches that changed the world from on the mount to the inaugural speeches of modern leaders their words have become an inspiration to millions of people</span><br><span class="line"></span><br><span class="line">Outputs:</span><br><span class="line">Following words contain either ascenders or descenders:</span><br><span class="line">throughout</span><br><span class="line">the</span><br><span class="line">of</span><br><span class="line">history</span><br><span class="line">there</span><br><span class="line">have</span><br><span class="line">been</span><br><span class="line">many</span><br><span class="line">famous</span><br><span class="line">speeches</span><br><span class="line">that</span><br><span class="line">changed</span><br><span class="line">the</span><br><span class="line">world</span><br><span class="line">from</span><br><span class="line">the</span><br><span class="line">mount</span><br><span class="line">to</span><br><span class="line">the</span><br><span class="line">inaugural</span><br><span class="line">speeches</span><br><span class="line">of</span><br><span class="line">modern</span><br><span class="line">leaders</span><br><span class="line">their</span><br><span class="line">words</span><br><span class="line">have</span><br><span class="line">become</span><br><span class="line">inspiration</span><br><span class="line">to</span><br><span class="line">millions</span><br><span class="line">of</span><br><span class="line">people</span><br><span class="line">Following words contain neither ascenders nor descenders:</span><br><span class="line">course</span><br><span class="line">on</span><br><span class="line">an</span><br><span class="line">The longest word that has neither ascenders nor descenders is:</span><br><span class="line">course</span><br></pre></td></tr></table></figure>
<p>As above results show, It works fine.</p>
<hr>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p>Koenig, A. and Moo, B.E., 2000. Accelerated C++.</p>
<p>Lippman, S.B., Lajoie, J. and Moo, B.E., 2013. C++ Primer, 5th edt.</p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Accelerated C++ Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title>Accelerated C++ Solutions to Exercises(Chapter 5 Part 3)</title>
    <url>/2018/03/19/Accelerated-C-Solutions-to-Exercises-Chapter-5-Part-3/</url>
    <content><![CDATA[<h1 id="Exercise-5-5"><a href="#Exercise-5-5" class="headerlink" title="Exercise 5-5"></a>Exercise 5-5</h1><p>Write a function named center(const vector<string>&amp;) that returns a picture in which all the lines of the original picture are padded out to their full width, and the padding is as evenly divided as possible between the left and right sides of the picture. What are the properties of pictures for which such a function is useful? How can you tell whether a given picture has those properties?</p>
<h2 id="Solution-amp-Results"><a href="#Solution-amp-Results" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>The full width is the size of the longest string and can be obtained via a <strong>for</strong> loop.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::const_iterator iter = p.<span class="built_in">begin</span>();</span><br><span class="line">			iter != p.<span class="built_in">end</span>(); ++iter)</span><br><span class="line">    &#123;</span><br><span class="line">        maxlen = <span class="built_in">max</span>(maxlen, (*iter).<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>The key is to compute the number of spaces (denoted by <strong>paddingLeft</strong>) needed for the left side padding. If we want that the padding is as evenly divided as possible, <strong>paddingLeft</strong> can be set as half of <strong>maxlen - (*iter).size()</strong>, which is the total number of spaces needed to pad out to the full width of a line.</p>
<p>If <strong>(maxlen - (*iter).size())</strong> is even, the numbers of spaces on both sides of the original string are the same (i.e. the case of that padding is evenly divided). </p>
<p>If <strong>(maxlen - (*iter).size())</strong> is odd, <strong>paddingLeft</strong> is in fact has the value of <strong>((maxlen - (*iter).size()) - 1)/2</strong>, and hence is one space less that the right side padding. </p>
<p>In summary, the program logic is</p>
<ol>
<li>find <strong>maxlen</strong>.</li>
<li>compute <strong>paddingLeft</strong>.</li>
<li>construct a new line based on the string in the original picture and <strong>paddingLeft</strong> spaces.</li>
<li>store each new line into a vector<string> and return it once finishes. </li>
</ol>
<p>The complete program and tests can be found below. </p>
<p><strong>mainfunction.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">max</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// function declaration</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">center</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;p)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// create an original picture</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; p;</span><br><span class="line">    p.push_back(<span class="string">"this is an"</span>);</span><br><span class="line">    p.push_back(<span class="string">"example"</span>);</span><br><span class="line">    p.push_back(<span class="string">"to"</span>);</span><br><span class="line">    p.push_back(<span class="string">"illustrate"</span>);</span><br><span class="line">    p.push_back(<span class="string">"framing"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// generate the centered picture</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; np = center(p);</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::const_iterator iter = np.<span class="built_in">begin</span>();</span><br><span class="line">        iter != np.<span class="built_in">end</span>(); ++iter)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *iter &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// define the function that returns a centered picture</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">center</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; centeredPicture;</span><br><span class="line">    <span class="built_in">string</span>::size_type maxlen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get the length of the longest string</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::const_iterator iter = p.<span class="built_in">begin</span>();</span><br><span class="line">            iter != p.<span class="built_in">end</span>(); ++iter)</span><br><span class="line">    &#123;</span><br><span class="line">        maxlen = <span class="built_in">max</span>(maxlen, (*iter).<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pad out the left side</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::const_iterator iter = p.<span class="built_in">begin</span>();</span><br><span class="line">            iter != p.<span class="built_in">end</span>(); ++iter)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span>::size_type paddingLeft = (maxlen - (*iter).<span class="built_in">size</span>())/<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">string</span> s = <span class="built_in">string</span>(paddingLeft, <span class="string">' '</span>) + (*iter);</span><br><span class="line">        centeredPicture.push_back(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> centeredPicture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Test Results</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this is an</span><br><span class="line"> example</span><br><span class="line">    to</span><br><span class="line">illustrate</span><br><span class="line"> framing</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Exercise-5-6"><a href="#Exercise-5-6" class="headerlink" title="Exercise 5-6"></a>Exercise 5-6</h1><p>Rewrite the extract_fails function from §5.1.1/77 so that instead of erasing each failing student from the input vector v, it copies the records for the passing students to the beginning of v, and then uses the resize function to remove the extra elements from the end of v. How does the performance of this version compare with the one in §5.1.1/77?</p>
<h2 id="Solution-amp-Results-1"><a href="#Solution-amp-Results-1" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>The original function is</p>
<p><strong>Method 1</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;Student_info&gt; <span class="title">extract_fails_method1</span><span class="params">(<span class="built_in">vector</span>&lt;Student_info&gt;&amp; students)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="built_in">vector</span>&lt;Student_info&gt; fail;    </span><br><span class="line">    <span class="built_in">vector</span>&lt;Student_info&gt;::size_type i = <span class="number">0</span>;    </span><br><span class="line">    <span class="comment">// invariant:elements [0, i) of students represent passing grades     </span></span><br><span class="line">    <span class="keyword">while</span> (i != students.<span class="built_in">size</span>()) </span><br><span class="line">    &#123;         </span><br><span class="line">        <span class="keyword">if</span> (fgrade(students[i]))</span><br><span class="line">        &#123;            </span><br><span class="line">            fail.push_back(students[i]);            </span><br><span class="line">            students.erase(students.<span class="built_in">begin</span>() + i);        </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span>            </span><br><span class="line">            ++i;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> fail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The revised version is</p>
<p><strong>Method 2</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;Student_info&gt; <span class="title">extract_fails_method2</span><span class="params">(<span class="built_in">vector</span>&lt;Student_info&gt;&amp; students)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;Student_info&gt; fail;    </span><br><span class="line">    <span class="built_in">vector</span>&lt;Student_info&gt;::size_type i = <span class="number">0</span>, j = students.<span class="built_in">size</span>();  </span><br><span class="line">    <span class="comment">// invariant:elements [0, i) of students represent passing grades     </span></span><br><span class="line">    <span class="keyword">while</span> (i != students.<span class="built_in">size</span>()) </span><br><span class="line">    &#123;         </span><br><span class="line">        <span class="keyword">if</span> (fgrade(students[i]))</span><br><span class="line">        &#123;     </span><br><span class="line">            fail.push_back(students[i]&#125;;                 </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="comment">// the size increases by 1</span></span><br><span class="line">            students.insert(students.<span class="built_in">begin</span>(), students[i]);  </span><br><span class="line">            <span class="comment">// the indice move forward by 1</span></span><br><span class="line">            ++i;  </span><br><span class="line">        &#125;</span><br><span class="line">        ++i;            </span><br><span class="line">    &#125;</span><br><span class="line">    students.resize(j - fail.<span class="built_in">size</span>());    </span><br><span class="line">    <span class="keyword">return</span> fail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The next step is to measure the performance of these two function, using the same methodology as that applied in <a href="http://quanttour.com/17/03/2018/Accelerated-C-Solutions-to-Exercises-Chapter-5-Part-2/" target="_blank" rel="noopener">Exercise 5-4</a>. I add above two methods into the file <strong>fails.cpp</strong> and <strong>fails.h</strong> as alternatives. To avoid redundancy, I only present the file that contains the main function in below. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Accelerated C++ Solutions Exercises 5-2. 5-3, 5-4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;		// to get declaration of max, sort</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;			// to get declaration of cin, cout, endl</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;		// to get declaration of domain_error</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;			// to get declaration of string</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"grade.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"fails.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"print.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"info.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;					<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;				<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">max</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;				<span class="keyword">using</span> <span class="built_in">std</span>::sort;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::domain_error;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    info students;</span><br><span class="line">    Student_info record;</span><br><span class="line">    <span class="built_in">string</span>::size_type maxlen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read and store all the records, and find the length of the longest name</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">read</span>(<span class="built_in">cin</span>, record))</span><br><span class="line">    &#123;</span><br><span class="line">        maxlen = <span class="built_in">max</span>(maxlen, record.name.<span class="built_in">size</span>());</span><br><span class="line">        students.push_back(record);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        info students_copy = students;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">// measure the performance for method1</span></span><br><span class="line">    	<span class="keyword">typedef</span> <span class="built_in">std</span>::chrono::high_resolution_clock Clock;</span><br><span class="line">    	Clock::time_point startTime = Clock::now();	    <span class="comment">// get current time</span></span><br><span class="line">    	info fails = extract_fails_method1(students);	<span class="comment">// extract records for failing students</span></span><br><span class="line">    	Clock::time_point endTime = Clock::now();	    <span class="comment">// get current time</span></span><br><span class="line"></span><br><span class="line">    	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Method 1 took me "</span></span><br><span class="line">    		 &lt;&lt; <span class="built_in">std</span>::chrono::duration_cast&lt;<span class="built_in">std</span>::chrono::duration&lt;<span class="keyword">double</span>&gt;&gt;(endTime - startTime).count()</span><br><span class="line">			 &lt;&lt; <span class="string">" seconds"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// measure the performance for method2</span></span><br><span class="line">    	startTime = Clock::now();	                    <span class="comment">// get current time</span></span><br><span class="line">    	fails = extract_fails_method2(students_copy);	<span class="comment">// extract records for failing students</span></span><br><span class="line">    	endTime = Clock::now();	                        <span class="comment">// get current time</span></span><br><span class="line"></span><br><span class="line">    	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Method 2 took me "</span></span><br><span class="line">    	     &lt;&lt;	<span class="built_in">std</span>::chrono::duration_cast&lt;<span class="built_in">std</span>::chrono::duration&lt;<span class="keyword">double</span>&gt;&gt;(endTime - startTime).count()</span><br><span class="line">    		 &lt;&lt; <span class="string">" seconds"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">// write each line of outputs for passing students</span></span><br><span class="line">    	<span class="keyword">if</span> (!students.empty())</span><br><span class="line">    	&#123;</span><br><span class="line">    		<span class="comment">//alphabetize the records</span></span><br><span class="line"></span><br><span class="line">        	sort(students.<span class="built_in">begin</span>(), students.<span class="built_in">end</span>(), compare);</span><br><span class="line">        	<span class="comment">// students.sort(compare);</span></span><br><span class="line">        	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Students who passed: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        	<span class="built_in">print</span>(students, maxlen);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        	<span class="built_in">cout</span> &lt;&lt; <span class="string">"What a pity! all students failed."</span>;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">// write a blank line</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// write each line of outputs for failing students</span></span><br><span class="line">        <span class="keyword">if</span>(!fails.empty())</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="comment">//alphabetize the records</span></span><br><span class="line"></span><br><span class="line">        	sort(fails.<span class="built_in">begin</span>(), fails.<span class="built_in">end</span>(), compare);</span><br><span class="line">        	<span class="comment">//fails.sort(compare);</span></span><br><span class="line">        	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Students who failed: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        	<span class="built_in">print</span>(fails, maxlen);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Congratulations! all students passed."</span>;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">catch</span>(domain_error e)&#123;</span><br><span class="line">    	<span class="built_in">cout</span> &lt;&lt; e.what();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The table below gives the comparison of these two methods, showing that method 2 performs slightly better than method 1. The result is in fact not reliable as it strongly depends on the number of passing students and failing students contained in the raw data. More experiments need to be done for more robust results.<br>|Number of lines|Method 1-erase| Method 2-insert&amp;resize|<br>| :— | :— | :— |<br>|10|0.000  seconds|0.000  seconds|<br>|1000|0.147114 seconds|0.117083 seconds|<br>|10000|0.848616 seconds|0.735503 seconds|</p>
<hr>
<h1 id="Exercise-5-7"><a href="#Exercise-5-7" class="headerlink" title="Exercise 5-7"></a>Exercise 5-7</h1><p>Given the implementation of frame in §5.8.1/93, and the following code fragment</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v;</span><br><span class="line">frame(v);</span><br></pre></td></tr></table></figure>
<p>describe what happens in this call. In particular, trace through how both the width functiona nd the frame function operate. Now, run this code. If the results differ from your expectations, first understand why your expectations and the program differ, and then change one to match the other.</p>
<h2 id="Solution-amp-Results-2"><a href="#Solution-amp-Results-2" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>Let’t recall the <strong>frame</strong> function</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">frame</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// to hold each rows of framed picture to be written</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ret;</span><br><span class="line">	<span class="comment">// get the length of the longest string</span></span><br><span class="line">	<span class="built_in">string</span>::size_type maxlen = <span class="built_in">width</span>(v);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// first line of outputs</span></span><br><span class="line">	<span class="function"><span class="built_in">string</span> <span class="title">border</span><span class="params">(maxlen + <span class="number">4</span>, <span class="string">'*'</span>)</span></span>;</span><br><span class="line">	ret.push_back(border);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::const_iterator iter = v.<span class="built_in">begin</span>(); iter != v.<span class="built_in">end</span>(); ++iter)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// new rows except two border lines</span></span><br><span class="line">		<span class="built_in">string</span> temp = <span class="string">"* "</span> + (*iter) + <span class="built_in">string</span>(maxlen - (*iter).<span class="built_in">size</span>(), <span class="string">' '</span>) + <span class="string">" *"</span>;</span><br><span class="line">		ret.push_back(temp);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// bottom line of outputs</span></span><br><span class="line">	ret.push_back(border);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Once calling this function with passing an empty vector<string> <strong>v</strong>, I expected following procedures happen one after another.</p>
<ol>
<li><p>the argument is passed by <strong>const reference</strong>. <strong>v</strong> refers to the empty vector<string> <strong>v</strong>.</p>
</li>
<li><p>an empty <strong>vector<string> ret</strong> is created.</p>
</li>
<li><p>an object of type <strong>string::size_type</strong> is created and named as <strong>maxlen</strong>. <strong>maxlen</strong> is initialized with a value returned by <strong>width</strong> function. </p>
</li>
<li><p>the computer enters into <strong>width</strong> function (as shown below). The arguments is also passed by <strong>const reference</strong> and hence parameter <strong>v</strong> refers to the empty vector<string> <strong>v</strong> defined in the main function.</p>
<p>4.1.    object <strong>maxlen</strong> is created and initialized with value of 0.</p>
<p>4.2.    the computer enters into a <strong>for</strong> loop. The init-statement is evaluated and <strong>iter</strong> is initialized as <strong>v.begin()</strong>. Then then condition is evaluated and the result is false as <strong>v.begin() == v.end()</strong> due to the fact that no any elements in the container. </p>
<p>4.3     <strong>for</strong> loop quits and <strong>maxlen</strong> that equals to 0 is returned. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span>::size_type <span class="title">width</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span>::size_type maxlen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::const_iterator iter = v.<span class="built_in">begin</span>(); iter != v.<span class="built_in">end</span>(); ++iter)</span><br><span class="line">    &#123;</span><br><span class="line">        maxlen = <span class="built_in">max</span>(maxlen, (*iter).<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxlen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>the computer goes back to the <strong>frame</strong> function and <strong>maxlen</strong> is initialized with value 0 (step 3 finishes).</p>
</li>
<li><p>object <strong>border</strong> is created and initialized with 4 asterisks. Then, it is stored into <strong>vector<string> ret</strong>.</p>
</li>
<li><p>the next <strong>for</strong> loop is similar to the <strong>for</strong> loop inside the <strong>width</strong> function. It quits and has no any effects.</p>
</li>
<li><p>object <strong>border</strong> is stored into <strong>vector<string> ret</strong> again. By then, <strong>ret</strong> has two elements, both of which are strings filled by 4 asterisks.</p>
</li>
<li><p><strong>ret</strong> is returned. The computer goes back to the function caller.</p>
</li>
</ol>
<p>According to my expection, the picture returned by <strong>frame</strong> only consist of two lines of strings each formed by 4 asterisks. Let’s verify this the program displayed below.</p>
<p><strong>A complete program</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">max</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// function declarations</span></span><br><span class="line"><span class="function"><span class="built_in">string</span>::size_type <span class="title">width</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;v)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">frame</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;v)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; p = frame(v);</span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::iterator iter = p.<span class="built_in">begin</span>(); iter != p.<span class="built_in">end</span>(); ++iter)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *iter &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// please fill this part with the width function described above</span></span><br><span class="line"><span class="comment">// please fill this part with the frame function described above</span></span><br></pre></td></tr></table></figure>
<p>As expected, the program produces following outputs</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">****</span><br><span class="line">****</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Exercise-5-8"><a href="#Exercise-5-8" class="headerlink" title="Exercise 5-8"></a>Exercise 5-8</h1><p>In the hcat function from §5.8.3/95, what would happen if we defined s outside the scope of the while? Rewrite and execute the program to confirm your hypothesis.</p>
<h2 id="Solution-amp-Results-3"><a href="#Solution-amp-Results-3" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><h3 id="Code-analysis"><a href="#Code-analysis" class="headerlink" title="Code analysis"></a>Code analysis</h3><p>Recalling the <strong>hcat</strong> function:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">hcat</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;left, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// to hold the each line of outputs</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// add one space column between two pictures</span></span><br><span class="line">	<span class="built_in">string</span>::size_type width1 = <span class="built_in">width</span>(left) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// iterators to look at elements from left and right respectively</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::const_iterator iter_i = left.<span class="built_in">begin</span>(), iter_j = right.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// continue until we've see all rows from two pictures</span></span><br><span class="line">	<span class="keyword">while</span> (iter_i != left.<span class="built_in">end</span>() || iter_j != right.<span class="built_in">end</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// construct new string to hold characters from two pictures</span></span><br><span class="line">		<span class="built_in">string</span> s;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// copy a row from left side picture</span></span><br><span class="line">		<span class="keyword">if</span> (iter_i != left.<span class="built_in">end</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			s  = (*iter_i);</span><br><span class="line">			++iter_i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// pad to full width</span></span><br><span class="line">		s += <span class="built_in">string</span>(width1 - s.<span class="built_in">size</span>(), <span class="string">' '</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// copy a row from right picture</span></span><br><span class="line">		<span class="keyword">if</span> (iter_j != left.<span class="built_in">end</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			s += (*iter_j);</span><br><span class="line">			++iter_j;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// store s into vector to form a new picture</span></span><br><span class="line">		ret.push_back(s);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Let’s analyse what happens if we define <strong>s</strong> outside the scope of the while loop:</p>
<ol>
<li><p><strong>s</strong> is an empty string before entering into the <strong>while</strong> loop.</p>
</li>
<li><p>the first iteration: </p>
<p> 2.1. <strong>s</strong> is assigned with the copy of the first element from the left picture, and then is padded out to the full width (left side).</p>
<p> 2.2. <strong>s</strong> is concatenated with the first element from the right picture.</p>
<p> 2.3. <strong>s</strong> is stored into <strong>vector<string> ret</strong> to formatted the first line of the new picture.</p>
</li>
<li><p>the <strong>n</strong>th interation:</p>
<p> case 1: the numbers of rows of both pictures are the same. The process of the rest iterations are similar to the first iteration until the while condition is evaluated to false. As a result, all rows of both pictures are copied into the new picture. The function has the same effect as the original one, where <strong>s</strong> is defined inside the <strong>while</strong> loop.</p>
<p> case 2: the left side picture has less rows than the right side picture. When <strong>iter_i == left.end()</strong> but <strong>iter_j != right.end()</strong>, the first <strong>if</strong> statements are ignored but the next statement (shown below) will result in compilation errors. </p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s +&#x3D; string(width1 - s.size(), &#39; &#39;);</span><br></pre></td></tr></table></figure>
<p> remembering that <strong>s.size()</strong> is the summation of widths of both sides, i.e. width1 plus the width of the right side picture. Therefore, <strong>width1 - s.size()</strong> is negative. </p>
<p> case 3: if left side picture has more rows than the right side picture. The process of the rest iterations are similar to case 1. The function has same effect as the original function, where <strong>s</strong> is defined inside of the <strong>while</strong> loop.</p>
</li>
</ol>
<h3 id="Rewrite-the-original-program"><a href="#Rewrite-the-original-program" class="headerlink" title="Rewrite the original program"></a>Rewrite the original program</h3><p>Now, let’s verify above expectations using following program, covering three cases and two functions(i.e. the original one and the modified one). The files of the program includes <strong>mainfunction.cpp</strong>, <strong>pics.cpp, pics.h, width.cpp. width.h, print.cpp and print.h</strong>. More details about the original program can be found in <a href="http://quanttour.com/14/03/2018/C-Sequential-Containers-Part-2/" target="_blank" rel="noopener">putting strings together</a>.</p>
<p><strong>mainfunction.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pics.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"print.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; pic1;</span><br><span class="line">	pic1.push_back(<span class="string">"aaaaaa"</span>);</span><br><span class="line">	pic1.push_back(<span class="string">"bbbbbbbbbbbbb"</span>);</span><br><span class="line">	pic1.push_back(<span class="string">"ccc"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; pic2;</span><br><span class="line">	pic2.push_back(<span class="string">"ddddddddddddd"</span>);</span><br><span class="line">	pic2.push_back(<span class="string">"eeeeeee"</span>);</span><br><span class="line">	pic2.push_back(<span class="string">"fffffffffff"</span>);</span><br><span class="line">	pic2.push_back(<span class="string">"ggggg"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; left, right;</span><br><span class="line">	<span class="comment">// Test case 1</span></span><br><span class="line">	left = right = pic1;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Test case 2</span></span><br><span class="line">	<span class="comment">// left = pic1; right = pic2;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Test case 3</span></span><br><span class="line">	<span class="comment">// left = pic2; right = pic1;</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; hcatPicture1 = hcat_function1(left, right);</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; hcatPicture2 = hcat_function2(left, right);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"The original function produces a picture shown as follows: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">print</span>(hcatPicture1);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"The modified function produces a picture shown as follows: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">print</span>(hcatPicture2);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>pics.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// functions that generate different pictures</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;		// to get declaration of string</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;		// to get declaration of vector</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"width.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pics.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// to horizontally concatenate two pictures: original function</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">hcat_function1</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;left, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// to hold the each line of outputs</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// add one space column between two pictures</span></span><br><span class="line">	<span class="built_in">string</span>::size_type width1 = <span class="built_in">width</span>(left) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// iterators to look at elements from left and right respectively</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::const_iterator iter_i = left.<span class="built_in">begin</span>(), iter_j = right.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// continue until we've see all rows from two pictures</span></span><br><span class="line">	<span class="keyword">while</span> (iter_i != left.<span class="built_in">end</span>() || iter_j != right.<span class="built_in">end</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// construct new string to hold characters from two pictures</span></span><br><span class="line">		<span class="built_in">string</span> s;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// copy a row from left side picture</span></span><br><span class="line">		<span class="keyword">if</span> (iter_i != left.<span class="built_in">end</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			s  = (*iter_i);</span><br><span class="line">			++iter_i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// pad to full width</span></span><br><span class="line">		s += <span class="built_in">string</span>(width1 - s.<span class="built_in">size</span>(), <span class="string">' '</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// copy a row from right picture</span></span><br><span class="line">		<span class="keyword">if</span> (iter_j != left.<span class="built_in">end</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			s += (*iter_j);</span><br><span class="line">			++iter_j;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// store s into vector to form a new picture</span></span><br><span class="line">		ret.push_back(s);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// to horizontally concatenate two pictures: modified function</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">hcat_function2</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;left, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// to hold the each line of outputs</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// add one space column between two pictures</span></span><br><span class="line">	<span class="built_in">string</span>::size_type width1 = <span class="built_in">width</span>(left) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// iterators to look at elements from left and right respectively</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::const_iterator iter_i = left.<span class="built_in">begin</span>(), iter_j = right.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// construct new string to hold characters from two pictures</span></span><br><span class="line">	<span class="built_in">string</span> s;</span><br><span class="line">	<span class="comment">// continue until we've see all rows from two pictures</span></span><br><span class="line">	<span class="keyword">while</span> (iter_i != left.<span class="built_in">end</span>() || iter_j != right.<span class="built_in">end</span>())</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">// copy a row from left side picture</span></span><br><span class="line">        <span class="keyword">if</span> (iter_i != left.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            s  = (*iter_i);</span><br><span class="line">            ++iter_i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// pad to full width</span></span><br><span class="line">        s += <span class="built_in">string</span>(width1 - s.<span class="built_in">size</span>(), <span class="string">' '</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// copy a row from right picture</span></span><br><span class="line">        <span class="keyword">if</span> (iter_j != right.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            s += (*iter_j);</span><br><span class="line">            ++iter_j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// store s into vector to form a new picture</span></span><br><span class="line">        ret.push_back(s);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>pics.h</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_PICS_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_PICS_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">hcat_function1</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; &amp;left,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; &amp;right)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">hcat_function2</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; &amp;left,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; &amp;right)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* GUARD_PICS_H */</span></span></span><br></pre></td></tr></table></figure>

<p><strong>width.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// function returns the size of the longest string in a vector&lt;string&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;	 // to get declaration of string</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;	 // to get declaration of vector</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; // to get declaration of max</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"width.h"</span>	 <span class="comment">// to get declaration of the function itself</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;  <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">max</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span>::size_type <span class="title">width</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span>::size_type maxlen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::const_iterator iter = v.<span class="built_in">begin</span>(); iter != v.<span class="built_in">end</span>(); ++iter)</span><br><span class="line">    &#123;</span><br><span class="line">        maxlen = <span class="built_in">max</span>(maxlen, (*iter).<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxlen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>width.h</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_WIDTH_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_WIDTH_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span>::size_type <span class="title">width</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; &amp;v)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* GUARD_WIDTH_H */</span></span></span><br></pre></td></tr></table></figure>

<p><strong>print.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// function to write each elements from a vector&lt;string&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"print.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;		// to get declaration of cout and endl</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;		// to get declaration of string</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;		// to get declaration of vector</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;		<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;		<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;pics)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// loop thru the vector and write elements one by one</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::const_iterator iter = pics.<span class="built_in">begin</span>(); iter != pics.<span class="built_in">end</span>(); ++iter)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; (*iter) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>print.h</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_OUTPUT_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_OUTPUT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; &amp;pics)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* GUARD_OUTPUT_H */</span></span></span><br></pre></td></tr></table></figure>
<h3 id="Test-results"><a href="#Test-results" class="headerlink" title="Test results"></a>Test results</h3><p><strong>Case 1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The original function produces a picture shown as follows: </span><br><span class="line">aaaaaa        aaaaaa</span><br><span class="line">bbbbbbbbbbbbb bbbbbbbbbbbbb</span><br><span class="line">ccc           ccc</span><br><span class="line"></span><br><span class="line">The modified function produces a picture shown as follows: </span><br><span class="line">aaaaaa        aaaaaa</span><br><span class="line">bbbbbbbbbbbbb bbbbbbbbbbbbb</span><br><span class="line">ccc           ccc</span><br></pre></td></tr></table></figure>

<p><strong>Case 2</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">This application has requested the Runtime to terminate it in an unusual way. </span><br><span class="line">Please contact the application&#39;s support team for more information. </span><br><span class="line">terminate called after throwing an instance of &#39;std::length_error&#39; </span><br><span class="line">what():  basic_string::_M_create</span><br></pre></td></tr></table></figure>

<p><strong>Case 3</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The original function produces a picture shown as follows: </span><br><span class="line">ddddddddddddd aaaaaa</span><br><span class="line">eeeeeee       bbbbbbbbbbbbb</span><br><span class="line">fffffffffff   ccc</span><br><span class="line">ggggg         </span><br><span class="line"></span><br><span class="line">The modified function produces a picture shown as follows: </span><br><span class="line">ddddddddddddd aaaaaa</span><br><span class="line">eeeeeee       bbbbbbbbbbbbb</span><br><span class="line">fffffffffff   ccc</span><br><span class="line">ggggg</span><br></pre></td></tr></table></figure>

<p>The results of all three cases are exactly as I expected and analysed in last section.</p>
<hr>
<p>To be continued.</p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Accelerated C++ Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title>Accelerated C++ Solutions to Exercises(Chapter 5 Part 2)</title>
    <url>/2018/03/17/Accelerated-C-Solutions-to-Exercises-Chapter-5-Part-2/</url>
    <content><![CDATA[<h1 id="Exercise-5-2-5-3-5-4"><a href="#Exercise-5-2-5-3-5-4" class="headerlink" title="Exercise 5-2, 5-3, 5-4"></a>Exercise 5-2, 5-3, 5-4</h1><p>5-2: Write the complete new version of the student-grading program, which extracts records for failing students, using vectors. Write another that uses lists. Measure the performance difference on input files of ten lines, 1,000 lines, and 10,000 lines.</p>
<p>5-3: By using a typedef, we can write one version of the program that implements either a vector-based solution or a list-based one. Write and test this version of the program.</p>
<p>5-4: Look again at the driver functions you wrote in the previous exercise. Note that it ispossible to write a driver that differs only in the declaration of the type for the data structure that holds the input file. If your vector and list test drivers differ in any other way, rewrite them so that they differ only in this declaration.</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>I’ll give solution to 5-4 directly as these three exercises are closely connected. The strategy can be divided into three steps:</p>
<ol>
<li>write drivers for using <strong>list</strong> or <strong>vector</strong> to hold input files.</li>
<li>add the function to extract records for failing students, and add the drivers for files where the declaration of specified container is needed.</li>
<li>change indices to iterators if necessary because <strong>list</strong> doesn’t support access elements via indices.</li>
<li>measure the performance difference of two containers on input files of 10 lines, 1000 lines and 10000 lines.</li>
</ol>
<h3 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1"></a>Step 1</h3><p>To switch the use of <strong>list</strong> and <strong>vector</strong>, I follows the suggestion of 5-3；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// typedef list&lt;Student_info&gt; info;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;Student_info&gt; info;</span><br></pre></td></tr></table></figure>
<p>The alias <strong>info</strong> can represent either the type <strong>list<Student_info></strong> or <strong>vector<Student_info></strong> and hence allows us switch from one version to another simply via modifying this declaration.</p>
<p>However, the type declared above is not only used in the file that contains the main function, but may also needed in other files. Therefore, I separate the declaration from the main function and create a header for this reason.<br><strong>info.h</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_INFO_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_INFO_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//typedef std::vector&lt;Student_info&gt; info;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;Student_info&gt; info;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* GUARD_INFO_H */</span></span></span><br></pre></td></tr></table></figure>
<p>All files that want to use the name <strong>info</strong> include the header where declares the name <strong>info</strong>. </p>
<h3 id="Step-2"><a href="#Step-2" class="headerlink" title="Step 2"></a>Step 2</h3><p>This step adds two functions: one is to extract the records for failing students; another one is a predicate on failing grades.<br>It can be observed that the header “info.h” is included for the purpose of defining the container <strong>fail</strong> to holding information of the failing students.<br><strong>fails.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"grade.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"fails.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"info.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// the predicate for students who failed</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">fgrade</span><span class="params">(<span class="keyword">const</span> Student_info &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> grade(s) &lt; <span class="number">60</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// function to extract the failed student records</span></span><br><span class="line"><span class="function">info <span class="title">extract_fails</span><span class="params">(info &amp;students)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    info fail;</span><br><span class="line">    info::iterator iter = students.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(iter != students.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(fgrade(*iter))</span><br><span class="line">        &#123;</span><br><span class="line">            fail.push_back(*iter);</span><br><span class="line">            iter = students.erase(iter);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ++iter;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>fails.h</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_FAILS_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_FAILS_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"info.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">fgrade</span><span class="params">(<span class="keyword">const</span> Student_info &amp;s)</span></span>;</span><br><span class="line"><span class="function">info <span class="title">extract_fails</span><span class="params">(info &amp;students)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* GUARD_FAILS_H*/</span></span></span><br></pre></td></tr></table></figure>

<h3 id="Step-3"><a href="#Step-3" class="headerlink" title="Step 3"></a>Step 3</h3><p>The last change needs to be done is using iterators instead of indices. To avoid messy, I rewrite the output section as a function named <strong>print</strong>. </p>
<p><strong>print.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"grade.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"print.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"info.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;		 <span class="keyword">using</span> <span class="built_in">std</span>::setprecision;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;		 <span class="keyword">using</span> <span class="built_in">std</span>::streamsize;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> info &amp;records, <span class="keyword">const</span> <span class="built_in">string</span>::size_type &amp;maxlen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (info::const_iterator iter = records.<span class="built_in">begin</span>(); iter != records.<span class="built_in">end</span>(); ++iter)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// write the name, blanks</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (*iter).name &lt;&lt; <span class="built_in">string</span>(maxlen + <span class="number">1</span> - (*iter).name.<span class="built_in">size</span>(), <span class="string">' '</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// compute and write the final grade</span></span><br><span class="line">        <span class="keyword">double</span> final_grade = grade(*iter);</span><br><span class="line">        streamsize prec = <span class="built_in">cout</span>.precision();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; setprecision(<span class="number">3</span>) &lt;&lt; final_grade &lt;&lt; setprecision(prec) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>print.h</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_PRINT_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_PRINT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"info.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> info &amp;records, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>::size_type &amp;maxlen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* GUARD_PRINT_H */</span></span></span><br></pre></td></tr></table></figure>

<p>Note that I didn’t add <strong>try</strong> block here as the <strong>exceptions</strong> may be thrown early in the process of extracting the failing records. </p>
<h3 id="Step-4"><a href="#Step-4" class="headerlink" title="Step 4"></a>Step 4</h3><p>To measure the performance of the <strong>vector</strong> based program and <strong>list</strong> based program, I uses members of the time library <strong><chrono></strong>. Specifically:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::chrono::high_resolution_clock Clock;</span><br><span class="line">Clock::time_point startTime = Clock::now();	<span class="comment">// get current time</span></span><br><span class="line">info fails = extract_fails(students);	    <span class="comment">// extract records for failing students</span></span><br><span class="line">Clock::time_point endTime = Clock::now();   <span class="comment">// get current time</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"It took me "</span> </span><br><span class="line">     &lt;&lt; <span class="built_in">std</span>::chrono::duration_cast&lt;<span class="built_in">std</span>::chrono::seconds&gt;(endTime - startTime).count()</span><br><span class="line">     &lt;&lt; <span class="string">" seconds"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>The usage of <strong>std::chrono::high_resolution_clock</strong> refers to<br><a href="http://www.cplusplus.com/reference/chrono/high_resolution_clock/now/" target="_blank" rel="noopener">high_resolution_clock</a>. </p>
<h3 id="A-complete-program"><a href="#A-complete-program" class="headerlink" title="A complete program"></a>A complete program</h3><p>By now, I have introduced the main changes relative to the original program. Therefore, the complete program includes following files</p>
<table>
<thead>
<tr>
<th align="left">header files</th>
<th align="left">source files</th>
</tr>
</thead>
<tbody><tr>
<td align="left">info.h</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">fails.h</td>
<td align="left">fails.cpp</td>
</tr>
<tr>
<td align="left">print.h</td>
<td align="left">print.cpp</td>
</tr>
<tr>
<td align="left">Student_info.h</td>
<td align="left">Student_info.cpp</td>
</tr>
<tr>
<td align="left">grade.h</td>
<td align="left">grade.cpp</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">mainfunction.cpp</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<p>I present the rest files in below. Noting that there are two major differences between the vector-based version and the list-based version. First is the declaration metioned above. The second is that the usage of <strong>sort</strong> function for two types of containers are different, for <strong>vector</strong>s, the statement is </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">sort(students.<span class="built_in">begin</span>(), students.<span class="built_in">end</span>(), compare);</span><br></pre></td></tr></table></figure>
<p>while for <strong>list</strong>s,</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">students.sort(compare);</span><br></pre></td></tr></table></figure>
<p>Strictly speaking, my solution doesn’t meet the requirements of 5-4. But I haven’t find a better one.</p>
<p><strong>mainfunction.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;		// to get declaration of max, sort</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;			// to get declaration of cin, cout, endl</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;		// to get declaration of domain_error</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;			// to get declaration of string</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;           </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"grade.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"fails.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"print.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"info.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;					<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;				<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">max</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;				<span class="keyword">using</span> <span class="built_in">std</span>::sort;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::domain_error;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    info students;</span><br><span class="line">    Student_info record;</span><br><span class="line">    <span class="built_in">string</span>::size_type maxlen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read and store all the records, and find the length of the longest name</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">read</span>(<span class="built_in">cin</span>, record))</span><br><span class="line">    &#123;</span><br><span class="line">        maxlen = <span class="built_in">max</span>(maxlen, record.name.<span class="built_in">size</span>());</span><br><span class="line">        students.push_back(record);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">    	<span class="comment">// measure the performance</span></span><br><span class="line">    	<span class="keyword">typedef</span> <span class="built_in">std</span>::chrono::high_resolution_clock Clock;</span><br><span class="line">    	Clock::time_point startTime = Clock::now();	<span class="comment">// get current time</span></span><br><span class="line">    	info fails = extract_fails(students);		<span class="comment">// extract records for failing students</span></span><br><span class="line">    	Clock::time_point endTime = Clock::now();	<span class="comment">// get current time</span></span><br><span class="line"></span><br><span class="line">    	<span class="built_in">cout</span> &lt;&lt; <span class="string">"It took me "</span> </span><br><span class="line">             &lt;&lt; <span class="built_in">std</span>::chrono::duration_cast&lt;<span class="built_in">std</span>::chrono::seconds&gt;(endTime - startTime).count() </span><br><span class="line">             &lt;&lt; <span class="string">" seconds"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">// write each line of outputs for passing students</span></span><br><span class="line">    	<span class="keyword">if</span> (!students.empty())</span><br><span class="line">    	&#123;</span><br><span class="line">    		<span class="comment">//alphabetize the records</span></span><br><span class="line"></span><br><span class="line">        	<span class="comment">//sort(students.begin(), students.end(), compare);</span></span><br><span class="line">        	students.sort(compare);</span><br><span class="line">        	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Students who passed: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        	<span class="built_in">print</span>(students, maxlen);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        	<span class="built_in">cout</span> &lt;&lt; <span class="string">"What a pity! all students failed."</span>;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">// write a blank line</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// // write each line of outputs for failing students</span></span><br><span class="line">        <span class="keyword">if</span>(!fails.empty())</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="comment">//alphabetize the records</span></span><br><span class="line"></span><br><span class="line">        	<span class="comment">//sort(fails.begin(), fails.end(), compare);</span></span><br><span class="line">        	fails.sort(compare);</span><br><span class="line">        	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Students who failed: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        	<span class="built_in">print</span>(fails, maxlen);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Congratulations! all students passed."</span>;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">catch</span>(domain_error e)&#123;</span><br><span class="line">    	<span class="built_in">cout</span> &lt;&lt; e.what();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Student_info.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>; <span class="keyword">using</span> <span class="built_in">std</span>::istream;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> Student_info &amp;x, <span class="keyword">const</span> Student_info &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.name &lt; y.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">istream &amp; <span class="title">read</span><span class="params">(istream &amp;is, Student_info &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// reads and store the student's name, midterm and final exam grades</span></span><br><span class="line">    is &gt;&gt; s.name &gt;&gt; s.midterm &gt;&gt; s.<span class="keyword">final</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reads and store all homework grades</span></span><br><span class="line">    read_hw(is, s.homework);</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">istream &amp; <span class="title">read_hw</span><span class="params">(istream &amp;in, <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;hw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (in)&#123;</span><br><span class="line">		<span class="comment">//get rid of previous contents</span></span><br><span class="line">		hw.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// read homework grades</span></span><br><span class="line">		<span class="keyword">double</span> x;</span><br><span class="line">		<span class="keyword">while</span>(in &gt;&gt; x)</span><br><span class="line">			hw.push_back(x);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// clear the stream so that input will work for the next student</span></span><br><span class="line">		in.<span class="built_in">clear</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Student_info.h</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_Student_info</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_Student_info</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Student_info.header file</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student_info</span>&#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">double</span> midterm, <span class="keyword">final</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; homework;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> Student_info &amp;, <span class="keyword">const</span> Student_info &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::istream &amp; <span class="title">read</span><span class="params">(<span class="built_in">std</span>::istream &amp;, Student_info &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::istream &amp; <span class="title">read_hw</span><span class="params">(<span class="built_in">std</span>::istream &amp;, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>grade.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"grade.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::domain_error;  <span class="keyword">using</span> <span class="built_in">std</span>::istream;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;        <span class="keyword">using</span> <span class="built_in">std</span>::sort;</span><br><span class="line"></span><br><span class="line"><span class="comment">// grade function 1</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">const</span> Student_info &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> grade(s.midterm, s.<span class="keyword">final</span>, s.homework);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// grade function 2</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">double</span> midterm, <span class="keyword">double</span> <span class="keyword">final</span>, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;hw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hw.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> domain_error(<span class="string">"student has done no homework"</span>);</span><br><span class="line">    <span class="keyword">return</span> grade(midterm, <span class="keyword">final</span>, median(hw));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// grade function 3</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">double</span> midterm, <span class="keyword">double</span> <span class="keyword">final</span>, <span class="keyword">double</span> homework)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.2</span>*midterm + <span class="number">0.4</span>*<span class="keyword">final</span> + <span class="number">0.4</span>*homework;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compute the median of vector&lt;double&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">median</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// get the size of the vector</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;::size_type vec_size;</span><br><span class="line">    vec_size <span class="built_in">size</span> = vec.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check whether the empty is empty</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span> == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> domain_error(<span class="string">"median of an empty vector"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sort the grades</span></span><br><span class="line">    sort(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// compute the median homework grade</span></span><br><span class="line">    vec_size mid = <span class="built_in">size</span>/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">size</span> % <span class="number">2</span> == <span class="number">0</span> ? (vec[mid] + vec[mid - <span class="number">1</span>])/<span class="number">2</span> : vec[mid];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>grade.h</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_grade_h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_grade_h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// grade.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">const</span> Student_info &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">median</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2 id="Results"><a href="#Results" class="headerlink" title="Results"></a>Results</h2><p>I also wrote a naive program that “randomly” generates thousands of names and grades. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>; 	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> initials&#123;<span class="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZ"</span>&#125;;</span><br><span class="line">    <span class="built_in">string</span> letters&#123;<span class="string">"abcdefghijklmnopqrstuvwxyz"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != <span class="number">10000</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = rand() % <span class="number">26</span>;</span><br><span class="line">        <span class="keyword">int</span> y = rand() % <span class="number">26</span>;</span><br><span class="line">        <span class="keyword">int</span> z = rand() % <span class="number">26</span>;</span><br><span class="line">        <span class="keyword">int</span> p = rand() % <span class="number">26</span>;</span><br><span class="line">        <span class="keyword">int</span> q = rand() % <span class="number">26</span>;</span><br><span class="line">        <span class="keyword">double</span> midterm = rand() % <span class="number">100</span> + (rand() % <span class="number">100</span>)/<span class="number">99.0</span>;</span><br><span class="line">        <span class="keyword">double</span> <span class="keyword">final</span> = rand() % <span class="number">100</span> + (rand() % <span class="number">100</span>)/<span class="number">99.0</span>;</span><br><span class="line">        <span class="keyword">double</span> homework = rand() % <span class="number">100</span> + (rand() % <span class="number">100</span>)/<span class="number">99.0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> name&#123;initials[x], letters[y], letters[z], letters[p], letters[q]&#125;;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="string">' '</span> &lt;&lt; midterm &lt;&lt; <span class="string">' '</span> &lt;&lt; <span class="keyword">final</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; homework &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The table below gives the performance difference of two version pograms on input files of ten lines, 1,000 lines, and 10,000 lines.</p>
<table>
<thead>
<tr>
<th align="left">Number of lines</th>
<th align="left">vector</th>
<th align="left">list</th>
</tr>
</thead>
<tbody><tr>
<td align="left">10</td>
<td align="left">0.00107  seconds</td>
<td align="left">0.00007  seconds</td>
</tr>
<tr>
<td align="left">1000</td>
<td align="left">0.136711 seconds</td>
<td align="left">0.003036 seconds</td>
</tr>
<tr>
<td align="left">10000</td>
<td align="left">0.826406 seconds</td>
<td align="left">0.015598 seconds</td>
</tr>
</tbody></table>
<p>Apparently, the <strong>list</strong> based program has much better performance than the <strong>vector</strong> based program, with using much less time in extracting the failing students’ records regardless of the file size. In addition, along with the increase of file size, the time taken by the <strong>list</strong> version program increases much slower than that taken by the <strong>vector</strong> version.  </p>
<hr>
<p>To be continued.</p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Accelerated C++ Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title>Accelerated C++ Solutions to Exercises(Chapter 5 Part 1)</title>
    <url>/2018/03/14/Accelerated-C-Solutions-to-Exercises-Chapter-5/</url>
    <content><![CDATA[<h1 id="Exercise-5-0"><a href="#Exercise-5-0" class="headerlink" title="Exercise 5-0"></a>Exercise 5-0</h1><p>Compile, execute, and test the programs in this chapter</p>
<h2 id="Solution-amp-Results"><a href="#Solution-amp-Results" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>Please find solutions and detailed analysis in <a href="http://quanttour.com/14/03/2018/C-Sequential-Containers-Part-2/" target="_blank" rel="noopener">Chapter 5 Sequential Containers </a>.</p>
<h1 id="Exercise-5-1"><a href="#Exercise-5-1" class="headerlink" title="Exercise 5-1"></a>Exercise 5-1</h1><p>Design and implement a program to produce a permuted index. A permuted index is one in which each phrase is indexed by every word in the phrase. So, given the following input,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The quick brown fox </span><br><span class="line">jumped over the fence</span><br></pre></td></tr></table></figure>
<p>the output would be</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">      The quick     brown fox </span><br><span class="line">jumped over the     fence</span><br><span class="line">The quick brown     fox                     </span><br><span class="line">                    jumped over the fence         </span><br><span class="line">         jumped     over the fence            </span><br><span class="line">            The     quick brown fox</span><br><span class="line">    jumped over     the fence                   </span><br><span class="line">                    The quick brown fox</span><br></pre></td></tr></table></figure>

<p>A good algorithm is suggested in The AWK Programming Language by Aho, Kernighan, and Weinberger (Addison-Wesley, 1988). That solution divides the problem into three steps:</p>
<ol>
<li><p>Read each line of the input and generate a set of rotations of that line. Each rotation puts the next word of the input in the first position and rotates the previous first word to the end of the phrase. So the output of this phase for the first line of our input would be</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The quick brown fox</span><br><span class="line">quick brown fox The</span><br><span class="line">brown fox The quick</span><br><span class="line">fox The quick brown</span><br></pre></td></tr></table></figure>
<p>Of course, it will be important to know where the original phrase ends and where the rotated beginning begins.</p>
</li>
<li><p>Sort the rotations.</p>
</li>
<li><p>Unrotate and write the permuted index, which involves finding the separator, putting the phrase back together, and writing it properly formatted.</p>
</li>
</ol>
<h2 id="Solution-amp-Results-1"><a href="#Solution-amp-Results-1" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><h3 id="program-logic"><a href="#program-logic" class="headerlink" title="program logic"></a>program logic</h3><p>The solution strategy provided above is quite straightforward. But before implementing such strategy, several stylized facts observed from the example should be listed. </p>
<ol>
<li>the output can be divided into two groups.</li>
<li>the right group of lines contains the <strong>key</strong> words (i.e. the alphabetically indexed words). The key word can be any word of a phrase. Therefore, when the first word of a phrase is indexed, the right part contains a complete phrase.</li>
<li>the left part and right part of the same line are complementary each other, which leads to a complete phrase. When the right part contains a complete phrase, the left part contains nothing but spaces. </li>
</ol>
<p>As described above, we can split the first phrase as follows</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                    The quick brown fox</span><br><span class="line">            The     quick brown fox    </span><br><span class="line">      The quick     brown fox </span><br><span class="line">The quick brown     fox</span><br></pre></td></tr></table></figure>
<p>Rather than generating rotations, I would like to split one phrase into all possible combinations. Each combination will be stored into a data structure defined as below.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">line</span>&#123;</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> left; <span class="comment">// contains the left part of a phrase</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> right;<span class="comment">// contains the right part of a phrase</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>In addition, we can define a vector to hold all combinations (i.e. objects of type <strong>line</strong>), covering all phrases to be entered. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">line</span>&gt; combinations;</span><br></pre></td></tr></table></figure>
<p>Once all combinations have been stored into the vector, we can sort the vector according to the value of the right part of each combination. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">sort(combinations.<span class="built_in">begin</span>(), combinations.<span class="built_in">end</span>(), compare);</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="built_in">line</span> &amp;x, <span class="keyword">const</span> <span class="built_in">line</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.right &lt; y.right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>By doing so, we have alphabetized all key words. The next is to format the left parts. The content of left part of each line has been fixed as the left part is bound with the right part. All left parts are lined up vertically on the right side while their left side are padded out with certain amount of spaces depending on the longest string of the left parts. </p>
<p>Assuming the length of the longest string is obtained and stored in <strong>maxlen</strong>, the left part of outputs for each line will be</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string(maxlen - combinations[z].left.size(), &#39; &#39;) + combinations[z].left</span><br></pre></td></tr></table></figure>

<p>It is worth noting that the permuted index is case-insensitive. Therefore, the strings that compared in the <strong>compare</strong> function should be converted to lower-case letters. In addition, a line of phrase is easily to be splitted if there is no extra spaces before or after the the line, or between words. However, a common case is that users enter more spaces than needed. Therefore, it is necessary to clean needless spaces before we split one line. </p>
<p>In summary, the program can be divided into five logic parts</p>
<ol>
<li>read in multiple lines of inputs</li>
<li>clean each line for removing needless spaces</li>
<li>split each line into all possible combinations</li>
<li>store all combinations for all lines and get <strong>maxlen</strong>. </li>
<li><strong>sort</strong> and print each line</li>
</ol>
<h3 id="files"><a href="#files" class="headerlink" title="files"></a>files</h3><p>The main function is shown below</p>
<p><strong>mainfunction.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;      // to get declaration of cin, cout and endl</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;	      // to get declaration of string and getline</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;	      // to get declaration of vector</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;     // to get declaration of sort</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cleaning.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"line.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;		<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>; 		<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;		<span class="keyword">using</span> <span class="built_in">std</span>::getline;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::sort;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="comment">// hold combinations</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">line</span>&gt; combinations;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// hold the length of the longest string</span></span><br><span class="line">	<span class="built_in">string</span>::size_type maxlen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// read in</span></span><br><span class="line">	<span class="built_in">string</span> words;</span><br><span class="line">	<span class="keyword">while</span>(getline(<span class="built_in">cin</span>, words))</span><br><span class="line">	&#123;     </span><br><span class="line">            <span class="comment">// split each line, store all combinations, record maxlen</span></span><br><span class="line">            <span class="keyword">if</span>(!words.empty())</span><br><span class="line">                  split(cleaning(words), combinations, maxlen);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// format the outputs</span></span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	sort(combinations.<span class="built_in">begin</span>(), combinations.<span class="built_in">end</span>(), compare);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// write each line of outputs: left part + 4 spaces + right part</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="built_in">line</span>&gt;::size_type z = <span class="number">0</span>; z != combinations.<span class="built_in">size</span>(); ++z)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; (<span class="built_in">string</span>(maxlen - combinations[z].left.<span class="built_in">size</span>(), <span class="string">' '</span>) + combinations[z].left)</span><br><span class="line">		     &lt;&lt; <span class="string">"    "</span> &lt;&lt; combinations[z].right &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>I put the <strong>split</strong> function and <strong>compare</strong> funtion into one file named <strong>line</strong>.</p>
<p><strong>line.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"line.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">tolower</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">isupper</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">max</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// function to get rotations of a line and store all rotations into vector&lt;line&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="built_in">string</span> words, <span class="built_in">vector</span>&lt;<span class="built_in">line</span>&gt; &amp;combs, <span class="built_in">string</span>::size_type &amp;maxlen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// store the original lines</span></span><br><span class="line">	<span class="built_in">line</span> originLine;</span><br><span class="line">	originLine.right = words;</span><br><span class="line">	originLine.left = <span class="string">""</span>;</span><br><span class="line">	combs.push_back(originLine);</span><br><span class="line">	maxlen = <span class="built_in">max</span>(maxlen, originLine.left.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">	<span class="comment">// store the splitted lines</span></span><br><span class="line">	<span class="built_in">string</span>::size_type i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (i != words.<span class="built_in">size</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">line</span> rotateLine;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">isspace</span>(words[i]))</span><br><span class="line">		&#123;</span><br><span class="line">			rotateLine.right = words.substr(i+<span class="number">1</span>, words.<span class="built_in">size</span>() - i);</span><br><span class="line">			rotateLine.left = words.substr(<span class="number">0</span>, i);</span><br><span class="line">			combs.push_back(rotateLine);</span><br><span class="line">			maxlen = <span class="built_in">max</span>(maxlen, rotateLine.left.<span class="built_in">size</span>());</span><br><span class="line">		&#125;</span><br><span class="line">		++i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// change characters to lowercase letters</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">tolowerString</span><span class="params">(<span class="built_in">string</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">string</span>::iterator iter = c.<span class="built_in">begin</span>(); iter != c.<span class="built_in">end</span>(); ++iter)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">isupper</span>(*iter))</span><br><span class="line">			*iter = <span class="built_in">tolower</span>(*iter);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// define the arguments for sort function</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="built_in">line</span> &amp;x, <span class="keyword">const</span> <span class="built_in">line</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tolowerString(x.right) &lt; tolowerString(y.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>line.h</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_LINE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_LINE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">line</span>&#123;</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> left;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> words, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">line</span>&gt; &amp;combs, <span class="built_in">std</span>::<span class="built_in">string</span>::size_type &amp;maxlen)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">tolowerString</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="built_in">line</span> &amp;x, <span class="keyword">const</span> <span class="built_in">line</span> &amp;y)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* GUARD_LINE_H */</span></span></span><br></pre></td></tr></table></figure>

<p>The final part is the <strong>cleaning</strong> function that is used to remove extra spaces. </p>
<p><strong>cleaning.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// this function removes needless spaces for a sentence</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cleaning.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">isspace</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">cleaning</span><span class="params">(<span class="built_in">string</span> words)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">string</span>::iterator iter = words.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// remove spaces before the real sentence begins</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isspace</span>(*iter))</span><br><span class="line">		iter = words.erase(iter);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// remove extra spaces between two words</span></span><br><span class="line">	<span class="keyword">while</span>((iter+<span class="number">1</span>) != words.<span class="built_in">end</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">isspace</span>(*iter) &amp;&amp; <span class="built_in">isspace</span>(*(iter + <span class="number">1</span>)))</span><br><span class="line">			iter = words.erase(iter);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			++iter;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// remove the trailing space</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">isspace</span>(*iter))</span><br><span class="line">		words.erase(iter);</span><br><span class="line">	<span class="keyword">return</span> words;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>cleaning.h</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_CLEANING_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_CLEANING_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">cleaning</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> words)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* GUARD_CLEANING_H */</span></span></span><br></pre></td></tr></table></figure>
<h3 id="Test-performance"><a href="#Test-performance" class="headerlink" title="Test performance"></a>Test performance</h3><p>Let’s test the required inputs</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The quick brown fox </span><br><span class="line">jumped over the fence</span><br><span class="line"></span><br><span class="line">      The quick    brown fox</span><br><span class="line">jumped over the    fence</span><br><span class="line">The quick brown    fox</span><br><span class="line">                   jumped over the fence</span><br><span class="line">         jumped    over the fence</span><br><span class="line">            The    quick brown fox</span><br><span class="line">    jumped over    the fence</span><br><span class="line">                   The quick brown fox</span><br></pre></td></tr></table></figure>
<p>To show the robustness of this program, I choose a text fragment from <em>The Declaration of Independence</em> as the inputs:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">He has refused for a long time, </span><br><span class="line">after such dissolution, </span><br><span class="line">to cause others to be elected; </span><br><span class="line">whereby the legislative powers, </span><br><span class="line">incapable of annihilation, </span><br><span class="line">have returned to the people at large for their exercise; </span><br><span class="line">the State remaining in the meantime exposed </span><br><span class="line">to all the dangers of invasion from </span><br><span class="line">without and convulsion within.</span><br></pre></td></tr></table></figure>

<p>The resulted output perfectly follows the requirement of the permuted index</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                            He has refused for    a long time,</span><br><span class="line">                                                  after such dissolution,</span><br><span class="line">                                            to    all the dangers of invasion from</span><br><span class="line">                                       without    and convulsion within.</span><br><span class="line">                                  incapable of    annihilation,</span><br><span class="line">                   have returned to the people    at large for their exercise;</span><br><span class="line">                            to cause others to    be elected;</span><br><span class="line">                                            to    cause others to be elected;</span><br><span class="line">                                   without and    convulsion within.</span><br><span class="line">                                    to all the    dangers of invasion from</span><br><span class="line">                                    after such    dissolution,</span><br><span class="line">                         to cause others to be    elected;</span><br><span class="line">have returned to the people at large for their    exercise;</span><br><span class="line">           the State remaining in the meantime    exposed</span><br><span class="line">                                He has refused    for a long time,</span><br><span class="line">          have returned to the people at large    for their exercise;</span><br><span class="line">                to all the dangers of invasion    from</span><br><span class="line">                                            He    has refused for a long time,</span><br><span class="line">                                                  have returned to the people at large for their exercise;</span><br><span class="line">                                                  He has refused for a long time,</span><br><span class="line">                           the State remaining    in the meantime exposed</span><br><span class="line">                                                  incapable of annihilation,</span><br><span class="line">                         to all the dangers of    invasion from</span><br><span class="line">                have returned to the people at    large for their exercise;</span><br><span class="line">                                   whereby the    legislative powers,</span><br><span class="line">                          He has refused for a    long time,</span><br><span class="line">                    the State remaining in the    meantime exposed</span><br><span class="line">                                     incapable    of annihilation,</span><br><span class="line">                            to all the dangers    of invasion from</span><br><span class="line">                                      to cause    others to be elected;</span><br><span class="line">                          have returned to the    people at large for their exercise;</span><br><span class="line">                       whereby the legislative    powers,</span><br><span class="line">                                        He has    refused for a long time,</span><br><span class="line">                                     the State    remaining in the meantime exposed</span><br><span class="line">                                          have    returned to the people at large for their exercise;</span><br><span class="line">                                           the    State remaining in the meantime exposed</span><br><span class="line">                                         after    such dissolution,</span><br><span class="line">                                        to all    the dangers of invasion from</span><br><span class="line">                                       whereby    the legislative powers,</span><br><span class="line">                        the State remaining in    the meantime exposed</span><br><span class="line">                              have returned to    the people at large for their exercise;</span><br><span class="line">                                                  the State remaining in the meantime exposed</span><br><span class="line">      have returned to the people at large for    their exercise;</span><br><span class="line">                     He has refused for a long    time,</span><br><span class="line">                                                  to all the dangers of invasion from</span><br><span class="line">                               to cause others    to be elected;</span><br><span class="line">                                                  to cause others to be elected;</span><br><span class="line">                                 have returned    to the people at large for their exercise;</span><br><span class="line">                                                  whereby the legislative powers,</span><br><span class="line">                        without and convulsion    within.</span><br><span class="line">                                                  without and convulsion within.</span><br></pre></td></tr></table></figure>

<hr>
<p>To be continued.</p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Accelerated C++ Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ - Sequential Containers (Part 2)</title>
    <url>/2018/03/14/C-Sequential-Containers-Part-2/</url>
    <content><![CDATA[<h1 id="Putting-strings-together"><a href="#Putting-strings-together" class="headerlink" title="Putting strings together"></a>Putting strings together</h1><p>This part provides a series of exercises about various concatenations of strings. The topic is similar to that in <a href="http://quanttour.com/23/02/2018/C-Looping-and-counting/" target="_blank" rel="noopener">Chpater 2 Looping and counting</a>. </p>
<h2 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise 1"></a>Exercise 1</h2><p>Briefly speaking, the first exercise requires us to design a program that can add a frame for a picture (shown as below).</p>
<p><strong>The original picture</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this is an</span><br><span class="line">example</span><br><span class="line">to</span><br><span class="line">illustrate</span><br><span class="line">framing</span><br></pre></td></tr></table></figure>
<p><strong>The framed picture</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">**************</span><br><span class="line">* this is an *</span><br><span class="line">* example    *</span><br><span class="line">* to         *</span><br><span class="line">* illustrate *</span><br><span class="line">* framing    *</span><br><span class="line">* ************</span><br></pre></td></tr></table></figure>
<p>The original picture is in fact formed by several lines of strings, of which each string is an element stored in the vector named <strong>p</strong>. The framed picture adds four edges for the original picture with asterisks. There is one space between the left-edge and the initial character of the strings, and one space between the right-edge and the end of the longest string. </p>
<h2 id="Exercise-2"><a href="#Exercise-2" class="headerlink" title="Exercise 2"></a>Exercise 2</h2><p>Once we have the framed picture, we can vertically concatenate it with the original one. The program should generate a final picture like this</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this is an</span><br><span class="line">example</span><br><span class="line">to</span><br><span class="line">illustrate</span><br><span class="line">framing</span><br><span class="line">**************</span><br><span class="line">* this is an *</span><br><span class="line">* example    *</span><br><span class="line">* to         *</span><br><span class="line">* illustrate *</span><br><span class="line">* framing    *</span><br><span class="line">**************</span><br></pre></td></tr></table></figure>
<p>Two pictures are lined up along the left-hand border.</p>
<h2 id="Exercise-3"><a href="#Exercise-3" class="headerlink" title="Exercise 3"></a>Exercise 3</h2><p>We can also perform horizontal concatenation on two pictures like the below picture shows</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this is an **************</span><br><span class="line">example    * this is an *</span><br><span class="line">to         * example    *</span><br><span class="line">illustrate * to         *</span><br><span class="line">framing    * illustrate *</span><br><span class="line">           * framing    *</span><br><span class="line">           **************</span><br></pre></td></tr></table></figure>
<p>Two pictures are lined up along the top border. In addition, there is a blank column that seperates two pictures. </p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><p>The book provides solutions to each exercise listed above, I’ll put all together and write a program that can generate above pictures once.</p>
<h3 id="The-framed-picture"><a href="#The-framed-picture" class="headerlink" title="The framed picture"></a>The framed picture</h3><p>Framing a picture is an old question. The solution strategy can be divided into three steps</p>
<ol>
<li>obtain the length (denoted by <strong>maxlen</strong>) of the longest string in <strong>p</strong> as the width of the framed picture depends on <strong>maxlen</strong>.</li>
<li>create a string object that filled by asterisks for generating the top line and bottom line. The number of the astersiks is <strong>maxlen + 4</strong>.</li>
<li>the middle lines are formed by 1 space character and the corresponding string in <strong>p</strong>, and a certain number of spaces. The number of spaces is the difference between the <strong>maxlen</strong> and the size of the corresponding string to be concatenated. </li>
</ol>
<p>Below shows the function that gives the length of the longest string in a object of vector<string>. I uses iterators instead of indices for all functions.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span>::size_type <span class="title">width</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span>::size_type maxlen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::const_iterator iter = v.<span class="built_in">begin</span>(); iter != v.<span class="built_in">end</span>(); ++iter)</span><br><span class="line">    &#123;</span><br><span class="line">        maxlen = <span class="built_in">max</span>(maxlen, (*iter).<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxlen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The function below generates the framed picture while keeping the original picture unchanged.  </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">frame</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// to hold each rows of framed picture to be written</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ret;</span><br><span class="line">	<span class="comment">// get the length of the longest string</span></span><br><span class="line">	<span class="built_in">string</span>::size_type maxlen = <span class="built_in">width</span>(v);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// first line of outputs</span></span><br><span class="line">	<span class="function"><span class="built_in">string</span> <span class="title">border</span><span class="params">(maxlen + <span class="number">4</span>, <span class="string">'*'</span>)</span></span>;</span><br><span class="line">	ret.push_back(border);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::const_iterator iter = v.<span class="built_in">begin</span>(); iter != v.<span class="built_in">end</span>(); ++iter)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// new rows except two border lines</span></span><br><span class="line">		<span class="built_in">string</span> temp = <span class="string">"* "</span> + (*iter) + <span class="built_in">string</span>(maxlen - (*iter).<span class="built_in">size</span>(), <span class="string">' '</span>) + <span class="string">" *"</span>;</span><br><span class="line">		ret.push_back(temp);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// bottom line of outputs</span></span><br><span class="line">	ret.push_back(border);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Vertical-concatenation"><a href="#Vertical-concatenation" class="headerlink" title="Vertical concatenation"></a>Vertical concatenation</h3><p>In fact we can generate the required picture without concatenation. The first step is to generate the original picture and then the second step is to generate the framed picture. They are closely connect if no blank line between two outputs. This implies that we can create a new object of <strong>verctor<string></strong> and copy all strings contained in two pictures into it. The function is shown below.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">vcat</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;top, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;bottom)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// copy the top picture</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ret = top;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// copy the bottom picture one line by one line</span></span><br><span class="line">    ret.insert(ret.<span class="built_in">end</span>(), bottom.<span class="built_in">begin</span>(), bottom.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>What’s new here is the <strong>insert</strong> function. <strong>vector</strong>, <strong>string</strong> and <strong>list</strong> all support <strong>insert</strong> function. The first parameter of this <strong>insert</strong> function means that the new elements will be inserted into a position that before the parameter specifies. The second and the third parameters indicate that the elements in the range of [bottom.begin(), bottom.end()) will be copied and inserted. This increases the length of vector. It has the same effect as the for loops shown below.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::const_iterator i = bottom.<span class="built_in">begin</span>(); i != bottom.<span class="built_in">end</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">	ret.push_back((*i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Horizontal-concatenation"><a href="#Horizontal-concatenation" class="headerlink" title="Horizontal concatenation"></a>Horizontal concatenation</h3><p>Similar to vertical voncatenation, we can generate the required picture without concatenation through alternately write rows of the original picture and the framed picture until all rows from two pictures are written. If the number of rows of two pictures are different, the one that has less number of rows will be replenished with blank strings. </p>
<p>Therefore, the key to the solution is to concatenate two strings, of which one from the original picture and another from the framed picture. As we did in the fisrt exercise, we need to pad enough spaces for each row of the original picture. Now, the number of spaces will be the difference between <strong>maxlen + 1</strong> and the size of each string itself as we want one space column between two pictures. The code below show the function.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">hcat</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;left, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// to hold the each line of outputs</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// add one space column between two pictures</span></span><br><span class="line">	<span class="built_in">string</span>::size_type width1 = <span class="built_in">width</span>(left) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// iterators to look at elements from left and right respectively</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::const_iterator iter_i = left.<span class="built_in">begin</span>(), iter_j = right.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// continue until we've see all rows from two pictures</span></span><br><span class="line">	<span class="keyword">while</span> (iter_i != left.<span class="built_in">end</span>() || iter_j != right.<span class="built_in">end</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// construct new string to hold characters from two pictures</span></span><br><span class="line">		<span class="built_in">string</span> s;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// copy a row from left side picture</span></span><br><span class="line">		<span class="keyword">if</span> (iter_i != left.<span class="built_in">end</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			s  = (*iter_i);</span><br><span class="line">			++iter_i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// pad to full width</span></span><br><span class="line">		s += <span class="built_in">string</span>(width1 - s.<span class="built_in">size</span>(), <span class="string">' '</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// copy a row from right picture</span></span><br><span class="line">		<span class="keyword">if</span> (iter_j != left.<span class="built_in">end</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			s += (*iter_j);</span><br><span class="line">			++iter_j;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// store s into vector to form a new picture</span></span><br><span class="line">		ret.push_back(s);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="A-complete-program"><a href="#A-complete-program" class="headerlink" title="A complete program"></a>A complete program</h1><p>I package all three pictures into one file and the width function into another file. In addition, I define a function more to deal with output. All files are displayed below with detailed comments for each step.<br><strong>output.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// function to write each elements from a vector&lt;string&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;		// to get declaration of cout and endl</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;		// to get declaration of string</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;		// to get declaration of vector</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"output.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;		<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;		<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;pics)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// loop thru the vector and write elements one by one</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::const_iterator iter = pics.<span class="built_in">begin</span>(); iter != pics.<span class="built_in">end</span>(); ++iter)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; (*iter) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>output.h</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_OUTPUT_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_OUTPUT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; &amp;pics)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* GUARD_OUTPUT_H */</span></span></span><br></pre></td></tr></table></figure>

<p><strong>width.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// function returns the size of the longest string in a vector&lt;string&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;	 // to get declaration of string</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;	 // to get declaration of vector</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; // to get declaration of max</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"width.h"</span>	 <span class="comment">// to get declaration of the function itself</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;  <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">max</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span>::size_type <span class="title">width</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">string</span>::size_type maxlen = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::const_iterator iter = v.<span class="built_in">begin</span>(); iter != v.<span class="built_in">end</span>(); ++iter)</span><br><span class="line">	&#123;</span><br><span class="line">		maxlen = <span class="built_in">max</span>(maxlen, (*iter).<span class="built_in">size</span>());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> maxlen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>width.h</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_WIDTH_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_WIDTH_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span>::size_type <span class="title">width</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; &amp;v)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* GUARD_WIDTH_H */</span></span></span><br></pre></td></tr></table></figure>

<p><strong>pics.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// functions that generate different pictures</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;		// to get declaration of string</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;		// to get declaration of vector</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"width.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pics.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// function to generate a framed picture</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">frame</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// to hold each rows of framed picture to be written</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ret;</span><br><span class="line">	<span class="comment">// get the length of the longest string</span></span><br><span class="line">	<span class="built_in">string</span>::size_type maxlen = <span class="built_in">width</span>(v);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// first line of outputs</span></span><br><span class="line">	<span class="function"><span class="built_in">string</span> <span class="title">border</span><span class="params">(maxlen + <span class="number">4</span>, <span class="string">'*'</span>)</span></span>;</span><br><span class="line">	ret.push_back(border);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::const_iterator iter = v.<span class="built_in">begin</span>(); iter != v.<span class="built_in">end</span>(); ++iter)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// new rows except two border lines</span></span><br><span class="line">		<span class="built_in">string</span> temp = <span class="string">"* "</span> + (*iter) + <span class="built_in">string</span>(maxlen - (*iter).<span class="built_in">size</span>(), <span class="string">' '</span>) + <span class="string">" *"</span>;</span><br><span class="line">		ret.push_back(temp);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// bottom line of outputs</span></span><br><span class="line">	ret.push_back(border);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// function to vertically concatenate two pictures</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">vcat</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;top, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;bottom)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// copy the top picture</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ret = top;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// copy the bottom picture one line by one line</span></span><br><span class="line">	ret.insert(ret.<span class="built_in">end</span>(), bottom.<span class="built_in">begin</span>(), bottom.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// function to horizontally concatenate two pictures</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">hcat</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;left, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// to hold the each line of outputs</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// add one space column between two pictures</span></span><br><span class="line">	<span class="built_in">string</span>::size_type width1 = <span class="built_in">width</span>(left) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// iterators to look at elements from left and right respectively</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::const_iterator iter_i = left.<span class="built_in">begin</span>(), iter_j = right.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// continue until we've see all rows from two pictures</span></span><br><span class="line">	<span class="keyword">while</span> (iter_i != left.<span class="built_in">end</span>() || iter_j != right.<span class="built_in">end</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// construct new string to hold characters from two pictures</span></span><br><span class="line">		<span class="built_in">string</span> s;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// copy a row from left side picture</span></span><br><span class="line">		<span class="keyword">if</span> (iter_i != left.<span class="built_in">end</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			s  = (*iter_i);</span><br><span class="line">			++iter_i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// pad to full width</span></span><br><span class="line">		s += <span class="built_in">string</span>(width1 - s.<span class="built_in">size</span>(), <span class="string">' '</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// copy a row from right picture</span></span><br><span class="line">		<span class="keyword">if</span> (iter_j != right.<span class="built_in">end</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			s += (*iter_j);</span><br><span class="line">			++iter_j;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// store s into vector to form a new picture</span></span><br><span class="line">		ret.push_back(s);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>pics.h</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_PICS_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_PICS_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">frame</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; &amp;v)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">vcat</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; &amp;top,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; &amp;bottom)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">hcat</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; &amp;left,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; &amp;right)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* GUARD_PICS_H */</span></span></span><br></pre></td></tr></table></figure>

<p><strong>mainfunction.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;		// to get declaration of cout and endl</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;		// to get declaration of string</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;		// to get declaration of vector</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"width.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pics.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"output.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;		<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;		<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// to hold the original picture</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; p;</span><br><span class="line">	p.push_back(<span class="string">"this is an"</span>);</span><br><span class="line">	p.push_back(<span class="string">"example"</span>);</span><br><span class="line">	p.push_back(<span class="string">"to"</span>);</span><br><span class="line">	p.push_back(<span class="string">"illustrate"</span>);</span><br><span class="line">	p.push_back(<span class="string">"framing"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; p1 = frame(p);</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; p2 = vcat(p, p1);</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; p3 = hcat(p, p1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	output(p);		<span class="comment">// print the original picture</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;	<span class="comment">// write a blank line to seperate two pictures</span></span><br><span class="line">	output(p1);		<span class="comment">// print the framed picture</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	output(p2);		<span class="comment">// print the vertically concatenated picture of p and p1</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	output(p3);		<span class="comment">// print the horizontally concatenated picture of p and p1</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Test-performance"><a href="#Test-performance" class="headerlink" title="Test performance"></a>Test performance</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this is an</span><br><span class="line">example</span><br><span class="line">to</span><br><span class="line">illustrate</span><br><span class="line">framing</span><br><span class="line"></span><br><span class="line">**************</span><br><span class="line">* this is an *</span><br><span class="line">* example    *</span><br><span class="line">* to         *</span><br><span class="line">* illustrate *</span><br><span class="line">* framing    *</span><br><span class="line">**************</span><br><span class="line"></span><br><span class="line">this is an</span><br><span class="line">example</span><br><span class="line">to</span><br><span class="line">illustrate</span><br><span class="line">framing</span><br><span class="line">**************</span><br><span class="line">* this is an *</span><br><span class="line">* example    *</span><br><span class="line">* to         *</span><br><span class="line">* illustrate *</span><br><span class="line">* framing    *</span><br><span class="line">**************</span><br><span class="line"></span><br><span class="line">this is an **************</span><br><span class="line">example    * this is an *</span><br><span class="line">to         * example    *</span><br><span class="line">illustrate * to         *</span><br><span class="line">framing    * illustrate *</span><br><span class="line">           * framing    *</span><br><span class="line">           **************</span><br></pre></td></tr></table></figure>
<p>The program works perfectly. </p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Notes</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ - Sequential Containers (Part 1)</title>
    <url>/2018/03/13/C-Sequential-Containers/</url>
    <content><![CDATA[<p>Recalling the student-grading program in <a href="http://quanttour.com/08/03/2018/Organizing-programs-and-data-Part-2/" target="_blank" rel="noopener">Organizing programs with data structures</a>, and thinking about how to separate students into two categories, passed and failed according to their final grades. Let’s define pass/fail criteria in final grades.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// predicate to determine whether a student failed</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">fgrade</span><span class="params">(<span class="keyword">const</span> Student_info &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> grade(s) &lt; <span class="number">60</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>If the computed grade is less than 60, it is a failing grade and the predicate yields a true value.</p>
<h1 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h1><h2 id="An-indices-approach"><a href="#An-indices-approach" class="headerlink" title="An indices approach"></a>An <strong>indices</strong> approach</h2><p>The next is to examine each element in <strong>students</strong> based on the function <strong>fgrade</strong>, and store the records for the students who failed and who passed seperately.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;Student_info&gt; <span class="title">extract_fails</span><span class="params">(<span class="built_in">vector</span>&lt;Student_info&gt; &amp;students)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Student_info&gt; pass, fail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Student_info&gt;::size_type i = <span class="number">0</span>;</span><br><span class="line">        i != students.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (fgrade(students[i]))</span><br><span class="line">            fail.push_back(students[i]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pass.push_back(students[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    students = pass;</span><br><span class="line">    <span class="keyword">return</span> fail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This function returns a vector named <strong>fail</strong> which contains the records for students who failed, and changes the original <strong>students</strong> to a vector which contains only the records for students who passed. It can be seen that the vector <strong>pass</strong> exists temporarily and seems to be superfluous from the perspective of the limited memory. </p>
<p>Alternatively, we can remove the <strong>pass</strong> and operate on the original <strong>student</strong> directly. The member function <strong>erase</strong> defined in the class template <strong>vector</strong> allows users to remove elements, either a single or a range, from a vector. Now let’s see how to change above code using <strong>erase</strong>.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;Student_info&gt; <span class="title">extract_fails</span><span class="params">(<span class="built_in">vector</span>&lt;Student_info&gt; &amp;students)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Student_info&gt; fail;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Student_info&gt;::size_type i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// loop invariant: [0, i) of students represent passing grades</span></span><br><span class="line">    <span class="keyword">while</span>(i != students.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(fgrade(students[i]))</span><br><span class="line">        &#123;</span><br><span class="line">            fail.pushback(students[i]);</span><br><span class="line">            students.erase(students.<span class="built_in">begin</span>() + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This function only creates one vector to hold the records for students who failed. The logic is quite straightforward：</p>
<ol>
<li>when the first iteration starts, <strong>i</strong> is 0 and <strong>students.size()</strong> yields the original length of the vector.</li>
<li>then, the while body is executed. If the ith student failed, the record will be stored into <strong>fail</strong>, and also be erased from the original vector. Noting that there are two side effects: first, the length of the vector decreases by 1; the index of all reminder elements move forward by 1. By then,the element students[1] in the original vector now becomes students[0] in the new vector as the original studnets[0] has been removed. Therefore, the examination starts from i = 0 again. </li>
<li>if the ith student passed, the record will be kept and the next loop examines the following element, i.e. students[i+1]. Therefore, i increases by 1 before the end of the current loop preparing for next loop.</li>
</ol>
<p>What’s new here is the arguments of <strong>erase</strong> function.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">students.erase(students.<span class="built_in">begin</span>() + i);</span><br></pre></td></tr></table></figure>
<p>We have mentioned in previous chapters that <strong>students.begin()</strong> denotes the initial element (i.e. corresponding to index 0) in the vector <strong>students</strong>. Increasing by i, the arguments denotes the <strong>i</strong>th element. The reason to use <strong>students.begin()</strong> is that the parameter type defined in <strong>erase</strong> is <strong>const_iterator</strong> (this is discussed laster). </p>
<p>Due to the length of the vector is not fixed, the <strong>students.size()</strong> should be used in the condition as it always yields the current length when it is evaluated. If a precomputed size is used, e.g. using size defined as below to replace <strong>students.size()</strong>, students[i] may refer to nonexist elements or the loop becomes endless once any of elements is removed. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;Student_info&gt;::size_type <span class="built_in">size</span> = students.<span class="built_in">size</span>();</span><br></pre></td></tr></table></figure>

<h2 id="An-iterators-approach"><a href="#An-iterators-approach" class="headerlink" title="An iterators approach"></a>An <strong>iterators</strong> approach</h2><p>It has been observed that each function defined above access elements from the <strong>vector</strong> in sequential order. Also it is known that <strong>indices</strong> allows us to access at random. From the perspective of the library, using <strong>indices</strong> has the same effect as that we request permissions to access elements randomly. In other words, <strong>indices</strong> privide the ability that we don’t want to use or we don’t need at all.  </p>
<p>Beyond <strong>indices</strong>, C++ supports another mechanism <strong>iterators</strong> that we can use to access elements in a vector. Not all standard containers support indices, but all standard containers supports <strong>iterators</strong>.</p>
<p><strong>iterators</strong> provide more flexibility in supporting certain operations depending on different types of containers. </p>
<p>In specific, an iterator is a value that </p>
<ul>
<li>identifies a container and an element in the container</li>
<li>let us examine the value stored in that element</li>
<li>provides operations for moving between elements in the container</li>
<li>restricts the available operations in ways that correspond to what the container can handle efficiently.</li>
</ul>
<h3 id="the-syntax"><a href="#the-syntax" class="headerlink" title="the syntax"></a>the syntax</h3><p>If we use indices for the iteration, for example, </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Student_info&gt;::size_type i = <span class="number">0</span>; </span><br><span class="line">    i != students.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; students[i].name &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>alternatively, we can use iterators also</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Student_info&gt;::const_iterator iter = students.<span class="built_in">begin</span>(); iter != students.<span class="built_in">end</span>(); ++iter)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (*iter).name &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>From above code, we know that the type of the <strong>iter</strong> is<br><strong>vector<Student_info>::const_iterator</strong>. More general, <strong>vector</strong> defines two associated itertor types:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vector&lt;type&gt;::const_iterator</span><br><span class="line">vector&lt;type&gt;::iterator</span><br></pre></td></tr></table></figure>
<p>The difference is that <strong>iterators</strong> of type <strong>const_iterator</strong> have only read access. If we want to use an <strong>iterator</strong> to change values in a vector, we should define it using <strong>iterator</strong> type.  </p>
<p>In addition, <strong>iter</strong> is initialized with the value of <strong>students.begin()</strong>. <strong>begin</strong> and <strong>end</strong> function return values that denotes the begining or one past the end of a container, respectively. Noting that <strong>students.begin()</strong> returns a value of type <strong>iterator</strong> but is converted to the type <strong>const_iterator</strong> in above code.</p>
<p>The next is to increase the value of <strong>iter</strong> using <strong>++iter</strong>. The effect of the increment operator on <strong>iter</strong> is up to how the <strong>iterator</strong> type defines. As a result, the iterator denotes the next element in the container after this expression is executed. </p>
<p>The statement in the <strong>for</strong> body shows how to indirect access to the elements in <strong>students</strong>. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; (*iter).name;</span><br></pre></td></tr></table></figure>
<p>The dereference operator (<em>) applies to *</em>iter** and returns an <strong>lvalue</strong> (i.e. the element) to which the iterator refers. </p>
<p>Alternatively, we can dereference an iterator and fetch the element via</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">iter-&gt;name</span><br></pre></td></tr></table></figure>
<p>It has same effect as <strong>(*iter).name</strong>.</p>
<h3 id="rewrite-functions-using-iterators"><a href="#rewrite-functions-using-iterators" class="headerlink" title="rewrite functions using iterators"></a>rewrite functions using iterators</h3><p>Now let’s use iterators to rewrite the <strong>extract_fails</strong> function. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;Student_info&gt; <span class="title">extract_fails</span><span class="params">(<span class="built_in">vector</span>&lt;Student_info&gt; &amp;students)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Student_info&gt; fail;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Student_info&gt;::const_iterator iter = students.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// loop invariant: [0, i) of students represent passing grades</span></span><br><span class="line">    <span class="keyword">while</span>(iter != students.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(fgrade(*iter))</span><br><span class="line">        &#123;</span><br><span class="line">            fail.pushback(*iter);</span><br><span class="line">            iter = students.erase(iter);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ++iter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>As mentioned earlier, we pass <strong>iter</strong> directly to the erase function as the parameter has type of <strong>const_iterator</strong>. </p>
<p>Noting that calling <strong>erase</strong> function invalidates all iterators that refer to elements after the one that was just removed. But the <strong>erase</strong> function will return an iterator that is positioned on the element that follows the erased one. Therefore, the statement becomes</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">iter = students.erase(iter);</span><br></pre></td></tr></table></figure>
<p>Iterators also support equility (=) and inequaility (!=) operations. Two iterators are equal if they denote the same element or they are off-the-end iterator for the same container. </p>
<h2 id="Iterator-arithmetic"><a href="#Iterator-arithmetic" class="headerlink" title="Iterator arithmetic"></a>Iterator arithmetic</h2><p>All standard containers support above iterator operations. But iterators for <strong>vector</strong> and <strong>string</strong> also support additional operations as shown below.</p>
<ol>
<li><p><strong>iter +/n</strong>. Adding/substracting an integer <strong>n</strong> to an iterator yields an iterator that denotes the <strong>n</strong>th emelemt (if available) after/before the original element, or one past the end of the container. </p>
</li>
<li><p><strong>iter1 - iter2</strong>. Substracting two iterators yields an number when added to the right-hand operand yields the left operand. The iterators must denote elements within the container or one past the end of the container.</p>
</li>
<li><p><strong>&gt;, &gt;=, &lt;, &lt;=</strong>. One iterator is less than another if it denotes an element that appears before the element that denoted by the other iterator. Both iterators must denote elements within the container or one past the end of the container.</p>
</li>
</ol>
<h1 id="list"><a href="#list" class="headerlink" title="list"></a>list</h1><p><strong>vector</strong> allows us to arbitrarily access elements efficiently. Moreover, it performs well when adding or deleting the element at the end of the vector. However, <strong>vector</strong> is not a good choice when it come to inserting or removing elements from the interior of the vector, such as functions illustrated above.  </p>
<p>To deal with such problems, the standard library provides another data structure <strong>list</strong> for us to efficiently insert or delete elements anywhere in the container. On the other hand, <strong>list</strong> doesn’t support random access via indices. It only supports bidirectional sequential access via iterators. </p>
<p>The <strong>list</strong> type is defined in the standard header <list>. Same as the <strong>vector</strong>, <strong>list</strong> is also a class template. In addition, <strong>list</strong> and <strong>vector</strong> share many operations. For example, we can use <strong>list</strong> to rewrite the function <strong>extract_fails</strong>.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// use list instead of vector</span></span><br><span class="line"><span class="function"><span class="built_in">list</span>&lt;Student_info&gt; <span class="title">extract_fails</span><span class="params">(<span class="built_in">list</span>&lt;Student_info&gt; &amp;students)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;Student_info&gt; fails;</span><br><span class="line">    <span class="built_in">list</span>&lt;Student_info&gt;::iterator iter = students.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(iter != students.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (fgrade(*iter))</span><br><span class="line">        &#123;</span><br><span class="line">            fail.push_back(*iter);</span><br><span class="line">            iter = students.erase(iter);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ++iter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The code above has no distinct difference comparing with the <strong>vector</strong> version. However, the important difference between <strong>list</strong>s and <strong>vector</strong>s is that how they affect on iterators.</p>
<ol>
<li><p>For <strong>vector</strong>s, the <strong>erase</strong> operation invalidates all iterators that refer to elements including the one was just removed and the subsequent elements. It is because that when removing one element, all following elements move one position towards the one erased. The <strong>push_back</strong> operation invalidates all iterators due to the fact the entirely <strong>vector</strong> might be reallocated to a new area for holding the new element. </p>
</li>
<li><p>For <strong>list</strong>s, the <strong>erase</strong> and <strong>push_back</strong> operations do not invalidate other iterators except the one that was erased. </p>
</li>
</ol>
<p>Another difference is that the <strong>list</strong> type does’t support the standard <strong>sort</strong> function. It has its own member funciton <strong>sort</strong> which can be called as follows</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span> &lt;Student_info&gt; students;</span><br><span class="line">students.sort(compare);</span><br></pre></td></tr></table></figure>
<h1 id="Taking-strings-apart"><a href="#Taking-strings-apart" class="headerlink" title="Taking strings apart"></a>Taking strings apart</h1><p>A <strong>string</strong> can be regarded as a special container that only contains characters. It supports many operations, such as random access through <strong>indices</strong> and <strong>iterators</strong>, similar to a <strong>vector</strong>. Therefore, we can access and operate on a specific character. In addition, the standard header <cctype> defines a bunch of functions that can be used to deal with single character in a <strong>string</strong>. The table below gives the details of each function</p>
<table>
<thead>
<tr>
<th align="left"><strong>cctype</strong> functions</th>
<th align="left">Source: Lippman etc. 2012, p.82</th>
</tr>
</thead>
<tbody><tr>
<td align="left">isalnum(c)</td>
<td align="left">true if c is a letter or a digit</td>
</tr>
<tr>
<td align="left">isalpha(c)</td>
<td align="left">true if c is a letter</td>
</tr>
<tr>
<td align="left">iscntrl(c)</td>
<td align="left">true if c is a control character</td>
</tr>
<tr>
<td align="left">isdigit(c)</td>
<td align="left">true if c is a digit</td>
</tr>
<tr>
<td align="left">isgraph(c)</td>
<td align="left">true if c is not a space but is printable</td>
</tr>
<tr>
<td align="left">islower(c)</td>
<td align="left">true if c is a lowercase letter</td>
</tr>
<tr>
<td align="left">isprint(c)</td>
<td align="left">true if c is a printable character</td>
</tr>
<tr>
<td align="left">ispunct(c)</td>
<td align="left">true if c is a punctuation character</td>
</tr>
<tr>
<td align="left">isspace(c)</td>
<td align="left">true if c is whitespace</td>
</tr>
<tr>
<td align="left">isupper(c)</td>
<td align="left">true if c is an uppercase letter</td>
</tr>
<tr>
<td align="left">isxdigit(c)</td>
<td align="left">true if c is a hexademical digit</td>
</tr>
<tr>
<td align="left">tolower(c)</td>
<td align="left">if c is an uppercase letter, it returns the lowercase letter; otherwise returns c unchanged</td>
</tr>
<tr>
<td align="left">toupper(c)</td>
<td align="left">if c is a lowercase letter, it returns the uppercase letter; otherwise returns c unchanged</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<p>For example, we can write a funciton to extract each word from a string like</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The wealth of the mind is the only wealth</span><br></pre></td></tr></table></figure>
<p>We can use a <strong>string</strong> member function <strong>substr</strong> to construct a new <strong>string</strong> object with its value initialized to a copy of a substring of the original <strong>string</strong>. <strong>substr</strong> defines two parameters, of which one is the inital position of the substring in the original string and the other one is the length of the substring. Therefore, the key to solve this project is to find the index of the begining of each word and the length. It can be observed that each word starts from a nonwhitespace character and ends with a character followed by whitespace. Assuming the first character of a word is positioned at indice <strong>i</strong> and the whitespace that closely follows the end of the word has indice <strong>j</strong>, the length of the word will be <strong>j - i</strong> (imagine the half-open range). </p>
<p>The solution is provided in the book and shown as below</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">split</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ret;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">string</span>::size_type string_size;</span><br><span class="line">    string_size i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// invariant: we have processed characters [original value of i, i)</span></span><br><span class="line">    <span class="keyword">while</span>(i != s.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ignore leading blanks</span></span><br><span class="line">        <span class="comment">// invariant: characters in range [original i, current i) are all spaces</span></span><br><span class="line">        <span class="keyword">while</span>(i != s.<span class="built_in">size</span>() &amp;&amp; <span class="built_in">isspace</span>(s[i]))    </span><br><span class="line">            ++i;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// find end of the next word</span></span><br><span class="line">        string_size j = i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// invariant: none of the characters in range [original j, current j)</span></span><br><span class="line">        <span class="keyword">while</span>(j != s.<span class="built_in">size</span>() &amp;&amp; !<span class="built_in">isspace</span>(s[j]))</span><br><span class="line">            ++j;</span><br><span class="line">        <span class="comment">// if we found some nonwhitespace characters</span></span><br><span class="line">        <span class="keyword">if</span> (i != j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// copy from s starting at i and taking j - i characters </span></span><br><span class="line">            ret.push_back(s.substr(i, j-i));</span><br><span class="line">            i = j;    </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Noting that, when the function try to recognize the last word, the third while loop will stop because of <strong>j == s.size()</strong> even if <strong>!isspace(s[j])</strong> is still true in the case that no whitespaces follows the last word. I add <strong>#include</strong> directives and using declarations, and test the program using the example string described above.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>; 		<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;		<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// function declaration</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">split</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// define a string contains words separated by whitespaces</span></span><br><span class="line">	<span class="built_in">string</span> s&#123;<span class="string">"The wealth of the mind is the only wealth"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// define a vector to hold splitted words</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; words = split(s);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write each line that contains one word</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::size_type i = <span class="number">0</span>; i != words.<span class="built_in">size</span>(); ++i)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; words[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Please define the split function here</span></span><br></pre></td></tr></table></figure>
<p><strong>Test results</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The</span><br><span class="line">wealth</span><br><span class="line">of</span><br><span class="line">the</span><br><span class="line">mind</span><br><span class="line">is</span><br><span class="line">the</span><br><span class="line">only</span><br><span class="line">wealth</span><br></pre></td></tr></table></figure>
<hr>
<p>To be continued.</p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Notes</tag>
      </tags>
  </entry>
  <entry>
    <title>Accelerated C++ Solutions to Exercises(Chapter 4 Part 2)</title>
    <url>/2018/03/11/Accelerated-C-Solutions-to-Exercises-Chapter-4-Part-2/</url>
    <content><![CDATA[<h1 id="Exercise-4-6"><a href="#Exercise-4-6" class="headerlink" title="Exercise 4-6"></a>Exercise 4-6</h1><p>Rewrite the Student_info structure to calculate the grades immediately and store only the final grade.</p>
<h2 id="Solution-amp-Results"><a href="#Solution-amp-Results" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>I didn’t understand very well about the original program when I went through it first time. Now I try to rewrite it in this program with detailed explinations on each step. The strategy can be divided into three parts:</p>
<ol>
<li>analyse the requirements</li>
<li>break the ultimate goal into smaller ones that are logically connected</li>
<li>design algorithms to accomplish small goals</li>
<li>logically verify the correctness of each part and put all together </li>
<li>test the performance</li>
</ol>
<h3 id="Requirements-interpretation"><a href="#Requirements-interpretation" class="headerlink" title="Requirements interpretation"></a>Requirements interpretation</h3><h4 id="What-we-have"><a href="#What-we-have" class="headerlink" title="What we have?"></a>What we have?</h4><p>The program asks to enter a file that contains multiple students’ information including <strong>name</strong>, <strong>midterm</strong> exam grade, <strong>final</strong> exam grades and a sequence of <strong>homework</strong> grades. The example below shows an input sample</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Robin 90 87 79 88 81 73 45 </span><br><span class="line">Brendan 70 69 88 100 91 75 66 </span><br><span class="line">Arsenii 99 87 89 88 74 90 70 </span><br><span class="line">Liam 83 66 100 76 87 91 78</span><br></pre></td></tr></table></figure>
<p>Note that the number of students is unkown and the number of homework grades is unknown as well. </p>
<h4 id="What-we-need-to-do"><a href="#What-we-need-to-do" class="headerlink" title="What we need to do?"></a>What we need to do?</h4><p>The program is required to generate a final grade report for a class. Specifically    </p>
<ol>
<li>each line of the report contains the information of one student, including <strong>name</strong> and a final <strong>grade</strong>.</li>
<li>the final grade is the weighted average of <strong>midterm</strong>, <strong>final</strong> and <strong>homework</strong> grades, of which the mediter exam grade counts for 20%, the final exam grade counts for 40%, and the median homework grade counts for 40%. </li>
<li>each line of outputs follows an alphabetical order according to the names.</li>
<li>the final grades are vertically aligned. </li>
</ol>
<p>An output sample can be found here</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arsenii 89.8</span><br><span class="line">Brendan 76.8</span><br><span class="line">Liam    77.8</span><br><span class="line">Robin   84.4</span><br></pre></td></tr></table></figure>
<h4 id="others-info"><a href="#others-info" class="headerlink" title="others info"></a>others info</h4><p>We are required to define a data structure to hold each student’s information including <strong>name</strong> and his final <strong>grade</strong>. This can be finished immediately. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a structure contains name and final grade</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student_info</span>&#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">double</span> grade;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>It can be seen that <strong>Student_info</strong> in fact have all information of outputs. Therefore, once it is filled with correct information, the rest is to format the report to be written. </p>
<h3 id="Decompose-the-program"><a href="#Decompose-the-program" class="headerlink" title="Decompose the program"></a>Decompose the program</h3><h4 id="Overall-structure"><a href="#Overall-structure" class="headerlink" title="Overall structure"></a>Overall structure</h4><p>Assuming that we have filled the information for one student(i.e. one object of <strong>Student_info</strong>), we need to store it for making preparations for generating the report. As the number of student is unknown, <strong>vector<Student_info></strong> is flexible enough to hold each <strong>Student_info</strong> object. Thus, the overall structure of this program can be</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="comment">// to hold the information for each student</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;Student_info&gt; students;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// one Student_info object to be filled</span></span><br><span class="line">	Student_info record;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// loop invariant: we have stored students.size() students already</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="comment">// condition statement)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// put the recorded student into the vector students</span></span><br><span class="line">		students.push_back(record);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// write statements to format the report</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>What the condition for this while loop should be? The condition for us to store <strong>record</strong> is that it has been filled(i.e. both name and grade contains correct information). Therefore, the condition shoule be <strong>true</strong> if <strong>record</strong> is successfully filled, and should be <strong>false</strong> if the attempt is failure. </p>
<p>There are two members in an object of type <strong>Student_info</strong>, one is <strong>name</strong> and the other one is <strong>grade</strong>. <strong>name</strong> comes from supplied information while <strong>grade</strong> can be computed using the information. It is necessary to write a function that not only can read and deal with supplied information but also meet the requirments of being the condition of above <strong>while</strong> loop. Let’s declare this function</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">istream &amp;<span class="title">read</span><span class="params">(istream &amp;is, Student_info &amp;s)</span></span>;</span><br></pre></td></tr></table></figure>
<p>The first parameter is a reference that refers to the object of input stream (i.e. istream). The second parameter is also a reference that refers to <strong>record</strong>. The reason to pass arguments by reference rather than value is that:</p>
<ol>
<li>the function needs to return a value that shows whether the reading attempt is successful. It is the pre-condition for filling <strong>record</strong>. </li>
<li>the <strong>istream</strong> objects can’t be copied. </li>
<li>the function needs to return the filled <strong>record</strong>. </li>
<li>By passing by reference, we can avoid seting two return values.</li>
</ol>
<p>As the condition of the <strong>while</strong> loop, <strong>read</strong> function returns an <strong>istream</strong> type object which is evaluated to be true if it is valid and otherwise it is evaluted to be false. Therefore, <strong>read</strong> function should return a valid <strong>istream</strong> object after finishing filling the <strong>record</strong>, and return an invalid <strong>istream</strong> object after finishing filling all <strong>record</strong>s. </p>
<h4 id="Fill-in-the-information"><a href="#Fill-in-the-information" class="headerlink" title="Fill in the information"></a>Fill in the information</h4><p>Let’s firstly consider how to fill the information for on student. The name can be stored directly into <strong>s.name</strong>. To hold <strong>midterm</strong> and <strong>final</strong> grades, we define two double type variables while to hold <strong>homework</strong> grades we define a variable of type <strong>vector<double></strong>. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">istream &amp; <span class="title">read</span><span class="params">(istream &amp;is, Student_info &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// reads and store the student's name, midterm and final exam grades</span></span><br><span class="line">	<span class="keyword">double</span> midterm, <span class="keyword">final</span>;</span><br><span class="line">	is &gt;&gt; s.name &gt;&gt; midterm &gt;&gt; <span class="keyword">final</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reads and store all homework grades</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; hw;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// call functions that store all homework grades</span></span><br><span class="line">	<span class="comment">// call functions that compute the final grade</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// return a valid is if both name and grade contain correct information</span></span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>To compute the final grade, what we lack is the median value of homework grades. But before we can compute the median grade, we need to store all possible homework grades using a function similar to <strong>read</strong>.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">istream &amp; <span class="title">read_hw</span><span class="params">(istream &amp;in, <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;hw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// read homework grades</span></span><br><span class="line">	<span class="keyword">double</span> x;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// loop invariant: we have read hw.size() homework grades</span></span><br><span class="line">	<span class="keyword">while</span>(in &gt;&gt; x)</span><br><span class="line">		hw.push_back(x);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This function is ok if there is only one student but doesn’t work for the input file shown above. When it finishes reading all homework grades of the first student, it terminates because that it encounters next student’s name rather than a double value, leading to the input stream being failure state. Therefore, we can add <strong>in.clear()</strong> before <strong>return in</strong> to reset the error state to good.  </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// clear the stream so that input will work for the next student</span></span><br><span class="line">	in.<span class="built_in">clear</span>();</span><br></pre></td></tr></table></figure>

<h4 id="Computations"><a href="#Computations" class="headerlink" title="Computations"></a>Computations</h4><p>Once we obtained the homework grades, we can compute the median value and then the final grade. The algorithms for these computations are not complicated. The function below will be called in the <strong>read</strong> function. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">double</span> midterm, <span class="keyword">double</span> <span class="keyword">final</span>, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;hw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hw.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> domain_error(<span class="string">"student has done no homework"</span>);</span><br><span class="line">    <span class="keyword">return</span> grade(midterm, <span class="keyword">final</span>, median(hw));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In this function, two functions are called. One is the median(hw) function which returns the median value, and anther one is overloaded <strong>grade</strong> function that returns the final grade which is again returned to the <strong>read</strong> function. Two functions are presented as follows</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// function to calculate median</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">median</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// get the size of the vector</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;::size_type vec_size;</span><br><span class="line">    vec_size <span class="built_in">size</span> = vec.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check whether the empty is empty</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span> == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> domain_error(<span class="string">"median of an empty vector"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sort the grades</span></span><br><span class="line">    sort(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// compute the median homework grade</span></span><br><span class="line">    vec_size mid = <span class="built_in">size</span>/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">size</span> % <span class="number">2</span> == <span class="number">0</span> ? (vec[mid] + vec[mid - <span class="number">1</span>])/<span class="number">2</span> : vec[mid];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// function to calculate final grade</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">double</span> midterm, <span class="keyword">double</span> <span class="keyword">final</span>, <span class="keyword">double</span> homework)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.2</span>*midterm + <span class="number">0.4</span>*<span class="keyword">final</span> + <span class="number">0.4</span>*homework;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="How-does-eof-works"><a href="#How-does-eof-works" class="headerlink" title="How does eof works?"></a>How does <strong>eof</strong> works?</h4><p>Now, we can complete the read function and the while loop. Noting that I add <strong>throw</strong> statement after finishing reading the homework grades. Correspondingly, I add the <strong>try</strong> block to catch any <strong>exception</strong> that might be thrown when reading students’ information. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">istream &amp; <span class="title">read</span><span class="params">(istream &amp;is, Student_info &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// reads and store the student's name, midterm and final exam grades</span></span><br><span class="line">	<span class="keyword">double</span> midterm, <span class="keyword">final</span>;</span><br><span class="line">	is &gt;&gt; s.name &gt;&gt; midterm &gt;&gt; <span class="keyword">final</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reads and store all homework grades</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; hw;</span><br><span class="line">	read_hw(is, hw);</span><br><span class="line">	<span class="keyword">if</span>(hw.empty())</span><br><span class="line">		<span class="keyword">throw</span> domain_error(<span class="string">"student has done no homework"</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// get the value of final grade</span></span><br><span class="line">	s.grade = grade(midterm, <span class="keyword">final</span>, hw);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// return a valid is if both name and grade contain correct information</span></span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="comment">// to hold the information for each student</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;Student_info&gt; students;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// one Student_info object to be filled</span></span><br><span class="line">	Student_info record;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// loop invariant: we have stored students.size() students already</span></span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(<span class="built_in">read</span>(<span class="built_in">cin</span>, record))</span><br><span class="line">    	&#123;</span><br><span class="line">			maxlen = <span class="built_in">max</span>(maxlen, record.name.<span class="built_in">size</span>());</span><br><span class="line">			students.push_back(record);</span><br><span class="line">    	&#125;</span><br><span class="line">	&#125;<span class="keyword">catch</span>(domain_error e)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; e.what() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// write statements to format the report</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Theoretically, we have finished most parts of the program. The next step is to format outputs if above functions work fine. Let’s logically verify this part with following steps</p>
<ol>
<li>when the computer executes the while loop, the condition is evaluated. </li>
<li>the computer enter into the <strong>read</strong> function. The function stores <strong>name</strong>, <strong>midterm</strong> and <strong>final</strong>, and create an empty object <strong>hw</strong>.</li>
<li>then the computer enters into the <strong>read_hw</strong> function. This function creates an object <strong>x</strong> and starts another while loop. </li>
<li>the condition <strong>in &gt;&gt; x</strong> is evaluated. In most cases, the condition is true until it encounters next student’s name. As a result, the input stream is changed to failure state. By then, it has stored all homework grades of the first student into the vector <strong>hw</strong>. </li>
<li>the state of <strong>in</strong> is reset to be good by using <strong>in.clear()</strong>.</li>
<li><strong>in</strong> is returned and the implementation goes back to the function <strong>read</strong>.</li>
<li><strong>grade</strong> function is called. Inside this function, another <strong>grade function</strong> is called and <strong>median</strong> function is called.</li>
<li><strong>s.grade</strong> is obtained, and <strong>is</strong> is returned. By then, <strong>record</strong> contains correct information of the first student.</li>
<li>step 1 continues, <strong>is</strong> is evaluated to be true which indicates that <strong>record</strong> is filled successfully. </li>
<li>the computer moves to the while body and <strong>record</strong> is stored into <strong>students</strong>. By then, both the name and final grade of the first student is available for us.</li>
<li>the while loop starts over again from step 1 - 10.</li>
</ol>
<p>Yeah, it works fine by now. However, how to stop it? Typically we can stop a while loop by sending a signal <strong>eof</strong> to set the input stream being a failure state. Let’s type <strong>Ctrl+Z/D</strong> and see how it works.</p>
<ol>
<li>same as above </li>
<li>same as above. Though <strong>name</strong>, <strong>midterm</strong> are uninitialized, the implementation would’t stop at this position.</li>
<li>same as above</li>
<li>the condition <strong>in &gt;&gt; x</strong> is evaluated to be false due to the <strong>eof</strong></li>
<li>same as above. By then, <strong>hw</strong> is still empty.</li>
<li>same as above</li>
<li><strong>grade</strong> function is called. An exception is thrown due to the fact of step 5.</li>
<li>the program fails</li>
</ol>
<p>So, what’s the problem? The immediate cause is the empty <strong>hw</strong>. We actually even don’t want to create the <strong>hw</strong> since we want to terminate the while loop immediately. Therefore, we need to add a condition like follow code shows</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">istream &amp; <span class="title">read</span><span class="params">(istream &amp;is, Student_info &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// reads and store the student's name, midterm and final exam grades</span></span><br><span class="line">	<span class="keyword">double</span> midterm, <span class="keyword">final</span>;</span><br><span class="line">	is &gt;&gt; s.name &gt;&gt; midterm &gt;&gt; <span class="keyword">final</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// to check whether eof is sent</span></span><br><span class="line">	<span class="keyword">if</span>(is)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// reads and store all homework grades</span></span><br><span class="line">		<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; hw;</span><br><span class="line">		read_hw(is, hw);</span><br><span class="line">		<span class="keyword">if</span>(hw.empty())</span><br><span class="line">			<span class="keyword">throw</span> domain_error(<span class="string">"student has done no homework"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// get the value of final grade</span></span><br><span class="line">		s.grade = grade(midterm, <span class="keyword">final</span>, hw);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// return a valid is if both name and grade contain correct information	</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Why don’t add the if condition at the very begining of the <strong>read</strong> function? It is because that the input stream hasn’t start to read anything at that position. Now we recheck each step after sending <strong>eof</strong> signal. </p>
<ol>
<li>same as above</li>
<li><strong>midterm</strong> and <strong>final</strong> is created. </li>
<li><strong>eof</strong> is read and the state of <strong>is</strong> is set to be <strong>failure</strong>.</li>
<li>condition <strong>is</strong> is evaluated to be false</li>
<li>return <strong>is</strong>. The computer goes back the step 1.</li>
<li>the condition in step 1 is evaluated to be false, while loop stops. </li>
</ol>
<p>Now, this part of code should work as expected. </p>
<h4 id="Formatting-the-outputs"><a href="#Formatting-the-outputs" class="headerlink" title="Formatting the outputs"></a>Formatting the outputs</h4><p>The next is to format each line of outputs according to requirements analysed above.<br>To alphabetize the outputs, we can use following code</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">sort(students.<span class="built_in">begin</span>(), students.<span class="built_in">end</span>(), compare);</span><br></pre></td></tr></table></figure>
<p>where <strong>compare</strong> is defined as follows</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> Student_info &amp;x, <span class="keyword">const</span> Student_info &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.name &lt; y.name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>To line up the final grades, we need to find the longest name and hence add one statement in the first while loop. <strong>maxlen</strong> will finally record the length of the longest name.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">maxlen &#x3D; max(maxlen, record.name.size());</span><br></pre></td></tr></table></figure>
<p>The final grade can be obtained via</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> final_grade = students[i].grade;</span><br></pre></td></tr></table></figure>

<p>####</p>
<h3 id="Put-all-together"><a href="#Put-all-together" class="headerlink" title="Put all together"></a>Put all together</h3><p>Following gives each file of the program. No more discussion here.<br><strong>mainfunction.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ios&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"grade.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;					<span class="keyword">using</span> <span class="built_in">std</span>::setprecision;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;				<span class="keyword">using</span> <span class="built_in">std</span>::sort;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;				<span class="keyword">using</span> <span class="built_in">std</span>::streamsize;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::domain_error;		<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">max</span>;					<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Student_info&gt; students;</span><br><span class="line">    Student_info record;</span><br><span class="line">    <span class="built_in">string</span>::size_type maxlen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read and store all the records, and find the length of the longest name</span></span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(<span class="built_in">read</span>(<span class="built_in">cin</span>, record))</span><br><span class="line">    	&#123;</span><br><span class="line">			maxlen = <span class="built_in">max</span>(maxlen, record.name.<span class="built_in">size</span>());</span><br><span class="line">			students.push_back(record);</span><br><span class="line">    	&#125;</span><br><span class="line">	&#125;<span class="keyword">catch</span>(domain_error e)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; e.what() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// alphabetize the records</span></span><br><span class="line">    sort(students.<span class="built_in">begin</span>(), students.<span class="built_in">end</span>(), compare);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write each line of outpurs</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Student_info&gt;::size_type i = <span class="number">0</span>; i != students.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// write the name, blanks</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; students[i].name &lt;&lt; <span class="built_in">string</span>(maxlen + <span class="number">1</span> - students[i].name.<span class="built_in">size</span>(), <span class="string">' '</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// compute and write the final grade</span></span><br><span class="line">		<span class="keyword">double</span> final_grade = students[i].grade;</span><br><span class="line">		streamsize prec = <span class="built_in">cout</span>.precision();</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; setprecision(<span class="number">3</span>) &lt;&lt; final_grade &lt;&lt; setprecision(prec) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Student_info.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"grade.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>; <span class="keyword">using</span> <span class="built_in">std</span>::istream; <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>; <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// function to define the additional arguments in max</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> Student_info &amp;x, <span class="keyword">const</span> Student_info &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.name &lt; y.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// function to read data for inputs and fill information</span></span><br><span class="line"><span class="function">istream &amp; <span class="title">read</span><span class="params">(istream &amp;is, Student_info &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// reads and store the student's name, midterm and final exam grades</span></span><br><span class="line">	<span class="keyword">double</span> midterm, <span class="keyword">final</span>;</span><br><span class="line">	is &gt;&gt; s.name &gt;&gt; midterm &gt;&gt; <span class="keyword">final</span>;</span><br><span class="line">	<span class="keyword">if</span> (is)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// reads and store all homework grades</span></span><br><span class="line">		<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; hw;</span><br><span class="line">		read_hw(is, hw);</span><br><span class="line">		<span class="keyword">if</span>(hw.empty())</span><br><span class="line">			<span class="keyword">throw</span> domain_error(<span class="string">"student has done no homework"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// get the final grade</span></span><br><span class="line">		s.grade = grade(midterm, <span class="keyword">final</span>, hw);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// function to read homework grades</span></span><br><span class="line"><span class="function">istream &amp; <span class="title">read_hw</span><span class="params">(istream &amp;in, <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;hw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// read homework grades</span></span><br><span class="line">	<span class="keyword">double</span> x;</span><br><span class="line">	<span class="keyword">while</span>(in &gt;&gt; x)</span><br><span class="line">		hw.push_back(x);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// clear the stream so that input will work for the next student</span></span><br><span class="line">	in.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Student_info.h</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_Student_info</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_Student_info</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Student_info.header file</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student_info</span>&#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">double</span> grade;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> Student_info &amp;, <span class="keyword">const</span> Student_info &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::istream &amp; <span class="title">read</span><span class="params">(<span class="built_in">std</span>::istream &amp;, Student_info &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::istream &amp; <span class="title">read_hw</span><span class="params">(<span class="built_in">std</span>::istream &amp;, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><strong>grade.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"grade.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::domain_error;  <span class="keyword">using</span> <span class="built_in">std</span>::istream;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;        <span class="keyword">using</span> <span class="built_in">std</span>::sort;</span><br><span class="line"></span><br><span class="line"><span class="comment">// grade function 1</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">double</span> midterm, <span class="keyword">double</span> <span class="keyword">final</span>, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;hw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hw.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> domain_error(<span class="string">"student has done no homework"</span>);</span><br><span class="line">    <span class="keyword">return</span> grade(midterm, <span class="keyword">final</span>, median(hw));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// grade function 2</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">double</span> midterm, <span class="keyword">double</span> <span class="keyword">final</span>, <span class="keyword">double</span> homework)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.2</span>*midterm + <span class="number">0.4</span>*<span class="keyword">final</span> + <span class="number">0.4</span>*homework;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compute the median of vector&lt;double&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">median</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// get the size of the vector</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;::size_type vec_size;</span><br><span class="line">    vec_size <span class="built_in">size</span> = vec.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check whether the empty is empty</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span> == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> domain_error(<span class="string">"median of an empty vector"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sort the grades</span></span><br><span class="line">    sort(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// compute the median homework grade</span></span><br><span class="line">    vec_size mid = <span class="built_in">size</span>/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">size</span> % <span class="number">2</span> == <span class="number">0</span> ? (vec[mid] + vec[mid - <span class="number">1</span>])/<span class="number">2</span> : vec[mid];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>grade.h</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_grade_h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_grade_h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// grade.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">median</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="Performance-test"><a href="#Performance-test" class="headerlink" title="Performance test"></a>Performance test</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Inputs</span><br><span class="line"></span><br><span class="line">Robin 90 87 79 88 81 73 45 </span><br><span class="line">Brendan 70 69 88 100 91 75 66 </span><br><span class="line">Arsenii 99 87 89 88 74 90 70 </span><br><span class="line">Liam 83 66 100 76 87 91 78 </span><br><span class="line"></span><br><span class="line">Outputs:</span><br><span class="line"></span><br><span class="line">Arsenii 89.8</span><br><span class="line">Brendan 76.8</span><br><span class="line">Liam    77.8</span><br><span class="line">Robin   84.4</span><br></pre></td></tr></table></figure>
<p>It performs as same as the original program provided in <a href="http://quanttour.com/08/03/2018/Organizing-programs-and-data-Part-2/" target="_blank" rel="noopener">Chapter 4</a>.</p>
<hr>
<h1 id="Exercise-4-7"><a href="#Exercise-4-7" class="headerlink" title="Exercise 4-7"></a>Exercise 4-7</h1><p>Write a program to calculate the average of the numbers stored in a vector<double>.</p>
<h2 id="Solution-amp-Results-1"><a href="#Solution-amp-Results-1" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>It’s a simple project and the solution can be divided into three steps</p>
<ol>
<li>define a function to read and store data into a vector<double>.</li>
<li>define a function to compute the average value.</li>
<li>set precision to format the double value of outputs.</li>
</ol>
<p>All details can be found in other exercises and hence no more explinations here.</p>
<p>Below shos the only file including both functions and main function.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;			<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;		<span class="keyword">using</span> <span class="built_in">std</span>::domain_error;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;		<span class="keyword">using</span> <span class="built_in">std</span>::istream;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::streamsize;	<span class="keyword">using</span> <span class="built_in">std</span>::setprecision;</span><br><span class="line"></span><br><span class="line"><span class="comment">// define function to read data into a vector</span></span><br><span class="line"><span class="function">istream &amp;<span class="title">read</span><span class="params">(istream &amp;is, <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;doubleValues)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> number;</span><br><span class="line">	<span class="keyword">while</span>(is &gt;&gt; number)</span><br><span class="line">		doubleValues.push_back(number);</span><br><span class="line">	<span class="keyword">return</span> is;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// define function to compute the average of a data sequence</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">average</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;doubleValues)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (doubleValues.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">throw</span> domain_error(<span class="string">"An empty vector"</span>);</span><br><span class="line">	<span class="keyword">typedef</span>  <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;::size_type vec_size;</span><br><span class="line">	<span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (vec_size i = <span class="number">0</span>; i != doubleValues.<span class="built_in">size</span>(); ++i)</span><br><span class="line">		sum += doubleValues[i];</span><br><span class="line">	<span class="keyword">return</span> sum/doubleValues.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; doubleValues;</span><br><span class="line">	<span class="built_in">read</span>(<span class="built_in">cin</span>, doubleValues);</span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">double</span> averageValue = average(doubleValues);</span><br><span class="line">            streamsize prec = <span class="built_in">cout</span>.precision();</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; setprecision(<span class="number">3</span>) &lt;&lt; averageValue </span><br><span class="line">            &lt;&lt; setprecision (prec) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;<span class="keyword">catch</span>(domain_error)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"You must enter at least 1 number. Pleast try again."</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Test</strong> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line">1.2 5.89 9.33 12.7 7.8 4</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">6.82</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Exercise-4-8"><a href="#Exercise-4-8" class="headerlink" title="Exercise 4-8"></a>Exercise 4-8</h1><p>If the following code is legal, what can we infer about the return type of f?</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> d = f()[n];</span><br></pre></td></tr></table></figure>
<h2 id="Solution-amp-Results-2"><a href="#Solution-amp-Results-2" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>From the code, we can infer  </p>
<ol>
<li><strong>f()[n]</strong> is possible a value of type <strong>int</strong> or <strong>float</strong> or <strong>double</strong> or <strong>bool</strong>. </li>
<li><strong>f()</strong> supports accessing the element using subscript and hence it could be a container.</li>
<li><strong>f()</strong> has the form of a <strong>function</strong>. </li>
</ol>
<p>According to above analysis, <strong>f()</strong> could be a function that returns a container which can hold values of types listed above. As far as I know, the container is <strong>vector</strong> and returns a type of <strong>vector<types></strong>(inside types including <strong>int</strong>, <strong>float</strong>, <strong>double</strong> and <strong>bool</strong>).</p>
<p>To verify my analysis, I wrote a simple program shown as below</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// funtion to return a vector&lt;double&gt;</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">f</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	number.push_back(<span class="number">11</span>);</span><br><span class="line">	number.push_back(<span class="number">20.5</span>);</span><br><span class="line">	<span class="keyword">return</span> number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; number;</span><br><span class="line">	<span class="keyword">double</span> x = f(number)[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">double</span> y = f(number)[<span class="number">1</span>];</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>It works as expected and gives results</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">11</span><br><span class="line">20.5</span><br></pre></td></tr></table></figure>
<p>If I change the type <strong>double</strong> to any of types listed above, the program works fine. </p>
<hr>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>Koenig, A. and Moo, B.E., 2000. Accelerated C++.</p>
<p>Lippman, S.B., Lajoie, J. and Moo, B.E., 2013. C++ Primer, 5th edt.</p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Accelerated C++ Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title>Accelerated C++ Solutions to Exercises(Chapter 4 Part 1)</title>
    <url>/2018/03/09/Accelerated-C-Solutions-to-Exercises-Chapter-4/</url>
    <content><![CDATA[<h1 id="Exercise-4-0"><a href="#Exercise-4-0" class="headerlink" title="Exercise 4-0"></a>Exercise 4-0</h1><p>Compile, execute, and test the programs in this chapter</p>
<h2 id="Solution-amp-Results"><a href="#Solution-amp-Results" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>This exercise has been done presented in <a href="http://quanttour.com/06/03/2018/C-Organizing-programs-and-data/" target="_blank" rel="noopener">Organizing programs with functions</a> and <a href="http://quanttour.com/08/03/2018/Organizing-programs-and-data-Part-2/" target="_blank" rel="noopener">Organizing programs with data structures</a>.</p>
<hr>
<h1 id="Exercise-4-1"><a href="#Exercise-4-1" class="headerlink" title="Exercise 4-1"></a>Exercise 4-1</h1><p>We noted in §4.2.3/65 that it is essential that the argument types in a call to maxmatch exactly. Will the following code work? If there is a problem, how would you fix it?</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> maxlen;</span><br><span class="line">Student_info s;</span><br><span class="line"><span class="built_in">max</span>(s.name.<span class="built_in">size</span>(), maxlen);</span><br></pre></td></tr></table></figure>

<h2 id="Solution-amp-Results-1"><a href="#Solution-amp-Results-1" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>It doesn’t work. There exist two problems here. </p>
<p>First, the <strong>max</strong> function defined in standard header<algorithm> requires that both arguments must have the same type. But in this piece of code, <strong>s.name.size()</strong> has the type of <strong>string::size_type</strong> while <strong>maxlen</strong> is a <strong>int</strong> type. To fix this, we need to define <strong>maxlen</strong> as a variable of type <strong>string::size_type</strong>. </p>
<p>Second, it should be initialized as a variable of <strong>built-in</strong> type(assuming no problem with type <strong>int</strong>) is undefined if it is not initialized explicitly. For a variable of other types, the default value (if available, otherwise the variable is undefined) depends on how each type defines. I did a simple experiment as follows</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span>::size_type y;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; y;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The result is</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4200939</span><br></pre></td></tr></table></figure>
<p>with warning</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;y&#39; is used uninitialized in this function</span><br></pre></td></tr></table></figure>
<p>The experiment shows that the type of <strong>string::size_type</strong> doesn’t support default initialization. To fixed this, we need to explicitly initialize it. </p>
<p>The correct code should be:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span>::size_type maxlen = <span class="number">0</span>;</span><br><span class="line">Student_info s;</span><br><span class="line"><span class="built_in">max</span>(s.name.<span class="built_in">size</span>(), maxlen);</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Exercise-4-2-4-3"><a href="#Exercise-4-2-4-3" class="headerlink" title="Exercise 4-2, 4-3"></a>Exercise 4-2, 4-3</h1><p>4-2: Write a program to calculate the squares of int values up to 100. The program should write two columns: The first lists the value; the second contains the square of that value.Use setw to manage the output so that the values line up in columns.</p>
<p>4-3: What happens if we rewrite the previous program to allow values up to but not including 1000 but neglect to change the arguments to setw? Rewrite the program to be more robust in the face of changes that allow i to grow without adjusting the setw arguments.</p>
<h2 id="Solution-amp-Result"><a href="#Solution-amp-Result" class="headerlink" title="Solution &amp; Result"></a>Solution &amp; Result</h2><h3 id="algorithms"><a href="#algorithms" class="headerlink" title="algorithms"></a>algorithms</h3><p>Exercise 4-3 is a generalized version of 4-2. Specifically, the program is required to write two colomns as follows</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  0        0</span><br><span class="line">  1        1</span><br><span class="line">  2        4</span><br><span class="line">  3        9</span><br><span class="line">...      ...</span><br><span class="line"> 99     9801</span><br><span class="line">100    10000 </span><br><span class="line">...      ...</span><br><span class="line">  n      n*n</span><br></pre></td></tr></table></figure>
<p>Each line contains an integer value followed by the square of the integer. The range of integers in the first column starts from 0 to 1000 (excluded). Most importantly, each line should be formated such that the values line up in columns. </p>
<p>The key to the solution is to find the longest number in each column. Then, we can set the width of the first column as the number of digits of the corresponding longest number. Analogously, the width of the second column will be set as the number of digits of the longest number in it, with an additional space to seperate from the first column.</p>
<p>For an ascending sequence, the longest numbers in both columns depend on the largest number. For exercise 4-2, the largest number is 100 and 10000 (square of 100) in the first and second column, respectively. We can write and format each line as below shows</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != <span class="number">101</span>; ++i)</span><br><span class="line">&#123;   </span><br><span class="line">    <span class="comment">// 100 has three digits and 10000 has 5 digits, 1 additional space for seperate two columns</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; setw(<span class="number">3</span>) &lt;&lt; i &lt;&lt; setw(<span class="number">6</span>) &lt;&lt; i*i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Exercise 4-3 requires more flexibility such that no needs to change <strong>setw</strong> arguments when the largest number changes. Naturally, the key is to compute the number of digits of a user-defined largest number, e,g. defined as <strong>maxNum</strong>.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hold the number of digits of maxNum and its square</span></span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hold the values of the largest number and its square</span></span><br><span class="line"><span class="keyword">int</span> j = maxNum;</span><br><span class="line"><span class="keyword">int</span> k = maxNum*maxNum;</span><br><span class="line"><span class="comment">// bounds check</span></span><br><span class="line"><span class="keyword">if</span> (j &gt;= <span class="number">1000</span> || j &lt; <span class="number">0</span>) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter a number greater than or equal to 0 and less than 1000. Please try again "</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// computations</span></span><br><span class="line"><span class="keyword">if</span> (j == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    m = n = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// loop invariant: we have counted n digits of the value j</span></span><br><span class="line">    <span class="keyword">while</span> (j != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// each operation j reduces one digit </span></span><br><span class="line">        j /= <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// maintain the loop invariant</span></span><br><span class="line">        ++n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// loop invariant: we have counted n digits of the value j</span></span><br><span class="line">    <span class="keyword">while</span> (k != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        k /= <span class="number">10</span>;</span><br><span class="line">        ++m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="organize-the-program-with-functions"><a href="#organize-the-program-with-functions" class="headerlink" title="organize the program with functions"></a>organize the program with functions</h3><p>Obviously, above code is partly repeated. I’ll rewrite the computations as a function which returns the number of digits of an entered value.<br><strong>width.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// function to compute the number of digits of an integer value</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"width.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">width</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(num != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            num /= <span class="number">10</span>;</span><br><span class="line">            ++n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>width.h</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_width_h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_width_h</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">width</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><strong>mainfunction.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"width.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;     <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;    <span class="keyword">using</span> <span class="built_in">std</span>::setw;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">// asks to enter the upper bound </span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter a number greater than or equal to 0 and less than 1000: "</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read the largest number</span></span><br><span class="line">    <span class="keyword">int</span> maxNum;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; maxNum;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bounds check</span></span><br><span class="line">    <span class="keyword">if</span> (maxNum &gt;= <span class="number">1000</span> || maxNum &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"The entered value is beyond the allowed value range. Please try again."</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write the outputs</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != maxNum + <span class="number">1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; setw(<span class="built_in">width</span>(maxNum)) &lt;&lt; i </span><br><span class="line">        &lt;&lt; setw(<span class="built_in">width</span>(maxNum*maxNum) + <span class="number">1</span>) &lt;&lt; i*i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Test-performance"><a href="#Test-performance" class="headerlink" title="Test performance"></a>Test performance</h3><p><strong>Test 1</strong>: the upper limit is 10</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Enter a number greater than or equal to 0 and less than 1000: 10</span><br><span class="line"> 0   0</span><br><span class="line"> 1   1</span><br><span class="line"> 2   4</span><br><span class="line"> 3   9</span><br><span class="line"> 4  16</span><br><span class="line"> 5  25</span><br><span class="line"> 6  36</span><br><span class="line"> 7  49</span><br><span class="line"> 8  64</span><br><span class="line"> 9  81</span><br><span class="line">10 100</span><br></pre></td></tr></table></figure>
<p><strong>Test 2</strong>: the upper limit is 101</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Enter a number greater than or equal to 0 and less than 1000: 101</span><br><span class="line">  0     0</span><br><span class="line">  1     1</span><br><span class="line">  2     4</span><br><span class="line">  3     9</span><br><span class="line"> ..    .. </span><br><span class="line"> 90  8100</span><br><span class="line"> 91  8281</span><br><span class="line"> 92  8464</span><br><span class="line"> 93  8649</span><br><span class="line"> 94  8836</span><br><span class="line"> 95  9025</span><br><span class="line"> 96  9216</span><br><span class="line"> 97  9409</span><br><span class="line"> 98  9604</span><br><span class="line"> 99  9801</span><br><span class="line">100 10000</span><br><span class="line">101 10201</span><br></pre></td></tr></table></figure>
<p><strong>Test 3</strong>: the upper limit is 1000</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Enter a number greater than or equal to 0 and less than 1000: 1000</span><br><span class="line">The entered value is beyond the allowed value range. Please try again.</span><br></pre></td></tr></table></figure>
<p>It can be seen from these tests that the program perform as expected. </p>
<hr>
<h1 id="Exercise-4-4"><a href="#Exercise-4-4" class="headerlink" title="Exercise 4-4"></a>Exercise 4-4</h1><p>Now change your squares program to use double values instead of ints. Use manipulators to manage the output so that the values line up in columns</p>
<h2 id="Solution-amp-Results-2"><a href="#Solution-amp-Results-2" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>The difference between this exercise and last exercise is that the function <strong>width</strong> defined above can not compute the number of digits of a double value. Admittedly, I didn’t found very good strategy to complete this project. I circument the problem applying the type conversion technique. Specifically</p>
<ol>
<li>divide the maxNum/maxNum*maxNum into integer part and fractional part. </li>
<li>compute the number of digits of the integer part using same function as shown above. </li>
<li>control the fractional part with an additional user-defined variable <strong>places</strong> which represents the number of places after the dot point. </li>
</ol>
<p>The arguments of <strong>*setw</strong> for the first column is: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">width(maxNum) + 1 + places</span><br></pre></td></tr></table></figure>
<p>The number <strong>1</strong> leaves room for the decimal point.</p>
<p>The arguments of <strong>*setw</strong> for the first column is:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">width(maxNum*maxNum) + 1 + 1 + places</span><br></pre></td></tr></table></figure>
<p>One of two values of 1 is added for the decimal point while the other one is added for seperating from the first column. I didn’t change anything in the <strong>width</strong> function described above and hence the arguments to be passed are converted to <strong>int</strong> type, leading to that the returned value of <strong>width</strong> is the width of the part before the decimal point. </p>
<p>Beyond this, the program asks to enter an initial value and an value of the increment for numbers of the first column. For example, we set the initial value as 0.0 and increment as 0.5, the first column becomes</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0.0</span><br><span class="line">0.5</span><br><span class="line">1.0</span><br><span class="line">...</span><br><span class="line">n</span><br></pre></td></tr></table></figure>
<p>where <strong>n</strong> is the largest number (i.e. maxNum) that available for outputs in the range of [0.0, 1000). It will be computed in the program. </p>
<p>To format outputs, I uses function <strong>fixed</strong> together with <strong>setprecision</strong> to fixed number of decimal places and <strong>showpoint</strong> to enable the display of trailing 0. A detailed comparison between these three can be found in <a href="http://quanttour.com/02/03/2018/C-Working-with-batches-of-data/" target="_blank" rel="noopener">C++ - Working with batches of data</a>.</p>
<p>Please find the <strong>midth.cpp</strong> and <strong>midth.h</strong> in exercise 4-2/3. The main function file is shown below.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Accelerated C++ Solutions Exercises 4-4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"width.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;				<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;			<span class="keyword">using</span> <span class="built_in">std</span>::setw;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::setprecision;	<span class="keyword">using</span> <span class="built_in">std</span>::fixed;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::streamsize;		<span class="keyword">using</span> <span class="built_in">std</span>::showpoint;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::noshowpoint;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// asks toset the range for outputs</span></span><br><span class="line">	<span class="keyword">double</span> minNum, incrementByValue;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter an intial value greater than or equal to 0.0 and less than 1000.0: "</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; minNum;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">"Enter the increment for each line of outputs: "</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; incrementByValue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bounds check</span></span><br><span class="line">    <span class="keyword">if</span> (minNum &gt;= <span class="number">1000.0</span> || minNum &lt; <span class="number">0.0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"The entered value is beyond the allowed value range. Please try again."</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// asks to enter a value that determines decimal places</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"How many places you want to keep after decimal point?\n"</span></span><br><span class="line">    		<span class="string">"Enter an integer to determine decimal places: "</span>;</span><br><span class="line">    <span class="keyword">int</span> places;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; places;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get the largest value that available for outputs</span></span><br><span class="line">    <span class="keyword">double</span> maxNum = minNum;</span><br><span class="line">    <span class="keyword">while</span> ((maxNum + incrementByValue) &lt; <span class="number">1000.0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    	maxNum += incrementByValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write the outputs</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">double</span> i = minNum; i &lt; <span class="number">1000.0</span>; i += incrementByValue)</span><br><span class="line">    &#123;</span><br><span class="line">    	streamsize prec = <span class="built_in">cout</span>.precision();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; showpoint &lt;&lt; fixed &lt;&lt; setprecision(places) </span><br><span class="line">        &lt;&lt; setw(<span class="built_in">width</span>(maxNum) + places + <span class="number">1</span>) &lt;&lt; i</span><br><span class="line">        &lt;&lt; setw(<span class="built_in">width</span>(maxNum*maxNum) + places + <span class="number">2</span>) &lt;&lt; i*i </span><br><span class="line">        &lt;&lt; setprecision(prec) &lt;&lt; noshowpoint &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>It is worth noting that we cannot use equality and inequality operators in the floating point value conditions as floating values cannot be precisely  represented in the computer world. Due to this limitation, I change the condition <strong>i != 1000</strong> to <strong>i &lt; 1000.0</strong>. I did several tests to show how is the performance.</p>
<p><strong>Test 1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Enter an intial value greater than or equal to 0.0 and less than 1000.0: 0</span><br><span class="line">Enter the increment for each line of outputs: 100</span><br><span class="line">How many places you want to keep after decimal point?</span><br><span class="line">Enter an integer to determine decimal places: 0</span><br><span class="line">  0.      0.</span><br><span class="line">100.  10000.</span><br><span class="line">200.  40000.</span><br><span class="line">300.  90000.</span><br><span class="line">400. 160000.</span><br><span class="line">500. 250000.</span><br><span class="line">600. 360000.</span><br><span class="line">700. 490000.</span><br><span class="line">800. 640000.</span><br><span class="line">900. 810000.</span><br></pre></td></tr></table></figure>
<p><strong>Test 2</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Enter an intial value greater than or equal to 0.0 and less than 1000.0: 0.5234</span><br><span class="line">Enter the increment for each line of outputs: 0.5</span><br><span class="line">How many places you want to keep after decimal point?</span><br><span class="line">Enter an integer to determine decimal places: 4</span><br><span class="line">  0.5234      0.2739</span><br><span class="line">  1.0234      1.0473</span><br><span class="line">  1.5234      2.3207</span><br><span class="line">  2.0234      4.0941</span><br><span class="line">  2.5234      6.3675</span><br><span class="line">  3.0234      9.1409</span><br><span class="line">  3.5234     12.4143</span><br><span class="line">  4.0234     16.1877</span><br><span class="line">  4.5234     20.4611</span><br><span class="line">  5.0234     25.2345</span><br><span class="line">  5.5234     30.5079</span><br><span class="line">  6.0234     36.2813</span><br><span class="line">  6.5234     42.5547</span><br><span class="line">  ....       ....</span><br><span class="line">996.0234 992062.6133</span><br><span class="line">996.5234 993058.8867</span><br><span class="line">997.0234 994055.6601</span><br><span class="line">997.5234 995052.9335</span><br><span class="line">998.0234 996050.7069</span><br><span class="line">998.5234 997048.9803</span><br><span class="line">999.0234 998047.7537</span><br><span class="line">999.5234 999047.0271</span><br></pre></td></tr></table></figure>

<p><strong>Test 3</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Enter an intial value greater than or equal to 0.0 and less than 1000.0: 999</span><br><span class="line">Enter the increment for each line of outputs: 1</span><br><span class="line">How many places you want to keep after decimal point?</span><br><span class="line">Enter an integer to determine decimal places: 1</span><br><span class="line">999.0 998001.0</span><br><span class="line">&#96;&#96;&#96;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Exercise-4-5"><a href="#Exercise-4-5" class="headerlink" title="Exercise 4-5"></a>Exercise 4-5</h1><p>Write a function that reads words from an input stream and stores them in a vector. Use that function both to write programs that count the number of words in the input, and to count how many times each word occurred.</p>
<h2 id="Solution-amp-Results-3"><a href="#Solution-amp-Results-3" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>This exercise is a variant of <a href="http://quanttour.com/04/03/2018/Accelerated-C-Solutions-to-Exercise-Chapter-3/" target="_blank" rel="noopener">Chapter 3 Exercise 3-3</a>. I uses exactly the same solution strategy in this project. Therefore, no more discussion here. The code and tests can be found below.</p>
<p><strong>mainfunction.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"wordsRead.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;		<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::setw;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::domain_error;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// hold the information of each words</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;words_info&gt; words;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// type alias</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;words_info&gt;::size_type vec_size;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="built_in">string</span>::size_type str_size;</span><br><span class="line">	str_size word_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// count the number of words</span></span><br><span class="line">	<span class="keyword">int</span> totalNum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// asks to enter words</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Please enter words: "</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// read, count and store words</span></span><br><span class="line">            wordsRead(<span class="built_in">cin</span>, words, totalNum, word_size);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// write the total number of inputs</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"The total number of words is: "</span> &lt;&lt; totalNum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// write each distinct word and its occurrence number</span></span><br><span class="line">            <span class="keyword">for</span> (vec_size i = <span class="number">0</span>; i != words.<span class="built_in">size</span>(); ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// format each line</span></span><br><span class="line">                <span class="keyword">int</span> n = <span class="number">9</span> + word_size - words[i].wordName.<span class="built_in">size</span>();</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; words[i].wordName &lt;&lt; setw(n) &lt;&lt; <span class="string">" appears "</span></span><br><span class="line">                        &lt;&lt; words[i].count &lt;&lt; <span class="string">" times"</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">		&#125;<span class="keyword">catch</span>(domain_error)&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"You must enter at least one word. Please try again."</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>wordsRead.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// function to read, count and store words</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"wordsRead.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::istream;		<span class="keyword">using</span> <span class="built_in">std</span>::domain_error;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;		<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">istream &amp; <span class="title">wordsRead</span><span class="params">(istream &amp;is, <span class="built_in">vector</span>&lt;words_info&gt; &amp;words, <span class="keyword">int</span> &amp;totalNum, <span class="built_in">string</span>::size_type &amp;word_size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	words_info <span class="keyword">word</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// loop invariant: we have read totalNum words now</span></span><br><span class="line">	<span class="keyword">while</span>(is &gt;&gt; <span class="keyword">word</span>.wordName)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// maintain the loop invariant</span></span><br><span class="line">		++totalNum;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// find the size of the longest word</span></span><br><span class="line">		<span class="keyword">if</span> (word_size &lt; <span class="keyword">word</span>.wordName.<span class="built_in">size</span>())</span><br><span class="line">			word_size = <span class="keyword">word</span>.wordName.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// set flag to find each distinct word</span></span><br><span class="line">		<span class="comment">// flag == true: the word is distinct</span></span><br><span class="line">		<span class="comment">// flag == false: the word exists</span></span><br><span class="line">		<span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="built_in">vector</span>&lt;words_info&gt;::size_type i = <span class="number">0</span>; i != words.<span class="built_in">size</span>(); ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// compare with previous distinct words</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">word</span>.wordName == words[i].wordName)</span><br><span class="line">			&#123;</span><br><span class="line">				++words[i].count;</span><br><span class="line">				flag = <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// if the word has not been entered, store</span></span><br><span class="line">		<span class="keyword">if</span> (flag == <span class="literal">true</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">word</span>.count = <span class="number">1</span>;</span><br><span class="line">			words.push_back(<span class="keyword">word</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (totalNum == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">throw</span> domain_error(<span class="string">"No input"</span>);</span><br><span class="line">	<span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>wordsRead.h</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_wordsRead_h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_wordsRead_h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">words_info</span>&#123;</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> wordName;</span><br><span class="line">	<span class="keyword">int</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::istream &amp; <span class="title">wordsRead</span><span class="params">(<span class="built_in">std</span>::istream &amp;, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;words_info&gt; &amp;words, <span class="keyword">int</span> &amp;, <span class="built_in">std</span>::<span class="built_in">string</span>::size_type &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* GUARD_wordsRead_h */</span></span></span><br></pre></td></tr></table></figure>

<h3 id="Test-Performance"><a href="#Test-Performance" class="headerlink" title="Test Performance"></a>Test Performance</h3><p><strong>Test 1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Please enter words: I am a good teacher and you are a good student</span><br><span class="line">The total number of words is: 11</span><br><span class="line">I       appears 1 times</span><br><span class="line">am      appears 1 times</span><br><span class="line">a       appears 2 times</span><br><span class="line">good    appears 2 times</span><br><span class="line">teacher appears 1 times</span><br><span class="line">and     appears 1 times</span><br><span class="line">you     appears 1 times</span><br><span class="line">are     appears 1 times</span><br><span class="line">student appears 1 times</span><br></pre></td></tr></table></figure>
<p><strong>Test 2</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Please enter words: what happens depends on the range of the values that the types permit</span><br><span class="line">The total number of words is: 13</span><br><span class="line">what    appears 1 times</span><br><span class="line">happens appears 1 times</span><br><span class="line">depends appears 1 times</span><br><span class="line">on      appears 1 times</span><br><span class="line">the     appears 3 times</span><br><span class="line">range   appears 1 times</span><br><span class="line">of      appears 1 times</span><br><span class="line">values  appears 1 times</span><br><span class="line">that    appears 1 times</span><br><span class="line">types   appears 1 times</span><br><span class="line">permit  appears 1 times</span><br></pre></td></tr></table></figure>

<hr>
<p>To be continued.</p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Accelerated C++ Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ - Organizing programs with data structures</title>
    <url>/2018/03/08/Organizing-programs-and-data-Part-2/</url>
    <content><![CDATA[<p>The program we have accomplished in last chapter is good enough for computing one students’ final grade, however, is unpractical in reality when it comes to generating a final grade report for a class. Assuming that we have a file that records all students’ information including their names, midterm and final exam grades, and homework grades. For example</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Robin 90 87 79 88 81 73 45</span><br><span class="line">Brendan 70 69 88 100 91 75 66</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>The program is required to compute the final grade for each student and generate a report like</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Bredan <span class="number">76.8</span></span><br><span class="line">Robin  <span class="number">84.4</span></span><br></pre></td></tr></table></figure>
<p>In specific, there are three requirements</p>
<ol>
<li>in the final grade, the mediter exam grade counts for 20%, the final exam grade counts for 40%, and the median homework grade counts for 40%. </li>
<li>the output follows an alphabetical order according to the names.</li>
<li>the final grades are vertically aligned.</li>
</ol>
<p>A similar program has been done in <a href="http://quanttour.com/05/03/2018/Accelerated-C-Solutions-to-Exercises-Chapter-3-Part-2/" target="_blank" rel="noopener">Exercise 3-5</a>, which can keep track of grades for several students at once though it uses the average homework grade rather than median value. The whole structure is simply a while loop. <a href="http://quanttour.com/06/03/2018/C-Organizing-programs-and-data/" target="_blank" rel="noopener">The program</a> in last chapter teaches us how to fullfill the first requirement with functions. Now we focus on how to meet the second the third requirements.</p>
<h1 id="Data-struct"><a href="#Data-struct" class="headerlink" title="Data struct"></a>Data <strong>struct</strong></h1><p>Last chapter mainly introdues how to write functions to deal with computations as well as data reading. However, the information such as name, medterm and final exam grades are still left there. If more information such as age, weight and grade need to be added, the program would be bloated. In fact, all these information can be integrated as a user-defined data structures as follows</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student_info</span> &#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">double</span> midterm, <span class="keyword">final</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; homework;        </span><br><span class="line">&#125; objectName;</span><br></pre></td></tr></table></figure>
<p>The code defines a <strong>struct</strong> that contains a group of data members. <strong>Student_info</strong> is the name of this type. Each data member is declared with a type and a name. <strong>objectName</strong> is an object of such type. Another way to declare an object is </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Student_info objectName;</span><br></pre></td></tr></table></figure>
<p>Note that there must be a semicolon at the end of the curly braces when defining a <strong>struct</strong> type. </p>
<p>It has been observed that each object of such type holds information for one student. We can store all students’ information into a vector, e.g. vector<Student_info> record.</p>
<h2 id="reading-data"><a href="#reading-data" class="headerlink" title="reading data"></a>reading data</h2><p>The function that an object of <strong>Student_info</strong> reads data is similar to that for a vector. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Student_info record;</span><br><span class="line"><span class="built_in">read</span>(<span class="built_in">cin</span>, record);</span><br></pre></td></tr></table></figure>
<p>The <strong>read</strong> function</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">istream &amp; <span class="title">read</span><span class="params">(istream &amp;is, Student_info &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">// reads and store the student's name, midterm and final exam grades</span></span><br><span class="line">    is &gt;&gt; s.name &gt;&gt; s.midterm &gt;&gt; s.<span class="keyword">final</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reads and store all homework grades</span></span><br><span class="line">    read_hw(is, s.homework);</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Since the function is similar to the <strong>read_hw</strong> function defined in <a href="http://quanttour.com/06/03/2018/C-Organizing-programs-and-data/" target="_blank" rel="noopener">this page</a>, no more discussed here. </p>
<h2 id="grade-function"><a href="#grade-function" class="headerlink" title="grade function"></a><strong>grade</strong> function</h2><p>Now the data have been stored into a sturct and concequently the grade function becomes<br><strong>overloaded function 1</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">const</span> Student_info &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> grade(s.meterm, s.<span class="keyword">final</span>, s.homework)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>overloaded function 2</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">double</span> midterm, <span class="keyword">double</span> <span class="keyword">final</span>, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;hw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (hw.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">throw</span> domain_error(<span class="string">"student has done no homework"</span>);</span><br><span class="line">	<span class="keyword">return</span> grade(midterm, <span class="keyword">final</span>, median(hw));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>overloaded function 3</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">double</span> midterm, <span class="keyword">double</span> <span class="keyword">final</span>, <span class="keyword">double</span> homework)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0.2</span>*midterm + <span class="number">0.4</span>*<span class="keyword">final</span> + <span class="number">0.4</span>*homework;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="stores-all-structs-into-a-vector"><a href="#stores-all-structs-into-a-vector" class="headerlink" title="stores all structs into a vector"></a>stores all <strong>struct</strong>s into a vector</h2><p>Once the <strong>record</strong> finishes reading data for inputs, we can store it into a vector.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;Student_info&gt; students;</span><br><span class="line">Student_info record;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">read</span>(<span class="built_in">cin</span>, record))</span><br><span class="line">&#123;</span><br><span class="line">    students.push_back(record);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="alphabetize-students"><a href="#alphabetize-students" class="headerlink" title="alphabetize students"></a>alphabetize <strong>students</strong></h1><p>Up to now, we have finished the code for all computations and data reading. The next step is to sort the <strong>students</strong> in an alphabetical order according to students’ names. In previous chapters, we uses the standard algorithm <strong>sort</strong> to accomplish sorting the <strong>homework</strong>. It can also be used to sort the <strong>students</strong>, but before we apply it we need to learn how it works on the <strong>homework</strong>.</p>
<p><strong>homework</strong> is a vector that contains all values of homework grades. The <strong>sort</strong> function compares objects in the vector using <strong>&lt;</strong>. It is clear when using <strong>&lt;</strong> to compare two numerical values but doesn’t works for the element type of a <strong>struct</strong>. Regarding to this case, the <strong>sort</strong> function provides an optional argument, a <strong>predicate</strong>, for us to define the ways to compare elements.</p>
<p>A <strong>predicate</strong> is a function that typically yields a true value of type <strong>bool</strong>. Let’s see how is it defined</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> Student_info &amp;x, <span class="keyword">const</span> Student_info &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.name &lt; y.name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The usage of the <strong>sort</strong> function is</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">sort(students.<span class="built_in">begin</span>(), students.<span class="built_in">end</span>, compare);</span><br></pre></td></tr></table></figure>
<p>It means that the <strong>sort</strong> function will compare elements in the <strong>students</strong> only according to its member <strong>name</strong>  rather than using <strong>&lt;</strong> directly. As for the effect of <strong>&lt;</strong> on strings, the expression is evaluated to be true if <strong>x.name</strong> is alphabetically ahead of <strong>y.name</strong>. Specifically, when compare two strings</p>
<ol>
<li>the result is the result of comparing the first character at which the strings differ. </li>
<li>if all characters of one string equal to the corresponding characters of another string, then the shorter one is less than the longer one. </li>
</ol>
<h1 id="align-the-final-grade-vertically"><a href="#align-the-final-grade-vertically" class="headerlink" title="align the final grade vertically"></a>align the final grade vertically</h1><p>Now we deal with the third requirement. Each line of outputs is formed by <strong>s.name</strong>, a blank string, and the <strong>grade</strong>. The key to solve this problem is to write a blank string with appropriate length such that all lines have same total length ahead of the final grades while the total length depends on the longest name. The minimum number of spaces between a name and a grade is one. The process can be logically divided into three steps</p>
<ol>
<li>find the longest name</li>
<li>calculate the total length ahead of the grade: the size of the longest name plus one(space).</li>
<li>Create a blank string for each line with length: the total length minus the size of each name. </li>
</ol>
<p>To find the longest name, we use another the <strong>max</strong> function defined in the header <algorithm>. The syntax is</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">max</span>(el, e2);</span><br></pre></td></tr></table></figure>
<p>It returns the larger one of two expressions which yield values of the same type. The comparison is similar to <a href="http://quanttour.com/04/03/2018/Accelerated-C-Solutions-to-Exercise-Chapter-3/" target="_blank" rel="noopener">Exercise 3-4 strategy 2</a>. </p>
<h1 id="A-complete-program"><a href="#A-complete-program" class="headerlink" title="A complete program"></a>A complete program</h1><p>Above steps show the core technicals that deals with three requirements mentioned at the begining. The new program built on <strong>struct</strong> and <strong>functions</strong> is presented as below</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Student_info&gt; students;</span><br><span class="line">    Student_info record;</span><br><span class="line">    <span class="built_in">string</span>::size_type maxlen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read and store all the records, and find the length of the longest name</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">read</span>(<span class="built_in">cin</span>, record))</span><br><span class="line">    &#123;</span><br><span class="line">        maxlen = <span class="built_in">max</span>(maxlen, record.name.<span class="built_in">size</span>());</span><br><span class="line">        students.push_back(record);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// alphabetize the records</span></span><br><span class="line">    sort(students.<span class="built_in">begin</span>(), students.<span class="built_in">end</span>(), compare);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write each line of outpurs</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Student_info&gt;::size_type i = <span class="number">0</span>; i != students.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// write the name, blanks </span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; students[i].name &lt;&lt; <span class="built_in">string</span>(maxlen + <span class="number">1</span> - students[i].name.<span class="built_in">size</span>(), <span class="string">' '</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// compute and write the final grade</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">double</span> final_grade = grade(students[i]);</span><br><span class="line">            streamsize prec = <span class="built_in">cout</span>.precision();</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; setprecision(<span class="number">3</span>) &lt;&lt; final_grade &lt;&lt; setprecision(prec);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(domain_error e)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; e.what();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In this program, we uses a new function <strong>what</strong> to write the diagnostic message if an exception is thrown. The catch clause named the diagnostic message as <strong>e</strong>, i.e. the object that contains the message. The message can be obtained from <strong>what()</strong>. </p>
<h1 id="Seperate-compilation"><a href="#Seperate-compilation" class="headerlink" title="Seperate compilation"></a>Seperate compilation</h1><p>Strictly speaking, above program is not a complete program as it doesn’t work when it is executed. Because we haven’t add the functions to be called in this program. It can be done by putting all stuff into a single file, which however may increase complexity and reduce readability. Alternatively, we can seperate the program into several files and compile these files seperately. In fact, we uses seperate compilation since the first program. For example, we can use <strong>IO</strong> class objects by means of including the header and declarations rather than defining the type in our programs. How this is done? Let’s write our own header files!</p>
<h2 id="header-file-and-source-file"><a href="#header-file-and-source-file" class="headerlink" title="header file and source file"></a>header file and source file</h2><p>To support seperate compilation, C++ distinguishes declarations and definitions which allows muliple files sharing one definition. For example, if we want to seperate the median function from above program, we need to put its definition into a source file named <strong>median.cpp</strong> (depending on your c++ implementations), and put its declarations into a header file named <strong>median.h</strong>. By doing so, the median function is allowed to be accessed in programs as long as we include its header file like</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"median.h"</span></span></span><br></pre></td></tr></table></figure>
<p>The header file is enclosed by double quotes rather than angle brackets, which makes it distinct from the standard library headers. The source file is created as follows</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// source file for median function </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; // to get declaration of sort</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt; // to get declaration of domain_error</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;    // to get declaration of vector</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;median.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// declarations for names</span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::domain_error;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::sort;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compute the median of vector&lt;double&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">median</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// get the size of the vector</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;::size_type vec_size;</span><br><span class="line">	vec_size <span class="built_in">size</span> = vec.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// check whether the empty is empty</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">size</span> == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">throw</span> domain_error(<span class="string">"median of an empty vector"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// sort the grades</span></span><br><span class="line">	sort(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">	<span class="comment">// compute the median homework grade</span></span><br><span class="line">	vec_size mid = <span class="built_in">size</span>/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">size</span> % <span class="number">2</span> == <span class="number">0</span> ? (vec[mid] + vec[mid - <span class="number">1</span>])/<span class="number">2</span> : vec[mid];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Note this file includes all needed headers for the median function itself. It contains both the function declarations and definitions, which allows the compiler to check the consistency between the declarations and definitions. The header file can be written as</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_median_h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_median_h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">median</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;)</span></span>;    </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>There are several new points here. First, the file include the needed header <vector>, and use <strong>std::vector</strong> instead of <strong>using std::vector</strong>. This is because we are not sure whether a user want a using declaration in their program as once we add using declaration,  all programs that include this header file get a <strong>using std::vector</strong>. This has been also emphasized in <a href="http://quanttour.com/02/02/2018/C++%20-%20Getting%20Started/" target="_blank" rel="noopener">C++ - Getting Started</a>.<br>Second, <strong>#ifndef</strong> directive responsible for checking whether <strong>GUARD_median_h</strong> is defined. <strong>GUARD_median_h</strong> (aka. header guard) is the name of a preprocessor variable that has two status: defined or not defined. The <strong>#define</strong> directive takes the name and defines it as a preprocessor variable. <strong>ifndef</strong> is true if the preprocessor variable is undefined and the preprocessor will process following contents until encounter <strong>endif</strong>. If <strong>ifndef</strong> is false, subsquent attempts to include <strong>median.h</strong> will be overlooked to avoid multiple inclusion. </p>
<h1 id="Reorganize-the-final-grade-program"><a href="#Reorganize-the-final-grade-program" class="headerlink" title="Reorganize the final grade program"></a>Reorganize the final grade program</h1><p>The reminder of this post aims to reorganize the final grade program applying the technical, seperate compilation,introduced in this post. Let’s list all functions and data structures needed in this program.</p>
<ol>
<li><strong>read</strong> function to read students’ information.</li>
<li><strong>read_hw</strong> function to read homework grades for each student.</li>
<li><strong>compare</strong> function as an optional argument in <strong>sort</strong>.</li>
<li>three <strong>grade functions</strong>(overloaded) to compute the final grade.</li>
<li><strong>median</strong> function to compute median of homework grades.</li>
<li>Beyond above functions, we also defined a data structure, <strong>Student_info</strong> to hold student’s information. </li>
</ol>
<p>Logically speaking, these entities can be divided into two groups: </p>
<ul>
<li>group 1 including 6, 1, 2, 3 deals with information</li>
<li>group 2 including 4, 5 deals with computation</li>
</ul>
<p>Therefore, we can package two groups into two independent files seperately. </p>
<h2 id="Group-1"><a href="#Group-1" class="headerlink" title="Group 1"></a>Group 1</h2><p><strong>Student_info.h</strong> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_Student_info</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_Student_info</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Student_info.header file</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student_info</span>&#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">double</span> midterm, <span class="keyword">final</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; homework;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> Student_info &amp;, <span class="keyword">const</span> Student_info &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::istream &amp; <span class="title">read</span><span class="params">(<span class="built_in">std</span>::istream &amp;, Student_info &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::istream &amp; <span class="title">read_hw</span><span class="params">(<span class="built_in">std</span>::istream &amp;, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><strong>Student_info.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// source file for Student_info related functions</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>; <span class="keyword">using</span> <span class="built_in">std</span>::istream;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> Student_info &amp;x, <span class="keyword">const</span> Student_info &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.name &lt; y.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">istream &amp; <span class="title">read</span><span class="params">(istream &amp;is, Student_info &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">// reads and store the student's name, midterm and final exam grades</span></span><br><span class="line">    is &gt;&gt; s.name &gt;&gt; s.midterm &gt;&gt; s.<span class="keyword">final</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reads and store all homework grades</span></span><br><span class="line">    read_hw(is, s.homework);</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">istream &amp; <span class="title">read_hw</span><span class="params">(istream &amp;in, <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;hw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (in)&#123;</span><br><span class="line">		<span class="comment">//get rid of previous contents</span></span><br><span class="line">		hw.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// read homework grades</span></span><br><span class="line">		<span class="keyword">double</span> x;</span><br><span class="line">		<span class="keyword">while</span>(in &gt;&gt; x)</span><br><span class="line">			hw.push_back(x);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// clear the stream so that input will work for the next student</span></span><br><span class="line">		in.<span class="built_in">clear</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Group-2"><a href="#Group-2" class="headerlink" title="Group 2"></a>Group 2</h2><p><strong>grade.h</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_grade_h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_grade_h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// grade.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">const</span> Student_info &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">median</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;)</span></span>;   </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">**grade.cpp**</span><br><span class="line">```c++</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"grade.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"student_info.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::domain_error;  <span class="keyword">using</span> <span class="built_in">std</span>::istream;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;        <span class="keyword">using</span> <span class="built_in">std</span>::sort;</span><br><span class="line"></span><br><span class="line"><span class="comment">// grade function 1</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">const</span> Student_info &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> grade(s.midterm, s.<span class="keyword">final</span>, s.homework);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// grade function 2</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">double</span> midterm, <span class="keyword">double</span> <span class="keyword">final</span>, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;hw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hw.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> domain_error(<span class="string">"student has done no homework"</span>);</span><br><span class="line">    <span class="keyword">return</span> grade(midterm, <span class="keyword">final</span>, median(hw));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// grade function 3</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">double</span> midterm, <span class="keyword">double</span> <span class="keyword">final</span>, <span class="keyword">double</span> homework)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.2</span>*midterm + <span class="number">0.4</span>*<span class="keyword">final</span> + <span class="number">0.4</span>*homework;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compute the median of vector&lt;double&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">median</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// get the size of the vector</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;::size_type vec_size;</span><br><span class="line">    vec_size <span class="built_in">size</span> = vec.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check whether the empty is empty</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span> == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> domain_error(<span class="string">"median of an empty vector"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sort the grades</span></span><br><span class="line">    sort(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// compute the median homework grade</span></span><br><span class="line">    vec_size mid = <span class="built_in">size</span>/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">size</span> % <span class="number">2</span> == <span class="number">0</span> ? (vec[mid] + vec[mid - <span class="number">1</span>])/<span class="number">2</span> : vec[mid];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Inputs:</span><br><span class="line"></span><br><span class="line">Robin 90 87 79 88 81 73 45</span><br><span class="line">Brendan 70 69 88 100 91 75 66</span><br><span class="line">Arsenii 99 87 89 88 74 90 70</span><br><span class="line">Liam 83 66 100 76 87 91 78</span><br><span class="line"></span><br><span class="line">Outputs:</span><br><span class="line"></span><br><span class="line">Arsenii 89.8</span><br><span class="line">Brendan 76.8</span><br><span class="line">Liam    77.8</span><br><span class="line">Robin   84.4</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Notes</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ - Organizing programs with functions</title>
    <url>/2018/03/06/C-Organizing-programs-and-data/</url>
    <content><![CDATA[<p>Previous chapters mainly covers topics including</p>
<ol>
<li><strong>main function</strong> structure</li>
<li><strong>statements</strong> such as expression statements and flow-of-control statements. </li>
<li>built-in types, such as <strong>int</strong>, <strong>float</strong>, <strong>double</strong>, <strong>bool</strong> and <strong>char</strong>.</li>
<li>standard library <strong>IO</strong> mechanism.</li>
<li>standard library <strong>string</strong>.</li>
<li>standard library <strong>vector</strong>. </li>
</ol>
<p>We have achieved several goals through certain statements and operations on objects of different types. However, the program becomes unmanageable along with increasingly complex functions and growing information. For this reason, this chapter introduces how to organize programs and data. </p>
<h1 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h1><h2 id="Basics"><a href="#Basics" class="headerlink" title="Basics"></a>Basics</h2><h3 id="writing-a-function"><a href="#writing-a-function" class="headerlink" title="writing a function"></a>writing a function</h3><p>If we break a program(e.g. <a href="http://quanttour.com/02/03/2018/C-Working-with-batches-of-data/" target="_blank" rel="noopener">A complete program</a>) into pieces, we found that it is in fact constituted by <strong>data information</strong>, <strong>homework grade computation</strong> and <strong>final grade computation</strong>. Both computations can be organized as a <strong>function</strong>, which is a named block of code. The functions will be called When the computation results are needed. Let’s start with writing a function to compute the <strong>final grade</strong>, assuming that the homework grade has been computed.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// compute the final grade of a student</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">double</span> midterm, <span class="keyword">double</span> <span class="keyword">final</span>, <span class="keyword">double</span> homework)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.2</span>*midterm + <span class="number">0.4</span>*<span class="keyword">final</span> + <span class="number">0.4</span>*homework;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Basically, it has the same structure as the <strong>main</strong> function except that we use empty parameter list in previous <strong>main</strong> function. </p>
<p>In general, a function includes four parts:</p>
<ol>
<li><strong>return type</strong>. In this case, it has return type of <strong>double</strong>.</li>
<li><strong>function name</strong>. In this case, the function is names as <strong>grade</strong>.</li>
<li><strong>parameter list</strong> enclosed in parentheses <strong>()</strong>. In this case, there are three parameters seperated by commas. All three parameters have type of <strong>double</strong>. They are defined like variables but only be created when the function is called.</li>
<li><strong>function body</strong> enclosed in curly braces <strong>{}</strong>. The return statements returns the result to function caller. </li>
</ol>
<h3 id="calling-a-function"><a href="#calling-a-function" class="headerlink" title="calling a function"></a>calling a function</h3><p>When calling the function, the excution of function caller is suspended and execution of the called function begins. We must supply corresponding <strong>arguments</strong> for the purpose of initializing the parameters. In other words, <strong>arguments</strong> are the initializers for a function’s parameters. <strong>Arguments</strong> can be variables or expressions or even values. But they must be provided in the same order as well as the same type as the parameters. If we replace the computation in the original program, it would be like</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"You final grade is "</span> &lt;&lt; setprecision(<span class="number">3</span>)</span><br><span class="line">    &lt;&lt; grade(midterm, <span class="keyword">final</span>, sum/count) &lt;&lt; setprecision(prec) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>The first parameter <strong>midterm</strong> will be initialized by copying the value of <strong>argument</strong> midterm into it. So do the other parameters. This is what so called <strong>call by value</strong>. Essentially, these parameters are created in an area independent from the variables in the calling function though they have the same values. Therefore, if the function manipulate these parameters, it wouldn’t change values of the calling function variables. In addition, the parameters are local to the function and only exist start from calling the function to returning from the function. Therefore, it doesn’t matter that we use same name as the variable in the calling function. </p>
<p>Once the execution encounters the return statement in the function body, the execution of the function ends and back to the calling function. </p>
<h2 id="Writing-a-median-function"><a href="#Writing-a-median-function" class="headerlink" title="Writing a median function"></a>Writing a median function</h2><p>Now we consider writing a median function that computes the median value of the homework grades. Let’s list four parts of a median function:</p>
<ol>
<li>the return type should be <strong>double</strong>.</li>
<li>it is named as <strong>median</strong> for clarity.</li>
<li>what we need for computation is only a <strong>vector</strong> of <strong>double</strong> type (assuming that we have read all grades). </li>
<li>computing algorithms. </li>
</ol>
<p>It’s pretty straightforward</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">median</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// algorithms to be written</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The algorithm in the original program is</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// get the size of the vector</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;::size_type vec_size;</span><br><span class="line">vec_size <span class="built_in">size</span> = homework.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// check special case</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">size</span> == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"You must enter your grades. "</span></span><br><span class="line">                <span class="string">"Please try again."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sort the grades</span></span><br><span class="line">sort(homework.<span class="built_in">begin</span>(), homework.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// compute the median homework grade</span></span><br><span class="line">vec_size mid = <span class="built_in">size</span>/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">double</span> median;</span><br><span class="line">median = <span class="built_in">size</span> % <span class="number">2</span> == <span class="number">0</span> ? (homework[mid] + homework[mid - <span class="number">1</span>])/<span class="number">2</span> : homework[mid];</span><br></pre></td></tr></table></figure>
<p>To write this piece of code into the function, we need to first change the variable name <strong>homework</strong> to <strong>vec</strong> as this function suites for more general cases. Nevertheless, you don’t have to do it if you dislike. The second step is to remove the variable <strong>median</strong> and add return because what this function need to do to return the median value. The last step is to change the code that deals with the case of empty vector. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">size</span> == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">throw</span> domain_error(<span class="string">"median of an empty vector"</span>);</span><br></pre></td></tr></table></figure>
<p>This is because the original code can not be used here due to it returns another value 1 (unless we change the function structure). In real word programming, <strong>throw</strong> an <strong>exception</strong> is a more general way to complain. The usage is explained in next part. Now the function is accomplished as shown below</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// function to compute the median of a vector&lt;double&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">median</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">// get the size of the vector</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;::size_type vec_size;</span><br><span class="line">    vec_size <span class="built_in">size</span> = vec.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check whether the empty is empty</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span> == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> domain_error(<span class="string">"median of an empty vector"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sort the grades</span></span><br><span class="line">    sort(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// compute the median homework grade</span></span><br><span class="line">    vec_size mid = <span class="built_in">size</span>/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">size</span> % <span class="number">2</span> == <span class="number">0</span> ? (vec[mid] + vec[mid - <span class="number">1</span>])/<span class="number">2</span> : vec[mid];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="try-blocks-and-Exception-handling"><a href="#try-blocks-and-Exception-handling" class="headerlink" title="try blocks and Exception handling"></a><strong>try</strong> blocks and Exception handling</h2><p><em>“Exceptions are run-time anomalies—such as losing a database connection or encountering unexpected input—that exist outside the normal functioning of a program.”</em> - Lippman etc. 2012</p>
<h3 id="throw-expressions"><a href="#throw-expressions" class="headerlink" title="throw expressions"></a><strong>throw</strong> expressions</h3><p><strong>throw</strong> expressions is used to detect the exceptions, which is followed by an <strong>exception</strong> onject that describes the problems that it encounters. It stops the execution of the current function and passes an exception object to the caller for handling it. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// the detecting part</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">size</span> == <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// throw raises exceptions</span></span><br><span class="line">    <span class="keyword">throw</span> domain_error(<span class="string">"median of an empty vector"</span>);</span><br></pre></td></tr></table></figure>
<p>For example, the exception object <strong>domian_error</strong> contains the information of that the caller can use to act on the exception. It is a type that the standard library defines in header <stdexcept> for use in reporting the logic error: argument is out side the values that the function can accept. What closely follows is a string enclosed by parentheses to describe the problem.</p>
<h3 id="the-try-block"><a href="#the-try-block" class="headerlink" title="the try block"></a>the <strong>try</strong> block</h3><p>The <strong>try</strong> block is the handling part uses to deal with an exception. Once the exception is thrown, it catches the exception and handle it according to the type of the exception object. The general syntax is </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// statements including the detecting part</span></span><br><span class="line">&#125; catches(exception object1)&#123;</span><br><span class="line">    <span class="comment">// handler-statements</span></span><br><span class="line">&#125; catches(exception object2)&#123;</span><br><span class="line">    <span class="comment">// handler-statements</span></span><br><span class="line">&#125;  ...</span><br></pre></td></tr></table></figure>
<p>The catch clause handles the exception and hence is termed as “exception handler”. If the statements between <strong>try</strong> and <strong>catch</strong> don’t throw any exceptions during execution, the program ignores the handler-statements and continue to next part. </p>
<p>It is worthing noting that each pair of curly braces forms a name scope. The application of the <strong>try</strong> block will be finished at the end of this post. </p>
<h2 id="Finish-the-grade-function"><a href="#Finish-the-grade-function" class="headerlink" title="Finish the grade function"></a>Finish the <strong>grade</strong> function</h2><p>Now we can embed the <strong>median</strong> function in the <strong>grade</strong> function. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// function to compute the final grade which is the weighted average grade of medterm exam grade, final exam grade and the median homework grade</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">double</span> midterm, <span class="keyword">double</span> <span class="keyword">final</span>, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;hw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hw.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> domain_error(<span class="string">"student has done no homework"</span>);</span><br><span class="line">    <span class="keyword">return</span> grade(midterm, <span class="keyword">final</span>, median(hw));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="reference-and-call-by-reference"><a href="#reference-and-call-by-reference" class="headerlink" title="reference and call by reference"></a><strong>reference</strong> and call by reference</h3><p>It has been noted that this <strong>grade</strong> function differs from the previous one mentioned at the beigining in the part of <strong>parameter list</strong>. The third parameter here has a compound type with modifier <strong>reference</strong>. Recalling that to declare a variable needs a <strong>type</strong> and a <strong>name</strong>. More generally, a declaration is a <strong>base type</strong> followed by a list of <strong>declarators</strong> including a <strong>name</strong> and an optional <strong>type modifier</strong>. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">    base type modifier name </span><br><span class="line">``` </span><br><span class="line">A variable declared in above form has a type named **compound type** which is built from the base type. In <span class="keyword">this</span> <span class="keyword">case</span>, the third parameter has a type of **<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;** with modifier **reference** which indicates that the onject named **hw** refers to its **initializer**. In other words, a reference is a **alias** <span class="keyword">and</span> **hw** is simply another name <span class="keyword">for</span> the argument to be passed. In addition, a reference to a reference is in fact that both references refer to the original object. For example</span><br><span class="line">```c++</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;hw1 = hw; <span class="comment">// hw1 is another name for the vector homework</span></span><br></pre></td></tr></table></figure>
<p>In contrast to <strong>call by value</strong>, this is termed as <strong>call by reference</strong>. When we operate on a reference, we actually operate on the object that the reference refers. For the purpose of computational effiency, passing argument by reference can avoid copies, particularly for objects of large containers or class types. But, it is not a good habit to modify the value of the object that the reference refers. It’s complete ok in this case as the object is passed by copy in the <strong>median</strong> function where we will operate on the homework grades. Beyond this, there is a <strong>const</strong> qualifier before the reference, which restrict the values of the object to be changed when operating on the reference. </p>
<h3 id="overloaded-function"><a href="#overloaded-function" class="headerlink" title="overloaded function"></a>overloaded function</h3><p>Recalling the previous <strong>grade function</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">```c++</span><br><span class="line"><span class="comment">// compute the final grade of a student</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">double</span> midterm, <span class="keyword">double</span> <span class="keyword">final</span>, <span class="keyword">double</span> homework)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.2</span>*midterm + <span class="number">0.4</span>*<span class="keyword">final</span> + <span class="number">0.4</span>*homework;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>These two functions have the same name but different parameter list. This is termed as <strong>function overloading</strong> with either different types or numbers of parameters. If two function only differs in <strong>return type</strong>, functions can not be overloaded. When calling the overloaded function, the complier determines which function to call according to the supplied arguments and the defined parameters in each funciton.</p>
<h2 id="Writing-a-reading-function"><a href="#Writing-a-reading-function" class="headerlink" title="Writing a reading function"></a>Writing a reading function</h2><p>Finally, we need to solve the problem that how to read home work grades into a vector. The oringal code is </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> x;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; homework;</span><br><span class="line"></span><br><span class="line"><span class="comment">// enter homework grades followed by end-of-file</span></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; x)</span><br><span class="line">    homework.push_back(x);</span><br></pre></td></tr></table></figure>
<p>So, what’s this function should return?<br>Obviously, the purpose is to fill the vector <strong>homework</strong> and therefore it should return a filled vector. Beyond this, the function is required to return another value to the <strong>stream</strong> to indicate whether the attempted input was successful.<br>Intuitively, it works like this:</p>
<p><img src="/images/readingfunction.png" alt="Funtion work flow"></p>
<p>But it is hard to deal with two returns in one function and alternatively we can define a parameter as a reference type for the purpose of changing the values in <strong>homework</strong> directly. See the code below</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// read the homework grades from an input stream into a vector homework</span></span><br><span class="line"><span class="function">istream &amp; <span class="title">read_hw</span><span class="params">(istream &amp;in, <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;hw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// statements to be filled</span></span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="lvalue"><a href="#lvalue" class="headerlink" title="lvalue"></a>lvalue</h3><p>We are familar with the second parameter which refers to its initializer to be passed, i.e. the vector <strong>homework</strong>. Since we intend to modify the passed arguments, the <strong>const</strong> qualifier has been dropped. There is an important difference between a <strong>const</strong> reference and a <strong>nonconst</strong> reference. For a <strong>const reference</strong>, the arguments to be passed can be any value while a <strong>non const reference</strong> can only refer to a <strong>lvalue</strong> object (i.e. a nontemporary object). Any expressions that generate arithmetic values are not <strong>lvalue</strong>. For example</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;j = i; <span class="comment">// correct: j is bound to i</span></span><br><span class="line"><span class="keyword">int</span> &amp;m = <span class="number">10</span>; <span class="comment">// error: initializer must be an nontemporary object</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;n = <span class="number">10</span>; <span class="comment">// correct: a const reference</span></span><br></pre></td></tr></table></figure>
<h3 id="member-function-clear"><a href="#member-function-clear" class="headerlink" title="member function clear"></a>member function <strong>clear</strong></h3><p>The first parameter is also a type of <strong>non-const</strong> reference which refers to the object <strong>cin</strong>. This is because we hope to change its internal state. As a result, the return type is also a reference as <strong>in</strong> is a reference. Another reason is that there is no copy or assign for <strong>IO</strong> objects. </p>
<p>Now we consider read entered grades into <strong>homework</strong>. Remember that We propose to write a program that can deal with multiple students’ records. One problem is that the vector might contain the grades of the last student. To keep the vector empty, we use <strong>hw.clear()</strong> to discard any contents the vector might have had. </p>
<p>Similarly, we also need to keep the <strong>cin</strong> be valid for each student. In previous chapter, We have explained that once we finishes typing in the homework grades a signal <strong>end-of-file</strong> needs to be sent for terminating the loop. The signal will change the internal state of the <strong>cin</strong> to be false. In addition, <strong>end-of-file</strong> is not the only input that can stop the loop. If we enter values of an improper type, the library would mark the input stream as being in <strong>failure state</strong> as well. For this reason, we use <strong>in.clear()</strong> to clear the error state of <strong>cin</strong> after finishing the input for one student. Note that both the vector and the object of <strong>istream</strong> have member function <strong>clear</strong> but the effects are completely different. The function is shown below</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// read homework grades from an input stream inti a vector</span></span><br><span class="line"><span class="function">istream &amp; <span class="title">read_hw</span><span class="params">(istream &amp;in, <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;hw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (in)&#123;</span><br><span class="line">        <span class="comment">//get rid of previous contents</span></span><br><span class="line">        hw.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// read homework grades</span></span><br><span class="line">        <span class="keyword">double</span> x;</span><br><span class="line">        <span class="keyword">while</span>(in &gt;&gt; x)</span><br><span class="line">            hw.push_back(x);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// clear the stream so that input will work for the next student</span></span><br><span class="line">        in.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="A-complete-program"><a href="#A-complete-program" class="headerlink" title="A complete program"></a>A complete program</h2><p>Up to now, we have changed the computations in the original program to functions including a function to homework grades, a function to calculate the median of homework grades and a function to calculate the final grade. A complete program is presented below</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include directives</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt; // to get declaration of cin, cout, endl,</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;istream&gt;  // to get declaration of istream</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;   // to get declaration of string</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;   // to get declaration of vector</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;// to get declaration of sort</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ios&gt;      // to get declaration of streamsize</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdexcept&gt;// to get declaration of domain_error</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;  // to get declaration of setprecision</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// add using declarations</span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>; 			<span class="keyword">using</span> <span class="built_in">std</span>::setprecision;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;			<span class="keyword">using</span> <span class="built_in">std</span>::streamsize;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;			<span class="keyword">using</span> <span class="built_in">std</span>::domain_error;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;			<span class="keyword">using</span> <span class="built_in">std</span>::istream;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;          <span class="keyword">using</span> <span class="built_in">std</span>::sort;</span><br><span class="line"></span><br><span class="line"><span class="comment">// declare functions</span></span><br><span class="line"><span class="function">istream &amp; <span class="title">read_hw</span><span class="params">(istream &amp;in, <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;hw)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">median</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; vec)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">double</span> midterm, <span class="keyword">double</span> <span class="keyword">final</span>, <span class="keyword">double</span> homework)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">double</span> midterm, <span class="keyword">double</span> grade, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;hw)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main function</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ask for and read the student's name</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Please enter your first name: "</span>;</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; name;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, "</span> &lt;&lt; name &lt;&lt; <span class="string">"!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ask for and read the midterm and final grades</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Please enter your midterm and final exam grades: "</span>;</span><br><span class="line">    <span class="keyword">double</span> midterm, <span class="keyword">final</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; midterm &gt;&gt; <span class="keyword">final</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ask for the homework grades</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter all your homework grades, followed by end-of-file: "</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read the homework grades</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; homework;</span><br><span class="line">    read_hw(<span class="built_in">cin</span>, homework);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// compute and generate the final grade, if possible</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">double</span> final_grade = grade(midterm, <span class="keyword">final</span>, homework);</span><br><span class="line">        streamsize prec = <span class="built_in">cout</span>.precision();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Your final grade is "</span> &lt;&lt; setprecision(<span class="number">3</span>)</span><br><span class="line">            &lt;&lt; final_grade &lt;&lt; setprecision(prec) &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(domain_error) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"You must enter your grade. Please trt again."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// define function to read homework grade</span></span><br><span class="line"><span class="function">istream &amp; <span class="title">read_hw</span><span class="params">(istream &amp;in, <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;hw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (in)&#123;</span><br><span class="line">		<span class="comment">//get rid of previous contents</span></span><br><span class="line">		hw.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// read homework grades</span></span><br><span class="line">		<span class="keyword">double</span> x;</span><br><span class="line">		<span class="keyword">while</span>(in &gt;&gt; x)</span><br><span class="line">			hw.push_back(x);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// clear the stream so that input will work for the next student</span></span><br><span class="line">		in.<span class="built_in">clear</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// define function to calculate median value</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">median</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// get the size of the vector</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;::size_type vec_size;</span><br><span class="line">	vec_size <span class="built_in">size</span> = vec.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// check whether the empty is empty</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">size</span> == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">throw</span> domain_error(<span class="string">"median of an empty vector"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// sort the grades</span></span><br><span class="line">	sort(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">	<span class="comment">// compute the median homework grade</span></span><br><span class="line">	vec_size mid = <span class="built_in">size</span>/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">size</span> % <span class="number">2</span> == <span class="number">0</span> ? (vec[mid] + vec[mid - <span class="number">1</span>])/<span class="number">2</span> : vec[mid];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// define a function to calculate final grade</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">double</span> midterm, <span class="keyword">double</span> <span class="keyword">final</span>, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;hw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (hw.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">throw</span> domain_error(<span class="string">"student has done no homework"</span>);</span><br><span class="line">	<span class="keyword">return</span> grade(midterm, <span class="keyword">final</span>, median(hw));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//define a function to calculate final grade (function overloading)</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">double</span> midterm, <span class="keyword">double</span> <span class="keyword">final</span>, <span class="keyword">double</span> homework)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0.2</span>*midterm + <span class="number">0.4</span>*<span class="keyword">final</span> + <span class="number">0.4</span>*homework;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>See from above program, why the statements inside the <strong>try</strong> block are not organized as such form</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    streamsize_prec = <span class="built_in">cout</span>.precision();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Your final grade is "</span> &lt;&lt; setprecision(<span class="number">3</span>)</span><br><span class="line">        &lt;&lt; grade(midterm, <span class="keyword">final</span>, homework) </span><br><span class="line">        &lt;&lt; setprecision(prec) &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span>...</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>In doing so, we probably can’t control the outputs as the <strong>grade</strong> function may be called after or before the string literals depending on the implementation. Also, if any exception is thrown, the precision may not be reset back to the original value as expected. </p>
<hr>
<p>To be continued.</p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Notes</tag>
      </tags>
  </entry>
  <entry>
    <title>Accelerated C++ Solutions to Exercises(Chapter 3 Part 2)</title>
    <url>/2018/03/05/Accelerated-C-Solutions-to-Exercises-Chapter-3-Part-2/</url>
    <content><![CDATA[<h1 id="Exercise-3-5"><a href="#Exercise-3-5" class="headerlink" title="Exercise 3-5"></a>Exercise 3-5</h1><p>Write a program that will keep track of grades for several students at once. The program could keep two vectors in sync: The first should hold the student’s names, and the second the final grades that can be computed as input is read. For now, you should assume a fixed number of homework grades. </p>
<h2 id="Solution-amp-Results"><a href="#Solution-amp-Results" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>The exercise tries to make the original program (see <a href="http://quanttour.com/02/03/2018/C-Working-with-batches-of-data/" target="_blank" rel="noopener">the first program</a>) more practical. There are two more requirements compared with the original one: first, it requires computing the final grades for several students at once; second, it requires keep tracking both the students’ name and their final grades. </p>
<p>To meet the first requirements, we can add a while loop which allows us compute the final grades multiple times for different student. The condition will be an variable whose value depends on users. Let’s finish this first</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// set initial status</span></span><br><span class="line"><span class="keyword">bool</span> <span class="built_in">running</span> = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">running</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// compound statements</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> flag;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Do you want to check more students? Please input Y/N: "</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; flag;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="string">'Y'</span>) ;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">running</span> = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>To meet the second requirement, we can store both names and the final grades into two vectors. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; names;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; finalGrades;</span><br></pre></td></tr></table></figure>
<p>Each time we store a student’s name, we will store his final grade after computation. When needs writing the outputs, we can use same index for both vectors as there is a one-to-one correspondence.</p>
<p>Below is the modified program </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ios&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;			<span class="keyword">using</span> <span class="built_in">std</span>::setprecision;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;		<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;		<span class="keyword">using</span> <span class="built_in">std</span>::streamsize;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; names;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; finalGrades;</span><br><span class="line">    <span class="keyword">bool</span> <span class="built_in">running</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">running</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ask for and read the student's name</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Please enter your first name: "</span>;</span><br><span class="line">        <span class="built_in">string</span> name;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; name;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// store the name into names</span></span><br><span class="line">        names.push_back(name);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, "</span> &lt;&lt; name &lt;&lt; <span class="string">"!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ask for and read the midterm and final grades</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Please enter you midterm and final exam grades: "</span>;</span><br><span class="line">        <span class="keyword">double</span> midterm, <span class="keyword">final</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; midterm &gt;&gt; <span class="keyword">final</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ask for the number of homework grades</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Please enter the number of your homeworks: "</span>;</span><br><span class="line">        <span class="keyword">int</span> numofHomeworks;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; numofHomeworks;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ask for all homework grades</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter all your homework grades: "</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// the number and the sum of grades read so far</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// a variable into which to read</span></span><br><span class="line">        <span class="keyword">double</span> x;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// invariant: we have read count grades so far, and sum is the sum of the first count grades</span></span><br><span class="line">        <span class="keyword">while</span> (count &lt; numofHomeworks)</span><br><span class="line">        &#123;</span><br><span class="line">            ++count;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">            sum += x;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// compute the fianl grade and store into finalGrades</span></span><br><span class="line">        <span class="keyword">double</span> finalGrade = <span class="number">0.2</span> * midterm + <span class="number">0.4</span> * <span class="keyword">final</span> + <span class="number">0.4</span> * sum/count;</span><br><span class="line">        finalGrades.push_back(finalGrade);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// check condition</span></span><br><span class="line">        <span class="keyword">char</span> flag;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Do you want to check more students? Please input Y/N: "</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; flag;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="string">'Y'</span>) ;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">running</span> = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// prepare for writing outputs</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::size_type vec_size;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (vec_size i = <span class="number">0</span>; i != names.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        streamsize prec = <span class="built_in">cout</span>.precision();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; names[i] &lt;&lt; <span class="string">"'s final grade is: "</span> &lt;&lt; setprecision(<span class="number">3</span>) &lt;&lt; finalGrades[i]</span><br><span class="line">            &lt;&lt;	setprecision(prec) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>It’s not complex once figure out the original program. I test the program and it works well (see below).<br><strong>Test</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Please enter your first name: Conor</span><br><span class="line">Hello, Conor!</span><br><span class="line">Please enter you midterm and final exam grades: 88 70</span><br><span class="line">Please enter the number of your homeworks: 3</span><br><span class="line">Enter all your homework grades: 65 76 81</span><br><span class="line">Do you want to check more students? Please input Y&#x2F;N: Y</span><br><span class="line">Please enter your first name: Brendan</span><br><span class="line">Hello, Brendan!</span><br><span class="line">Please enter you midterm and final exam grades: 70 80</span><br><span class="line">Please enter the number of your homeworks: 2</span><br><span class="line">Enter all your homework grades: 90 85</span><br><span class="line">Do you want to check more students? Please input Y&#x2F;N: Y</span><br><span class="line">Please enter your first name: Robin</span><br><span class="line">Hello, Robin!</span><br><span class="line">Please enter you midterm and final exam grades: 90 90</span><br><span class="line">Please enter the number of your homeworks: 5</span><br><span class="line">Enter all your homework grades: 80 70 60 50 40</span><br><span class="line">Do you want to check more students? Please input Y&#x2F;N: N</span><br><span class="line"></span><br><span class="line">Conor&#39;s final grade is: 75.2</span><br><span class="line">Brendan&#39;s final grade is: 81</span><br><span class="line">Robin&#39;s final grade is: 78</span><br></pre></td></tr></table></figure>
<p>Note that the final grades don’t retain the tail <strong>zero</strong>s and the dot point though we set precision arguments as 3. Please find more experiments about <strong>setprecision</strong> at <a href="http://quanttour.com/02/03/2018/C-Working-with-batches-of-data/" target="_blank" rel="noopener">Working with batches of data </a>. </p>
<hr>
<h1 id="Exercise-3-6"><a href="#Exercise-3-6" class="headerlink" title="Exercise 3-6"></a>Exercise 3-6</h1><p>The average-grade computation in  <a href="http://quanttour.com/02/03/2018/C-Working-with-batches-of-data/" target="_blank" rel="noopener">the first program</a> might divide by zero if the student didn’t enter any grades. Division by zero is undefined in C++, which means that the implementation is permitted to do anything it likes. What does your C++ implementation do in this case? Rewrite the program so that its behavior does not depend on how the implementation treats division by zero.</p>
<h2 id="Solution-amp-Results-1"><a href="#Solution-amp-Results-1" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>To figure out how c++ implementation deals with division by 0, I did several experiments.<br><strong>Experiment 1</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i/j &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    returo <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The result shows that disivion by 0 with both integers makes the program crash.</p>
<p><strong>Experiment 2</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">double</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i/j &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; x/y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> m = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">double</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; m/n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This program works and returns three <strong>inf</strong> which means <strong>infinity</strong>. </p>
<p><strong>Exerpriment 3</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> h = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> k1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> k2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; h/k1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; h/k2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The third program is the case of the original program and it returns <strong>nan</strong> which means <strong>Not-A-Number</strong>. </p>
<p>There is one question on quora <a href="https://www.quora.com/Why-does-division-by-zero-return-INF-infinite-with-floats-but-makes-the-program-crash-with-integers-in-C++" target="_blank" rel="noopener">Why does division by zero return INF (infinite) with floats, but makes the program crash with integers in C++?</a>. Many answers can be found there but I can’t understand the mechanism well. </p>
<p>Anyway, division by 0 is a special case and should be treated seperately. For the original program, one way is to check the <strong>count</strong> before the division. For example, we can add below piece of code after the while loop finishes</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"No homework grades entered, please try again."</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Alternatively, we can set a default value for the average homework grade.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> homeworkGrade;</span><br><span class="line"><span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">    homeworkGrade = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    homeworkGrade = sum/count;</span><br></pre></td></tr></table></figure>
<p>Now I apply the second method and present the modified program below.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ios&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;			<span class="keyword">using</span> <span class="built_in">std</span>::setprecision;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;		<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;		<span class="keyword">using</span> <span class="built_in">std</span>::streamsize;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ask for and read the student's name</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Please enter your first name: "</span>;</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; name;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, "</span> &lt;&lt; name &lt;&lt; <span class="string">"!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ask for and read the midterm and final grades</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Please enter you midterm and final exam grades: "</span>;</span><br><span class="line">    <span class="keyword">double</span> midterm, <span class="keyword">final</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; midterm &gt;&gt; <span class="keyword">final</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ask for the homework grades</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter all your homework grades, "</span></span><br><span class="line">            <span class="string">"followed by end-of-file: "</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the number and the sum of grades read so far</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a variable into which to read</span></span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// invariant: we have read count grades so far, and sum is the sum of the first count grades</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; x)</span><br><span class="line">    &#123;</span><br><span class="line">        ++count;</span><br><span class="line">        sum += x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// special case treatment</span></span><br><span class="line">    <span class="keyword">double</span> homeworkGrade;</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">        homeworkGrade = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        homeworkGrade = sum/count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write a blank line to seperate outputs</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write the result</span></span><br><span class="line">    streamsize prec = <span class="built_in">cout</span>.precision();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Your final grade is "</span> &lt;&lt; setprecision(<span class="number">3</span>) &lt;&lt;</span><br><span class="line">            <span class="number">0.2</span> * midterm + <span class="number">0.4</span> * <span class="keyword">final</span> + <span class="number">0.4</span> * homeworkGrade</span><br><span class="line">            &lt;&lt;setprecision(prec) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Test</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Please enter your first name: Brendan</span><br><span class="line">Hello, Brendan!</span><br><span class="line">Please enter you midterm and final exam grades: 95 77</span><br><span class="line">Enter all your homework grades, followed by end-of-file:</span><br><span class="line"></span><br><span class="line">Your final grade is 49.8</span><br></pre></td></tr></table></figure>
<p>Now, it works better than the original one.</p>
<hr>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>Koenig, A. and Moo, B.E., 2000. Accelerated C++.</p>
<p>Lippman, S.B., Lajoie, J. and Moo, B.E., 2013. C++ Primer, 5th edt.</p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Accelerated C++ Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title>Accelerated C++ Solutions to Exercises(Chapter 3 Part 1)</title>
    <url>/2018/03/04/Accelerated-C-Solutions-to-Exercise-Chapter-3/</url>
    <content><![CDATA[<h1 id="Exercise-3-0"><a href="#Exercise-3-0" class="headerlink" title="Exercise 3-0"></a>Exercise 3-0</h1><p>Compile, execute, and test the programs in this chapter</p>
<h2 id="Solution-amp-Results"><a href="#Solution-amp-Results" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>This exercise has been accomplished in <a href="http://quanttour.com/02/03/2018/C-Working-with-batches-of-data/" target="_blank" rel="noopener">C++ - Working with batches of data</a> with detailed explination.</p>
<hr>
<h1 id="Exercise-3-1"><a href="#Exercise-3-1" class="headerlink" title="Exercise 3-1"></a>Exercise 3-1</h1><p>Suppose we wish to find the median of a collection of values. Assume that we have read some of the values so far, and that we have no idea how many values remain to be read. Prove that we cannot afford to discard any of the values that we have read. Hint: One proof strategy is to assume that we can discard a value, and then find values for the unread—and therefore unknown—part of our collection that would cause the median to be the value that we discarded.</p>
<h2 id="Solution-amp-Results-1"><a href="#Solution-amp-Results-1" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>It is known that the median value of a data sample is sensitive to the number of elements. If the number is an odd number, the mid element is unique and the median value is the value of this mid element. However, if the number is an even number, there exist two mid elements and the median value is the average value of these two elements. Consider that, once a value is discarded, the number of the elements changes from odd (or even) to even (odd), and hence the median value would be inaccurate. </p>
<p>For example, follow sequence of values is part of a data sample,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 8 3 4 9 7 0</span><br></pre></td></tr></table></figure>
<p>the unknown part is </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">11 6 13 9</span><br></pre></td></tr></table></figure>
<p>The ture median value is 7. If 0 is discarded, the median value becomes 7.5. If 7 is discarded, the median value is still 7. If 9 is discarded, the median value is 6.5. This indicates that the median value would be an unreliable measure for a data sample if any of values is discarded. </p>
<hr>
<h1 id="Exercise-3-2"><a href="#Exercise-3-2" class="headerlink" title="Exercise 3-2"></a>Exercise 3-2</h1><p>Write a program to compute and print the quartiles (that is, the quarter of the numbers with the largest values, the next highest quarter, and so on) of a set of integers.</p>
<h2 id="Solutions-amp-Results"><a href="#Solutions-amp-Results" class="headerlink" title="Solutions &amp; Results"></a>Solutions &amp; Results</h2><p>Quartiles of an ordered dataset are values that divide the data set into four equal parts, i.e. quarters. An intuitive strategy is to find the median value of the whole data set, and then find the median values of the divided two parts respecitively. As a result, there will exist three median values which are first quartile, second quartile and third quartile relative to the whole data set. Therefore, once we know how to compute the median value, we know how to compute quartiles. Now I’ll enter into the details of how to implement such a computing algorithm.</p>
<h3 id="data-preparation"><a href="#data-preparation" class="headerlink" title="data preparation"></a>data preparation</h3><p>At the very beiging stage, we need to store and sort all values</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="built_in">cout</span> &lt;&lt; <span class="string">"Please enter a sequence of integers, "</span></span><br><span class="line"><span class="string">"followed by end-of-file: "</span>;</span><br><span class="line"> <span class="keyword">int</span> x;</span><br><span class="line"> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; integers; <span class="comment">// to hold all values</span></span><br><span class="line"> <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; x)</span><br><span class="line">     integers.push_back(x);</span><br><span class="line"> sort(integers.<span class="built_in">begin</span>(), integers.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>
<h3 id="find-the-median-value"><a href="#find-the-median-value" class="headerlink" title="find the median value"></a>find the median value</h3><p>Now we have a sorted data set. Due to the calculation of a median value depends on the number of elements in the data set, we need to consider several cases. The number of elements is the size of <strong>integers</strong>.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::size_type vec_size;</span><br><span class="line">vec_size <span class="built_in">size</span> = integers.<span class="built_in">size</span>();</span><br></pre></td></tr></table></figure>
<ol>
<li><p>if there is no elements(i.e. <strong>size</strong> == 0), it is impossible to compute the median value.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">size</span> == <span class="number">0</span>)</span><br><span class="line">&#123;  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"You must enter at least one integer. "</span></span><br><span class="line">        <span class="string">"Please try again."</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>if <strong>size</strong> is an even number, the median value is the average value of two mid elements. In addition, <strong>size/2</strong> is exactly devided and represent the number of each side elements.<br>Due to the index of a vector starts from 0, the mid elements should be <strong>integers[size/2 - 1]</strong> and <strong>integers[size/2]</strong>. Therefore, the median value is the average of the corresponding two values. As shown in above graph, the number of elements of both sides equals to <strong>size/2</strong> because</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">left side:  number &#x3D; size&#x2F;2 - 1 - 0 + 1 &#x3D; size&#x2F;2</span><br><span class="line">right side: number &#x3D; size - 1 - size&#x2F;2 + 1 &#x3D; size&#x2F;2</span><br></pre></td></tr></table></figure>
<p><img src="/images/even.png" alt="If size is an even number"></p>
</li>
<li><p>if <strong>size</strong> is an odd number, the median value is the value of the unique mid element. <strong>size/2</strong> yields the same value as <strong>(size-1)/2</strong> in c++. Then the mid element is exact the <strong>integers[(size-1)/2]</strong> as both sides of this element has same number of elements(as shown in below graph).  This can also be verified mathematically</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">left side:  number &#x3D; (size-1)&#x2F;2 - 1 - 0 + 1 &#x3D; (size-1)&#x2F;2</span><br><span class="line">right side: number &#x3D; size - 1 - &#123;(size-1)&#x2F;2 + 1&#125; + 1 &#x3D; (size-1)&#x2F;2;</span><br></pre></td></tr></table></figure>
<p><img src="/images/odd.png" alt="If size is an odd number"></p>
</li>
</ol>
<p>Now let’s translate the algorithm into real code</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vec_size mid = <span class="built_in">size</span>/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">double</span> Q2; <span class="comment">// the median is in fact the second quartile denoted by Q2</span></span><br><span class="line">Q2 = <span class="built_in">size</span> % <span class="number">2</span> == <span class="number">0</span> ? (integers[mid - <span class="number">1</span>] + integers[mid])/<span class="number">2.0</span></span><br><span class="line">            : integers[mid];</span><br></pre></td></tr></table></figure>
<p><strong><em>Note that when calculate the average of two mid elements, I divide by 2.0 rather than 2 for the purpose of avoiding the loss of precision.This is because the quotient of two integers will be an integer.</em></strong></p>
<h3 id="find-the-first-quartile"><a href="#find-the-first-quartile" class="headerlink" title="find the first quartile"></a>find the first quartile</h3><p>From above analysis, we have known how to find a median, i.e. the second quartile of the dataset. The median has divided the data into two equal groups: first group is from the smallest value to the median and the other one is from the median value to the largest value. Therefore, the middle value of the first group is in fact the first quartile(also known as lower quartile) and the middle value of the second group is the third quartile (also known as upper quartile). We can apply the same method to find both middle values. Similarly, the first step is to find the size (denoted by <strong>half_size</strong>) for both groups and discuss different cases. </p>
<p>From above analysis, we know that</p>
<ol>
<li>if <strong>size</strong> is an even number, <strong>half_size</strong> == <strong>size/2</strong>.</li>
<li>if <strong>size</strong> is an odd number, <strong>half_size</strong> == <strong>(size-1)/2</strong>. <a href="https://en.wikipedia.org/wiki/Quartile" target="_blank" rel="noopener">See wikipedia-Quartile Method 1</a></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vec_size half_size; <span class="comment">// defind a variable to represent the size of two equal groups.</span></span><br><span class="line">half_size = <span class="built_in">size</span> % <span class="number">2</span> == <span class="number">0</span> ? <span class="built_in">size</span>/<span class="number">2</span> : (<span class="built_in">size</span><span class="number">-1</span>)/<span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>Now let’s find the middle value of the first group values. </p>
<ol>
<li>if <strong>half_size == 0</strong>, then <strong>size == 1</strong>. In this case, the single element is all we have and hence all quartiles equals to the value of the single element.</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// variables to hold the first quartile and third quartile</span></span><br><span class="line"><span class="keyword">double</span> Q1, Q3; </span><br><span class="line"><span class="keyword">if</span> (half_size == <span class="number">0</span>)</span><br><span class="line">    Q1 = Q3 = integers[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p>if <strong>half_size</strong> is an even number, <strong>half_size/2</strong> is exactly divided and the mid elements are integers[half_size/2] and integers[half_size/2 - 1]. </p>
</li>
<li><p>if <strong>half_size</strong> is an odd number, <strong>half_size/2</strong> gives the value of <strong>(half_size - 1)/2</strong>. The middle value is integers[(half_size-1)/2].</p>
</li>
</ol>
<p>Both two cases are exactly the same as finding the median for the whole dataset. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vec_size mid_first = half_size/<span class="number">2</span>;</span><br><span class="line">Q1 = half_size % <span class="number">2</span> == <span class="number">0</span> ? (integers[mid_first - <span class="number">1</span>] + integers[mid_first])/<span class="number">2.0</span>  : integers[mid_first];</span><br></pre></td></tr></table></figure>

<h3 id="find-the-third-quartile"><a href="#find-the-third-quartile" class="headerlink" title="find the third quartile"></a>find the third quartile</h3><p>The upper quartile is computed as same as the lower quartile except the index to be applied. If <strong>size</strong> is even, then the starting point for the second half is <strong>mid</strong>, while if <strong>size</strong> is odd, the starting point is <strong>mid+1</strong>. Therefore</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vec_size mid_second = <span class="built_in">size</span> % <span class="number">2</span> == <span class="number">0</span> ? (half_size/<span class="number">2</span> + mid) : (half_size/<span class="number">2</span> + mid + <span class="number">1</span>);</span><br><span class="line">Q3 = half_size % <span class="number">2</span> ? (integers[mid_second - <span class="number">1</span>] + integers[mid_second])/<span class="number">2.0</span> </span><br><span class="line">: integers[mid_second];</span><br></pre></td></tr></table></figure>

<h3 id="A-complete-program"><a href="#A-complete-program" class="headerlink" title="A complete program"></a>A complete program</h3><p>Now let’s put all pieces of code togther and add appropriate headers as well s using declarations. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ios&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>; 			<span class="keyword">using</span> <span class="built_in">std</span>::sort;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>; 			<span class="keyword">using</span> <span class="built_in">std</span>::streamsize;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;			<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::setprecision; 	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ask for and read integers</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Please enter a sequence of integers, "</span></span><br><span class="line">            <span class="string">"followed by end-of-file: "</span>;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; integers; <span class="comment">// to hold all values</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; x)</span><br><span class="line">        integers.push_back(x);</span><br><span class="line">    sort(integers.<span class="built_in">begin</span>(), integers.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get the size of the dataset</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::size_type vec_size;</span><br><span class="line">    vec_size <span class="built_in">size</span> = integers.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span> == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"You must enter at least one integer. "</span></span><br><span class="line">            <span class="string">"Please try again."</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find the median value which in fact is the second quartile denoted by Q2</span></span><br><span class="line">    vec_size mid = <span class="built_in">size</span>/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">double</span> Q2;</span><br><span class="line">    Q2 = <span class="built_in">size</span> % <span class="number">2</span> == <span class="number">0</span> ? (integers[mid - <span class="number">1</span>] + integers[mid])/<span class="number">2.0</span> : integers[mid];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get the size of two equal groups.</span></span><br><span class="line">    vec_size half_size; </span><br><span class="line">    half_size = <span class="built_in">size</span> % <span class="number">2</span> == <span class="number">0</span> ? <span class="built_in">size</span>/<span class="number">2</span> : (<span class="built_in">size</span><span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find the first quartile and third quartile denoted by Q1 and Q3 respectively</span></span><br><span class="line">    <span class="keyword">double</span> Q1, Q3;</span><br><span class="line">    <span class="keyword">if</span> (half_size == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Q1 = Q3 = integers[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        vec_size mid_first = half_size/<span class="number">2</span>;</span><br><span class="line">        Q1 = half_size % <span class="number">2</span> == <span class="number">0</span> ? (integers[mid_first - <span class="number">1</span>] + integers[mid_first])/<span class="number">2.0</span> : integers[mid_first];</span><br><span class="line"></span><br><span class="line">        vec_size mid_second = <span class="built_in">size</span> % <span class="number">2</span> == <span class="number">0</span> ? (half_size/<span class="number">2</span> + mid) : (half_size/<span class="number">2</span> + mid + <span class="number">1</span>);</span><br><span class="line">        Q3 = half_size % <span class="number">2</span> == <span class="number">0</span> ? (integers[mid_second - <span class="number">1</span>] + integers[mid_second])/<span class="number">2.0</span> : integers[mid_second];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    streamsize prec = <span class="built_in">cout</span>.precision();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; setprecision(<span class="number">3</span>) &lt;&lt; <span class="string">"The first quartile is: "</span> &lt;&lt; Q1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The second quartile is: "</span> &lt;&lt; Q2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The second quartile is: "</span> &lt;&lt; Q3 &lt;&lt; setprecision(prec) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Test-performance"><a href="#Test-performance" class="headerlink" title="Test performance"></a>Test performance</h3><p><strong>Test sequence 1</strong>: 1 2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Please enter a sequence of integers, followed by end-of-file: 1 2</span><br><span class="line">The first quartile is: 1</span><br><span class="line">The second quartile is: 1.5</span><br><span class="line">The second quartile is: 2</span><br></pre></td></tr></table></figure>
<p><strong>Test sequence 2</strong>: 1 2 3</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Please enter a sequence of integers, followed by end-of-file: 1 2 3</span><br><span class="line">The first quartile is: 1</span><br><span class="line">The second quartile is: 2</span><br><span class="line">The second quartile is: 3</span><br></pre></td></tr></table></figure>
<p><strong>Test sequence 3</strong>: 1 2 3 4</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Please enter a sequence of integers, followed by end-of-file: 1 2 3 4</span><br><span class="line">The first quartile is: 1.5</span><br><span class="line">The second quartile is: 2.5</span><br><span class="line">The second quartile is: 3.5</span><br></pre></td></tr></table></figure>
<p><strong>Test sequence 3</strong>: 1 3 5 6 9 0 3 2 5 3 8 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Please enter a sequence of integers, followed by end-of-file: 1 3 5 6 9 0 3 2 5 3 8 </span><br><span class="line">The first quartile is: 2</span><br><span class="line">The second quartile is: 3</span><br><span class="line">The second quartile is: 6</span><br></pre></td></tr></table></figure>
<p>Yeah, it works perfectly. </p>
<hr>
<h1 id="Exercise-3-3"><a href="#Exercise-3-3" class="headerlink" title="Exercise 3-3"></a>Exercise 3-3</h1><p>Write a program to count how many times each distinct word appears in its input.</p>
<h2 id="Solution-amp-Results-2"><a href="#Solution-amp-Results-2" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><h3 id="Intuitive-explanations"><a href="#Intuitive-explanations" class="headerlink" title="Intuitive explanations"></a>Intuitive explanations</h3><p>The purposes of this program is to write out each distinct word followed by its occurrence numbers in the input. And what we have is only unknown amount of words to be entered. Imagine that there is only one word(e.g. word1) in total, then the output will be:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">word1 appears 1 times</span><br></pre></td></tr></table></figure>
<p>Now in the case of two words, e.g. word1 and word2, if word1 is the same as word2, then the output will be:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">word1 appears 2 times</span><br></pre></td></tr></table></figure>
<p>otherwise</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">word1 appears 1 times</span><br><span class="line">word2 appears 1 times</span><br></pre></td></tr></table></figure>
<p>From these two cases, we have seen that</p>
<ol>
<li>word1 needs to be stored and its occurrence needs to be recorded</li>
<li>word2 needs to be compared with word1. As a result, it will be discarded if they are the same and the occurrence number of word1 is increased by 1, and it will be stored if they are different and its occurrence number increases by 1. </li>
</ol>
<p>By analogy, following entered words will be compared with each stored word, and will be discarded if there already exist one same word otherwise will be stored, meanwhile, the corresponding occurrence numbers are adjusted. Finally, all stored words are distinct with eachother and their occurrence numbers have been clearly recorded. Now I enter the details of this program.</p>
<h3 id="vectors-and-the-structure"><a href="#vectors-and-the-structure" class="headerlink" title="vectors and the structure"></a>vectors and the structure</h3><p>To hold each distinct word and the associated number of occurrence, I define two vectors whis have types of <strong>int</strong> and <strong>string</strong> respectively. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; counter;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; words;</span><br></pre></td></tr></table></figure>
<p>The next step is to ask for enterring word by word and store the distinct word. This can be accomplished with a while statement. To write all distinct words as well as the occurrence numbers, we can loop through <strong>words</strong> and <strong>counter</strong> using index from <strong>0</strong> to <strong>words.size() - 1</strong>.<br>Therefore, the whole structure is </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; counter;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; words;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::size_type vec_size;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> <span class="keyword">word</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; <span class="keyword">word</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* pseudocode</span></span><br><span class="line"><span class="comment">         * if the word is a new distinct word</span></span><br><span class="line"><span class="comment">         *      words.push_back(word);</span></span><br><span class="line"><span class="comment">         *      counter.push_back(1);</span></span><br><span class="line"><span class="comment">         * if the word already exists</span></span><br><span class="line"><span class="comment">         *      adjust the number of occurrence for </span></span><br><span class="line"><span class="comment">         *      the existed distinct word</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if there is no inputs, send warning</span></span><br><span class="line">    <span class="keyword">if</span> (words.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"You must input at least one word. Please try again."</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (vec_size i = <span class="number">0</span>; i != words.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; words[i] &lt;&lt; <span class="string">" appears "</span> &lt;&lt; counter[i] &lt;&lt; <span class="string">" times"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="loop-invariants"><a href="#loop-invariants" class="headerlink" title="loop invariants"></a>loop invariants</h3><p>The only part that is needed is write the while body. The loop invariant is that <strong>words</strong> contains each distinct word entered and <strong>counter</strong> contains the associated number of occurrence. Therefore, two goals need to be accomplished inside the while loop:</p>
<ol>
<li>check whether the current is distinct from all existed distinct words</li>
<li>adjust <strong>word</strong> and <strong>counter</strong> to maintain the loop invariant</li>
</ol>
<p>The first goal can be accomplished by comparing the current word with each word stored in <strong>words</strong>. In addition, a flag is set to indicate the status of the outcomes, that is, a distinct word or an existed word. Let’s see the code below</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> flag = <span class="number">0</span>; <span class="comment">// initial status</span></span><br><span class="line"><span class="keyword">for</span> (vec_size i = <span class="number">0</span>;  i != words.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">word</span> == words[i])</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="comment">// if the word is already existed, discard the word but change the counter</span></span><br><span class="line">        ++counter[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// change status show this word is not a distinct word</span></span><br><span class="line">        flag = <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The second goal is partly accomplished by the code above and the rest case is when the current <strong>word</strong> is a distinct word. Accordingly, the word should be stored into <strong>words</strong> and the initial value for occurrence number is 1. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (flag == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    words.push_back(<span class="keyword">word</span>);</span><br><span class="line">    counter.push_back(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now the program is finished, and please find the complete version in the following part. I also did several tests and it works as expected. Note that I omitted the process that verify the correctness of the loop invariants here. </p>
<h3 id="A-complete-program-1"><a href="#A-complete-program-1" class="headerlink" title="A complete program"></a>A complete program</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;		<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// vectors for holding each distinct word and its occurrence numbers</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; counter;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; words;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// using type alias for convenience</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::size_type vec_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ask for and read words one by one</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Please enter a sequence of words, and followed by end-of-file: "</span>;</span><br><span class="line">    <span class="built_in">string</span> <span class="keyword">word</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// while loop invariant: words and counter contains each distinct word and the associated times</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; <span class="keyword">word</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// set flags to indicate whether the current word already exists</span></span><br><span class="line">        <span class="comment">// flag == 0: the word is distinct from each existed distinct word</span></span><br><span class="line">        <span class="comment">// flag == 1: the word is already exist</span></span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// to maintain the outer loop invariant, compare the current word</span></span><br><span class="line">        <span class="comment">// with each existed distinct word using following for loops</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// for loop invariant: the current word has been compared with the ith distinct word</span></span><br><span class="line">        <span class="keyword">for</span> (vec_size i = <span class="number">0</span>;  i != words.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// adjust the number of occurrence by 1 for existed distinct words</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">word</span> == words[i])</span><br><span class="line">            &#123;</span><br><span class="line">                ++counter[i];</span><br><span class="line">                flag = <span class="number">1</span>; <span class="comment">// change flag value to indicate that this word is distinct</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// maintain the outer loop invariant: store the new distinct word and its occurrence number</span></span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            words.push_back(<span class="keyword">word</span>);</span><br><span class="line">            counter.push_back(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// send warning if there is no any words entered</span></span><br><span class="line">    <span class="keyword">if</span> (words.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"You must input at least one word. Please try again."</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write a blank line to seperate the outputs</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (vec_size i = <span class="number">0</span>; i != words.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; words[i] &lt;&lt; <span class="string">" appears "</span> &lt;&lt; counter[i] &lt;&lt; <span class="string">" times"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Test-performance-1"><a href="#Test-performance-1" class="headerlink" title="Test performance"></a>Test performance</h3><p><strong>Test 1</strong>: house</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Please enter a sequence of words followed by end-of-file: house</span><br><span class="line"></span><br><span class="line">house appears 1 times</span><br></pre></td></tr></table></figure>
<p><strong>Test 2</strong>: house number one and number two</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Please enter a sequence of words followed by end-of-file: house number one and number two</span><br><span class="line"></span><br><span class="line">house appears 1 times</span><br><span class="line">number appears 2 times</span><br><span class="line">one appears 1 times</span><br><span class="line">and appears 1 times</span><br><span class="line">two appears 1 times</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Exercise-3-4"><a href="#Exercise-3-4" class="headerlink" title="Exercise 3-4"></a>Exercise 3-4</h1><p>Write a program to report the length of the longest and shortest string in its input.</p>
<h2 id="Solution-amp-Results-3"><a href="#Solution-amp-Results-3" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><h3 id="Strategy-1"><a href="#Strategy-1" class="headerlink" title="Strategy 1"></a>Strategy 1</h3><p>A very simple solution strategy to this exercise is that store the length of each string into a vector and then implement a library sort algorithm. I won’t go into details as it is simple. Please find the code and tests below. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;     <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ask for words</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Please enter words followed by end-of-file: "</span>;</span><br><span class="line">    <span class="built_in">string</span> <span class="keyword">word</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// creat a vector for holding the length of each string</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">string</span>::size_type word_size;</span><br><span class="line">    <span class="built_in">vector</span>&lt;word_size&gt; length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read word and store the length</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; <span class="keyword">word</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        length.push_back(<span class="keyword">word</span>.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (length.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"You must input at least one word."</span></span><br><span class="line">                <span class="string">"Please try again."</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sort all lengths in an nondecreasing order</span></span><br><span class="line">    sort(length.<span class="built_in">begin</span>(), length.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The length of the shortest string is: "</span> &lt;&lt; length[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The length of the longest string is: "</span> &lt;&lt; length[length.<span class="built_in">size</span>() - <span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Test 1</strong>: I am a good teacher </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Please enter words followed by end-of-file: I am a good teacher </span><br><span class="line">The length of the shortest string is: 1</span><br><span class="line">The length of the longest string is: 7</span><br></pre></td></tr></table></figure>
<p><strong>Test 2</strong>: what are you going to do</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Please enter words followed by end-of-file: what are you going to do</span><br><span class="line">The length of the shortest string is: 2</span><br><span class="line">The length of the longest string is: 5</span><br></pre></td></tr></table></figure>
<h3 id="Strategy-2"><a href="#Strategy-2" class="headerlink" title="Strategy 2"></a>Strategy 2</h3><p>Above strategy is computational inefficient due to the fact that it sorts all length values while we only need two extremes. An alternative strategy is to use <strong>insert sort</strong> algorithm but only sort one round for each of extremes. For example, now there is a sequence of integers</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">n1 n2 n3 n4 ... nx ny nz</span><br></pre></td></tr></table></figure>
<p>Step 1: assumming the largest number is <strong>n1</strong>.</p>
<p>Step 2: compare <strong>n1</strong> and <strong>n2</strong>, if <strong>n1 &gt;= n2</strong>, we exchange their positions with eachother. But if <strong>n1 &lt; n2</strong>, we keep their order and assume <strong>n2</strong> is the largest number.</p>
<p>Step 3: compare the larger number of step 2 with <strong>n3</strong>. Deal with the comparison result as same as that in step 2. </p>
<p>Step 4: continue comparison until the last number. Now the number in the rightest position is the final result, i.e. the largest number. </p>
<p>By analogy, we can find the smallest number. In this case, the precedure is simpler as we don’t need to exchange their positions. For finding the largest number, we simply discard the smaller value in each comparison. It is pretty easy to understand and no more detailed description here. Please see the complete program below.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>; 	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ask for inputs</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Please enter words followed by end-of-file: "</span>;</span><br><span class="line">    <span class="built_in">string</span> <span class="keyword">word</span>;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">string</span>::size_type str_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// variables for holding the length values of the longest and shortest strings </span></span><br><span class="line">    str_size longestLength = <span class="number">0</span>;</span><br><span class="line">    str_size shortestLength = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read words one by one</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; <span class="keyword">word</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// insert sort to get the largest value and samllest value only</span></span><br><span class="line">        <span class="keyword">if</span> (longestLength == <span class="number">0</span> || longestLength &lt; <span class="keyword">word</span>.<span class="built_in">size</span>())</span><br><span class="line">            longestLength = <span class="keyword">word</span>.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (shortestLength == <span class="number">0</span> || shortestLength &gt; <span class="keyword">word</span>.<span class="built_in">size</span>())</span><br><span class="line">            shortestLength = <span class="keyword">word</span>.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if there is no inputs, send warning</span></span><br><span class="line">    <span class="keyword">if</span> (longestLength == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"You must enter at least one word. Please try again."</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The length of the shortest string is: "</span> &lt;&lt; shortestLength &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The length of the longest string is: "</span> &lt;&lt; longestLength &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Test 1</strong>: I am a good teacher </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Please enter words followed by end-of-file: I am a good teacher </span><br><span class="line">The length of the shortest string is: 1</span><br><span class="line">The length of the longest string is: 7</span><br></pre></td></tr></table></figure>
<p><strong>Test 2</strong>: what are you going to do</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Please enter words followed by end-of-file: what are you going to do</span><br><span class="line">The length of the shortest string is: 2</span><br><span class="line">The length of the longest string is: 5</span><br></pre></td></tr></table></figure>
<p>The results of above two programs are exactly the same. </p>
<hr>
<p>To be continued. </p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Accelerated C++ Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ - Working with batches of data</title>
    <url>/2018/03/02/C-Working-with-batches-of-data/</url>
    <content><![CDATA[<p><em>Imagine a course in which each student’s final exam counts for 40% of the final grade, the midterm exam counts for 20%, and the average homework grade makes up the remaining 40%. Now we are asked to write a program that reads a student’s exam and homework grades and computes a final grade.</em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ios&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;			<span class="keyword">using</span> <span class="built_in">std</span>::setprecision;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;		<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;		<span class="keyword">using</span> <span class="built_in">std</span>::streamsize;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// ask for and read the student's name</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Please enter your first name: "</span>;</span><br><span class="line">	<span class="built_in">string</span> name;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; name;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, "</span> &lt;&lt; name &lt;&lt; <span class="string">"!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ask for and read the midterm and final grades</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Please enter you midterm and final exam grades: "</span>;</span><br><span class="line">	<span class="keyword">double</span> midterm, <span class="keyword">final</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; midterm &gt;&gt; <span class="keyword">final</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ask for the homework grades</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter all your homework grades, "</span></span><br><span class="line">			<span class="string">"followed by end-of-file: "</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// the number and the sum of grades read so far</span></span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// a variable into which to read</span></span><br><span class="line">	<span class="keyword">double</span> x;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// invariant: we have read count grades so far, and sum is the sum of the first count grades</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; x)</span><br><span class="line">	&#123;</span><br><span class="line">		++count;</span><br><span class="line">		sum += x;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// write the result</span></span><br><span class="line">	streamsize prec = <span class="built_in">cout</span>.precision();</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Your final grade is "</span> &lt;&lt; setprecision(<span class="number">3</span>) </span><br><span class="line">         &lt;&lt; <span class="number">0.2</span> * midterm + <span class="number">0.4</span> * <span class="keyword">final</span> + <span class="number">0.4</span> * sum/count </span><br><span class="line">         &lt;&lt; setprecision(prec) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="More-about-IO-system"><a href="#More-about-IO-system" class="headerlink" title="More about IO system"></a>More about IO system</h1><p>The goal of above program is to compute a final grade, which is a simple math question-computing the weighted average. Let’s start from the <strong>#include</strong> directives</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ios&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>We are familar with <iostream> which is the header that defines the standard input/output stream objects, and <string> which is the header that defines string type objects. Correspondingly, objects <strong>cin</strong> , <strong>cout</strong> and <strong>endl</strong> are defined in the <strong>iostream</strong> library, and <strong>string</strong> is defined in the <strong>string</strong> class. These names are defined in the namespace <strong>std</strong>, and need to be declared in the form of <strong>std::name</strong> or <strong>using std::name</strong> before we can use them.</p>
<p>Similarly, the <ios> is a header that defines the type <strong>streamsize</strong> which represents sizes. The <iomanip> defines the manipulator <strong>setprecision</strong> which sets the decimal precision. Both names <strong>streamsize</strong> and <strong>setprecision</strong> are defined in the namespace std.</p>
<h2 id="setprecision-shownpoint-amp-fixed"><a href="#setprecision-shownpoint-amp-fixed" class="headerlink" title="setprecision, shownpoint &amp; fixed"></a>setprecision, shownpoint &amp; fixed</h2><p><strong>setprecision</strong> is used to format floating-point values, such as <strong>float</strong> and <strong>double</strong> type values. It manipulates the stream by causing the subsequent output on that stream to be written with a given number of digits. The syntax is </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&lt;&lt; setprecision(<span class="keyword">int</span> n) &lt;&lt;</span><br></pre></td></tr></table></figure>
<p>The parameter <strong>n</strong> determines the number of digits to be written. In this case, <strong>setprecision(3)</strong> means the output will remain three digits. Let’s do some experiments to explore more about <strong>setprecision</strong></p>
<p><strong>Experiment 1</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ios&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;		<span class="keyword">using</span> <span class="built_in">std</span>::setprecision;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">12345</span>;</span><br><span class="line">    <span class="keyword">float</span> f1 = <span class="number">12345</span>;</span><br><span class="line">    <span class="keyword">float</span> f2 = <span class="number">3.148</span>;;</span><br><span class="line">    <span class="keyword">float</span> f3 = <span class="number">0.03148</span>;</span><br><span class="line">    <span class="keyword">float</span> f4 = <span class="number">0.03108</span>;</span><br><span class="line">    <span class="keyword">float</span> f5 = <span class="number">0.03100</span>;</span><br><span class="line">    <span class="keyword">float</span> f6 = <span class="number">1000.435</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; setprecision(<span class="number">3</span>) &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f1 &lt;&lt; <span class="built_in">endl</span>;   </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f4 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f5 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f6 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The result is shown below</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">12345</span><br><span class="line">1.23e+004</span><br><span class="line">3.15</span><br><span class="line">0.0315</span><br><span class="line">0.0311</span><br><span class="line">0.031</span><br><span class="line">1e+003</span><br></pre></td></tr></table></figure>
<p>It can be seen from this experiment that </p>
<ol>
<li><strong>setprecision</strong> doesn’t work on int type values</li>
<li>the parameter <strong>n</strong> (in this case is 3) controls the number of significant digits (i.e. count from the first non-zero number).</li>
<li>it follows the rounding principles.</li>
<li>it omits the trailing <strong>0</strong>s.</li>
</ol>
<p>If one want to keep the trailing zero, the manipulator <strong>showpoint</strong> can be used. <strong>showpoint</strong> is declared in the <strong>ios</strong> library and its name is also in the namespace std. It sets the format flag and always includes the decimal point as well as the tail 0 for matching the precision. The <strong>showpoint</strong> flag can be unset with the <strong>noshowpoint</strong> manipulator. </p>
<p>If we want control the precision of the decimal part, we can use <strong>fixed</strong> manipulator to fixed the decimal part. Together with the <strong>setprecision(n)</strong>, the number of digits in the fractional part will be fixed at <strong>n</strong>. If there is no enough numbers after the decimal point, zero will be added to match the precision. </p>
<p>To veryfy the usages of <strong>showpoint</strong> and <strong>fixed</strong>, I did tests as follows.</p>
<p><strong>Experiment 2</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ios&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;		<span class="keyword">using</span> <span class="built_in">std</span>::setprecision;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::fixed;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::showpoint;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::noshowpoint;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> f1 = <span class="number">1000.00</span>;</span><br><span class="line">    <span class="keyword">float</span> f2 = <span class="number">3.14800</span>;</span><br><span class="line">    <span class="keyword">float</span> f3 = <span class="number">0.03148</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; showpoint &lt;&lt; setprecision(<span class="number">4</span>) &lt;&lt; f1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f3 &lt;&lt; noshowpoint &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write a bank line to sepearate outputs</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">6</span>) &lt;&lt; f1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The result is as analysed above</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1000.</span><br><span class="line">3.148</span><br><span class="line">0.03148</span><br><span class="line"></span><br><span class="line">1000.000000</span><br><span class="line">3.148000</span><br><span class="line">0.031480</span><br></pre></td></tr></table></figure>
<h2 id="streamsize"><a href="#streamsize" class="headerlink" title="streamsize"></a>streamsize</h2><p>Once we changed the precision, the subsequent output would be formated to match the precision. If we want to change back, we can reset the precision to the original setting if we know the precision value. If we don’t know the previous setting of the <strong>cout</strong>, the <strong>cout.presicion</strong> returns us the value and its type is <strong>streamsize</strong>. </p>
<p>Without using <strong>setprecision</strong>, we could use <strong>cout.precision(n)</strong> to set the precision. The usage is shown as below</p>
<p><strong>Experiment 3</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ios&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;		<span class="keyword">using</span> <span class="built_in">std</span>::setprecision;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::fixed;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::streamsize;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> f1 = <span class="number">1000.00</span>;</span><br><span class="line">    <span class="keyword">float</span> f2 = <span class="number">3.14800</span>;</span><br><span class="line">    <span class="keyword">float</span> f3 = <span class="number">0.03148</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// return the current precision</span></span><br><span class="line">    streamsize prec1 = <span class="built_in">cout</span>.precision();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set precision to 2</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; setprecision(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set precision to 3, return previous value</span></span><br><span class="line">    streamsize prec2 = <span class="built_in">cout</span>.precision(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the outputs should have three decimal digits</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; f1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reset precision value to its previous value</span></span><br><span class="line">    <span class="built_in">cout</span>.precision(prec2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the outputs should have two decimal digits</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; f1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reset the the initial precision value</span></span><br><span class="line">    <span class="built_in">cout</span>.precision(prec1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; f1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check the original value of precision</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The origin precision value is: "</span> &lt;&lt; prec1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The comments show the expected results according to that </p>
<ol>
<li><strong>streamsize precision()</strong> returns the the value of the current floating-point precision.</li>
<li><strong>streamsize precision(int n)</strong> sets the precision to a new value.</li>
</ol>
<p>The program gives result as I expected</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1000.000</span><br><span class="line">3.148</span><br><span class="line">0.031</span><br><span class="line"></span><br><span class="line">1000.00</span><br><span class="line">3.15</span><br><span class="line">0.03</span><br><span class="line"></span><br><span class="line">1000.000000</span><br><span class="line">3.148000</span><br><span class="line">0.031480</span><br><span class="line"></span><br><span class="line">The origin precision value is: 6</span><br></pre></td></tr></table></figure>
<h1 id="Return-to-while-statement"><a href="#Return-to-while-statement" class="headerlink" title="Return to while statement"></a>Return to while statement</h1><p>Let’s get back to the example. The statements in the function body begin with writing a greeting as illustrated in previous chapters. Then, it reads two values into two variables <strong>midterm</strong> and <strong>final</strong>. The input operations can be chained as</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cin</span> &gt;&gt; midterm &gt;&gt; <span class="keyword">final</span>;</span><br></pre></td></tr></table></figure>
<p>This statement is equivalent to</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cin</span> &gt;&gt; midterm;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; <span class="keyword">final</span>;</span><br></pre></td></tr></table></figure>
<p>The next statement shows a new form of writing string literals. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter all your homework grades, "</span></span><br><span class="line">        <span class="string">"followed by end-of-file: "</span>;</span><br></pre></td></tr></table></figure>
<p>It seems that two string lterals will be written, but in fact it has the same effect as the following statement</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter all your homework grades, followed by end-of-file: "</span>;</span><br></pre></td></tr></table></figure>
<p>This is because two or more string literals separated only by whitespace are concatenated automatically. </p>
<p>What closely follow is the while loop. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a variable into which to read</span></span><br><span class="line"><span class="keyword">double</span> x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// invariant: we have read count grades so far, and sum is the sum of the first count grades</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; x)</span><br><span class="line">&#123;</span><br><span class="line">    ++count;</span><br><span class="line">    sum += x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>count</strong> is defined for counting the number of inputs as well as describing the loops. <strong>sum</strong> is defined for holding the summation of homework grades. Note that it is initialized with an int value 0 though it is a double type variable. Therefore, the int value will be converted automatically to double type with the fractional part of 0. </p>
<p>Since the number of homework grades is unkonwn, we could not use the while loop as before as we don’t know the number of loops. The <strong>while loop</strong> here makes it available to input multiple times continuously. As we know, the condition in a while loop should yield a value of bool, that is, true or false, otherwise the value (if available) will be converted to the type of bool. According to Koenig and Moo (2000), <em>the <strong>istream</strong> class provides a conversion that can be used to convert <strong>cin</strong> to a value that can be used in a condition</em>. <em>In addition, the value depends on the iternal state of the <strong>istream</strong> object, which will remember whether the last attempt to read worked</em>. Hence, the <strong>cin &gt;&gt; x</strong> will theoretically always yield a true value as long as we keep inputing right type values. In this example, it reminds us to send “EOF” signal, which will change the value to false, to stop the loop. </p>
<h1 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h1><p>The example above shows how to compute an average value of a batch of data. In reality, the goal is probably to compute the median, or other statistics in the data. However, the inputted data are not stored in above program and hence are unavailable to access. Naturally, the first step is to store the data and the second step is to access or compute the target value via algorithms. Now we learn how to deal with these problems with <strong>vector</strong>. </p>
<h2 id="Defining-and-Initializing-vectors"><a href="#Defining-and-Initializing-vectors" class="headerlink" title="Defining and Initializing vectors"></a>Defining and Initializing <strong>vector</strong>s</h2><p>The vector is a <strong>class template</strong>. Before using the vector in a program, we need to include the header and qualify the name either explicitly or using <em>using declaration</em>. For example</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span></span><br></pre></td></tr></table></figure>
<p>A <strong>vector</strong> is a container that holds a sequence  of objects of the same type. The syntax of creating a vector is</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;T&gt; name; <span class="comment">// default initialization</span></span><br></pre></td></tr></table></figure>
<p>The <strong>name</strong>  is the template name. The <strong>T</strong> insides the angle brackets represents the type of the contained objects. It could be built-in types like <strong>int</strong>, <strong>char</strong>, or class types such as <strong>string</strong>, or even <strong>vector</strong> which means that the element contained in this vector is also a vector. </p>
<p>The vector template defines how to initialze vectors. When a vector is defalut initialized, it has no elements, which creats an empty <strong>vector</strong>. We can also initialize <strong>vector</strong>s using copy initialization or direct initialization or list initialization (see the table below).</p>
<table>
<thead>
<tr>
<th align="left">Ways to initialize a vector</th>
<th align="left">reference: Lippman etc. 2012</th>
</tr>
</thead>
<tbody><tr>
<td align="left">vector<T> v1</td>
<td align="left">default initialization and creat an empty vector</td>
</tr>
<tr>
<td align="left">vector<T> v2(v1)</td>
<td align="left">copy all elements in v1 to v2</td>
</tr>
<tr>
<td align="left">vector<T> v2 = v1</td>
<td align="left">has same effect as the last one</td>
</tr>
<tr>
<td align="left">vector<T> v3(n, val)</td>
<td align="left">direct initialization with n elements of the same value val</td>
</tr>
<tr>
<td align="left">vector<T> v4(n)</td>
<td align="left">v4 has n copies of value-initialized object</td>
</tr>
<tr>
<td align="left">vector<T> v5{a, b, c}</td>
<td align="left">v5 has three elements initialized with initializers a, b, c respectively</td>
</tr>
<tr>
<td align="left">vector<T> v5 = {a, b, c}</td>
<td align="left">has same effect as the last one</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<p>What new usage here is the value-initialization</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;T&gt; <span class="title">v4</span><span class="params">(n)</span></span></span><br></pre></td></tr></table></figure>
<p>The <strong>n</strong> here only provide the number of elements that will be contained in the <strong>vector</strong>. But there is no initializers provided. In this case, all elements will be initialized following the principle of default initialization determined by the type of the elements. For example</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// 10 elements will be initialized with 0</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">v2</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// 10 elements will be initialized to empty string type objects</span></span><br></pre></td></tr></table></figure>
<p>If the type of the contained elements does’t support default initialization, the initialization of the vector would be failure. </p>
<p>In addition, it is worth noting the difference between </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>)    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>and </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(<span class="number">2</span>)    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2&#123;<span class="number">10</span>&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(<span class="number">3</span>)    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">10</span>, <span class="number">1</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>and</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(<span class="number">4</span>)    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v4&#123;<span class="number">10</span>, <span class="number">1</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>The first one is value-initialization as explained above while the second is list initialization with initializer 10. The third one is direct initialization with value 1 and the total number of elements is 10. The fourth one is list initialization with initializers 10 and 1, and the total number of elements is 2.</p>
<p>However, there exist some special cases</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(<span class="number">5</span>)    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">v5</span><span class="params">(<span class="string">"hello"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">(<span class="number">6</span>)    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v6&#123;<span class="number">10</span>&#125;; <span class="comment">// 10 value-initialized elements</span></span><br></pre></td></tr></table></figure>
<p>Example (5) is incorrect as we can not copy the string lterals to a vector. Example (6) is correct but has the same effect as example (1) rather than list initialization. This is because 10 can not be used to initialize an element of string type, instead it can be used to initialize the vector with 10 value-initialized <strong>string</strong>s. </p>
<p>Now returing to the beigining of this post, I’ll define a vector for the purpose of holding all homework grades.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> x;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; homework;</span><br></pre></td></tr></table></figure>
<h2 id="Operations-on-vectors"><a href="#Operations-on-vectors" class="headerlink" title="Operations on vectors"></a>Operations on <strong>vector</strong>s</h2><h3 id="Reading-the-elements"><a href="#Reading-the-elements" class="headerlink" title="Reading the elements"></a>Reading the elements</h3><p>One feature of a vector is that it has variable size, which is particularly helpful for us when the number of elements is unknown. The member function <strong>push_back</strong> can add a new element at the end of the vector after the current last element. The usage is shown below</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; x)</span><br><span class="line">&#123;</span><br><span class="line">    homework.push_back(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The x is passed as an argument and its value is copied to the new element. As a result, the size of the vector <strong>homework</strong> is increased by 1.  </p>
<h3 id="Implementing-algorithms"><a href="#Implementing-algorithms" class="headerlink" title="Implementing algorithms"></a>Implementing algorithms</h3><p>Now all data have been stored into a vector. Assuming the goal of the program is to compute the median of the data set. It is known that the median value depends on the number of the stored elements (i.e. the size of the vector). </p>
<ol>
<li>if there exist an odd number of numbers, the median value is the value of the middle number. </li>
<li>if there exist an even number of numbers, there is no single middle number and the median value is the average value of two middle numbers.  </li>
</ol>
<p>For a program, we also need to consider the case of no elements.</p>
<ol start="3">
<li>if there is no elements at present, throwing a warning and asking to input again.</li>
</ol>
<p>Similar as a string, the size of a vector can be obtained through its member function <strong>size</strong>. For example, homework.size() returns the size of the vector. The returned value has a type of <strong>vector<T>::size_type</strong>. Now we can translate above conditions to real code</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// obtain the size of homework</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;::size_type vec_size;</span><br><span class="line">vecsize <span class="built_in">size</span> = homework.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">size</span> == <span class="number">0</span>)</span><br><span class="line">&#123;   <span class="built_in">cout</span> &lt;&lt; <span class="string">"You must enter your grades. "</span></span><br><span class="line">            <span class="string">"Please try again."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// return 1 instead of 0 to indicate failure </span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span> % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// compute median</span></span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    <span class="comment">// compute median</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Note that an alternative for the condition <strong>size == 0</strong> is the <strong>empty</strong> function which returns true if vector is empty else returns false. The usage is the same as that for <strong>string</strong>s.</p>
<h4 id="Type-Aliases"><a href="#Type-Aliases" class="headerlink" title="Type Aliases"></a>Type Aliases</h4><p>For convenience, we uses <strong>type alias</strong> instead of using <strong>vector<double>::size_type</strong> directly in defining variables of such type. A <strong>type alias</strong> defines the name <strong>vec_size</strong> as a synonym for <strong>vector<double>::size_type</strong>. There are two ways to define type alias</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(1)    typedef double length; &#x2F;&#x2F; length is a synonym for double</span><br><span class="line"></span><br><span class="line">(2)    using length &#x3D; double; &#x2F;&#x2F; length is a synonmy for double</span><br></pre></td></tr></table></figure>
<p>The second method is the new feature of new standards c++2011.</p>
<h4 id="sort-function"><a href="#sort-function" class="headerlink" title="sort function"></a>sort function</h4><p>Now the rest of the work is to find the median and basically speaking, is to sort the data set. This can be done by using a library algoritm.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line">... <span class="comment">// other code </span></span><br><span class="line">sort(homework.<span class="built_in">begin</span>(), homework.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>
<p>The <strong>sort</strong> function is defined in the library <strong>algorithm</strong> and therefore the header is added. It sorts the values in a container in an nondecreasing order. The arguments to <strong>sort</strong> specify the range of the data to be sorted. <strong>begin</strong> and <strong>end</strong> are member functions of the vector and represents the first element and (one past)the last element in <strong>homework</strong> respectively.<br>They are <strong>iterators</strong> and will further discussed in chapter 6.</p>
<p>After we obtained a ordered sequence of values, now I illustrate how to determine the median value.<br><img src="/images/even.png" alt="If size is an even number"></p>
<p>Similar as a string, we can access individual elements using <strong>subscript operator</strong>([]) and the index uses an asymmetrical range from 0 to the size of <strong>homework</strong> (excluded). If the size of <strong>homework</strong> is an even number, then size is exactly devided by 2. Due to the index starts from 0 ranther than 1, the mid elements should be <strong>homework[size/2 - 1]</strong> and <strong>homework[size/1]</strong>. Therefore, the median value is the average of the corresponding two values. As shown in above graph, the number of elements of both sides equals to <strong>size/2</strong> because</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">left side:  number &#x3D; size&#x2F;2 - 1 - 0 + 1 &#x3D; size&#x2F;2</span><br><span class="line">right side: number &#x3D; size - 1 - size&#x2F;2 + 1 &#x3D; size&#x2F;2</span><br></pre></td></tr></table></figure>
<p>If size is an odd number, the result of <strong>size/2</strong> is in fact the value of <strong>(size-1)/2</strong>. Then the mid element is exact the <strong>homework[(size-1)/2]</strong> as both sides of this element has same number of elements(as shown in below graph).  This can also be verified mathematically</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">left side:  number &#x3D; (size-1)&#x2F;2 - 1 - 0 + 1 &#x3D; (size-1)&#x2F;2</span><br><span class="line">right side: number &#x3D; size - 1 - &#123;(size-1)&#x2F;2 + 1&#125; + 1 &#x3D; (size-1)&#x2F;2;</span><br></pre></td></tr></table></figure>
<p><img src="/images/odd.png" alt="If size is an odd number"></p>
<p>Now let’s translate the algorithms to real code</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&#123; </span><br><span class="line">   vec_sz mid = <span class="built_in">size</span>/<span class="number">2</span>;</span><br><span class="line">   <span class="keyword">double</span> median;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">size</span> % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        median = (homework[mid] + homework[mid<span class="number">-1</span>])/<span class="number">2.0</span>;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">        median = homework[mid] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>Note that when calculate the average of two mid elements, I divide by 2.0 rather than 2 for the purpose of avoiding the loss of precision.This is because the quotient of two integers will be an integer.</em></strong></p>
<h4 id="The-conditional-or-ternary-operator"><a href="#The-conditional-or-ternary-operator" class="headerlink" title="The conditional (or ternary) operator"></a>The conditional (or ternary) operator</h4><p>An alternative statements for above <strong>if-else</strong> clause is to use the conditional (or ternary) operator (?:). The syntax is</p>
<pre><code>(condition 1) ? expression 1 : expression 2</code></pre><p>It means that if condition 1 evaluates to true, then expression 2 is evaluated, and if condition 1 evaluates to false, then expression 3 is evaluated instead.</p>
<p>Therefore, we can change above code as</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&#123; </span><br><span class="line">   vec_sz mid = <span class="built_in">size</span>/<span class="number">2</span>;</span><br><span class="line">   <span class="keyword">double</span> median;</span><br><span class="line">   </span><br><span class="line">   median =  <span class="built_in">size</span> % <span class="number">2</span> == <span class="number">0</span>) ? (homework[mid] + homework[mid<span class="number">-1</span>])/<span class="number">2.0</span> : median = homework[mid];                </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="A-complete-program"><a href="#A-complete-program" class="headerlink" title="A complete program"></a>A complete program</h1><p>Finally, I put all pieces of code together and obtained the complete program. Also, it works well when I test it.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ios&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>; 			<span class="keyword">using</span> <span class="built_in">std</span>::sort;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>; 			<span class="keyword">using</span> <span class="built_in">std</span>::streamsize;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;			<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::setprecision; 	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ask for and read the student's name</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Please enter your first name: "</span>;</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; name;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, "</span> &lt;&lt; name &lt;&lt; <span class="string">"!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ask for and read the midterm and final grades</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Please enter your midterm and final grades: "</span>;</span><br><span class="line">    <span class="keyword">double</span> midterm, <span class="keyword">final</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; midterm &gt;&gt; <span class="keyword">final</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ask for the student entered some homework grades</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter all your homework grades, "</span></span><br><span class="line">            <span class="string">"followed by end-of-file: "</span>;</span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; homework;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; x)</span><br><span class="line">        homework.push_back(x);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check that the student entered homework grades</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;::size_type vec_size;</span><br><span class="line">    vec_size <span class="built_in">size</span> = homework.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span> == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"You must enter your grades. "</span></span><br><span class="line">                <span class="string">"Please try again."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sort the grades</span></span><br><span class="line">    sort(homework.<span class="built_in">begin</span>(), homework.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// compute the median homework grade</span></span><br><span class="line">    vec_size mid = <span class="built_in">size</span>/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">double</span> median;</span><br><span class="line">    median = <span class="built_in">size</span> % <span class="number">2</span> == <span class="number">0</span> ? (homework[mid] + homework[mid - <span class="number">1</span>])/<span class="number">2</span></span><br><span class="line">            : homework[mid];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// compute and write the final grade</span></span><br><span class="line">    streamsize prec = <span class="built_in">cout</span>.precision();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Your final grade is "</span> &lt;&lt; setprecision(<span class="number">3</span>)</span><br><span class="line">        &lt;&lt; <span class="number">0.2</span> * midterm + <span class="number">0.4</span> * <span class="keyword">final</span> + <span class="number">0.4</span> * median</span><br><span class="line">        &lt;&lt; setprecision(prec) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Test and results:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Please enter your first name: Bruce</span><br><span class="line">Hello, Bruce!</span><br><span class="line">Please enter your midterm and final grades: 80 90</span><br><span class="line">Enter all your homework grades, followed by end-of-file: 50 60 70 80 90</span><br><span class="line">Your final grade is 80</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Notes</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ - Built-in types and expressions</title>
    <url>/2018/03/02/C-Built-in-types-and-expressions/</url>
    <content><![CDATA[<h1 id="Arithmetic-types"><a href="#Arithmetic-types" class="headerlink" title="Arithmetic types"></a>Arithmetic types</h1><table>
<thead>
<tr>
<th align="left">Arithmetic types in C++</th>
<th align="left"></th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">Type</td>
<td align="left">Meaning</td>
<td align="left">Minimum size</td>
</tr>
<tr>
<td align="left">bool</td>
<td align="left">boolean</td>
<td align="left">NA</td>
</tr>
<tr>
<td align="left">char</td>
<td align="left">character</td>
<td align="left">8bits</td>
</tr>
<tr>
<td align="left">wchar_t</td>
<td align="left">wide character</td>
<td align="left">16bits</td>
</tr>
<tr>
<td align="left">char16_t</td>
<td align="left">Unicode character</td>
<td align="left">16bits</td>
</tr>
<tr>
<td align="left">char32_t</td>
<td align="left">Unicode character</td>
<td align="left">32bits</td>
</tr>
<tr>
<td align="left">short</td>
<td align="left">short integer</td>
<td align="left">16bits</td>
</tr>
<tr>
<td align="left">int</td>
<td align="left">integer</td>
<td align="left">16bits</td>
</tr>
<tr>
<td align="left">long</td>
<td align="left">long integer</td>
<td align="left">32bits</td>
</tr>
<tr>
<td align="left">long long</td>
<td align="left">long integer</td>
<td align="left">64bits</td>
</tr>
<tr>
<td align="left">float</td>
<td align="left">single-precision floating-point</td>
<td align="left">6 significant digits</td>
</tr>
<tr>
<td align="left">double</td>
<td align="left">double-precision floating-point</td>
<td align="left">10 significant digits</td>
</tr>
<tr>
<td align="left">long double</td>
<td align="left">extended-precision floating-point</td>
<td align="left">10 significant digits</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Notes</tag>
      </tags>
  </entry>
  <entry>
    <title>Accelerated C++ Solutions to Exercises (Chapter 2 Part3)</title>
    <url>/2018/03/01/Accelerated-C-Solutions-to-Exercises-Chapter-2-Part3/</url>
    <content><![CDATA[<h1 id="Exercise-2-6"><a href="#Exercise-2-6" class="headerlink" title="Exercise 2-6"></a>Exercise 2-6</h1><p>What does the following code do?</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">    i += <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Solution-amp-Results"><a href="#Solution-amp-Results" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>The program writes 10 rows of numbers, starting from 1 to 10.</p>
<p>The <strong>while statement</strong> starts from testing the condition and then executes the <strong>while body</strong> if the <strong>condition</strong> is true. It stops executing the while body until the condition becomes false. Let’s analyse the first iteration</p>
<ul>
<li>First, the condition of the first time iteration is true as <strong>0 &lt; 10</strong> is true. </li>
<li>Second, the expression <strong>i += 1;</strong> is evaluated, and the variable <strong>i</strong> becomes 1 after the execution. </li>
<li>then, the following statement is executed and the variable <strong>i</strong> is written on the output device. </li>
<li>finally, the while loop starts all over again from testing the condition.</li>
</ul>
<p>From above steps we have seen that</p>
<ul>
<li>the first number to output is 1. </li>
<li><strong>i</strong> is increased by 1 each iteration.</li>
</ul>
<p>Accordingly, the final iteration can be deducted</p>
<ul>
<li>when <strong>i</strong> = 9, the row of output is 9 and the condition is still true.</li>
<li>after the evaluation of <strong>i += 1;</strong>, <strong>i</strong> equals 10.</li>
<li>then the output is 10 in the following step.</li>
<li>the <strong>while statement</strong> starts again and tests the condition, but the condition <strong>10 &lt; 10</strong> is false. </li>
<li>the <strong>while statement</strong> finishes.</li>
</ul>
<p>Now I complete the program and test it</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; <span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>As expected, it writes 10 rows of outputs from 1 to 10 with one number in each row. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<p>Note that the cursor appears on the next line of the final number 10 due to the following manipulator <strong>endl</strong>.</p>
<p>We can also explain the program from the perspective of its goal. Condiser that, we want the program to print out 10 rows, each of which contains a number, starting from 1 to 10 orderly. The loop invariant can be expressed as: <em>we have written i rows now and the number in current row is i</em>. To verify the loop invariant, we need to verify it at two specific points:</p>
<ol>
<li>the first point is before the first time that the condition is evaluated. In this case, it is correct as there is 0 output at current position.</li>
<li>the second point is before the end of the while body. Once the first statement is executed, <strong>i</strong> is increased by 1. To maintain the loop invariant, it needs writing a row which contains the number <strong>i</strong>. Therefore, the loop statement works as expected in each iteration. </li>
</ol>
<p>For clarity, I add comments for the program</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">// loop invariant: we have written i rows now and the number in current row is i</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; <span class="number">10</span>)</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="comment">// i changes with increment of 1</span></span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// to maintain the loop invariant, write 1 row</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><p>See deatiled analysis in <a href="http://quanttour.com/23/02/2018/C-Looping-and-counting/" target="_blank" rel="noopener">C++ - Looping and counting</a>.</p>
<hr>
<h1 id="Exercise-2-7"><a href="#Exercise-2-7" class="headerlink" title="Exercise 2-7"></a>Exercise 2-7</h1><p>Write a program to count down from 10 to -5.</p>
<h2 id="Solution-amp-Results-1"><a href="#Solution-amp-Results-1" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>This exercise is similar to the program in the last exercise. There are 16 numbers in total and hence there should be overal 16 loop times. Naturally, we use the range [0, 16) to describe the loop statements. The loop invariant can be expressed as <em>we have written i rows and the number that written in this row is j</em>. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">// The loop invariant can be expressed as we have  </span></span><br><span class="line">    <span class="comment">// written i rows and the number written in this row is j. </span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; <span class="number">16</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// write a row of outputs</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// to maintain the loop invariant, increase the value of i by adding 1</span></span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>What is the value of <strong>j</strong>? As mentioned above, the loop invariant needs to be verified at two specific points. First, before the first time that the condition is evaluated, we have written 0 rows. Second, before the end of the while body, we have written 1 row and the number should be 10. Therefore, the inital value of <strong>j</strong> should be 10. It is still not clear now. I’ll further verify the loop invariant in the second and third iteration. </p>
<p>The second iteration:</p>
<ul>
<li>before the the condition is evaluated, the loop invariant is correct as currently there is one row and the output is 10. </li>
<li>before the end of the while body, <strong>i</strong> increases by 1. The number to output is 9. To maintain the loop invariant, j should be decreased by 1. </li>
</ul>
<p>The third iteration:</p>
<ul>
<li>before the the condition is evaluated, the loop invariant is correct as currently there are 2 rows and the second output is 9. </li>
<li>before the end of the while body, <strong>i</strong> increases by 1. The number to output is 8. To maintain the loop invariant, j should be decreased by 1. </li>
</ul>
<p>It has been seen from above descriptions, each iteration <strong>i</strong> changes with increment by 1 while <strong>j</strong> changes with decrement by 1. Therefore, the sum of <strong>i</strong> and <strong>j</strong> should be constant, and hence <strong>j = 10 - i</strong> as <strong>j</strong> has initial value 10. In other words, the loop invariant is <strong>i + j = 10</strong>, of which the <strong>i</strong> represents the row number and <strong>j</strong> represents the number contained in the <strong>i</strong> row of outputs. </p>
<p>Accordingly, the complete program is</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// loop invariant: we have written i rows and the number </span></span><br><span class="line">    <span class="comment">// written in this row is j = 10-i.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; <span class="number">16</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// write a row of outputs</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; j &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// to maintain the loop invariant, increase the value </span></span><br><span class="line">        <span class="comment">// of i by adding 1, change the value o j to 10 - i</span></span><br><span class="line">        ++i;</span><br><span class="line">        j = <span class="number">10</span> -i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The program works as expected with following outputs</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">9</span><br><span class="line">8</span><br><span class="line">7</span><br><span class="line">6</span><br><span class="line">5</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">-1</span><br><span class="line">-2</span><br><span class="line">-3</span><br><span class="line">-4</span><br><span class="line">-5</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Exercise-2-8"><a href="#Exercise-2-8" class="headerlink" title="Exercise 2-8"></a>Exercise 2-8</h1><p>Write a program to generate the product of the numbers in the range [1, 10).</p>
<h2 id="Solution-amp-Results-2"><a href="#Solution-amp-Results-2" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>The product of the numbers in the range [1, 10) is </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 x 2 x 3 x 4 x 5 x 6 x 7 x 8 x 9</span><br></pre></td></tr></table></figure>
<p>Essentially, it is a factorial of number 9. I can transform above expression as </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">9! &#x3D; 1 x 2 x 3 x ... x 8 x 9</span><br></pre></td></tr></table></figure>
<p>or </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">9! &#x3D; 9 x 8!</span><br></pre></td></tr></table></figure>
<p>Therefore, the calculation can be designed as a loop statement containing 8 times loops. In each iteration, we calculate the factorial of a number from 2 till 9. The loop invariant is that <em>we have calculated the factorial <strong>i</strong> times and the number <strong>f</strong></em>. I’ll use the range [0, 8) to count the loops. The complete program is shown as below</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> product = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// we have calculated the factorial i times and the number is f</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != <span class="number">8</span>; ++i)</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="comment">// increase the value of f by 1</span></span><br><span class="line">        ++f;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// to maintain the loop invariant, calculate the factorial of number f</span></span><br><span class="line">        product *= f;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; product &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The results is </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">362880</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Exercise-2-9"><a href="#Exercise-2-9" class="headerlink" title="Exercise 2-9"></a>Exercise 2-9</h1><p>Write a program that asks the user to enter two numbers and tells the user which number is larger than the other.</p>
<h2 id="Solution-amp-Results-3"><a href="#Solution-amp-Results-3" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>It’s a simple exercise, and I’ll skip analysis and present the program directly</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Please enter two integers: "</span>;</span><br><span class="line">    <span class="comment">// read two numbers</span></span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a == b)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">" equals to "</span>  &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a &gt; b)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">" is greater than "</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a &lt; b)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; b &lt;&lt; <span class="string">" is greater than "</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Test 1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Please enter two numbers: 5 8</span><br><span class="line">8 is greater than 5</span><br></pre></td></tr></table></figure>
<p><strong>Test 2</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Please enter two numbers: 4 2</span><br><span class="line">4 is greater than 2</span><br></pre></td></tr></table></figure>
<p><strong>Test 3</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Please enter two numbers: 100 100</span><br><span class="line">100 equals to 100</span><br></pre></td></tr></table></figure>
<h1 id="Exercise-2-10"><a href="#Exercise-2-10" class="headerlink" title="Exercise 2-10"></a>Exercise 2-10</h1><p>Explain each of the uses of std:: in the following program:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k =  <span class="number">0</span>;    </span><br><span class="line">    <span class="keyword">while</span> (k != <span class="number">5</span>) </span><br><span class="line">    &#123;         </span><br><span class="line">        <span class="comment">// invariant: we have written k asterisks so far      </span></span><br><span class="line">        <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;        </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"*"</span>;        </span><br><span class="line">        ++k;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;      </span><br><span class="line">    <span class="comment">// std:: is required here    </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Solution-amp-Results-4"><a href="#Solution-amp-Results-4" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>The first <strong>std::</strong> in line 9</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br></pre></td></tr></table></figure>
<p>The using declaration qualify us to use the name <strong>cout</strong>, which is defined in the namespace <strong>std</strong>, directly instead of <strong>std::cout</strong>. However, the declaration is only valid within the block of the <strong>while statement</strong> as the curly braces form a name scope. </p>
<p>This also explains the requirements of the <strong>std::</strong> in line 13. If one want to use the unqualified <strong>cout</strong>, <strong>endl</strong> inside the main function body, he should write the <em>using declarations</em> for each different <strong>name</strong> before the start of the main function. For example</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k =  <span class="number">0</span>;    </span><br><span class="line">    <span class="keyword">while</span> (k != <span class="number">5</span>) </span><br><span class="line">    &#123;         </span><br><span class="line">        <span class="comment">// invariant: we have written k asterisks so far      </span></span><br><span class="line">        <span class="comment">// using std::cout - is not required now     </span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"*"</span>;        </span><br><span class="line">        ++k;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;      </span><br><span class="line">    <span class="comment">// std:: is not required now  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Now, both programs work well and give the results</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*****</span><br></pre></td></tr></table></figure>
<h2 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h2><p>See <a href="http://quanttour.com/02/02/2018/C++%20-%20Getting%20Started/" target="_blank" rel="noopener">C++ - Getting Started</a>. </p>
<hr>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p>Koenig, A. and Moo, B.E., 2000. Accelerated C++.</p>
<p>Lippman, S.B., Lajoie, J. and Moo, B.E., 2013. C++ Primer, 5th edt.</p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Accelerated C++ Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title>Accelerated C++ Solutions to Exercises (Chapter 2 Part2)</title>
    <url>/2018/02/25/Accelerated-C-Solutions-to-Exercises-Chapter-2-Part2/</url>
    <content><![CDATA[<h1 id="Exercise-2-4"><a href="#Exercise-2-4" class="headerlink" title="Exercise 2-4"></a>Exercise 2-4</h1><p>The framing program writes the mostly blank lines that seperate the borders from the greeting one character at a time. Change the program so that it writes all the spaces needed in a single output expression.</p>
<h2 id="Solution-amp-Results"><a href="#Solution-amp-Results" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>Without considering the frame itself, there only exist two types of row. The first type is the rows that full of spaces. The second type is the row that contains the <strong>greeting</strong> and spaces symmetricly located on two sides of the <strong>greeting</strong>. Therefore, one of the possible solutions is to write one row directly each time instead of writing one character. First, I defines two variables representing two blank strings</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">   <span class="comment">// two blank strings containing different number of spaces</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">string</span> <span class="title">blankStringTopBottom</span><span class="params">(cols - <span class="number">2</span>, <span class="string">' '</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">string</span> <span class="title">blankStringLeftRight</span><span class="params">(pad, <span class="string">' '</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>The first string is in fact the first type of row and can be written directly given certain conditions. The second row can be obtained by means of catenate operations</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">   <span class="comment">// the string that contains both the greeting and blanks</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> greetingRow = blankStringLeftRight + greeting +                             blankStringLeftRight;</span><br></pre></td></tr></table></figure>
<p>To maintain the <strong>loop invariant</strong>, the <strong>c</strong> need to be adjusted after each output. Due to one row is written each time (ignoring the borders),  <strong>c</strong> increases <strong>cols - 1</strong> every time.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c += cols - <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>The modified program is</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// using namespace std and names</span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>; <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ask for the person's name</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Please enter your first name: "</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read the name</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// build the message that we intend to write</span></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">string</span> greeting = <span class="string">"Hello, "</span> + name + <span class="string">"!"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the number of blanks surrounding the greeting</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> pad = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the number of rows and columns</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> rows = pad * <span class="number">2</span> + <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">string</span>::size_type cols = greeting.<span class="built_in">size</span>() + pad * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// two blank strings containing different number of spaces</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="built_in">string</span> <span class="title">blankStringTopBottom</span><span class="params">(cols - <span class="number">2</span>, <span class="string">' '</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="built_in">string</span> <span class="title">blankStringLeftRight</span><span class="params">(pad, <span class="string">' '</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the string that contains both the greeting and blanks</span></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">string</span> greetingRow = blankStringLeftRight + greeting + blankStringLeftRight;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// write a blank line to separate the output from the input</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write rows rows of output</span></span><br><span class="line">    <span class="comment">// invariant: we have written r rows so far</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r != rows; ++r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span>::size_type c = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// we have written c characters so far in the current row</span></span><br><span class="line">        <span class="keyword">while</span> (c != cols)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// are we on the border?</span></span><br><span class="line">            <span class="keyword">if</span> (r == <span class="number">0</span> || r == rows - <span class="number">1</span> ||</span><br><span class="line">                c == <span class="number">0</span> || c == cols - <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"*"</span>;</span><br><span class="line">                ++c;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;   <span class="comment">// is it time to write the greeting row?</span></span><br><span class="line">                <span class="keyword">if</span> (r == pad + <span class="number">1</span>)</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; greetingRow;</span><br><span class="line">                <span class="comment">// is it time to write the non-greeting rows?</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; blankStringTopBottom;</span><br><span class="line">                c += cols - <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>A simple test has been done and the outputs are written on the console window as below</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Please enter your first name: Bruce</span><br><span class="line"></span><br><span class="line">*****************</span><br><span class="line">*               *</span><br><span class="line">* Hello, Bruce! *</span><br><span class="line">*               *</span><br><span class="line">*****************</span><br></pre></td></tr></table></figure>
<h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><p>See deatiled analysis in <a href="http://quanttour.com/23/02/2018/C-Looping-and-counting/" target="_blank" rel="noopener">C++ - Looping and counting</a>.</p>
<hr>
<h1 id="Exercise-2-5"><a href="#Exercise-2-5" class="headerlink" title="Exercise 2-5"></a>Exercise 2-5</h1><p>Write a set of “*” characters so that they form a square, a rectangle, and a triangle.</p>
<h2 id="Solution-amp-Results-1"><a href="#Solution-amp-Results-1" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><h3 id="The-design-ideas"><a href="#The-design-ideas" class="headerlink" title="The design ideas"></a>The design ideas</h3><p>The correct program for this exercise is non-unique as the requirements are loose. It doesn’t specify the details of each shape. I tried to design a program that is flexible enough to meet more needs and preferences. For example, users may ask the program to write various rectangles (or squares/triangles) with different lengths or different appearance such as solid or hollow shapes. In summary, I intend to design a program with following properties</p>
<ol>
<li>provide choices for three types of shapes, i.e. <strong>square</strong>, <strong>rectangle</strong> and <strong>triangle</strong>.</li>
<li><ul>
<li>for a <strong>square</strong>, the length of the side is customizable</li>
<li>for a <strong>rectangle</strong>, the length and the width are customizable, and the base can be the long side or the short side.</li>
<li>for a <strong>triangle</strong>, the height is customizable and the <strong>triangle</strong> is a equilateral triangle.</li>
</ul>
</li>
<li>for all shapes, there are two types of appearance: solid and hollow.</li>
</ol>
<h3 id="The-Primary-Structure"><a href="#The-Primary-Structure" class="headerlink" title="The Primary Structure"></a>The Primary Structure</h3><p>Due to there are three types of shape, we can use <strong>if else statement</strong> as one of the choices of the primary structure and provide three banches for the three shapes. First, flags are needed for indicating what shape type is to be written. For example:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* flags for what shape to print</span></span><br><span class="line"><span class="comment"> *  shapeType == 1, print a square shape</span></span><br><span class="line"><span class="comment"> *  shapeType == 2, print a rectangle shape</span></span><br><span class="line"><span class="comment"> *  shapeType == 3, print a triangle shape </span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>In addition, each type of shape can be a solid shape or hollow shape. Therefore, a choice for the appearance will be provided for users before the computer enters into each branch. For other properties, such as lengths of sides and heights, are not the same for each types of shape and will be solved in the branches. Therefore, the whole structure of the program is</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// select a shape</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Select a shape type\n"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"1. A Square\n2. A Rectangle\n3. A Triangle\n"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Please enter 1 or 2 or 3: "</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read the shape type</span></span><br><span class="line">    <span class="keyword">int</span> shapeType;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; shapeType;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write a blank line for clarity</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// select appearance</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Do you want a solid shape?\n"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"yes: a solid shape\nno: a hollow shape\n"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Please enter y or n: "</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read the shape appearance</span></span><br><span class="line">    <span class="keyword">char</span> shapeAppearance;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; shapeAppearance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write a blank line for clarity</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (shapeType == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// statements for generating a square </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (shapeType == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// statements for generating a rectangle</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (shapeType == <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// statements for generating a triangles</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Algorithms"><a href="#Algorithms" class="headerlink" title="Algorithms"></a>Algorithms</h3><h4 id="A-square-shape"><a href="#A-square-shape" class="headerlink" title="A square shape"></a>A square shape</h4><p>The core part of the program is how to impelment the algorithms that can generate different shapes. I starts with the implementation of writing a square. Assuming the edge length of the square is 10, the program aims to generate two different squares as follows</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">**********          **********</span><br><span class="line">*        *          **********                  </span><br><span class="line">*        *          **********</span><br><span class="line">*        *          **********</span><br><span class="line">*        *   and    **********</span><br><span class="line">*        *          **********</span><br><span class="line">*        *          **********</span><br><span class="line">*        *          **********</span><br><span class="line">*        *          **********</span><br><span class="line">**********          **********</span><br></pre></td></tr></table></figure>
<p>Note that for all the shapes, the length or height means the number of columns or rows formed by asterisks (and spaces). </p>
<p>The algorithm is similar as that in the <strong>framed greeting</strong> program except that it doesn’t need to write the greeting itself. Essentially, there are two types of string：one is full filled with asterisks and another one is filled by blanks and two asterisks located at both ends of the blanks. The structure could be a for loop or while loop, which is up to your preference. Firstly, I define the variables that are needed.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// read in edge length for a square</span></span><br><span class="line"><span class="keyword">int</span> edgeLength;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; edgeLength;</span><br><span class="line"></span><br><span class="line"><span class="comment">// string variable type 1: full of asterisks</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">asteriskString</span><span class="params">(edgeLength, <span class="string">'*'</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// string variable type 2: blanks and asterisks</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">blankString</span><span class="params">(edgeLength - <span class="number">2</span>, <span class="string">' '</span>)</span></span>;</span><br><span class="line"><span class="built_in">string</span> mixedString = <span class="string">"*"</span> + blankString + <span class="string">"*"</span>;</span><br></pre></td></tr></table></figure>
<p>The solid square shape is simple and only needs one type of the string type vairable. If we choose one of the loop statements, the loop invariant can be expressed as: <em>we have written r rows of output</em>, of which <strong>r</strong> is the counting variable. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// invariant: we have written r rows of output</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r != edgeLength; ++r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// write a row whose length is the edge length</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; asteriskString &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>To maintaint the loop invariant, <strong>r</strong> is increased by 1 after each iteration. Once the for loop finishes, the condition <strong>r != edgeLength</strong> is false and <strong>r = edgeLength</strong>. Then, the loop invariant becomes: we have written <strong>edgeLength</strong> rows of outputs, which keeps the correctness of our loop statement. </p>
<p>For a hollow square shape, the output of each row is conditional on its position. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// is it the first row or last row of outputs?</span></span><br><span class="line"><span class="keyword">if</span> (r == <span class="number">0</span> || r == edgeLength - <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; asteriskString &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; mixedString &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>Now, we can combine two cases together</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">if</span> (shapeType == <span class="number">1</span>)</span><br><span class="line">&#123;   </span><br><span class="line">       <span class="built_in">cout</span> &lt;&lt; <span class="string">"Please enter the edge length: "</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// read the edge length</span></span><br><span class="line">       <span class="keyword">int</span> edgeLength;</span><br><span class="line">       <span class="built_in">cin</span> &gt;&gt; edgeLength;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// write a blank line to separate inputs and outputs</span></span><br><span class="line">       <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// string type 1: full of asterisks</span></span><br><span class="line">       <span class="function"><span class="built_in">string</span> <span class="title">asteriskString</span><span class="params">(edgeLength, <span class="string">'*'</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// string type 2: blanks and asterisks</span></span><br><span class="line">       <span class="function"><span class="built_in">string</span> <span class="title">blankString</span><span class="params">(edgeLength - <span class="number">2</span>, <span class="string">' '</span>)</span></span>;</span><br><span class="line">       <span class="built_in">string</span> mixedString = <span class="string">"*"</span> + blankString + <span class="string">"*"</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r != edgeLength; ++r)</span><br><span class="line">       &#123;   </span><br><span class="line">           <span class="comment">// is it rows of a solid shape or </span></span><br><span class="line">           <span class="comment">// the first/ last row of a hollow shape ?</span></span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (shapeAppearance == <span class="string">'y'</span> || r == <span class="number">0</span> || r == edgeLength - <span class="number">1</span>)</span><br><span class="line">               <span class="comment">// write a row whose length is the edge length</span></span><br><span class="line">               <span class="built_in">cout</span> &lt;&lt; asteriskString &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               <span class="built_in">cout</span> &lt;&lt; mixedString &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="A-rectangle-shape"><a href="#A-rectangle-shape" class="headerlink" title="A rectangle shape"></a>A rectangle shape</h4><p>Square shapes can be regarded as a special case of rectangles. We can simply modify the above algorithm to generate a rectangle. I use <strong>base lenght</strong> and <strong>height</strong> instead of the <strong>length</strong> and <strong>width</strong> for convenience.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (shapeType == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Please enter the base length and height\n"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The base lenght = "</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read the base length</span></span><br><span class="line">    <span class="keyword">int</span> baseLength;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; baseLength;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The height = "</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read the height</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">height</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; <span class="built_in">height</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write a blank line to separate inputs and outputs</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// string type 1: full of asterisks</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">asteriskString</span><span class="params">(baseLength, <span class="string">'*'</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// string type 2: blanks and asterisks</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">blankString</span><span class="params">(baseLength - <span class="number">2</span>, <span class="string">' '</span>)</span></span>;</span><br><span class="line">    <span class="built_in">string</span> mixedString = <span class="string">"*"</span> + blankString + <span class="string">"*"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r != <span class="built_in">height</span>; ++r)</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="comment">// is it rows of a solid shape or </span></span><br><span class="line">        <span class="comment">// the first/ last row of a hollow shape ?</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (shapeAppearance == <span class="string">'y'</span> || r == <span class="number">0</span> || r == <span class="built_in">height</span> - <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; asteriskString &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; mixedString&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="A-triangle-shape"><a href="#A-triangle-shape" class="headerlink" title="A triangle shape"></a>A triangle shape</h4><p>For a triangle, the ideal result is to print out follow two shapes, providing the height is 4.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   *                   *</span><br><span class="line">  ***      and        * *</span><br><span class="line"> *****               *   *</span><br><span class="line">*******             *******</span><br></pre></td></tr></table></figure>
<p>The solid trangle shape is formed only by asterisks ignoring the outer blanks. However, the number of asterisks of each row is different with eachother. From the table below, we can see a pattern in the numbers of asterisks of the rows. </p>
<p>| The <strong>r</strong>th Row| The number of columns of each row |<br>| :—: | :—: | :—: |<br>|0|1|<br>|1|3|<br>|2|5|<br>|3|7|<br>|4|9|<br>|…|…|<br>|r|(r*2 + 1)|<br>|Height|loop finishes|</p>
<p>The table shows that when the program writes the <strong>r</strong>th row, it needs to write asterisks in a total number of <strong>r*2 + 1</strong>.<br>It also shows that the number of columns is <strong>height*2 - 1</strong>.     </p>
<p>For the hollow triangle shapes, there are two types of rows: the first type is rows filled only by asterisks such as the first row and the last row; another type is rows formed by blanks with two asterisks located at both ends of the blanks. The table gives the pattern in the numbers of blanks of the rows. </p>
<p>| The <strong>r</strong>th Row| The number of blanks in each row |<br>| :—: | :—: | :—: |<br>|0|0|<br>|1|1|<br>|2|3|<br>|3|5|<br>|4|7|<br>|…|…|<br>|r|((r-1)*2 + 1)|<br>|Height|loop finishes|</p>
<p>Correspondingly, I define variables inside a for loop as below</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r != <span class="built_in">height</span>; ++r)</span><br><span class="line">&#123;    </span><br><span class="line">    <span class="comment">// is it the row of a solid shape, or the first or the last row of the hollow shape</span></span><br><span class="line">    <span class="keyword">if</span> (shapeAppearance == <span class="string">'y'</span> || r == <span class="number">0</span> || r == <span class="built_in">height</span> - <span class="number">1</span>)</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="comment">// string type 1: full of asterisks</span></span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">asteriskString</span><span class="params">(r*<span class="number">2</span> + <span class="number">1</span>, <span class="string">'*'</span>)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// string type 2: blanks and asterisks</span></span><br><span class="line">        <span class="built_in">string</span> blankString(((r<span class="number">-1</span>)*<span class="number">2</span> + <span class="number">1</span>), <span class="string">' '</span>);</span><br><span class="line">        <span class="built_in">string</span> mixedString = <span class="string">"*"</span> + blankString + <span class="string">"*"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>What we need next is to find the condition for writing each row as each row has different initial position. Before the real start of each row, we only need to output spaces. The table below gives the pattern of the initial column position of each row. </p>
<p>| The <strong>r</strong>th Row| The column number of the initial position |<br>| :—: | :—: | :—: |<br>|height | loop finishes|<br>|height - 1| 0|<br>|height - 2|1|<br>|…|…|<br>|r|height - r - 1|<br>|…|…|<br>|0|height - 1|</p>
<p>The table shows that when the loop processes the column number <strong>height - r - 1</strong>, it starts to write the strings that I defined above. When we incorporate the column loops into the row loops, the program becomes</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (shapeType == <span class="number">3</span>)</span><br><span class="line">&#123;   </span><br><span class="line">    <span class="comment">// read the height</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Please enter the height: "</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">height</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; <span class="built_in">height</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write a blank line to separate inputs and outputs</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// loop invariant: we have written r rows now</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r != <span class="built_in">height</span>; ++r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// loop invariant: we have written c characters so far in the current line</span></span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(c != (<span class="built_in">height</span>*<span class="number">2</span> - <span class="number">1</span>))</span><br><span class="line">        &#123;   <span class="comment">// // is it the row of a solid shape, or the first or the last row of the hollow shape</span></span><br><span class="line">            <span class="keyword">if</span> (shapeAppearance == <span class="string">'y'</span> </span><br><span class="line">                            || r == <span class="number">0</span> </span><br><span class="line">                            || r == <span class="built_in">height</span> - <span class="number">1</span>)</span><br><span class="line">            &#123;   </span><br><span class="line">                <span class="comment">// is it time to write the real row?</span></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="built_in">height</span> - r - <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// string type 1: full of asterisks</span></span><br><span class="line">                    <span class="function"><span class="built_in">string</span> <span class="title">asteriskString</span><span class="params">(r*<span class="number">2</span> + <span class="number">1</span>, <span class="string">'*'</span>)</span></span>;</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; asteriskString;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// maintain the loop invariant</span></span><br><span class="line">                    c += (r*<span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">                    <span class="comment">// maintain the loop invariant</span></span><br><span class="line">                    ++c;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;   </span><br><span class="line">                <span class="comment">// is it time to write the real row?</span></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="built_in">height</span> - r - <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// string type 2: blanks and asterisks</span></span><br><span class="line">                    <span class="built_in">string</span> blankString(((r<span class="number">-1</span>)*<span class="number">2</span> + <span class="number">1</span>), <span class="string">' '</span>);</span><br><span class="line">                    <span class="built_in">string</span> mixedString = <span class="string">"*"</span> + blankString + <span class="string">"*"</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; mixedString;</span><br><span class="line">                    <span class="comment">// maintain the loop invariant</span></span><br><span class="line">                    c += ((r<span class="number">-1</span>)*<span class="number">2</span> + <span class="number">1</span> + <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">                    ++c;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="A-complete-program-and-tests"><a href="#A-complete-program-and-tests" class="headerlink" title="A complete program and tests"></a>A complete program and tests</h3><p>Let’s put all pieces together</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Accelerated C++ Solutions Exercises 2-5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// using namespace std and names</span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>; <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// select a shape</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Select a shape type\n"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"1. A Square\n2. A Rectangle\n3. A Triangle\n"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Please enter 1 or 2 or 3: "</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read the shape type</span></span><br><span class="line">    <span class="keyword">int</span> shapeType;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; shapeType;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write a blank line for clarity</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// select appearance</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Do you want a solid shape?\n"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"yes: a solid shape\nno: a hollow shape\n"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Please enter y or n: "</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read the shape appearance</span></span><br><span class="line">    <span class="keyword">char</span> shapeAppearance;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; shapeAppearance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write a blank line for clarity</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (shapeType == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Please enter the edge length: "</span>;</span><br><span class="line">        <span class="keyword">int</span> edgeLength;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; edgeLength;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// write a blank line to separate inputs and outputs</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// string type 1: full of asterisks</span></span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">asteriskString</span><span class="params">(edgeLength, <span class="string">'*'</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// string type 2: blanks and asterisks</span></span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">blankString</span><span class="params">(edgeLength - <span class="number">2</span>, <span class="string">' '</span>)</span></span>;</span><br><span class="line">        <span class="built_in">string</span> mixedString = <span class="string">"*"</span> + blankString + <span class="string">"*"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r != edgeLength; ++r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (shapeAppearance == <span class="string">'y'</span> || r == <span class="number">0</span> || r == edgeLength - <span class="number">1</span>)</span><br><span class="line">                <span class="comment">// write a row whose length is the edge length</span></span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; asteriskString &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; mixedString &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (shapeType == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Please enter the base length and height\n"</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"The base lenght = "</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// read the base length</span></span><br><span class="line">        <span class="keyword">int</span> baseLength;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; baseLength;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"The height = "</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// read the height</span></span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">height</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; <span class="built_in">height</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// write a blank line to separate inputs and outputs</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// string type 1: full of asterisks</span></span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">asteriskString</span><span class="params">(baseLength, <span class="string">'*'</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// string type 2: blanks and asterisks</span></span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">blankString</span><span class="params">(baseLength - <span class="number">2</span>, <span class="string">' '</span>)</span></span>;</span><br><span class="line">        <span class="built_in">string</span> mixedString = <span class="string">"*"</span> + blankString + <span class="string">"*"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r != <span class="built_in">height</span>; ++r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (shapeAppearance == <span class="string">'y'</span> || r == <span class="number">0</span> || r == <span class="built_in">height</span> - <span class="number">1</span>)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; asteriskString &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; mixedString&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (shapeType == <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Please enter the height: "</span>;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">height</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; <span class="built_in">height</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// write a blank line to separate inputs and outputs</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// loop invariant: we have written r rows now</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r != <span class="built_in">height</span>; ++r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// loop invariant: we have written c characters so far in the current line</span></span><br><span class="line">            <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(c != (<span class="built_in">height</span>*<span class="number">2</span> - <span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (shapeAppearance == <span class="string">'y'</span> || r == <span class="number">0</span> || r == <span class="built_in">height</span> - <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (c == <span class="built_in">height</span> - r - <span class="number">1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// string type 1: full of asterisks</span></span><br><span class="line">                        <span class="function"><span class="built_in">string</span> <span class="title">asteriskString</span><span class="params">(r*<span class="number">2</span> + <span class="number">1</span>, <span class="string">'*'</span>)</span></span>;</span><br><span class="line">                        <span class="built_in">cout</span> &lt;&lt; asteriskString;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// maintain the loop invariant</span></span><br><span class="line">                        c += (r*<span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">                        <span class="comment">// maintain the loop invariant</span></span><br><span class="line">                        ++c;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (c == <span class="built_in">height</span> - r - <span class="number">1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// string type 2: blanks and asterisks</span></span><br><span class="line">                        <span class="built_in">string</span> blankString(((r<span class="number">-1</span>)*<span class="number">2</span> + <span class="number">1</span>), <span class="string">' '</span>);</span><br><span class="line">                        <span class="built_in">string</span> mixedString = <span class="string">"*"</span> + blankString + <span class="string">"*"</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="built_in">cout</span> &lt;&lt; mixedString;</span><br><span class="line">                        <span class="comment">// maintain the loop invariant</span></span><br><span class="line">                        c += ((r<span class="number">-1</span>)*<span class="number">2</span> + <span class="number">1</span> + <span class="number">2</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">                        ++c;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Note that I used the same variables names <strong>asteriskString</strong>, <strong>blankString</strong> and <strong>mixedString</strong> in all three branches, but it does not matter the correctness as each branch is an independent block. I did three tests and the program works as expected. Please see the results below</p>
<p><strong>Test 1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Select a shape type</span><br><span class="line">1. A Square</span><br><span class="line">2. A Rectangle</span><br><span class="line">3. A Triangle</span><br><span class="line">Please enter 1 or 2 or 3: 1</span><br><span class="line"></span><br><span class="line">Do you want a solid shape?</span><br><span class="line">yes: a solid shape</span><br><span class="line">no: a hollow shape</span><br><span class="line">Please enter y or n: y</span><br><span class="line"></span><br><span class="line">Please enter the edge length: 5</span><br><span class="line"></span><br><span class="line">*****</span><br><span class="line">*****</span><br><span class="line">*****</span><br><span class="line">*****</span><br><span class="line">*****</span><br></pre></td></tr></table></figure>
<p><strong>Test 2</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Select a shape type</span><br><span class="line">1. A Square</span><br><span class="line">2. A Rectangle</span><br><span class="line">3. A Triangle</span><br><span class="line">Please enter 1 or 2 or 3: 2</span><br><span class="line"></span><br><span class="line">Do you want a solid shape?</span><br><span class="line">yes: a solid shape</span><br><span class="line">no: a hollow shape</span><br><span class="line">Please enter y or n: n</span><br><span class="line"></span><br><span class="line">Please enter the base length and height</span><br><span class="line">The base lenght &#x3D; 8</span><br><span class="line">The height &#x3D; 4</span><br><span class="line"></span><br><span class="line">********</span><br><span class="line">*      *</span><br><span class="line">*      *</span><br><span class="line">********</span><br></pre></td></tr></table></figure>
<p><strong>Test 3</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Select a shape type</span><br><span class="line">1. A Square</span><br><span class="line">2. A Rectangle</span><br><span class="line">3. A Triangle</span><br><span class="line">Please enter 1 or 2 or 3: 3</span><br><span class="line"></span><br><span class="line">Do you want a solid shape?</span><br><span class="line">yes: a solid shape</span><br><span class="line">no: a hollow shape</span><br><span class="line">Please enter y or n: n</span><br><span class="line"></span><br><span class="line">Please enter the height: 6</span><br><span class="line"></span><br><span class="line">     *     </span><br><span class="line">    * *    </span><br><span class="line">   *   *   </span><br><span class="line">  *     *  </span><br><span class="line"> *       * </span><br><span class="line">***********</span><br></pre></td></tr></table></figure>

<hr>
<p>To be continued. </p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Accelerated C++ Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ - Looping and counting</title>
    <url>/2018/02/23/C-Looping-and-counting/</url>
    <content><![CDATA[<p>In last chapter, the authors Koenig and Moo presents how to write a program that can produce a framed greeting. This chapter is to make the program more flexible so that we can change the size of the frame easily. Let’s have a look at the framed greeting again:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">********************</span><br><span class="line">*                  *</span><br><span class="line">* Hello, Estragon! *</span><br><span class="line">*                  *</span><br><span class="line">********************</span><br></pre></td></tr></table></figure>
<p>It has been observed that the greeting work has following characteristics:</p>
<ul>
<li>it consist of three elements: the greeting itself, asterisks and spaces. </li>
<li>the greeting itself will be fixed once we finished inputing. </li>
<li>the greeting itself is centrally located, meaning that it is surrounded by blank rows and the same number of black columns.</li>
<li>the outmost rows and columns are constituted by asterisks.</li>
</ul>
<p>Clearly, the size of the frame is determined by the length of the greeting itself and the number of blank lines(i.e. spaces in this case). Now, we can define a variable named <strong>pad</strong> that represents the length of spaces (e.g. 1):</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> pad = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>Then, we can indicate the number of rows with defining another variable:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> rows = <span class="number">1</span> + <span class="number">2</span> + <span class="number">2</span> * pad;</span><br></pre></td></tr></table></figure>
<p>The number 1 means the row of the greeting itself and the number 2 means two edges formed by asterisks. Once we know the number of rows, we can write the program similar as the the original one which defines several variables for each row and prints one by one. However, we need to change the code every time we change the frame size. This problem can be tackled with using <strong>iterative statements</strong> which will fully utilize the information listed above including the position of each type of elements. </p>
<h2 id="While-statement-amp-for-statement"><a href="#While-statement-amp-for-statement" class="headerlink" title="While statement &amp; for statement"></a>While statement &amp; for statement</h2><p>A <strong>while statement</strong> repeatedly executes a given statement as long as a pre-dertimined condition is true. The syntax of a <strong>while statement</strong> is </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (condition)</span><br><span class="line">    statement</span><br></pre></td></tr></table></figure>
<p>The processing of <strong>while statement</strong> starts from testing the <strong>condition</strong> and then executes the statement (aka, the <strong>while body</strong>) if the <strong>condition</strong> is true, and it starts all over again until the <strong>condition</strong> becomes false. Our purpose is to write each row, totalling <strong>rows</strong> times. Hence, what the program need here is a counting variable which is used to control the outputs. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> r = <span class="number">0</span>; <span class="comment">// counting variable with initial value 0</span></span><br><span class="line"><span class="keyword">while</span> (r != rows)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// write a row of output</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    ++r; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The while loop requires a single statement but the logic of our program need more. Hence, we can use a <strong>compound statement</strong> which refers to a block formed by a pair of curly braces. As shown above, We can write a sequence of statements and declarations or empty statement in the block. Note that the block forms a scope and the right brace (<strong>}</strong>) indicates the end of the statement. </p>
<p>The condition is an expression that returns <strong>bool</strong> type value (true or false). When the condition yields an arithmetic type value, the value will be converted to a value of <strong>bool</strong> type:</p>
<ol>
<li>zero values convert to <strong>false</strong></li>
<li>non-zero values convert to <strong>true</strong></li>
</ol>
<p>The <strong>inequality operator</strong> (<strong>!=</strong>) test the inequality between <strong>r</strong> and <strong>rows</strong>. The table below gives the logical and rational operators (all returns a value of bool type)：</p>
<table>
<thead>
<tr>
<th align="left">Associativity</th>
<th align="left">Operator</th>
<th align="left">Function</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Right</td>
<td align="left">!</td>
<td align="left">Logical NOT</td>
</tr>
<tr>
<td align="left">Left</td>
<td align="left">&lt;</td>
<td align="left">less than</td>
</tr>
<tr>
<td align="left">Left</td>
<td align="left">&lt;=</td>
<td align="left">less than or equal</td>
</tr>
<tr>
<td align="left">Left</td>
<td align="left">&gt;</td>
<td align="left">greater than</td>
</tr>
<tr>
<td align="left">Left</td>
<td align="left">&gt;=</td>
<td align="left">greater than or equal</td>
</tr>
<tr>
<td align="left">Left</td>
<td align="left">==</td>
<td align="left">equality</td>
</tr>
<tr>
<td align="left">Left</td>
<td align="left">!=</td>
<td align="left">inequality</td>
</tr>
<tr>
<td align="left">Left</td>
<td align="left">&amp;&amp;</td>
<td align="left">Logical AND</td>
</tr>
<tr>
<td align="left">Left</td>
<td align="left">&#124;&#124;</td>
<td align="left">Logical OR</td>
</tr>
<tr>
<td align="left">Source: <em>C++ Primer 2012</em></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<p>The <strong>++</strong>(<strong>–</strong>) is the increment (decrement) operator which adds (subtract) 1 to the variable <strong>r</strong>. The expression is equivalent to</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">r = r + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>If we want to add another variable with varing values each time, we can use compound assignment operators (refer to arithmetic operators)</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">+=</td>
<td align="center">-=</td>
<td align="center">*=</td>
<td align="center">/=</td>
<td align="center">%/</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">For example, <strong>x += y;</strong> is equivalent to</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">x = x + y;</span><br></pre></td></tr></table></figure></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Comparing with the ordinary assignment, compound assignment only evaluate the left operand once while the ordinary assignment evaluate twice.</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>Let’s get back to the <strong>while statement</strong>. According to the condition, the counting process will starts from <strong>0</strong> till <strong>rows-1</strong> and the statement is expected to be executed <strong>rows</strong> times. In this case, an alternative loop structure can also be considered, a <strong>for statement</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (init-statement; condition; expression) <span class="comment">// for header</span></span><br><span class="line">    statement                               <span class="comment">// for body</span></span><br></pre></td></tr></table></figure>
<p>The <strong>for header</strong> controls the <strong>for body</strong> which contains the statement that needs to be executed. The <strong>init-statement</strong> can only be one of three statements: <strong>declaration statement</strong>, an <strong>expression statement</strong> and a<strong>null statement</strong>(using a semicolon).<br>The processing order of the <strong>for statement</strong> is</p>
<ol>
<li>at the begining of the loop, <strong>init-statement</strong> will be executed.</li>
<li>then, condition will be evaluated and the <strong>for body</strong> would be executed if the condition returns true. Otherwise, the loop terminates.</li>
<li>if condition is true, the last step of the loop is to execute <strong>expression</strong>.</li>
</ol>
<p>In this case, the <strong>for statement</strong> can be write as</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> r; r != rows; ++r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// write a row of output</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Loop-invariant"><a href="#Loop-invariant" class="headerlink" title="Loop invariant"></a>Loop invariant</h2><p>To verify the correctness of the loops, the book introduces two techniques. The first is that the condition must be false when the loop finishes. In this case, when the while statement finishes, <strong>r != rows</strong> is false. Another one is to use <strong>loop invariant</strong> which is a property that is true before and after each loop. In this example, the <strong>loop invariant</strong> is not the core language but a comment before the while statement:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; invariant: we have written r rows so far</span><br></pre></td></tr></table></figure>
<p>The loop invariant shows that the while statement works as expected, and in turn the program should meet the requirements that invariant is true in each iteration. There are two specific points for verify this：</p>
<ol>
<li>the first point is before the first time that the condition is evaluated. In this example, we know it is correct as there is no output yet. </li>
<li>the second point is before the end of the while body. Once the while body is executed, one row will be written. To meet the requirement, we increase the value of <strong>r</strong> by adding 1 each time. </li>
</ol>
<p>When the while statement finishes, there will be <strong>rows</strong> lines are written as <strong>r = rows</strong>. The below piece of code shows how the <strong>loop invariant</strong> plays its role.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// invariant: we have written r rows so far</span></span><br><span class="line"><span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// setting r to 0 makes the invariant true</span></span><br><span class="line"><span class="keyword">while</span> (r != rows)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// we can assume the invariant is true here</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// writting a row of output makes the invariant false</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// incrementing r makes the invariant true again</span></span><br><span class="line">    ++r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// we can conclude that the invariant is true here</span></span><br></pre></td></tr></table></figure>
<p>Up to now, we have figured how to control the loops for producing right number of rows. Similarly, we can use <strong>while</strong> loop or <strong>for</strong> loop to produce every character of each specific row. By the analogy, the first step is to define a variable to representing the number of columns. But the difference is that the number of columns is not only determined by blanks but also by the size of the greeting itself.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>::size_type cols = greeting.<span class="built_in">size</span>() + pad * <span class="number">2</span> + <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>The variable <strong>cols</strong> is defined as a <strong>std::string::size_type</strong> to keep consistent with the type of <strong>greeting.size()</strong>. This knowledge has been introduced in my last notes. We can also use type specifiers <strong>auto</strong> or <strong>decltype</strong>. For example</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> cols = greeting.<span class="built_in">size</span>() + pad*<span class="number">2</span> + <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>What if we use <strong>int</strong> type directly? Then the variable might be insufficient if one input a name that is long enough. Now we can write the structure for writing a specific row.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>:：<span class="built_in">string</span>::size_type c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// invariant: we have written c characters so far in the current row</span></span><br><span class="line"><span class="keyword">while</span> (c != cols)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// write one or more characters  </span></span><br><span class="line">    <span class="comment">// adjust the value of c to maintain the invariant </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="if-statements"><a href="#if-statements" class="headerlink" title="if statements"></a>if statements</h2><p>Now We already have the whole structure of the program. What we need next is to determine what character is needed to be written for each row and column. As listed at the begining of this notes, we can utilize the characteristic of the target. I’ll further transform the information to plain english for clarify the logic of the program. There are three components in the outputs: asterisk, spaces and the greeting. The asterisks form the border of the frame and will be written when the loop is processing</p>
<ul>
<li>the first row       or</li>
<li>the last row    or</li>
<li>the first column    or</li>
<li>the last column </li>
</ul>
<p>These conditions can be expressed by means of the logical operators and relational operators</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">r &#x3D;&#x3D; 0 || r &#x3D;&#x3D; rows - 1 || c &#x3D;&#x3D; 0 || cols - 1</span><br></pre></td></tr></table></figure>
<p>The relational operators <strong>==</strong> have lower <strong>precedence</strong> than the arithmetic operators. Therefore, <strong>r == rows - 1</strong> is equivalent to <strong>r == (rows - 1)</strong>. </p>
<p>The <strong>logical OR</strong> operator has lower <strong>precedence</strong> than the relational operators. Therefore, above expression means</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(r &#x3D;&#x3D; 0) || (r &#x3D;&#x3D; rows - 1) || (c &#x3D;&#x3D; 0) || (cols - 1)</span><br></pre></td></tr></table></figure>
<p>Moreover, the <strong>logical OR</strong> (as well as the <strong>logical AND</strong>) is left associative and the expression is evluated using the <strong>short-circuit strategy</strong>, that is, <em>“the right side of an || is evaluated if and only if the left side is false (true for the <strong>logical AND</strong>)”</em> (Lippman ect. 2012, p.154). </p>
<p>To evaluate above condition, we use the <strong>if statement</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) </span><br><span class="line">    statement</span><br></pre></td></tr></table></figure>
<p>or <strong>if else statement</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition)</span><br><span class="line">    statement1</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    statement2</span><br></pre></td></tr></table></figure>
<p>or <strong>nested if statement</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition1)</span><br><span class="line">    statement1</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (condition2)</span><br><span class="line">    statement2</span><br></pre></td></tr></table></figure>
<p>Now we have got a complete structure for printing out the border</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (r == <span class="number">0</span> || r == rows - <span class="number">1</span> || c == <span class="number">0</span> || cols - <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"*"</span>;</span><br><span class="line">    ++c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (other condition)</span><br><span class="line">    <span class="comment">// write one or more noborder characters</span></span><br><span class="line">    <span class="comment">// adjust the value of c to maintain the invariant</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>By the analogy, we can determine the condition for outputing the greeting</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">r &#x3D;&#x3D; pad + 1 &amp;&amp; c &#x3D;&#x3D; pad + 1</span><br></pre></td></tr></table></figure>
<p>Note that we don’t need to write the condition of the each character of the <strong>greeting</strong> as once we find the row and the initial position we can print out the variable directly. Therefore, the value of the counting variable <strong>c</strong> will add a value of <strong>greeting.size()</strong> to maintain the invairant. Finally, it is not necessary to find the condition for the space characters as the remainder of the frame can only be spaces. Let’s combine three situations together</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (r == <span class="number">0</span> || r == rows - <span class="number">1</span> || c == <span class="number">0</span> || cols - <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"*"</span>;</span><br><span class="line">    ++c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (r == pad + <span class="number">1</span> &amp;&amp; c == pad + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; greeting;</span><br><span class="line">        c += greeting.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        ++c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>One common mistake in using <strong>if statement</strong> is that missing the curly braces after <strong>if</strong> or <strong>else</strong> when there are multiple statements. We should pay much attention on this in the case of <strong>nested if statements</strong> as there may exist more <strong>if</strong> branches than <strong>else</strong> branches. It is confusing how each <strong>else</strong> match with the <strong>if</strong> branches, which is commonly termed as <strong>dangling else</strong>. In the default seeting, C++ specifies that each else is matched with the closest preceding unmatched if. To avoid the ambiguity, it is recommended to control execution with curly braces.</p>
<h2 id="The-complete-framing-program"><a href="#The-complete-framing-program" class="headerlink" title="The complete framing program"></a>The complete framing program</h2><p>Now we can put all pieces together to get the complete framing program. Note there are several ways to organize the <strong>if statements</strong> and both <strong>while loop</strong> and <strong>for loop</strong> are available. Therefore, the program below is only one of the correct programs.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// using namespace std and names</span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>; <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ask for the person's name</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Please enter your first name: "</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read the name</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// build the message that we intend to write</span></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">string</span> greeting = <span class="string">"Hello, "</span> + name + <span class="string">"!"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the number of blanks surrounding the greeting</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> pad = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// the number of rows and columns </span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> rows = pad * <span class="number">2</span> + <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">string</span>::size_type cols = greeting.<span class="built_in">size</span>() + pad * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write a blank line to separate the output from the input</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write rows rows of output</span></span><br><span class="line">    <span class="comment">// invariant: we have written r rows so far</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r != rows; ++r) </span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="comment">// we have written c characters so far in the current row</span></span><br><span class="line">        <span class="built_in">string</span>::size_type c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (c != cols)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// are we on the border?</span></span><br><span class="line">            <span class="keyword">if</span> (r == <span class="number">0</span> || r == rows - <span class="number">1</span> || </span><br><span class="line">                c == <span class="number">0</span> || c == cols - <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"*"</span>;</span><br><span class="line">                ++c;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;   <span class="comment">// is it time to write the greeting?</span></span><br><span class="line">                <span class="keyword">if</span> (r == pad + <span class="number">1</span> &amp;&amp; c == pad + <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; greeting;</span><br><span class="line">                    c += greeting.<span class="built_in">size</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt;<span class="string">" "</span>;</span><br><span class="line">                    ++c;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Now we can test the program with changing the number of blanks to 2, and type <strong>Bruce</strong> after the input prompt. It gives the outputs as we expected. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Please enter your first name: Bruce</span><br><span class="line"></span><br><span class="line">*******************</span><br><span class="line">*                 *</span><br><span class="line">*                 *</span><br><span class="line">*  Hello, Bruce!  *</span><br><span class="line">*                 *</span><br><span class="line">*                 *</span><br><span class="line">*******************</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Notes</tag>
      </tags>
  </entry>
  <entry>
    <title>Accelerated C++ Solutions to Exercises(Chapter 2 Part 1)</title>
    <url>/2018/02/22/Accelerated-C-Solutions-to-Exercises-Chapter-2/</url>
    <content><![CDATA[<h1 id="Exercise-2-0"><a href="#Exercise-2-0" class="headerlink" title="Exercise 2-0"></a>Exercise 2-0</h1><p>Compile and run the program presented in this chapter</p>
<h2 id="Solution-amp-Results"><a href="#Solution-amp-Results" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>This exercise has been accomplished in <a href="http://quanttour.com/23/02/2018/C-Looping-and-counting/" target="_blank" rel="noopener">C++ - Looping and counting</a> with detailed explination.</p>
<hr>
<h1 id="Exercise-2-1"><a href="#Exercise-2-1" class="headerlink" title="Exercise 2-1"></a>Exercise 2-1</h1><p>Change the framing program so that it writes its greeting with no separation from the frame.</p>
<h2 id="Solution-amp-Results-1"><a href="#Solution-amp-Results-1" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>This can be easily accomplished by changing the number of the blanks to 0. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// using namespace std and names</span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>; <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ask for the person's name</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Please enter your first name: "</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read the name</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// build the message that we intend to write</span></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">string</span> greeting = <span class="string">"Hello, "</span> + name + <span class="string">"!"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the number of blanks surrounding the greeting</span></span><br><span class="line">    <span class="comment">// change to 0 to meet the requirement</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> pad = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the number of rows and columns</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> rows = pad * <span class="number">2</span> + <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">string</span>::size_type cols = greeting.<span class="built_in">size</span>() + pad * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write a blank line to separate the output from the input</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write rows rows of output</span></span><br><span class="line">    <span class="comment">// invariant: we have written r rows so far</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r != rows; ++r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span>::size_type c = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// we have written c characters so far in the current row</span></span><br><span class="line">        <span class="keyword">while</span> (c != cols)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// are we on the border?</span></span><br><span class="line">            <span class="keyword">if</span> (r == <span class="number">0</span> || r == rows - <span class="number">1</span> ||</span><br><span class="line">                c == <span class="number">0</span> || c == cols - <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"*"</span>;</span><br><span class="line">                ++c;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;   <span class="comment">// is it time to write the greeting?</span></span><br><span class="line">                <span class="keyword">if</span> (r == pad + <span class="number">1</span> &amp;&amp; c == pad + <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; greeting;</span><br><span class="line">                    c += greeting.<span class="built_in">size</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt;<span class="string">" "</span>;</span><br><span class="line">                    ++c;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Again, once we typed <strong>Bruce</strong> after the input prompt, the program writes below outputs on the console window</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Please enter your first name: Bruce</span><br><span class="line"></span><br><span class="line">***************</span><br><span class="line">*Hello, Bruce!*</span><br><span class="line">***************</span><br></pre></td></tr></table></figure>
<h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><p>See deatiled analysis in <a href="http://quanttour.com/23/02/2018/C-Looping-and-counting/" target="_blank" rel="noopener">C++ - Looping and counting</a>.</p>
<hr>
<h1 id="Exercise-2-2-2-3"><a href="#Exercise-2-2-2-3" class="headerlink" title="Exercise 2-2, 2-3"></a>Exercise 2-2, 2-3</h1><p>2-2. Change the framing program so that it uses a different amount of space to seperate sides from the greeting than it uses to seperate the top and botton borders from the greeting.</p>
<p>2-3. Rewrite the framing program to ask the user to supply the amount of spacing to leave between the frame and the greeting.</p>
<p>These two exercises will be answered together. </p>
<h2 id="Solution-amp-Results-2"><a href="#Solution-amp-Results-2" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>It has been seen from the program (as shown in Exercise 2-1), the variable <strong>pad</strong> controls the spaces. Therefore, it is necessary to replace the <strong>pad</strong> with two seperate variables for controling the spaces on the leftside and rightside, and the spaces on the upside and downside, respectively. For example, I define two variables with initializers 2 and 3 seperately</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> lr_sides_pad  = <span class="number">2</span>; <span class="comment">// controls left and right blanks</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> tb_sides_pad = <span class="number">3</span>;  <span class="comment">// controls top and bottom blanks</span></span><br></pre></td></tr></table></figure>
<p>Correspondingly, the size of <strong>rows</strong> becomes</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> rows = tb_sides_pad * <span class="number">2</span> + <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>and the size of <strong>cols</strong> becomes</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">string</span>::size_type cols = greeting.<span class="built_in">size</span>() + lr_sides_pad * <span class="number">2</span> + <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>In addition, the condition for determining the position of the <strong>greeting</strong> changes to  </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">r == tb_sides_pad + <span class="number">1</span> &amp;&amp; c == lr_sides_pad + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>Up to now, I have replaced all <strong>pad</strong> with above two new variables. However, the frame size is still predetermined in the program and not very flexible. We further change it so that the size can meet each user’s preference. We need to redifine the variables and assign user-defined values to them.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ask for the number of blanks that on the left or right side</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Please enter the number of spaces between the greeting and the left border (or the right boder): "</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// read the number of blanks that on the left or right side</span></span><br><span class="line"><span class="keyword">int</span> lr_sides_pad;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; lr_sides_pad;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ask for the number of blanks that on the upper or below side</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Please enter the number of spaces between the greeting and the top border (or the bottom boder): "</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// read the number of blanks that on the left or right side</span></span><br><span class="line"><span class="keyword">int</span> tb_sides_pad;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; tb_sides_pad;</span><br></pre></td></tr></table></figure>

<p>Now the program becomes</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// using namespace std and names</span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>; <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ask for the person's name</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Please enter your first name: "</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read the name</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// build the message that we intend to write</span></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">string</span> greeting = <span class="string">"Hello, "</span> + name + <span class="string">"!"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ask for the number of blanks that on the left or right side</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Please enter the number of spaces between the greeting and the left border (or the right boder): "</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// read the number of blanks that on the left or right side</span></span><br><span class="line">    <span class="keyword">int</span> lr_sides_pad;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; lr_sides_pad;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ask for the number of blanks that on the upper or below side</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Please enter the number of spaces between the greeting and the top border (or the bottom boder): "</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// read the number of blanks that on the left or right side</span></span><br><span class="line">    <span class="keyword">int</span> tb_sides_pad;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; tb_sides_pad;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the number of rows and columns</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> rows = tb_sides_pad * <span class="number">2</span> + <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">string</span>::size_type cols = greeting.<span class="built_in">size</span>() + lr_sides_pad * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write a blank line to separate the output from the input</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write rows rows of output</span></span><br><span class="line">    <span class="comment">// invariant: we have written r rows so far</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r != rows; ++r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span>::size_type c = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// we have written c characters so far in the current row</span></span><br><span class="line">        <span class="keyword">while</span> (c != cols)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// are we on the border?</span></span><br><span class="line">            <span class="keyword">if</span> (r == <span class="number">0</span> || r == rows - <span class="number">1</span> ||</span><br><span class="line">                c == <span class="number">0</span> || c == cols - <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"*"</span>;</span><br><span class="line">                ++c;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;   <span class="comment">// is it time to write the greeting?</span></span><br><span class="line">                <span class="keyword">if</span> (r == tb_sides_pad + <span class="number">1</span> &amp;&amp; </span><br><span class="line">                    c == lr_sides_pad + <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; greeting;</span><br><span class="line">                    c += greeting.<span class="built_in">size</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt;<span class="string">" "</span>;</span><br><span class="line">                    ++c;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>I performed three tests and present the results here</p>
<h3 id="Test-1-input-Bruce-2-3"><a href="#Test-1-input-Bruce-2-3" class="headerlink" title="Test 1: input: Bruce 2 3"></a>Test 1: input: Bruce 2 3</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Please enter your first name: Bruce</span><br><span class="line">Please enter the number of spaces between the greeting and the left border (or the right border): 2</span><br><span class="line">Please enter the number of spaces between the greeting and the top border (or the bottom border): 3</span><br><span class="line"></span><br><span class="line">*******************</span><br><span class="line">*                 *</span><br><span class="line">*                 *</span><br><span class="line">*                 *</span><br><span class="line">*  Hello, Bruce!  *</span><br><span class="line">*                 *</span><br><span class="line">*                 *</span><br><span class="line">*                 *</span><br><span class="line">*******************</span><br></pre></td></tr></table></figure>
<h3 id="Test-2-input-Bruce-4-0"><a href="#Test-2-input-Bruce-4-0" class="headerlink" title="Test 2: input: Bruce 4 0"></a>Test 2: input: Bruce 4 0</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Please enter your first name: Bruce</span><br><span class="line">Please enter the number of spaces between the greeting and the left border (or the right border): 4</span><br><span class="line">Please enter the number of spaces between the greeting and the top border (or the bottom border): 0</span><br><span class="line"></span><br><span class="line">***********************</span><br><span class="line">*    Hello, Bruce!    *</span><br><span class="line">***********************</span><br></pre></td></tr></table></figure>
<h3 id="Test-3-input-Bruce-5-5"><a href="#Test-3-input-Bruce-5-5" class="headerlink" title="Test 3: input: Bruce 5 5"></a>Test 3: input: Bruce 5 5</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Please enter your first name: Bruce</span><br><span class="line">Please enter the number of spaces between the greeting and the left border (or the right border): 5</span><br><span class="line">Please enter the number of spaces between the greeting and the top border (or the bottom border): 5</span><br><span class="line"></span><br><span class="line">*************************</span><br><span class="line">*                       *</span><br><span class="line">*                       *</span><br><span class="line">*                       *</span><br><span class="line">*                       *</span><br><span class="line">*                       *</span><br><span class="line">*     Hello, Bruce!     *</span><br><span class="line">*                       *</span><br><span class="line">*                       *</span><br><span class="line">*                       *</span><br><span class="line">*                       *</span><br><span class="line">*                       *</span><br><span class="line">*************************</span><br></pre></td></tr></table></figure>
<h2 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h2><p>See deatiled analysis in <a href="http://quanttour.com/23/02/2018/C-Looping-and-counting/" target="_blank" rel="noopener">C++ - Looping and counting</a>.</p>
<hr>
<p>To be continued.</p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Accelerated C++ Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title>Accelerated C++ Solutions to Exercises(Chapter 1)</title>
    <url>/2018/02/22/Accelerated-C-Solutions-to-Exercises-Chapter-1/</url>
    <content><![CDATA[<h1 id="Exercise-1-0"><a href="#Exercise-1-0" class="headerlink" title="Exercise 1-0"></a>Exercise 1-0</h1><p>Compile, execute, and test the programs in this chapter. </p>
<h2 id="Solution-amp-Results"><a href="#Solution-amp-Results" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>The first program:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ask for a person's name, and greet the person</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ask for the person's name</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Please enter your first name: "</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read the name</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name; <span class="comment">// define name</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; name; <span class="comment">// read into</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// write a greeting</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, "</span> &lt;&lt; name &lt;&lt; <span class="string">"!"</span> &lt;&lt; <span class="built_in">std</span>:: <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Test: type <strong>Liam</strong> according to the prompt and the console window displays as follows:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Please enter your first name: Liam</span><br><span class="line">Hello, Liam!</span><br></pre></td></tr></table></figure>
<p>The second program:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ask for a person's name, and generate a framed greeting</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Please enter your first name: "</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// build the message that we intend to write</span></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> greeting = <span class="string">"Hello, "</span> + name + <span class="string">"!"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// build the second and forth lines of the output</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">spaces</span><span class="params">(greeting.<span class="built_in">size</span>(), <span class="string">' '</span>)</span></span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> second = <span class="string">"* "</span> + spaces + <span class="string">" *"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// build the first and fifth lines of the output</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">first</span><span class="params">(second.<span class="built_in">size</span>(), <span class="string">'*'</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write it all</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; first &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; second &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"* "</span> &lt;&lt; greeting &lt;&lt; <span class="string">" *"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; second &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; first &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Test: type <strong>Liam</strong> according to the prompt and the console window displays as follows: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Please enter your first name: Liam</span><br><span class="line"></span><br><span class="line">****************</span><br><span class="line">*              *</span><br><span class="line">* Hello, Liam! *</span><br><span class="line">*              *</span><br><span class="line">****************</span><br></pre></td></tr></table></figure>

<h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><p>See <a href="http://quanttour.com/11/02/2018/C-Working-with-strings/" target="_blank" rel="noopener">C++ - Working with strings</a>.</p>
<hr>
<h1 id="Exercise-1-1"><a href="#Exercise-1-1" class="headerlink" title="Exercise 1-1"></a>Exercise 1-1</h1><p>Are the following definitions valid? Why or why not?</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> hello = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> message = hello + <span class="string">", world"</span> + <span class="string">"!"</span>;</span><br></pre></td></tr></table></figure>
<h2 id="Solution-amp-Results-1"><a href="#Solution-amp-Results-1" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>Yes, above definitions are valid. </p>
<p>The first statement defines a string type variable named <strong>hello</strong> and initialize the variable with copying string literals <strong>Hello</strong> into it. The second statement defines a variable named <strong>message</strong> and copy the value of the right side of the <strong>=</strong> into it. The right side is an expression that the concatenation operator <strong>+</strong> operates on the object <strong>hello</strong> and two <strong>string literals</strong>. First, the operator is left-associative and hence:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const std::string message &#x3D; hello + &quot;, world&quot; + &quot;!&quot;;</span><br><span class="line">                          &#x3D; (hello + &quot;, world&quot;) + &quot;!&quot;;</span><br></pre></td></tr></table></figure>
<p>Due to the fact that the result of <strong>(hello + “, world”)</strong> is also a string type object, the whole expression is simply to concatenate a string and a string literals, which is legal and valid. The test is shown below:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>; <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> hello = <span class="string">"Hello"</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> message = hello + <span class="string">", world"</span> + <span class="string">"!"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; hello &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; message &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The program runs ok and display results on the console window as below:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hello</span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure>
<h2 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h2><p>As stated by Lippman ect. (2012): <em>“When we mix strings and string or character literals, at least one operand to each + operator must be of string type”</em>. For more analysis, please see <a href="http://quanttour.com/11/02/2018/C-Working-with-strings/" target="_blank" rel="noopener">C++ - Working with strings</a>.</p>
<hr>
<h1 id="Exercise-1-2"><a href="#Exercise-1-2" class="headerlink" title="Exercise 1-2"></a>Exercise 1-2</h1><p>Are the following definitions valid? Why or why not?</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> exclam = <span class="string">"!"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> message = <span class="string">"Hello"</span> + <span class="string">", world"</span> + exclam;</span><br></pre></td></tr></table></figure>
<h2 id="Solution-amp-Results-2"><a href="#Solution-amp-Results-2" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>The definition of <strong>exclam</strong> is valid but the definition of <strong>message</strong> is illegal and hence invalid. This is because that the operator <strong>+</strong> is left-associative and cannot concatenate two string literals. Follow program shows my test:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>; <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> exclam = <span class="string">"!"</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> message = <span class="string">"Hello"</span> + <span class="string">", world"</span> + exclam;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; exclam &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; message &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>As expected, the compilation reports errors as below:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">invalid operands of types &#39;const char [6]&#39; and &#39;const char [8]&#39; to binary &#39;operator+&#39;.</span><br></pre></td></tr></table></figure>
<h2 id="Analysis-2"><a href="#Analysis-2" class="headerlink" title="Analysis"></a>Analysis</h2><p>See <a href="http://quanttour.com/22/02/2018/Accelerated-C-Solutions-to-Exercises-Chapter-1/" target="_blank" rel="noopener">Exercise 1-1</a> and<br><a href="http://quanttour.com/11/02/2018/C-Working-with-strings/" target="_blank" rel="noopener">C++ - Working with strings</a>.</p>
<hr>
<h1 id="Exercise-1-3"><a href="#Exercise-1-3" class="headerlink" title="Exercise 1-3"></a>Exercise 1-3</h1><p>Is the following program valid? If so, what does it do? If not, why not?</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123; <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> s = <span class="string">"a string"</span>;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">    &#123; <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> s = <span class="string">"another string"</span>;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Solution-amp-Results-3"><a href="#Solution-amp-Results-3" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>Yes, it is a valid program.<br>The program intends to print two different strings, both of which have the same name <strong>s</strong> within the main function body.<br>I firstly present the result when running the program:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a string</span><br><span class="line">another string</span><br></pre></td></tr></table></figure>
<p>These two varibles are not conflict because their names have different scopes that formed by two pairs of curly braces. Specifically:</p>
<ul>
<li>Both variables are local variables as they are inside of the main function. </li>
<li>The first <strong>s</strong> is visible from its declaration until the end of its scope, that is, the scope formed by the first nested curly braces.</li>
<li>The second <strong>s</strong> is visible from its declaration until the end of the second nested curly braces.</li>
<li>Two names refer to different entities in different scope. </li>
</ul>
<p>From the perspective of memory management, the first variable exists only when the part of the program within the first nested braces is executing, and disappears and returns the memory it occupied once the computer reaches the end of the braces. It has limited lifetime and so does the second variable. </p>
<h2 id="Analysis-3"><a href="#Analysis-3" class="headerlink" title="Analysis"></a>Analysis</h2><p>See <a href="http://quanttour.com/11/02/2018/C-Working-with-strings/" target="_blank" rel="noopener">C++ - Working with strings</a>.</p>
<hr>
<h1 id="Exercise-1-4"><a href="#Exercise-1-4" class="headerlink" title="Exercise 1-4"></a>Exercise 1-4</h1><h2 id="Question-1"><a href="#Question-1" class="headerlink" title="Question 1"></a>Question 1</h2><p>Is the following program valid? </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123; <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> s = <span class="string">"a string"</span>; <span class="comment">//outer scope</span></span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#123; <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> s = <span class="string">"another string"</span>; <span class="comment">// inner scope</span></span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Solution-amp-Results-4"><a href="#Solution-amp-Results-4" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>Yes, the program is valid.<br>In constrast with the last program, the scopes of two names are not independent with eachother but are nested:</p>
<ul>
<li>The scope of the first <strong>s</strong> is the <strong>outer scope</strong>, containing the other scope, that is, the <strong>inner scope</strong> where the second <strong>s</strong> is in. </li>
<li>The name that declared in the <strong>outer scope</strong> can be can be accessed and reused in the nested scope, i.e. <strong>inner scope</strong>.</li>
</ul>
<p>Therefore, the logic of this program can be described as:</p>
<ol>
<li>the first variable is defined and initialized with string literals <strong>“a string”</strong> and is printed out in the following statement.</li>
<li><em>“the variable”</em> is redefined in the <strong>inner scope</strong> and initialized with string literals <strong>another string</strong>. Then, it is printed out in the following step.</li>
<li>the second <strong>s</strong> is destroyed at the end of its scope, that is, the first right brace (<strong>}</strong>).</li>
<li>the first <strong>s</strong> is still available after the first right brace, but is destroyed once the computer reaches the second right brace. </li>
</ol>
<p>Note that two variables are different and the second variable doesn’t overwriting the first one though they both use the name <strong>s</strong>. To confirm this, I simply add one statement between the first right curly brace and second right curly brace:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; s &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>Then, I run the program and it yields:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a string</span><br><span class="line">another string</span><br><span class="line">a string</span><br></pre></td></tr></table></figure>
<h2 id="Question-2"><a href="#Question-2" class="headerlink" title="Question 2"></a>Question 2</h2><p>what if we change <strong>}</strong> <strong>}</strong> to <strong>}</strong>;<strong>}</strong> in the third line from the end?</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123; <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> s = <span class="string">"a string"</span>;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#123; <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> s = <span class="string">"another string"</span>;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;;&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Solution-amp-Results-5"><a href="#Solution-amp-Results-5" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>The program is still valid after adding an semicolon betwween the first and second right curly brace. The semicolon typically working as a statement terminator in C++. In this case, it does nothing except forming a <strong>null statement</strong>. This program leads to the same results as the program that without adding a semicolon. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a string</span><br><span class="line">another string</span><br></pre></td></tr></table></figure>
<h2 id="Analysis-4"><a href="#Analysis-4" class="headerlink" title="Analysis"></a>Analysis</h2><p>I didn’t found very good interpretations about the role of the semicolon in C++. For more analysis, please move to <a href="https://stackoverflow.com/questions/6464436/what-is-the-semicolon-in-c" target="_blank" rel="noopener">What is the semicolon in C++?</a> and <a href="https://www.quora.com/What-is-the-function-of-semicolon-in-C++" target="_blank" rel="noopener">What is the function of semicolon in C++?</a>  , where some good answers have been provided by the forum users. </p>
<hr>
<h1 id="Exercise-1-5"><a href="#Exercise-1-5" class="headerlink" title="Exercise 1-5"></a>Exercise 1-5</h1><p>Is this program valid? If so, what does it do? If not, say why not, and rewrite it to be valid.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;  <span class="built_in">std</span>::<span class="built_in">string</span> s = <span class="string">"a string"</span>;</span><br><span class="line">    &#123;  <span class="built_in">std</span>::<span class="built_in">string</span> x = s + <span class="string">", really"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Solution-amp-Results-6"><a href="#Solution-amp-Results-6" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>No, this program is invalid. S<br>imilarly as last two exercises, this question tries to test my understanding on the scope of a name. The scope of name <strong>s</strong> is <strong>outter scope</strong> and can be accessed in the <strong>inner scope</strong> where the variable <strong>x</strong> is defined. Therefore, it is correct that initializing <strong>x</strong> with a expression which oncatenates a string and string literals. It is also ok to output <strong>s</strong> inside the nested scope. However, the statement <strong>std::cout &lt;&lt; x &lt;&lt; std::endl;</strong> would be invalid due to the fact that <strong>x</strong> doesn’t exist anymore once the computer reaches the end of its scope, that is, the first right curly brace. As expected, when running this program, error occurs:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;x&#39; was not declared in this scope</span><br></pre></td></tr></table></figure>
<p>To correct it, we can simply put the statement:<strong>std::cout &lt;&lt; x &lt;&lt; std::endl;</strong> into the <strong>inner scope</strong>, or directly remove the nested curly braces as long as the name is not redefined in a same scope. Both corrections work well and following results can be seen on the console window:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a string</span><br><span class="line">a string, really</span><br></pre></td></tr></table></figure>
<h2 id="Analysis-5"><a href="#Analysis-5" class="headerlink" title="Analysis"></a>Analysis</h2><p>See <a href="http://quanttour.com/22/02/2018/Accelerated-C-Solutions-to-Exercises-Chapter-1/" target="_blank" rel="noopener">Exercise 1-3, Exercise 1-4</a> and<br><a href="http://quanttour.com/11/02/2018/C-Working-with-strings/" target="_blank" rel="noopener">C++ - Working with strings</a>.</p>
<hr>
<h1 id="Exercise-1-6"><a href="#Exercise-1-6" class="headerlink" title="Exercise 1-6"></a>Exercise 1-6</h1><p>What does the following program do if, when it asks you for input, you type two names(for example, Samuel Beckett)? Predict the behavior before running the program, then try it.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">// prompt that asks for input</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"What is your name? "</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// define an string type variable named **name** which is empty initially.</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read the contents into **name**</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// output greetings as well as asking for input</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, "</span> &lt;&lt; name</span><br><span class="line">              &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span> &lt;&lt; <span class="string">"And what is yours?"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// read new contents into the same variable </span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// output greeting</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, "</span> &lt;&lt; name</span><br><span class="line">              &lt;&lt; <span class="string">"; nice to meet you too!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Solution-amp-Results-7"><a href="#Solution-amp-Results-7" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>The program intends to create a greeting conversation between two people. For For clarity, I added comments for each statement first. Let’s analyse this program step by step:</p>
<ol>
<li>once click the running button, the computer reads the first statement and stores the contents *<em>What is your name? *</em> into buffer. </li>
<li>the <strong>cin</strong> statement triggers the flush of <strong>cout</strong>, and user can type two names <strong>Samuel Beckett</strong> according to the prompt. I predict following contents would be written on the output device:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">What is your name? Samuel Beckett</span><br></pre></td></tr></table></figure></li>
<li>then, the <strong>cin</strong> reads from the first character untill it encounters the whitespace. Therefore, only <strong>Samuel</strong> is stored into <strong>name</strong>. </li>
<li>the fouth statement would flush the <strong>cout</strong> because of the manipulator <strong>endl</strong>. Then, the console windows should have following outputs:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hello, Samuel</span><br></pre></td></tr></table></figure></li>
<li>the fifth statement <strong>cin</strong> flushes buffer and following sentence will be printed out straight after above contents.<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">And what is yours?</span><br></pre></td></tr></table></figure></li>
<li>then, <strong>cin</strong> starts reading the rest content <strong>Beckett</strong> and stores into <strong>name</strong>. The new name <strong>Beckett</strong> rewrites this variable. </li>
<li>finally, the last buffer flush happens once the computer reads <strong>std::endl</strong>. Following contents are expected to appear on the console window.<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hello, Beckett; nice to meet you too!</span><br></pre></td></tr></table></figure></li>
<li>finished.</li>
</ol>
<p>As ecpected, the final results of this program is shown as follows:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">What is your name? Samuel Beckett</span><br><span class="line">Hello, Samuel</span><br><span class="line">And what is yours?Hello, Beckett; nice to meet you too!</span><br></pre></td></tr></table></figure>
<h2 id="Analysis-6"><a href="#Analysis-6" class="headerlink" title="Analysis"></a>Analysis</h2><p>I am not entirly sure about my analysis, and may update this in the futuer if I get new ideas. </p>
<hr>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p>Koenig, A. and Moo, B.E., 2000. Accelerated C++.</p>
<p>Lippman, S.B., Lajoie, J. and Moo, B.E., 2013. C++ Primer, 5th edt.</p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Accelerated C++ Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ - Working with strings</title>
    <url>/2018/02/11/C-Working-with-strings/</url>
    <content><![CDATA[<h1 id="Variables-Initialization-amp-Declarations"><a href="#Variables-Initialization-amp-Declarations" class="headerlink" title="Variables, Initialization &amp; Declarations"></a>Variables, Initialization &amp; Declarations</h1><p>Conventionally, I present the program that provided in <a href="https://www.amazon.com/Accelerated-C-Practical-Programming-Example/dp/020170353X" target="_blank" rel="noopener">Accelerated C++: Practical Programming by Example</a> here:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ask for a person's name, and greet the person</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ask for the person's name</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Please enter your first name: "</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read the name</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;       <span class="comment">// define name</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; name;       <span class="comment">// read into</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// write a greeting</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, "</span> &lt;&lt; name &lt;&lt; <span class="string">"!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The program is based on <strong>Hello, world!</strong> and is improved to say <strong>Hello</strong> to anyone you specified. It asks you to input a name (e.g. Batman) and then output as follows:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Hello, Batman!</span><br></pre></td></tr></table></figure>
<h2 id="Variables"><a href="#Variables" class="headerlink" title="Variables"></a>Variables</h2><p>To realize this function, a variable is defined to hold input. According to Koenig (2000), <em>“a variable is an object that has a name”</em> while <em>“an object is a part of the computer’s memory that has a type”</em>. Therefore, a variable should have:</p>
<ol>
<li><strong>name</strong>: for identifying the object that is needed to be manipulated.</li>
<li><strong>type</strong>: determines the size and layout of the variable’s memory, range of values that can be stored within the memory, and operations that can be applied to the variable. </li>
</ol>
<p>In this case, the variable is named <strong>name</strong> and its type is <strong>std::string</strong>. The <strong>std::</strong> means that the <strong>string</strong> type is defined in namespace <strong>std</strong>. Therefore, we need to include the standard header <strong>string</strong> as same as include the header <strong>iostream</strong> at the begining of this program. This statement also indicates the syntax of defining variables: <em>a type specifier followed by one name (or more names sepreated by commas), and ends with a semicolon</em>. </p>
<p>As this program shows, the variable <strong>name</strong> is defined within the function body and hence it is a <strong>local variable</strong>, i.e. the variable is only valid when the function body is executed. Once the computer reachers the <strong>}</strong>, it destroys the variable <strong>name</strong> and returns the memory that the variable occupied during its lifetime. </p>
<h2 id="Initialization"><a href="#Initialization" class="headerlink" title="Initialization"></a>Initialization</h2><p>An object is initialized and gets a specified value (i.e. initializer) when it is created. C++ defines several types of initializations. The example provided above uses <strong>default initialization</strong> in defining the variable <strong>name</strong>. </p>
<h3 id="Default-initialization"><a href="#Default-initialization" class="headerlink" title="Default initialization"></a>Default initialization</h3><p>The <strong>default initialization</strong> means that no initializer is applied to a variable when it is defined. In the case of <strong>default initialization</strong>, the variable gets a <strong>default value</strong> which depends on its type and may also depends on where the variable is defined. Note that the default value of an object of built-in type, e.g. arithmetic type, depends on where it is defined:</p>
<ul>
<li>variables defined outside any function body are initialized to zero (or <strong>null character</strong> for <strong>char</strong> type?).</li>
<li>in general, variables of built-in type defined inside a function are uninitialized.</li>
</ul>
<p>For example, I write a program as below for testing:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i; <span class="keyword">bool</span> h; <span class="keyword">char</span> m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j; <span class="keyword">bool</span> k; <span class="keyword">char</span> n;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span> &lt;&lt; j &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; h &lt;&lt; <span class="string">' '</span> &lt;&lt; k &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; m &lt;&lt; <span class="string">' '</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The results is: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 4201179</span><br><span class="line">0 0</span><br><span class="line">  a</span><br></pre></td></tr></table></figure>

<p>with warnings:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;j&#39; is used uninitialized in this function [-Wuninitialized]</span><br><span class="line">&#39;k&#39; is used uninitialized in this function [-Wuninitialized]</span><br><span class="line">&#39;n&#39; is used uninitialized in this function [-Wuninitialized]</span><br></pre></td></tr></table></figure>
<p>Clearly, it will result severe errors if we try to access the value or copy the value of such uninitialized variables. </p>
<p>Each class defines different ways to initialize objects of the class type. If default initialization is allowed, the default value of an object is determined by the class. For example, the default initialization of a <strong>string</strong> leads to an <strong>empty string</strong> (i.e. no characters). In the first program, the variable <strong>name</strong> is the <strong>empty string</strong>. </p>
<h3 id="Copy-amp-Direct-initialization"><a href="#Copy-amp-Direct-initialization" class="headerlink" title="Copy &amp; Direct initialization"></a>Copy &amp; Direct initialization</h3><p>Another way to initialize variables is using <strong>=</strong>, that is <strong>copy initialize</strong> by copying the initializer on the right side into the created object. For example:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> j = <span class="string">'a'</span>;</span><br><span class="line"><span class="built_in">string</span> s1 = <span class="string">"Hello"</span>;</span><br></pre></td></tr></table></figure>
<p>The values used to initialize objects can also be expressions:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> j = i*<span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>The copy initialization seems like assignment, however, is completely different. As Lippman etc. (2012) point out： <em>“Initialization happens when a variable is given a value when it is created. Assignment obliterates an object’s current value and replaces that value with a new one.”</em></p>
<p>We can also initialize above objects without using “=”: </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">i</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">j</span><span class="params">(<span class="string">'a'</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(<span class="string">"Hello"</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>This way is named <strong>direct initialization</strong>. The <strong>string</strong> type variables can also be initialized using an alternative form:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// direct initialization, s1 is aaaaa</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(<span class="number">5</span>, <span class="string">'a'</span>)</span></span>; </span><br><span class="line"><span class="comment">// copy initialization, s2 is aaaaa</span></span><br><span class="line"><span class="built_in">string</span> s2 = <span class="built_in">string</span>(<span class="number">5</span>, <span class="string">'a'</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// decomposition of s2</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s0</span><span class="params">(<span class="number">5</span>, <span class="string">'a'</span>)</span></span>; <span class="comment">// s0 is aaaaa</span></span><br><span class="line"><span class="built_in">string</span> s2 = s0;    <span class="comment">// copy s0 into s2</span></span><br></pre></td></tr></table></figure>
<p>The differences between <strong>copy initialization</strong> and <strong>direct initialization</strong> will not be disscussed until chapter 9;</p>
<h3 id="List-initialization"><a href="#List-initialization" class="headerlink" title="List initialization"></a>List initialization</h3><p>The C++ 11 standards supports an alternative form for the <strong>copy initialization</strong> and <strong>direct initialization</strong> using curly braces. For example:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = &#123;<span class="number">10</span>&#125;; <span class="comment">// same as _int i = 10;_</span></span><br><span class="line"><span class="keyword">int</span> j&#123;<span class="number">10</span>&#125;;    <span class="comment">// same as _int j(10);_</span></span><br><span class="line"><span class="built_in">string</span> s1 = &#123;<span class="string">"Hello"</span>&#125;; <span class="comment">// same as _string s1 = "Hello";_</span></span><br><span class="line"><span class="built_in">string</span> s2 &#123;<span class="string">"Hello"</span>&#125;;   <span class="comment">// same as _string s2("Hello");_</span></span><br></pre></td></tr></table></figure>
<p>This form is known as <strong>list initialization</strong>. The major difference between <strong>list initialization</strong> and above methods is that <strong>list initialization</strong> doesn’t allow narrowing for the conversion of built-in type variables. To show this property, I performed an experiment using following codes:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> i = <span class="number">10.9876</span>;</span><br><span class="line">    <span class="keyword">int</span> num1 = i;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">num2</span><span class="params">(i)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> num3&#123;i&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; num1 &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// ok but result is truncated: 10</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; num2 &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// ok but result is truncated: 10</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; num3 &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// warning: narrowing conversion of  'i' from 'double' to 'int' inside &#123; &#125; </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Hence, <strong>list initialization</strong> is a more reliable approach compared with other alternatives. </p>
<h2 id="Declarations"><a href="#Declarations" class="headerlink" title="Declarations"></a>Declarations</h2><p>As analysed above, the definition of a variable requires <strong>type</strong>, <strong>name</strong> and initializers. For convenience, <strong>C++</strong> supports <strong>separate compilation</strong>, that is, allows a program to be split into several files and compiled independently. In fact, we have already used the <strong>separate compilation</strong> in previous examples, such as the usage of <strong>IO</strong> system. The <strong>std::cout</strong> is defined in the header <strong>iostream</strong> but can be used in our programs through simply including the header file. To realize this function, a variable needs declaration which requires stating the <strong>type</strong> and <strong>name</strong>. The difference between <strong>declaration</strong> and <strong>definition</strong> is that the variable may be explicitly initialized in its <strong>definition</strong>. To declare a a variable only, we need add <strong>extern</strong> and don’t explicitly initialize it:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i; <span class="comment">// declares but not defines i</span></span><br><span class="line"><span class="keyword">int</span> i;        <span class="comment">// declares and defines i</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i = <span class="number">10</span>; <span class="comment">// declares and defines i</span></span><br></pre></td></tr></table></figure>
<p>But it should be noted that(Lippman etc. 2012):</p>
<ul>
<li>It is an error to provide an initializer on an extern inside a function.</li>
<li>Variables must be defined exactly once but can be declared many times. </li>
</ul>
<h1 id="Operations-on-strings"><a href="#Operations-on-strings" class="headerlink" title="Operations on strings"></a>Operations on strings</h1><h2 id="Reading-amp-Writing-strings"><a href="#Reading-amp-Writing-strings" class="headerlink" title="Reading &amp; Writing strings"></a>Reading &amp; Writing strings</h2><p>To read the inputs into <strong>name</strong>, this program uses <strong>std::cin</strong> and operator <strong>&gt;&gt;</strong>. It will discard whitespace characters such as <strong>space</strong>, <strong>tab</strong> and <strong>backspace</strong>, and then reads chars into <strong>name</strong> until it encounters another whitespace. For example, following three piece of inputs yield same outputs when we run the program:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Bruce</span><br><span class="line">[a tab space]Bruce      </span><br><span class="line">Bruce Lee</span><br></pre></td></tr></table></figure>
<p>Results:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hello, Bruce!</span><br><span class="line">Hello, Bruce!</span><br><span class="line">Hello, Bruce!</span><br></pre></td></tr></table></figure>
<p>The <strong>IO</strong> library accumulates and stores the characters using an internal data structure named <strong>buffer</strong>, and <strong>flushes</strong> the buffer by writing the contents to the output device only when necessary. There are three events that cause the system to flush the buffer:</p>
<ul>
<li>the buffer might be full and the library will flush it automatically.</li>
<li>the library might be asked to read from the standard input stream. Then, it will flush the buffer immediately. This indicates another side effect of input operation.</li>
<li>when we explicitly say to do so: e.g. <strong>std::endl</strong>.</li>
</ul>
<p>The input operator <strong>&gt;&gt;</strong> is also left-associative and returns the left-hand operands as their results. Therefore, multiple reads can be done like below codes :</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s1, s2; <span class="comment">// define two string type variables</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; s1 &gt;&gt; s2; <span class="comment">// reads from cin into s1 and s2 seprately</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s1 &lt;&lt; s2 &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// writes two strings</span></span><br></pre></td></tr></table></figure>
<p>In some cases, we would like to read chars as well as whitespaces. To fulfill this, we need to use <strong>getline</strong> instead of <strong>&gt;&gt;</strong> with the syntax: </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::getline(<span class="built_in">std</span>::<span class="built_in">cin</span>, name)</span><br></pre></td></tr></table></figure>
<p>The <strong>getline</strong> function will read chars into variable <strong>name</strong> until it encounters <strong>line feed</strong> (note that the <strong>line feed</strong> will also be read but not stored into the variable). I modified the program using <strong>getline</strong>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ask for the person's name</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Please enter your full name: "</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read the name</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name; <span class="comment">// define name</span></span><br><span class="line">    <span class="built_in">std</span>::getline(<span class="built_in">std</span>::<span class="built_in">cin</span>, name); <span class="comment">// read into</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// write a greeting</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, "</span> &lt;&lt; name &lt;&lt; <span class="string">"!"</span>  &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>When I run the program and input “Bruce Lee”, it results:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Please enter your first name: Bruce Lee</span><br><span class="line">Hello, Bruce Lee!</span><br></pre></td></tr></table></figure>

<h2 id="The-string-size-and-concatenate-operations"><a href="#The-string-size-and-concatenate-operations" class="headerlink" title="The string size and concatenate operations"></a>The string size and concatenate operations</h2><p>Now we go into a little bit complex operations and aim to produce a framed greeting like below:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Please enter your full name: Bruce Lee </span><br><span class="line">*********************</span><br><span class="line">*                   *</span><br><span class="line">* Hello, Bruce Lee! *</span><br><span class="line">*                   *</span><br><span class="line">*********************</span><br></pre></td></tr></table></figure>
<p>Let’s provide the program first:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ask for a person's name, and generate a framed greeting</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Please enter your full name: "</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="built_in">std</span>::getline(<span class="built_in">std</span>::<span class="built_in">cin</span>, name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// build the message that we intend to write</span></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> greeting = <span class="string">"Hello, "</span> + name + <span class="string">"!"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// build the second and forth lines of the output</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">spaces</span><span class="params">(greeting.<span class="built_in">size</span>(), <span class="string">' '</span>)</span></span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> second = <span class="string">"* "</span> + spaces + <span class="string">" *"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// build the first and fifth lines of the output</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">first</span><span class="params">(second.<span class="built_in">size</span>(), <span class="string">'*'</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write it all</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; first &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; second &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"* "</span> &lt;&lt; greeting &lt;&lt; <span class="string">" *"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; second &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; first &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The first three statements are exactly the same as those in the last program. However, we define a new string type variable named <strong>greeting</strong> and initialize it with the message that we will write using opetator <strong>+</strong>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> greeting = <span class="string">"Hello, "</span> + name + <span class="string">"!"</span>;</span><br></pre></td></tr></table></figure>
<p>The keyword <strong>const</strong> means that the value of the variable keeps constant since the first time read in. The <strong>+</strong> concatenate two strings (may also be one string and one string literals but cannot be two string literals) into a single string. As mentioned in previous chapter, operators have different effect on operands depending on the types of operands, which is commonly termed as <strong>overloaded</strong>. Same as operators <strong>&gt;&gt;</strong> and <strong>&lt;&lt;</strong>, <strong>+</strong> is also left-associative. </p>
<p>The remainder parts of the frame is simply constituted by asterisks and spaces while the numbers of asterisks and spaces are determined by the size of <strong>greeting</strong>. Recalling the ways to initialize a string type variable filled by same chars(e.g. ‘a’):</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s0</span><span class="params">(<span class="number">5</span>, <span class="string">'a'</span>)</span></span>; <span class="comment">// s0 is aaaaa</span></span><br></pre></td></tr></table></figure>
<p>What we need here is to figure out the size of <strong>greeting</strong>. <strong>greeting.size()</strong> is a member function of the object. By calling this member function, we will obtain an integer that means the number of chars in <strong>greeting</strong>. The returned value is in fact not a <strong>int</strong> type value, but a <strong>string::size_type</strong>. In this case, we know that this value is unsigned and hence cann’t compare this value with other signed values for avoiding errors. If we don’t know what exactly the type is, we can use type deduction with specifiers <strong>auto</strong> and <strong>decltype</strong>. For example:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> len = greeting.<span class="built_in">size</span>();</span><br></pre></td></tr></table></figure>
<p>The variable <strong>len</strong> is <strong><strong>string::size_type</strong></strong>. Similarly:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(greeting.<span class="built_in">size</span>) len;</span><br></pre></td></tr></table></figure>
<p>The differences of these two specifiers are:</p>
<ul>
<li>the variable that defined using <strong>auto</strong> must have initializer.</li>
<li><strong>auto</strong>‘s type deduction ignores top-level <strong>const</strong>s but keeps low-level <strong>const</strong>s. But <strong>decltype</strong>‘s type deduction returns type including top-level <strong>const</strong>s. (This will be discussed again in chapter 10).</li>
</ul>
<h2 id="Random-access-using-a-subscript"><a href="#Random-access-using-a-subscript" class="headerlink" title="Random access using a subscript"></a>Random access using a subscript</h2><p>If there needs to access some characters of the string, we can use the <strong>subscript operator</strong>([]) to access and sequentially operate on individual characters. Inside the operator, an index value is required to denote the position of the character to be accessed. The operation returns a reference to the character of the given position.</p>
<p>The index value should be a value of type <strong>string::size_type</strong>, and its range should be <strong>&gt;= 0 and &lt; size()</strong>. In other words, it use asymmetric range [0, size()). To show more about the random access, I did a experiment as below</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;		<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str = &#123;<span class="string">"abcdef"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// obtain the size of str1</span></span><br><span class="line">    <span class="built_in">string</span>::size_type strSize = str.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// define an signed type variable</span></span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write the string one character by one character</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str[x] &lt;&lt; str[<span class="number">1</span>] &lt;&lt; str[<span class="number">2</span>] &lt;&lt; str[<span class="number">3</span>]</span><br><span class="line">        &lt;&lt;str[<span class="number">4</span>] &lt;&lt; str[strSize<span class="number">-1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// access the character beyond the range of [0, strSize-1)</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str[strSize] &lt;&lt; str[strSize + <span class="number">1</span>] &lt;&lt; str[<span class="number">10</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Results:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">abcdef</span><br><span class="line">  b</span><br></pre></td></tr></table></figure>
<p>The example above shows that it leads to unknown results if we use a subscript that beyond the range of [0, size()). In addition, it works if we use a integer value has a signed type (in contrast, the <strong>string::size_type</strong> is unsigned integeral value).<br>This is because the index value of the signed type can be converted to the type of <strong>string::size_type</strong>. </p>
<h2 id="Other-operations"><a href="#Other-operations" class="headerlink" title="Other operations"></a>Other operations</h2><p><strong>empty</strong> function returns a <strong>bool</strong> type value that indicates whether the string type variable is empty. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">greeting.empty(); <span class="comment">// if greeting is empty, it returns 1, otherwise returns 0;</span></span><br></pre></td></tr></table></figure>
<p><strong>&lt;, &lt;=, &gt;, &gt;=</strong> <em>“test whether one string is less than, less than or equal to, greater than, or greater than or equal to another. These operators use the same strategy as a (case-sensitive) dictionary”</em> (Lippman etc. 2012, p80). </p>
<hr>
<p>Next: C++ - Looping and counting.</p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Notes</tag>
      </tags>
  </entry>
  <entry>
    <title>Accelerated C++ Solutions to Exercises(Chapter 0)</title>
    <url>/2018/02/06/Accelerated-C-Solution-to-Exercise-Chapter%200/</url>
    <content><![CDATA[<p><strong>All the programs were compiled and excuted within the setting of Eclipse CDT and MinGW64</strong></p>
<hr>
<h1 id="Exercise-0-0"><a href="#Exercise-0-0" class="headerlink" title="Exercise 0-0"></a>Exercise 0-0</h1><p>Compile and run the <strong>Hello, world!</strong> program</p>
<h2 id="Solution-amp-Results"><a href="#Solution-amp-Results" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>Compile and run <strong>Hello, world!</strong> program with MinGW + Eclipse CDT:</p>
<p><img src="/images/Exercise0_0.PNG" alt="Hello, world!"></p>
<h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><p>See <a href="http://quanttour.com/02/02/2018/C++%20-%20Getting%20Started/" target="_blank" rel="noopener">C++ - Getting Started</a>. </p>
<hr>
<h1 id="Exercise-0-1"><a href="#Exercise-0-1" class="headerlink" title="Exercise 0-1"></a>Exercise 0-1</h1><p>What does the following statement do?</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> + <span class="number">4</span>;</span><br></pre></td></tr></table></figure>
<h2 id="Solution-amp-Results-1"><a href="#Solution-amp-Results-1" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>The expression statement yields 7 as its results because it contains two int type operands (i.e. 3 and 4), and one operator (i.e. addition). However, it has no side effects on the state of the program and the implementation. Hence, there should be nothing displayed on the console when the program is excuated. As expected, the graph below shows the result along with a warning description <em>statement has no effect ‘3+4’</em>. </p>
<p><img src="/images/Exercise0_1.PNG" alt="Expression Statement: 3+4;"></p>
<h2 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h2><p>See <a href="http://quanttour.com/02/02/2018/C++%20-%20Getting%20Started/" target="_blank" rel="noopener">C++ - Getting Started</a>.</p>
<hr>
<h1 id="Exercise-0-2"><a href="#Exercise-0-2" class="headerlink" title="Exercise 0-2"></a>Exercise 0-2</h1><p>Write a program that, when run, writes</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">This (&quot;) is a quote, and this (\) is a backslash.</span><br></pre></td></tr></table></figure>
<h2 id="Solution-amp-Results-2"><a href="#Solution-amp-Results-2" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>It seems that this program is exactly the same as the <strong>Hello, world!</strong> program in Exercise 0-0 once we replace the string literals. In doing so, however, the compiler reports errors as below graph shows. </p>
<p><img src="/images/Exercise0_2_1.PNG" alt="Compilation errors"></p>
<p>The the occurrence of errors is due to the facts：</p>
<ol>
<li>Characters should be enclosed in double quotes and the string literals is not allowed to span lines. </li>
<li>Some characters such as backslash or single/double quotes have special meaning in C++ language. </li>
<li>Some characters such as backspace or control character are <em>nonprintable</em>. </li>
</ol>
<p>Therefore, it is impossible to use such characters directly. Instead, the language provides <em>escape sequence</em> to represent such characters. The <em>escape sequence</em> begins with a backslash, i.e. in the form of <strong>\+character</strong>. The follow graph shows the right solution to this question.</p>
<p><img src="/images/Exercise0_2_2.PNG" alt="String literals output"></p>
<h2 id="Analysis-2"><a href="#Analysis-2" class="headerlink" title="Analysis"></a>Analysis</h2><p> The below table gives the <em>escape sequences</em> that are defined in C++ language. </p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>newline</td>
<td>\n</td>
<td>horizontal tab</td>
<td>\t</td>
<td>alert bell</td>
<td>\a</td>
</tr>
<tr>
<td>vertical</td>
<td>\v</td>
<td>backspace</td>
<td>\b</td>
<td>double quote</td>
<td>\“</td>
</tr>
<tr>
<td>backslash</td>
<td>\\</td>
<td>question mark</td>
<td>?</td>
<td>single quote</td>
<td>\‘</td>
</tr>
<tr>
<td>carriage return</td>
<td>\r</td>
<td>formfeed</td>
<td>\f</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>One can choose another syntax for using <em>Escape sequence</em>: a backslash followed by by hexadecimal or octal digits while the value represents the numerical value of the character. For example, the linefeed command in C++ can be written in three ways:</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>character</td>
<td>\n</td>
</tr>
<tr>
<td>octal digits</td>
<td>\12</td>
</tr>
<tr>
<td>hexadecimal digits</td>
<td>\x0a</td>
</tr>
</tbody></table>
<p>If a backslash followed by more than three octal digits, the <em>escape sequence</em> is only valid for the first three digits while the rest digits will be read as normal character. For example, <strong>‘\12345’</strong> is equivalent to <strong>‘S’</strong> followed by <strong>‘4’</strong> and <strong>‘5’</strong>. But if a backslash followed by the hex digits, the <em>escape sequence</em> uses all the hex digits. </p>
<hr>
<h1 id="Exercise-0-3"><a href="#Exercise-0-3" class="headerlink" title="Exercise 0-3"></a>Exercise 0-3</h1><p>The string literal “\t” represents a tab character; different C++ implementations display tabs in different ways. Experiment with your implementation to learn how it treats tabs. </p>
<h2 id="Solution-amp-Results-3"><a href="#Solution-amp-Results-3" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>In my view, the <em>different implementations</em> could be interpretated as: different C++ compilers or different versions, which may have different interpretation of C++ standards or different support for certain C++ features. Different IDEs or editors might also have an impact on the final displays of results due to various settings. Actually, I am not very sure about my understanding on this.</p>
<p>To test how different implementations display tabs, I wrote an output statement in which the Horizontal tab <strong>‘\t’</strong>  is inserted into a string literals in a random manner. Then, I run the program in four different environments. First I present the codes here：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Accelerated C++ Solution to Exercises 0-3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// for loops for generating 10 groups' string literals. </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">3</span>; j &lt; <span class="number">13</span>; j++)</span><br><span class="line">    &#123;   <span class="comment">// for loops for generating each character of the string literals</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> i = <span class="string">'A'</span>; i &lt; <span class="string">'z'</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i;</span><br><span class="line">        <span class="comment">// the insertation of the horizontal tab is </span></span><br><span class="line">        <span class="comment">// conditional on the bool expression: (int)i % j == 0</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">int</span>)i % j == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">'\t'</span>;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The following content displays four environment settings and the results. </p>
<h3 id="Linux-GNU-G-Vim-Editor"><a href="#Linux-GNU-G-Vim-Editor" class="headerlink" title="Linux   GNU(G++) + Vim Editor"></a>Linux   GNU(G++) + Vim Editor</h3><p><img src="/images/Exercise0_3_linvim.jpg" alt="Linux GNU + Vim"></p>
<h3 id="Linux-GNU-G-Eclipse"><a href="#Linux-GNU-G-Eclipse" class="headerlink" title="Linux   GNU(G++) + Eclipse"></a>Linux   GNU(G++) + Eclipse</h3><p><img src="/images/Exercise0_3_linec.png" alt="Linux GNU + Eclipse"></p>
<h3 id="Windows-MinGW-Vim-Editor"><a href="#Windows-MinGW-Vim-Editor" class="headerlink" title="Windows MinGW    + Vim Editor"></a>Windows MinGW    + Vim Editor</h3><p><img src="/images/Exercise0_3_minvim.PNG" alt="MinGW + Vim"></p>
<h3 id="Windows-MinGW-Eclipse"><a href="#Windows-MinGW-Eclipse" class="headerlink" title="Windows MinGW    + Eclipse"></a>Windows MinGW    + Eclipse</h3><p><img src="/images/Exercise0_3_minec.PNG" alt="MinGW + Eclipse"></p>
<p>Unfortunately, the experiments failed to response the question correctly as there is no difference between these implementations regarding to displaying tabs. But it reveals that the <strong>tab</strong> stops every 8 spaces and always aligns the followed text to the next stop, regardless of the position where the <strong>tab</strong> is inserted into. I will keep focus on this question and try to find a better solution to this question. </p>
<h2 id="Analysis-3"><a href="#Analysis-3" class="headerlink" title="Analysis"></a>Analysis</h2><p>To be continued.</p>
<hr>
<h1 id="Exercise-0-4"><a href="#Exercise-0-4" class="headerlink" title="Exercise 0-4"></a>Exercise 0-4</h1><p>Write a program that, when run, writes the <strong>Hello, world!</strong> program as its out put.</p>
<h2 id="Solution-amp-Results-4"><a href="#Solution-amp-Results-4" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>The question is not complicated. But, be carefull about the output of the nexted double quotes. </p>
<p><img src="/images/Exercise0_4.PNG" alt="Hello, world! program print"></p>
<h2 id="Analysis-4"><a href="#Analysis-4" class="headerlink" title="Analysis"></a>Analysis</h2><p>See <a href="http://quanttour.com/06/02/2018/Accelerated-C-Solution-to-Exercise-Chapter%200/" target="_blank" rel="noopener">Solution to Exercise 0-2</a>.</p>
<hr>
<h1 id="Exercise-0-5"><a href="#Exercise-0-5" class="headerlink" title="Exercise 0-5"></a>Exercise 0-5</h1><p>Is this a valid program? Why or why not?</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line">int main() std::cout &lt;&lt; "Hello, world!" &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<h2 id="Solution-amp-Results-5"><a href="#Solution-amp-Results-5" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>The program is invalid as shown below:</p>
<p><img src="/images/Exercise0_5.PNG" alt="A invalid program"></p>
<p>It is clear that <strong>curly braces</strong> are missing for a complete <strong>main function</strong> in this program. A correct main function should include a function body which is a block of statements enclosed by a pair of <strong>curly braces</strong>. </p>
<h2 id="Analysis-5"><a href="#Analysis-5" class="headerlink" title="Analysis"></a>Analysis</h2><p>If one has no any programming knowledge, he probabily can’t figure out the error only from the error reports: </p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">expected initializer before 'std'</span><br></pre></td></tr></table></figure>
<p>Why the compile error shows like this? A possible reason is that the compiler treats codes outside the function as declarations of variables. To define a variable, one should firstly specify the <strong>type specifier</strong> and then declare the <strong>name</strong> of the variable, and finally add a semicolon. Once the variable is created, it is initialized. Consider that the compiler treats <strong><em>int main()</em></strong> as a declaration of a variable, it will find that the initialization of this variable is failed due to lacking of a semicolon. </p>
<hr>
<h1 id="Exercise-0-6"><a href="#Exercise-0-6" class="headerlink" title="Exercise 0-6"></a>Exercise 0-6</h1><p>Is this a valid program? Why or why not?</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;&#123;&#123;&#123;&#123;&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, world! &lt;&lt; std::endl;&#125;&#125;&#125;&#125;&#125;&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="Solution-amp-Results-6"><a href="#Solution-amp-Results-6" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>In contrast to the program in Exercise 0-5, this program is valid because it has a complete structure of a main function. Beyond the outmost curly bracces, the rest curly braces form independent blocks and can be nested. </p>
<p><img src="/images/Exercise0_6.PNG" alt="A valid program"></p>
<h2 id="Analysis-6"><a href="#Analysis-6" class="headerlink" title="Analysis"></a>Analysis</h2><p>See <a href="http://quanttour.com/02/02/2018/C++%20-%20Getting%20Started/" target="_blank" rel="noopener">C++ - Getting Started</a> and <a href="http://quanttour.com/06/02/2018/Accelerated-C-Solution-to-Exercise-Chapter%200/" target="_blank" rel="noopener">Solution to Exercise 0-5</a>.</p>
<hr>
<h1 id="Exercise-0-7"><a href="#Exercise-0-7" class="headerlink" title="Exercise 0-7"></a>Exercise 0-7</h1><p>Is this a valid program? Why or why not?</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*This is a comment that extends over several lines</span></span><br><span class="line"><span class="comment">      because it uses /* and */</span> as its starting <span class="keyword">and</span> ending delimiters */</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Does this work?"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Solution-amp-Results-7"><a href="#Solution-amp-Results-7" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>The program is invalid：</p>
<p><img src="/images/Exercise0_7.PNG" alt="A invalid program"></p>
<p>As mentioned in <a href="http://quanttour.com/02/02/2018/C++%20-%20Getting%20Started/" target="_blank" rel="noopener">C++ - Getting Started</a>, comment pairs cannot nest. The warning also confirms this restriction.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">..\Exercise0_7.cpp:7:25: warning: &quot;&#x2F;*&quot; within comment [-Wcomment]</span><br></pre></td></tr></table></figure>
<p>To Solve the problem, we can add single line comments before each lines of comments. Below graph gives the correct implementation:</p>
<p><img src="/images/Exercise0_7_1.PNG" alt="A valid program"></p>
<h2 id="Analysis-7"><a href="#Analysis-7" class="headerlink" title="Analysis"></a>Analysis</h2><p>See <a href="http://quanttour.com/02/02/2018/C++%20-%20Getting%20Started/" target="_blank" rel="noopener">C++ - Getting Started</a>.</p>
<hr>
<h1 id="Exercise-0-8"><a href="#Exercise-0-8" class="headerlink" title="Exercise 0-8"></a>Exercise 0-8</h1><p>Is this a valid program? Why or why not?</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// This is a comment that extends over several lines</span></span><br><span class="line">    <span class="comment">// by using // at the begining of each line instead of </span></span><br><span class="line">    <span class="comment">// using /* or */ to delimit comments.</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Does this work?"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h2 id="Solution-amp-Results-8"><a href="#Solution-amp-Results-8" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>It is a valid program which successfully corrects the program in Exercise0-7</p>
<p><img src="/images/Exercise0_8.PNG" alt="A valid program"></p>
<h2 id="Analysis-8"><a href="#Analysis-8" class="headerlink" title="Analysis"></a>Analysis</h2><p>See <a href="http://quanttour.com/02/02/2018/C++%20-%20Getting%20Started/" target="_blank" rel="noopener">C++ - Getting Started</a> and <a href="http://quanttour.com/06/02/2018/Accelerated-C-Solution-to-Exercise-Chapter%200/" target="_blank" rel="noopener">Solution to Exercise 0-7</a>.</p>
<hr>
<h1 id="Exercise-0-9"><a href="#Exercise-0-9" class="headerlink" title="Exercise 0-9"></a>Exercise 0-9</h1><p>What is the shortest valid program?</p>
<h2 id="Solution-amp-Results-9"><a href="#Solution-amp-Results-9" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>As I mentioned in <a href="http://quanttour.com/02/02/2018/C++%20-%20Getting%20Started/" target="_blank" rel="noopener">C++ - Getting Started</a>, a valid program must contain a main function while a main function includes four elements: <strong><em>return type, function name, parameter list and function body</em></strong>. </p>
<p>Therefore, the shortest valid program works like this：</p>
<p><img src="/images/Exercise0_9.PNG" alt="The shortest valid program"></p>
<p>Andrew Koenig who is the author of <strong><em>Accelerated C++: Practical Programming by Example</em></strong> states: </p>
<ol>
<li>generally, functions must include at least one return statement.</li>
<li>the main function is special and may omit the return. In this case, the implementation will assume a return value of zero. </li>
</ol>
<p>The shortest valid program I present here omits the <strong>return</strong> statement. But as pointed out by Andrew Koenig, explicitly including a return from <strong>main</strong> function is a good practice. </p>
<h2 id="Analysis-9"><a href="#Analysis-9" class="headerlink" title="Analysis"></a>Analysis</h2><p>See <a href="http://quanttour.com/02/02/2018/C++%20-%20Getting%20Started/" target="_blank" rel="noopener">C++ - Getting Started</a>.</p>
<hr>
<h1 id="Exercise-0-10"><a href="#Exercise-0-10" class="headerlink" title="Exercise 0-10"></a>Exercise 0-10</h1><p>Rewrite the <strong>Hello, world!</strong> program so that a newline occurs everywhere that whitespace is allowed in the program.</p>
<h2 id="Solution-amp-Results-10"><a href="#Solution-amp-Results-10" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>Recalling the <strong>Hello, world!</strong> program:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, world!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>There exits one space in the string literals Hello, world!”. I would replace the space with a newline character <strong>\n</strong>. The graph below shows my implementation and result:</p>
<p><img src="/images/Exercise0_10.PNG" alt="New Hello, world! program"></p>
<h2 id="Analysis-10"><a href="#Analysis-10" class="headerlink" title="Analysis"></a>Analysis</h2><p>See <a href="http://quanttour.com/02/02/2018/C++%20-%20Getting%20Started/" target="_blank" rel="noopener">C++ - Getting Started</a>. </p>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p>Koenig, A. and Moo, B.E., 2000. Accelerated C++.</p>
<p>Lippman, S.B., Lajoie, J. and Moo, B.E., 2013. C++ Primer, 5th edt.</p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Accelerated C++ Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ - Getting Started</title>
    <url>/2018/02/02/C++%20-%20Getting%20Started/</url>
    <content><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>To have a better understanding on the C++ programming language, I decided to learn it from the very begining and take detailed notes from the textbooks <a href="https://www.amazon.com/Accelerated-C-Practical-Programming-Example/dp/020170353X" target="_blank" rel="noopener">Accelerated C++: Practical Programming by Example</a> and <a href="https://www.amazon.com/Primer-5th-Stanley-B-Lippman/dp/0321714113" target="_blank" rel="noopener">C++ Primer (5th Edition)</a>, and some online C++ tutorials. In addition, I plan to complete the exercises of each chapter in the <a href="https://www.amazon.com/Accelerated-C-Practical-Programming-Example/dp/020170353X" target="_blank" rel="noopener">Accelerated C++</a> with providing detailed codes analysis and implementation processes.<br>Please check the solutions to the first chapter exercises here: <a href="http://quanttour.com/06/02/2018/Accelerated-C-Solution-to-Exercise-Chapter%200/" target="_blank" rel="noopener">Accelerated C++ Solutions to Exercises Chapter 0</a></p>
<h1 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello, world!"></a>Hello, world!</h1><p>Let’s start by writing a simple program, <strong>Hello, world!</strong>, and then analyse its <strong>structure</strong>.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* A simple C++ Program</span></span><br><span class="line"><span class="comment">* Author: Mr. Nobody</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;	</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// output Hello, world!</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, world!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0-1-Comments"><a href="#0-1-Comments" class="headerlink" title="0.1 Comments"></a>0.1 Comments</h1><p>As shown above, there are two types of comments in C++:</p>
<ol>
<li>Single line comment indicated by two slash signs <strong>//</strong>.</li>
<li>Comment pairs using two delimiters, beigining with a <strong>/*</strong> and ending with a <strong>*/</strong>. </li>
</ol>
<h1 id="0-2-include"><a href="#0-2-include" class="headerlink" title="0.2 #, #include"></a>0.2 #, #include</h1><p>Lines begining with <strong>#</strong> are preprocessor directives which are preprocessed before actual compilation, i.e. the compilation of the program itself. These preprocessor directives are not part of the program statement, and hence semicolons <strong>;</strong>, marking the end of most statements in C++, are not required.  </p>
<p>The directive <strong>#include</strong> gives preprocessor instructions to include a header file, i.e. copy the entire content of the specified header or file and insert. There are two ways to use **#include#:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;header&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"file"</span></span></span><br></pre></td></tr></table></figure>
<p>The angle-brackets <strong>&lt;&gt;</strong> are generally used to include a header of the standard library, e.g. iostream, string…, while the quotes <strong>“”</strong> include a file that is typically programmer-defined. For example, the program above includes a standard header named <strong>iostream</strong> to accomplish Input-Output (<strong>IO</strong>) as the C++ language doesn’t define any statements to do <strong>IO</strong>. </p>
<h1 id="0-3-The-main-function"><a href="#0-3-The-main-function" class="headerlink" title="0.3 The main function"></a>0.3 The main function</h1><p>Every C++ program must contain a <strong>main</strong> function. The main function is being called when the operating system runs a program. As same as other functions, the main function also includes four elements: <em>return type</em>, <em>function name</em>, <em>parameter list</em> and <em>function body</em>.     </p>
<p>The main function requires an <strong>int</strong> (i.e. integers) type return value. A return value of zero tells the implementation that the program ran successfully while a non-zero value indicates errors. The example above has an empty parameter list, showing that there is nothing between the parentheses (<strong>()</strong>). </p>
<p>The function body begins with an open curly brace (<strong>{</strong>) and ends with a close curly brace (<strong>}</strong>). The braces indicate that all the statements inside are part of the same function, of which the return statement terminates the execution of the function by returning a value to the function’s caller. Of course, the value that returned should has the same type as the defined return type of the function. In the case of <em>main function</em>, if the return statement is omitted, the implementation would assume a return value of zero (<em><strong>not recommended</strong></em>).  </p>
<h1 id="0-4-IO-amp-using-declarations"><a href="#0-4-IO-amp-using-declarations" class="headerlink" title="0.4 IO &amp; using declarations"></a>0.4 IO &amp; using declarations</h1><p>Before the return statement inside the braces, the first statement (as shown below) achieves the goal of this program. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, world!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>As mentioned above, the statement writes <strong>Hello, World!</strong> on the standard output. The <strong>std::</strong> indicates the followed name is part of the namespace named std. The names <strong>std::cout</strong> and <strong>std::cin</strong> refer to the objects of the standard output stream (<strong>ostream</strong>) and input stream (<strong>istream</strong>), which had already been defined in the <strong>iostream</strong> library. Another two objects that are defined in the <strong>iostream</strong> library are <strong>cerr</strong> and <strong>clog</strong>. The <strong>cerr</strong>, representing <strong>standard error</strong>, is used to output warning or error messages. The <strong>clog</strong> is used to output the general information about the execution of the program. The name <strong>std::endl</strong>, which is a manipulator, ends the current line of output. The output operator (<strong>&lt;&lt;</strong>) and input operator (<strong>&gt;&gt;</strong>) indicate that what follows is inserted to <strong>std::cout</strong> and <strong>std::cin</strong>. To use these objects, firstly we need to include the associated standard header, namely <strong>iostream</strong>. </p>
<p>To simplify the usage of library names from namesapce <strong>std</strong>, one could use unqualified names <strong>cout</strong> or <strong>cin</strong> instead of <strong>std::cout</strong> or <strong>std::cin</strong> by the means of <em>using declarations</em>. For example, above program is exactly as same as the below program:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* A simple C++ Program</span></span><br><span class="line"><span class="comment">* Author: Mr. Nobody</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;	</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// output Hello, world!</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, world!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;f</span><br></pre></td></tr></table></figure>
<p>It should be noted that <strong>Headers</strong> should not include <em>using declarations</em> for the purpose of avoiding potential name confilits. </p>
<h1 id="0-5-Expressions-amp-Scope"><a href="#0-5-Expressions-amp-Scope" class="headerlink" title="0.5 Expressions &amp; Scope"></a>0.5 Expressions &amp; Scope</h1><p>An <em>Expression</em> typically contains <em>operators</em> and <em>operands</em>. It becomes an <em>expression statement</em> when it is followed by a semicolon. The expression statement asks the implementation to compute or evaluate the expression but discards the results. However, the computation may lead to side effects such as printing a result. For example:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> + <span class="number">4</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, world!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>The first statement yields a result 7 but has no side effects. In other words, it is useless because the result is discarded. The second statement is useful because of its side effects, that is, the string is inserted into the standard output stream and hence is printed out. </p>
<p>In this case, <strong>&lt;&lt;</strong> symbols are operators while <strong>std::cout</strong>, <strong>std::endl</strong> and <strong>Hello, world!</strong> are operands. Every operand has a type that determines the effect of the operators. As mentioned above, <strong>std::cout</strong> has type <strong>std::ostream</strong>. Then, the operator <strong>&lt;&lt;</strong> writes the given value (i.e. its right-hand operand) on the given <strong>ostream</strong> (i.e. the left-hand operand)</p>
<p>The operator <strong>&lt;&lt;</strong> is <em>left-associative</em>, that is, the operator returns its left-hand operands. The second <strong>&lt;&lt;</strong> has following relationships with its left and right operands, connecting the output requests.  </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, world!"</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>The scope of a name is the part of a program, in which the name is valid. The above program shows two kinds of scopes: one kind is <em>namespace scope</em>, i.e. scope name <strong>std</strong> and scope operator <strong>::</strong>; another kind is <em>block scope</em> formed by curly braces. </p>
<h1 id="0-6-Others"><a href="#0-6-Others" class="headerlink" title="0.6 Others"></a>0.6 Others</h1><p>Another aspect is that C++ programs do not have strict requirements on <em>indentation</em> and <em>spaces</em>, allowing improving readability based on personal preference. However, three entities are not allowed to be used in a free-form. </p>
<ol>
<li><em>string literals</em> which enclosed in double quotes are generally not span lines.</li>
<li><em>preprocessor directive</em> should be put on its own line. </li>
<li><em><strong>//</strong> type comments</em> should ends at the end of the current line, and  <em>/***/</em> type comments cannot nest.</li>
</ol>
<hr>
<p>Next: <a href="http://quanttour.com/11/02/2018/C-Working-with-strings/" target="_blank" rel="noopener">C++ - Working with strings</a>.</p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Notes</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2018/02/01/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
</search>
