<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Times New Roman:300,300italic,400,400italic,700,700italic|Courier New:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"quantein.com","root":"/","scheme":"Muse","version":"7.7.2","exturl":false,"sidebar":{"position":"right","display":"post","padding":60,"offset":12,"onmobile":true},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Stochastic Modelling Notes; Programming Notes">
<meta property="og:type" content="website">
<meta property="og:title" content="Liam&#39;s Blog">
<meta property="og:url" content="http://quantein.com/page/2/index.html">
<meta property="og:site_name" content="Liam&#39;s Blog">
<meta property="og:description" content="Stochastic Modelling Notes; Programming Notes">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Liam">
<meta property="article:tag" content="Stochastic Modelling Notes; Programming Notes">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://quantein.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false
  };
</script>

  <title>Liam's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Liam's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">If history repeats itself, and the unexpected always happens, how incapable must Man be of learning from experience?â€”George Bernard Shaw.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="search-pop-overlay">
  <div class="popup search-popup">
      <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

  </div>
</div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/quantliam" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://quantein.com/2018/05/14/C-Revisiting-character-pictures/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liam">
      <meta itemprop="description" content="Stochastic Modelling Notes; Programming Notes">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Liam's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/05/14/C-Revisiting-character-pictures/" class="post-title-link" itemprop="url">C++ - Revisiting character pictures</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-05-14 16:00:05" itemprop="dateCreated datePublished" datetime="2018-05-14T16:00:05+08:00">2018-05-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2018-05-16 00:09:26" itemprop="dateModified" datetime="2018-05-16T00:09:26+08:00">2018-05-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Programming/" itemprop="url" rel="index"><span itemprop="name">Programming</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span></span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>NaN:aN</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://quantein.com/2018/05/14/Sorting-Algorithms-C-Implementations-Bubble-Sort/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liam">
      <meta itemprop="description" content="Stochastic Modelling Notes; Programming Notes">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Liam's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/05/14/Sorting-Algorithms-C-Implementations-Bubble-Sort/" class="post-title-link" itemprop="url">Sorting Algorithms C++ Implementations - Bubble Sort</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2018-05-14 15:50:17 / Modified: 15:57:10" itemprop="dateCreated datePublished" datetime="2018-05-14T15:50:17+08:00">2018-05-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithms/" itemprop="url" rel="index"><span itemprop="name">Algorithms</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span></span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>NaN:aN</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Bubble-Sort"><a href="#Bubble-Sort" class="headerlink" title="Bubble Sort"></a>Bubble Sort</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*-----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * main.cpp || Created on: 13 May 2018 || Author: Liam</span></span><br><span class="line"><span class="comment"> *-----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * this program tests the bubble sort algorithm implemented in three ways</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Logic:</span></span><br><span class="line"><span class="comment"> * 1. each time find the largest number of the unsorted sequence and put it at</span></span><br><span class="line"><span class="comment"> *    the last position of the sequence. Then the unsorted sequence becomes the</span></span><br><span class="line"><span class="comment"> *    sequence, which is the original sequence excludes the last element.</span></span><br><span class="line"><span class="comment"> *	      * compare adjacent numbers one pair by one pair from the begining</span></span><br><span class="line"><span class="comment"> *	        position to the second last position, and exchange the position of</span></span><br><span class="line"><span class="comment"> * 	        two numbers if left-side number is larger than the right-side number</span></span><br><span class="line"><span class="comment"> * 	      * after each iteration, right-most position of the unsorted sequence</span></span><br><span class="line"><span class="comment"> * 	        holds the largest element, and hence the unsorted sequence becomes</span></span><br><span class="line"><span class="comment"> *    		the sequence, which is the original sequence excludes the last</span></span><br><span class="line"><span class="comment"> * 	        element.</span></span><br><span class="line"><span class="comment"> * 2. repectively perform step 1. There are two cases that the iteration stops:</span></span><br><span class="line"><span class="comment"> * 	      * the unsorted sequence only has one number left</span></span><br><span class="line"><span class="comment"> *            * there is no any exchange happens in last iteration, which means that</span></span><br><span class="line"><span class="comment"> *              all elements are in order already. Therefore, we do not need to</span></span><br><span class="line"><span class="comment"> *              perform step 1 again. In this case, we get the best time complexity</span></span><br><span class="line"><span class="comment"> *              if the sequence is completely sorted after the first iteration.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Complexity analysis:</span></span><br><span class="line"><span class="comment"> * time complexity: Best = O(n), Average, Worst = O(n^2)</span></span><br><span class="line"><span class="comment"> * auxiliary space: worst-case = O(1)</span></span><br><span class="line"><span class="comment"> *-----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p> <strong>Implementations</strong><br> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">ifndef</span> SORTINGALGORITHMS_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SORTINGALGORITHMS_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// array based version</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(T* p, <span class="built_in">std</span>::<span class="keyword">size_t</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">std</span>::<span class="keyword">size_t</span> i = n<span class="number">-1</span>; i != <span class="number">0</span>; --i)&#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">std</span>::<span class="keyword">size_t</span> j = <span class="number">0</span>; j != i; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p[j] &gt; p[j+<span class="number">1</span>])&#123;</span><br><span class="line">                T temp = p[j];</span><br><span class="line">                p[j] = p[j+<span class="number">1</span>];</span><br><span class="line">                p[j+<span class="number">1</span>] = temp;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="literal">true</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// iterator based version STL style (c++11)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> BidirectionalIterator&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(BidirectionalIterator <span class="built_in">begin</span>, BidirectionalIterator <span class="built_in">end</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">begin</span> == <span class="built_in">end</span>)  <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> endIter = <span class="built_in">std</span>::prev(<span class="built_in">end</span>); endIter != <span class="built_in">begin</span>; --endIter)&#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> iter = <span class="built_in">begin</span>; iter != endIter; ++iter)&#123;</span><br><span class="line">            <span class="keyword">auto</span> iterNext = <span class="built_in">std</span>::next(iter);</span><br><span class="line">            <span class="keyword">if</span>(*iter &gt; *iterNext)&#123;</span><br><span class="line">                <span class="built_in">std</span>::iter_swap(iter, iterNext);</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="literal">true</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// iterator based version with user-defined comparator</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> BidirectionalIterator, <span class="keyword">typename</span> Comparator&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(BidirectionalIterator <span class="built_in">begin</span>, BidirectionalIterator <span class="built_in">end</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        Comparator comp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">begin</span> == <span class="built_in">end</span>)  <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> endIter = <span class="built_in">std</span>::prev(<span class="built_in">end</span>); endIter != <span class="built_in">begin</span>; --endIter)&#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> iter = <span class="built_in">begin</span>; iter != endIter; ++iter)&#123;</span><br><span class="line">            <span class="keyword">auto</span> iterNext = <span class="built_in">std</span>::next(iter);</span><br><span class="line">            <span class="keyword">if</span>(comp(*iterNext, *iter))&#123;</span><br><span class="line">                <span class="built_in">std</span>::iter_swap(iter, iterNext);</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="literal">true</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* SORTINGALGORITHMS_H_ */</span></span></span><br></pre></td></tr></table></figure></p>
<p><strong>Test Program-main.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SortingAlgorithms.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">list</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// struct defined for testing</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span>&#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// comparator 1</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">compare_age</span>(<span class="title">const</span> <span class="title">T</span>&amp; <span class="title">x</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">y</span>)&#123;</span></span><br><span class="line">    <span class="keyword">return</span> x.age &lt; y.age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// comparator 2</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">compare_name</span>(<span class="title">const</span> <span class="title">T</span>&amp; <span class="title">x</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">y</span>)&#123;</span></span><br><span class="line">    <span class="keyword">return</span> x.name &lt; y.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// test 1: array-based version</span></span><br><span class="line">    <span class="keyword">double</span> arr[<span class="number">10</span>] = &#123;<span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    BubbleSort(arr, arr+ <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Sorted array: "</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i != <span class="number">10</span>; ++i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// test 2: iterator-based version</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">str</span><span class="params">(<span class="string">"eclipseworkspace"</span>)</span></span>;</span><br><span class="line">    BubbleSort(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Sorted string "</span> &lt;&lt; str &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; l&#123;<span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    BubbleSort(l.<span class="built_in">begin</span>(), l.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Sorted list: "</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i: l)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// test 3: user-defined comparator</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;student&gt; students;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>)&#123;</span><br><span class="line">        student temp;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; temp.name &gt;&gt; temp.age;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">cin</span>)</span><br><span class="line">            students.push_back(temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BubbleSort(students.<span class="built_in">begin</span>(), students.<span class="built_in">end</span>(), compare_age&lt;student&gt;);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Sorted vector according to age:\n"</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i: students)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i.name &lt;&lt; <span class="string">" "</span> &lt;&lt; i.age &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">    BubbleSort(students.<span class="built_in">begin</span>(), students.<span class="built_in">end</span>(), compare_name&lt;student&gt;);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Sorted vector according to name:\n"</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i: students)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i.name &lt;&lt; <span class="string">" "</span> &lt;&lt; i.age &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Outputs:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Sorted array: 1 2 3 4 5 6 7 8 9 10 </span><br><span class="line">Sorted string acceeeiklopprssw</span><br><span class="line">Sorted list: 1 2 3 4 5 6 7 8 9 10 </span><br><span class="line">John 18</span><br><span class="line">Mike 16</span><br><span class="line">Liam 23</span><br><span class="line">Anna 26</span><br><span class="line">Bobo 21</span><br><span class="line">Sorted vector according to age:</span><br><span class="line">Mike 16</span><br><span class="line">John 18</span><br><span class="line">Bobo 21</span><br><span class="line">Liam 23</span><br><span class="line">Anna 26</span><br><span class="line">Sorted vector according to name:</span><br><span class="line">Anna 26</span><br><span class="line">Bobo 21</span><br><span class="line">John 18</span><br><span class="line">Liam 23</span><br><span class="line">Mike 16</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://quantein.com/2018/05/09/Sorting-Algorithms-C-Implementations/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liam">
      <meta itemprop="description" content="Stochastic Modelling Notes; Programming Notes">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Liam's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/05/09/Sorting-Algorithms-C-Implementations/" class="post-title-link" itemprop="url">Sorting Algorithms C++ Implementations-Selection Sort</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-05-09 23:31:24" itemprop="dateCreated datePublished" datetime="2018-05-09T23:31:24+08:00">2018-05-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2018-05-10 23:49:13" itemprop="dateModified" datetime="2018-05-10T23:49:13+08:00">2018-05-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithms/" itemprop="url" rel="index"><span itemprop="name">Algorithms</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span></span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>NaN:aN</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Selection-Sort"><a href="#Selection-Sort" class="headerlink" title="Selection Sort"></a>Selection Sort</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*-----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * Created on: 9 May 2018 || Author: Liam</span></span><br><span class="line"><span class="comment"> *-----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * This file contains three generic functions that implement</span></span><br><span class="line"><span class="comment"> * the selection sort algorithm, and a test program</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Logical steps:</span></span><br><span class="line"><span class="comment"> * 1. select the minimum value from the sequence</span></span><br><span class="line"><span class="comment"> * 2. put the minimun value in the first position</span></span><br><span class="line"><span class="comment"> * 3. ignore the first position and sort the remaining</span></span><br><span class="line"><span class="comment"> *	  sequence by repetitively executing step 1 and 2</span></span><br><span class="line"><span class="comment"> *	  till the last number</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Complexity analysis:</span></span><br><span class="line"><span class="comment"> * time complexity: Best, Average and Worst-case = O(n^2)</span></span><br><span class="line"><span class="comment"> * auxiliary space: worst-case = O(1)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *-----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p><strong>Implementations</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SORTINGALGORITHMS_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SORTINGALGORITHMS_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// built-in array-based version</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectionSort</span><span class="params">(T* p, <span class="built_in">std</span>::<span class="keyword">size_t</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">std</span>::<span class="keyword">size_t</span> i = <span class="number">0</span>; i != n<span class="number">-1</span>; ++i)&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="keyword">size_t</span> imin = i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">std</span>::<span class="keyword">size_t</span> j = imin+<span class="number">1</span>; j != n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(p[i] &gt; p[j])</span><br><span class="line">                    imin = j;</span><br><span class="line">            &#125;</span><br><span class="line">            T temp = p[i];</span><br><span class="line">            p[i] = p[imin];</span><br><span class="line">            p[imin] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// iterator-based version STL style (C++11)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ForwardIterator&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectionSort</span><span class="params">(ForwardIterator <span class="built_in">begin</span>, ForwardIterator <span class="built_in">end</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">begin</span> != <span class="built_in">end</span>; ++<span class="built_in">begin</span>)&#123;</span><br><span class="line">        <span class="keyword">auto</span> imin = <span class="built_in">std</span>::min_element(<span class="built_in">begin</span>, <span class="built_in">end</span>);</span><br><span class="line">        <span class="keyword">if</span>(imin != <span class="built_in">begin</span>)</span><br><span class="line">            <span class="built_in">std</span>::iter_swap(<span class="built_in">begin</span>, imin);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// iterator-based version with comparator</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ForwardIterator, <span class="keyword">typename</span> Comparator&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectionSort</span><span class="params">(ForwardIterator <span class="built_in">begin</span>, ForwardIterator <span class="built_in">end</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        Comparator comp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; <span class="built_in">begin</span> != <span class="built_in">end</span>; ++<span class="built_in">begin</span>)&#123;</span><br><span class="line">        <span class="keyword">auto</span> imin = <span class="built_in">std</span>::min_element(<span class="built_in">begin</span>, <span class="built_in">end</span>, comp);</span><br><span class="line">        <span class="keyword">if</span>(imin != <span class="built_in">begin</span>)</span><br><span class="line">            <span class="built_in">std</span>::iter_swap(<span class="built_in">begin</span>, imin);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* SORTINGALGORITHMS_H_ */</span></span></span><br></pre></td></tr></table></figure>

<p><strong>Test Program-main.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;	// std::cout, endl</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;	// std::string</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;		// std::list</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;	// std::vector</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SortingAlgorithms.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">list</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// struct defined for testing</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span>&#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// comparator 1</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">compare_age</span>(<span class="title">const</span> <span class="title">T</span>&amp; <span class="title">x</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">y</span>)&#123;</span></span><br><span class="line">    <span class="keyword">return</span> x.age &lt; y.age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// comparator 2</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">compare_name</span>(<span class="title">const</span> <span class="title">T</span>&amp; <span class="title">x</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">y</span>)&#123;</span></span><br><span class="line">    <span class="keyword">return</span> x.name &lt; y.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// test 1: array-based version</span></span><br><span class="line">    <span class="keyword">double</span> arr[<span class="number">10</span>] = &#123;<span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    SelectionSort(arr, arr+ <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Sorted array: "</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i != <span class="number">10</span>; ++i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// test 2: iterator-based version</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">str</span><span class="params">(<span class="string">"eclipseworkspace"</span>)</span></span>;</span><br><span class="line">    SelectionSort(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Sorted string "</span> &lt;&lt; str &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; l&#123;<span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    SelectionSort(l.<span class="built_in">begin</span>(), l.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Sorted list: "</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i: l)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// test 3: user-defined comparator</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;student&gt; students;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>)&#123;</span><br><span class="line">        student temp;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; temp.name &gt;&gt; temp.age;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">cin</span>)</span><br><span class="line">            students.push_back(temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SelectionSort(students.<span class="built_in">begin</span>(), students.<span class="built_in">end</span>(), compare_age&lt;student&gt;);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Sorted vector according to age:\n"</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i: students)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i.name &lt;&lt; <span class="string">" "</span> &lt;&lt; i.age &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">    SelectionSort(students.<span class="built_in">begin</span>(), students.<span class="built_in">end</span>(), compare_name&lt;student&gt;);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Sorted vector according to name:\n"</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i: students)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i.name &lt;&lt; <span class="string">" "</span> &lt;&lt; i.age &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Outputs:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Sorted array: 1 2 3 4 5 6 7 8 9 10 </span><br><span class="line">Sorted string acceeeiklopprssw</span><br><span class="line">Sorted list: 1 2 3 4 5 6 7 8 9 10 </span><br><span class="line">John 18</span><br><span class="line">Mike 16</span><br><span class="line">Liam 23</span><br><span class="line">Anna 26</span><br><span class="line">Bobo 21</span><br><span class="line">Sorted vector according to age:</span><br><span class="line">Mike 16</span><br><span class="line">John 18</span><br><span class="line">Bobo 21</span><br><span class="line">Liam 23</span><br><span class="line">Anna 26</span><br><span class="line">Sorted vector according to name:</span><br><span class="line">Anna 26</span><br><span class="line">Bobo 21</span><br><span class="line">John 18</span><br><span class="line">Liam 23</span><br><span class="line">Mike 16</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://quantein.com/2018/05/09/C-Managing-memory-almost-automatically/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liam">
      <meta itemprop="description" content="Stochastic Modelling Notes; Programming Notes">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Liam's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/05/09/C-Managing-memory-almost-automatically/" class="post-title-link" itemprop="url">C++ - Managing memory (almost) automatically</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-05-09 22:19:53" itemprop="dateCreated datePublished" datetime="2018-05-09T22:19:53+08:00">2018-05-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2018-05-13 23:09:08" itemprop="dateModified" datetime="2018-05-13T23:09:08+08:00">2018-05-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Programming/" itemprop="url" rel="index"><span itemprop="name">Programming</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span></span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>NaN:aN</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>In last chapter, we write a new class named <strong>Student_info</strong> to encapsulate the pointer to <strong>Core</strong> so that we do not need to concern about the memory management. Now weâ€™ll further improve our class by seperating the class into two classes: one is a pure interface class and the other is a single pointerlike class which manages the underlying memory. The purpose to do so is that we then can use the pointerlike class with mutiple interface classes. In addition, by doing so, we can avoid copying objects unnecessarily. So what do we mean by saying <strong>copy an object</strong>? If an object <strong>x</strong> refers to an object <strong>y</strong>, does copying <strong>x</strong> cause <strong>y</strong> to be copied too ?</p>
<ol>
<li>if <strong>y</strong> is a memer of <strong>x</strong>, the answer must be yes</li>
<li>if <strong>x</strong> is nothing but a pointer to <strong>y</strong>, the answer is no.</li>
</ol>
<p>This chapter defines three versions of our pointerlike class, each of which differs from the others in how it defines copying. </p>
<h1 id="Handles-that-copy-their-objects"><a href="#Handles-that-copy-their-objects" class="headerlink" title="Handles that copy their objects"></a>Handles that copy their objects</h1><p>It is known that <strong>pointer</strong> is a primitive, low-level data structure. Working with <strong>pointers</strong> directly may leads to severe mistakes due to the fact that <strong>pointers</strong> are independent of the objects to which they point(Koenig and Moo 2000): </p>
<p><em>1. Copying a pointer doesnâ€™t copy the corresponding object, leading to surprises if two pointers inadvertently point to the same object.</em> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>);   <span class="comment">// p: pointer to an int object that has value 10</span></span><br><span class="line"><span class="keyword">int</span>* q = p;             <span class="comment">// q: points to the same int object </span></span><br><span class="line">*q = <span class="number">100</span>;               <span class="comment">// if we modify the object pointed by q</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *p;             <span class="comment">// we inevitably changes the object pointed by p</span></span><br><span class="line">                        <span class="comment">// the output is 100</span></span><br></pre></td></tr></table></figure>
<p><em>2. Destroying a pointer doesnâ€™t destroy its object, leading to memory leaks.</em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nameless</span><span class="params">(<span class="keyword">size_t</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="keyword">int</span>[n];<span class="comment">// local variable p is destroyed when this function </span></span><br><span class="line">&#125;                       <span class="comment">// finishes, however, the dynamically allocated                                  // array still exists on the heap.</span></span><br></pre></td></tr></table></figure>
<p><em>3. Deleting an object without destroying a pointer to it leads to a dangling pointer, which causes undefined behavior if the program uses the pointer.</em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>);   <span class="comment">// p: pointer to an int object that has value 10</span></span><br><span class="line"><span class="keyword">int</span>* q = p;             <span class="comment">// q: points to the same int object </span></span><br><span class="line"><span class="keyword">delete</span> p;               <span class="comment">// destroy the object pointed by p</span></span><br><span class="line">p = <span class="literal">nullptr</span>;            <span class="comment">// p points to nowhere now</span></span><br><span class="line">*q = <span class="number">100</span>;               <span class="comment">// undefined behavior as the object pointed by q has been destroyed.</span></span><br></pre></td></tr></table></figure>

<p><em>4. Creating a pointer without initializing it leaves the pointer unbound, which also causes undefined behavior if the program uses it.</em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p;                 <span class="comment">// unnitialized variable p, which is unbound to any object</span></span><br><span class="line">*p = <span class="number">100</span>;               <span class="comment">// undefined behavior</span></span><br></pre></td></tr></table></figure>
<p>The <strong>Student_info</strong> class allows us to use pointers without worrying about above problems. Now we still let <strong>Student_info</strong> to provide the interface, but makes the handle class be independent of the type of the object that it manages. The properties that our class will provide are :</p>
<p><em>1. A <strong>Handle</strong> is a value that refers to an object.</em></p>
<p><em>2. We can copy a <strong>Handle</strong> object.</em></p>
<p><em>3. We can test a <strong>Handle</strong> object to determine whether it is bound to another object.</em></p>
<p><em>4. We can use a <strong>Handle</strong> to trigger polymorphic behavior when it points to an object of a class that belongs to an inheritance hierarchy. That is, if we call a <strong>virtual</strong> function through our class, we want the implementation to choose the function to run dynamically, just as if weâ€™d called the function through a real pointer.</em></p>
<p>Our <strong>Handle</strong> class will take over the memory management and therefore, we should attach only one <strong>Handle</strong> to any object, and we should not access the object directly through a built-in pointer. To tackle problems when using a built-in pointer, </p>
<ol>
<li>When we copy a <strong>Handle</strong> object, weâ€™ll make a new copy of the object so that each <strong>Handle</strong> points to its own copy, such as what the copy constructor does in the <strong>Student_info</strong> class, calling <strong>clone()</strong> to create a new object. </li>
<li>When we destroy a <strong>Handle</strong>, it will destroy the associated object, such as what the <strong>destructor</strong> does in the <strong>Student_info</strong>.  </li>
<li>We allows users to create unbound <strong>Handles</strong> but we will throw an exception if the user attempts to access the object to which an unbound <strong>Handle</strong> refers. Users who want to avoid the exception can test to see whether the <strong>Handle</strong> is bound, for example, the operations defined in the <strong>Student_info</strong> class check whether the handle object was bound to a real object. </li>
</ol>
<h2 id="A-generic-Handle-class"><a href="#A-generic-Handle-class" class="headerlink" title="A generic Handle class"></a>A generic Handle class</h2><p>Now, letâ€™s write the <strong>Handle</strong> class:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">Handle</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Handle(): p(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    Handle(<span class="keyword">const</span> Handle&amp; s): p(<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.p) p = s.p-&gt;clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Handle&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Handle&amp; rhs)&#123;</span><br><span class="line">        <span class="keyword">if</span>(&amp;rhs != <span class="keyword">this</span>)&#123;</span><br><span class="line">            <span class="keyword">delete</span> p;</span><br><span class="line">            p = rhs.p ? rhs.p-&gt;clone() : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Handle() &#123; <span class="keyword">delete</span> p; &#125;</span><br><span class="line"></span><br><span class="line">    Handle(T* t): p(t) &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> p; &#125; <span class="comment">// type conversion</span></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span>;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* p;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Firstly, we observe that the <strong>Handle</strong> is a class template and can accommodate to any type. For example, <strong>Handle<Core></strong> holds a pointer to an object of <strong>Core</strong> type. </p>
<p>The default constructor initializes the pointer to a <strong>nullptr</strong>. The copy constructor lets the <strong>Handle</strong> object refers to a newly created object that has the same value as the object pointed by the passed argument. The <strong>operator=</strong> is samilar to the copy constructor except that it destroyes the original object pointed by the <strong>Handle</strong> object. The destructor is obvious. All these four members are defined exactly the same as those defined in the <strong>Student_info</strong> class. </p>
<p>The other constructor that takes an argument lets us to bind the pointer to an actual object:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Handle&lt;Core&gt; <span class="title">student</span><span class="params">(<span class="keyword">new</span> Grad)</span></span>;</span><br></pre></td></tr></table></figure>
<p>Finally, we define three <strong>operator</strong> functions: the first one <strong>operator bool()</strong> tests the value of a <strong>Handle</strong>, and returns <strong>true</strong> if the <strong>Handle</strong> is bound to an object, and false otherwise(in fact converts the Handle type to a bool type value); The other two deine <strong>operator*</strong> and <strong>operator-&gt;</strong> which give access to the object bound to the <strong>Handle</strong>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span>&amp; <span class="title">Handle</span>&lt;T&gt;:</span>:<span class="keyword">operator</span>* () <span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p)</span><br><span class="line">        <span class="keyword">return</span> *p;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">throw</span> runtime_error(<span class="string">"unbound Handle"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span>* <span class="title">Handle</span>&lt;T&gt;:</span>:<span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(p)</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">throw</span> runtime_error(<span class="string">"unbound Handle"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The <strong>operator*</strong> allows us to access <strong>*student.p</strong> by using <strong>*student</strong>. It yields a reference to the bound object.<br>The <strong>-&gt;</strong> operator is used to access a member whose name appears in its right operand from an object named by its left operand. It returns a value that can be treated as a pointer. Therefore, if x is a value that defines <strong>operator-&gt;</strong>, then</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x-&gt;y;</span><br></pre></td></tr></table></figure>
<p>is equivalent to </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(x.<span class="keyword">operator</span>-&gt;())-&gt;y;</span><br></pre></td></tr></table></figure>
<p>is equivalent to</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.p-&gt;y; <span class="comment">// p is pointer data member, for example, p is Core*</span></span><br></pre></td></tr></table></figure>
<p>By doing so, we can use the <strong>Handle</strong> object as if we are using a pointer to the associated object. Both <strong>operator*</strong> and <strong>operator-&gt;</strong> yield either a reference or a pointer, through which we obtain dynamic binding. For example, if we execute <strong>student-&gt;grade()</strong>, weâ€™re calling <strong>grade()</strong> through <strong>student.p</strong>, that is, a pointer. The particular version of <strong>grade</strong> to be run depends on the type of the object to which <strong>student.p</strong> points to. Similarly, if we execute <strong>(*student).grade()</strong>, weâ€™re calling <strong>grade()</strong> through a reference to the object and so the implementation will decide which particular version of the function to call. </p>
<h2 id="Using-a-generic-Handle"><a href="#Using-a-generic-Handle" class="headerlink" title="Using a generic Handle"></a>Using a generic Handle</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt; Handle&lt;Core&gt; &gt; students;    <span class="comment">// changed type</span></span><br><span class="line">    Handle&lt;Core&gt; record;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="built_in">string</span>::size_type maxlen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read and store the data</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; ch)&#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">'U'</span>)</span><br><span class="line">            record = <span class="keyword">new</span> Core;    (      <span class="comment">// allocate a Core object</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            record = <span class="keyword">new</span> Grad;          <span class="comment">// allocate a Grad object</span></span><br><span class="line">        record-&gt;<span class="built_in">read</span>(<span class="built_in">cin</span>);              <span class="comment">// Handle&lt;T&gt;::-&gt;, then virtual call to read</span></span><br><span class="line">        maxlen = <span class="built_in">max</span>(maxlen, record-&gt;name().<span class="built_in">size</span>());</span><br><span class="line">        students.push_back(record);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write the names and grades</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt; Handle&lt;Core&gt; &gt;::size_type i = <span class="number">0</span>; i != students.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">        <span class="comment">// students[i] is a Handle, which we deference to call the function</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; students[i]-&gt;name()</span><br><span class="line">             &lt;&lt; <span class="built_in">string</span>(maxlen + <span class="number">1</span> - students[i]-&gt;name().<span class="built_in">size</span>(), <span class="string">' '</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">double</span> final_grade = students[i]-&gt;grade();</span><br><span class="line">            streamsize prec = <span class="built_in">cout</span>.precision();</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; setprecision(<span class="number">3</span>) &lt;&lt; final_grade</span><br><span class="line">                &lt;&lt; setprecision(prec) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (domain_error e)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; e.what() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We can rewrite our <strong>Student_info</strong> class to a pure interface class:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student_info</span>&#123;</span></span><br><span class="line">    Student_info () &#123; &#125; <span class="comment">// calls default constructor of Handle&lt;Core&gt;</span></span><br><span class="line">    Student_info (<span class="built_in">std</span>::istream&amp; is) &#123; <span class="built_in">read</span>(is); &#125;</span><br><span class="line">    <span class="comment">// no copy, assign, or destructor: they're no longer needed</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::istream&amp; <span class="title">read</span><span class="params">(<span class="built_in">std</span>::istream)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cp)</span><br><span class="line">            <span class="keyword">return</span> cp-&gt;name();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">throw</span> runtime_error(<span class="string">"uninitialized Student"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cp) </span><br><span class="line">            <span class="keyword">return</span> cp-&gt;grade()</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">throw</span> runtime_error(<span class="string">"uninitialized Student"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> Student_info&amp; s1, <span class="keyword">const</span> Student_info&amp; s2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s1.name() &lt; s2.name();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Handle&lt;Core&gt; cp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Since the **Handle** <span class="class"><span class="keyword">class</span> <span class="title">defines</span> <span class="title">constructor</span>, <span class="title">copy</span> <span class="title">constructor</span>, <span class="title">assignment</span> <span class="title">operator</span>, <span class="title">as</span> <span class="title">well</span> <span class="title">as</span> <span class="title">destructor</span>, <span class="title">we</span> <span class="title">do</span> <span class="title">not</span> <span class="title">need</span> <span class="title">to</span> <span class="title">define</span> <span class="title">these</span> <span class="title">members</span> <span class="title">for</span> <span class="title">our</span> **<span class="title">Student_info</span>** <span class="title">again</span>. <span class="title">Here</span> <span class="title">we</span> <span class="title">need</span> <span class="title">one</span> <span class="title">step</span> <span class="title">more</span>, <span class="title">that</span> <span class="title">is</span>, <span class="title">to</span> <span class="title">redefine</span> <span class="title">the</span> **<span class="title">read</span>** <span class="title">function</span>:</span></span><br><span class="line">```c++</span><br><span class="line"><span class="function">istream&amp; <span class="title">Student_info::read</span><span class="params">(istream&amp; is)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    is &gt;&gt; ch;</span><br><span class="line">    <span class="keyword">if</span>(ch == <span class="string">'U'</span>)</span><br><span class="line">        cp = <span class="keyword">new</span> Core(is);  <span class="comment">// implicitly converts from a Core* to a Handle&lt;Core&gt; through Handle::Handle(T*)</span></span><br><span class="line">    <span class="keyword">else</span>                    <span class="comment">// then assigns the value from the temporary Handle object to cp</span></span><br><span class="line">        cp = <span class="keyword">new</span> Grad(is);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>when we execute the <strong>cp = new Core(is)</strong>, the right-hand side creates a new <strong>Core</strong> object from input stream, which we implicitly convert to a <strong>Handle<Core></strong> using <strong>Handle(T*)</strong> constructor. That <strong>Handle</strong> value is then assigned to <strong>cp</strong> by calling the assignment operator. The assignment constructs and destroys an extra copy of the <strong>Core</strong> object that we created. The reason behind this is that copying or assigning a Handle object always makes a new copy of the object that the <strong>Handle</strong> points to. Doing so can avoid the dangling pointer as each Handle only points to its own object, however, may also make uncessary copies like above assignment operation. </p>
<h1 id="Reference-counted-handles"><a href="#Reference-counted-handles" class="headerlink" title="Reference-counted handles"></a>Reference-counted handles</h1><p>This section solves above problem by providing a <strong>Handle</strong> class that does not copy the underlying object when the <strong>Handle</strong> itself is copied. To avoid danglling pointer problem, weâ€™ll need to free that object at the point when the last <strong>Handle</strong> that points to it goes away. Weâ€™ll use a <strong>reference count</strong> to keep track of how many objects refer to another object. Each time we create a new handle that refers to our target object, we increment the reference count object, while each time a referring object goes away we decrement the reference count. Finally, when the last referring object goes away, we know that it is safe to destroy the target object. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">Ref_handle</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// manage reference count as well as pointer</span></span><br><span class="line">    Ref_handle(): refer(<span class="keyword">new</span> <span class="keyword">size_t</span>(<span class="number">1</span>)), p(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    Ref_handle(T* t): refptr(<span class="keyword">new</span> <span class="keyword">size_t</span>(<span class="number">1</span>)), p(t) &#123;&#125;</span><br><span class="line">    Ref_handle(<span class="keyword">const</span> Ref_handle&amp; h): refptr(h.refptr), p(h.p)&#123;</span><br><span class="line">        ++*refptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Ref_handle&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Ref_handle&amp;);</span><br><span class="line">    ~Ref_handle();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// as before</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> p; &#125;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(p)</span><br><span class="line">            <span class="keyword">return</span> *p;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error(<span class="string">"unbound Ref_handle"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p)</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error(<span class="string">"unbound Ref_handle"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* p;</span><br><span class="line">    <span class="keyword">size_t</span>* refptr;     <span class="comment">// newly added</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Above code shows our <strong>Ref_handle</strong> class:</p>
<ol>
<li><p>we add a new pointer, <strong>refptr</strong>, to to the new handle class to track the reference count</p>
</li>
<li><p>if we default construct a Ref_handle object or construct from an existed T<em>, we initialized *</em>refptr** to 1</p>
</li>
<li><p>if we construct a Ref_handle object from another Ref_handle, we do not copy the underlying object but instead only copy the value of the pointer from the passed argument. Then, our <strong>Ref_handle</strong> object points to the same object as the passed argument. In addition, we let the <strong>refptr</strong> points to the counter object pointed by <strong>h.refptr</strong>, then increment the counter value by 1 as there is a new pointer <strong>Ref_handle.p</strong> points to the object pointed by <strong>h.p</strong> now.</p>
</li>
<li><p>the assignment operator also modifies the counter object instead of copying the underlying object:</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Ref_handle</span>&lt;T&gt;&amp; <span class="title">Ref_handle</span>&lt;T&gt;:</span>:<span class="keyword">operator</span>=(<span class="keyword">const</span> Ref_handle&amp; rhs)&#123;</span><br><span class="line">    ++*rhs.refptr;</span><br><span class="line">    <span class="comment">// free the left-hand side, destroy pointers if appropriate</span></span><br><span class="line">    <span class="keyword">if</span>(--*refptr == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">delete</span> refptr;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// copy in values from the right-hand side</span></span><br><span class="line">    refptr = rhs.refptr;</span><br><span class="line">    p = rhs.p;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> the assignment operation typically involves obliterating the value of the left-hand side operand. If the operand is a pointer, we execute <strong>delete p</strong> to free the space occupied by the object that pointed by <strong>p</strong>, if there is no other pointers points to the same object. Therefore, we executes <strong>delete p</strong> as well as <strong>delete refptr</strong> conditional on <strong>â€“*refptr == 0</strong>. If <strong>â€“*refptr == 0</strong> is false, we do not execute <strong>delete</strong> operation, but we still need to decrement the counter object pointed by <strong>refptr</strong>, which has been done by executing <strong>â€“*refptr ==0</strong>. However, we also need to avoid self-assignment and hence we increment <strong>*refptr</strong> first. </p>
<p> The next step is to bind our <strong>Ref_handle</strong> to the object that pointed by the passed argument. Like what the copy constructor does, we copy pointers but donâ€™t copy the underlying object. </p>
</li>
<li><p>the destructor checks whether the <strong>Ref_handle</strong> object being destroyed is the last one bound to its <strong>T</strong> object:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">Ref_handle</span>&lt;T&gt;:</span>:~Ref_handle()&#123;</span><br><span class="line">    <span class="keyword">if</span> (--*refptr == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">delete</span> refptr;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>This version of <strong>*Ref_handle</strong> class works well for classes that can share state between copies of different objects, however, cannot provide valuelike behavior like the <strong>Handle</strong> class described in last section. It does avoid needless copying, however, avoid all copying even we want to copy the underlying data. Next, we discuss how to write a <strong>Handle</strong> that let us decide when to share data.</p>
<h1 id="Handles-that-let-you-decide-when-to-share-data"><a href="#Handles-that-let-you-decide-when-to-share-data" class="headerlink" title="Handles that let you decide when to share data"></a>Handles that let you decide when to share data</h1><p>Now we write our last version of <strong>generic handle class</strong>, which not only preserves the performance of <strong>Ref_handle</strong> but also provides the valuelike behavior of <strong>Handle</strong>s. In general, the new handle class, named as <strong>Ptr</strong>, will copy the object if we are about to change the contents, but only if there is another handle attached to the same object. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">Ptr</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// new member to copy the object conditionally when needed</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">make_unique</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(*refptr != <span class="number">1</span>)&#123;</span><br><span class="line">            --*refptr;</span><br><span class="line">            refptr = <span class="keyword">new</span> <span class="keyword">size_t</span>(<span class="number">1</span>);</span><br><span class="line">            p = p ? p-&gt;clone() : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the rest of the class looks like Ref_handle except for its name</span></span><br><span class="line">    Ptr(): refptr(<span class="keyword">new</span> <span class="keyword">size_t</span>(<span class="number">1</span>)), p(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    Ptr(T* t): refptr(<span class="keyword">new</span> <span class="keyword">size_t</span>(<span class="number">1</span>)), p(t) &#123;&#125;</span><br><span class="line">    Ptr(<span class="keyword">const</span> Ptr&amp; h): refptr(h.refptr), p(h.p) &#123;</span><br><span class="line">        ++*refptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Ptr&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Ptr&amp;); </span><br><span class="line">    ~Ptr();</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> p; &#125;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span>;</span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* p;</span><br><span class="line">    <span class="keyword">size_t</span>* refptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>This new <strong>Ptr</strong> class has the mostly same members and implementations as the <strong>Ref_handle</strong> class, except that it defines a new <strong>make_unique</strong> function. The <strong>make_unique</strong> function calls the <strong>clone()</strong> function to copy the underlying object only in the condition that the reference count is not 1. More specific, if <strong>*refptr == 1</strong>, then it means that there is no any other <strong>Ptr</strong> objects are bound to the underlying object, and hence there is no need to do a underlying copy again;but if <strong>*refptr != 1</strong>, it means that there still other <strong>Ptr</strong>(s) are bound to the underlying object, and hence it is necessary to make our <strong>Ptr</strong> points to its own object to avoid bring changes to the object pointed by other <strong>Ptr</strong>(s). If we intend to add a function that can change the contents of the underlying object, we should call <strong>make_unique</strong> to make a copy of the underlying object. </p>
<h1 id="An-improvement-on-controllable-handles"><a href="#An-improvement-on-controllable-handles" class="headerlink" title="An improvement on controllable handles"></a>An improvement on controllable handles</h1><p>There is one problem when we use above <strong>Ptr</strong> to deal with some classes that do not have a member function <strong>clone()</strong>. In such case, we will define an intermediary global function that we can both call and create:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">T</span>* <span class="title">clone</span>(<span class="title">const</span> <span class="title">T</span>* <span class="title">tp</span>)&#123;</span></span><br><span class="line">    <span class="keyword">return</span> tp-&gt;clone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Then we can change our <strong>make_unique</strong> member to call it</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">Ptr</span>&lt;T&gt;:</span>:make_unique()&#123;</span><br><span class="line">    <span class="keyword">if</span>(*refptr != <span class="number">1</span>)&#123;</span><br><span class="line">        --*refptr;</span><br><span class="line">        refptr = <span class="keyword">new</span> <span class="keyword">size_t</span>(<span class="number">1</span>);</span><br><span class="line">        p = p ? clone(p) : <span class="number">0</span>; <span class="comment">// call global version of clone</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The new clone function doesâ€™t make any change to the <strong>make_unique</strong> function and hence works well for our <strong>Student_info</strong> class. Another example, the <strong>Vec<char></strong> doesnâ€™t provide a clone function, how can we define an intermediary function to let the <strong>Ptr&lt; Vec<char> &gt;</strong> work?</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="function">Vec&lt;<span class="keyword">char</span>&gt;* <span class="title">clone</span><span class="params">(<span class="keyword">const</span> Vec&lt;<span class="keyword">char</span>&gt;* vp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Vec&lt;<span class="keyword">char</span>&gt;(*vp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The novelty here is <strong>template&lt;&gt;</strong>, which indicates a function is a <strong>template specialization</strong>. The <strong>template specialization</strong> means that the template is a particular version of a template function for the argument type. If we pass <strong>clone</strong> a <strong>Vec<char>*</strong>, the compiler will use this specialized version of <strong>clone</strong>. If we pass other types of pointers, it will instantiate the general template form of <strong>clone</strong>. </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://quantein.com/2018/05/08/C-Using-inheritance-and-dynamic-binding/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liam">
      <meta itemprop="description" content="Stochastic Modelling Notes; Programming Notes">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Liam's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/05/08/C-Using-inheritance-and-dynamic-binding/" class="post-title-link" itemprop="url">C++ - Using inheritance and dynamic binding</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-05-08 13:37:57" itemprop="dateCreated datePublished" datetime="2018-05-08T13:37:57+08:00">2018-05-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2018-05-12 21:43:30" itemprop="dateModified" datetime="2018-05-12T21:43:30+08:00">2018-05-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Programming/" itemprop="url" rel="index"><span itemprop="name">Programming</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span></span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>NaN:aN</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Inheritance"><a href="#Inheritance" class="headerlink" title="Inheritance"></a>Inheritance</h1><p>In this chapter, we intend to extend our grading program such that it meets the new requirements: students can take undergraduate or graduate credit while graduate students have to write a thesis in addition to the homework and exams. In other words, a record for graduate credit is the same as for undergraduate credit except that it has extra properties related to the thesis. This problem can be abstracted and solved by a mechanism called <strong>inheritance</strong>, which is one of the cornerstones of OOP. </p>
<p>Specifically, weâ€™ll write two classes, the first class is the abstraction of the core requirements and is named <strong>Core</strong> while the second class represents the requirements for graduate credit and hence named <strong>Grad</strong>. The <strong>Grad</strong> class captures extra requirements but has same core requirements as the <strong>Core</strong> class. Therefore, We write two classes such that the <strong>Grad</strong> class can inherit the properties from the <strong>Core</strong> class. Typically, we say that the <strong>Grad</strong> class is derived from or inherits from the <strong>base</strong> class, i.e. the <strong>Core</strong> class here. letâ€™s see how to define these two classes:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Core</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Core();</span><br><span class="line">    Core(<span class="built_in">std</span>::istream&amp;);</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::istream&amp; <span class="title">read</span><span class="params">(<span class="built_in">std</span>::istream&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::istream&amp; <span class="title">read_common</span><span class="params">(<span class="built_in">std</span>::istream&amp;)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> n;</span><br><span class="line">    <span class="keyword">double</span> midterm, <span class="keyword">final</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; homework;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grad</span>:</span> <span class="keyword">public</span> Core&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Grad();</span><br><span class="line">    Grad(<span class="built_in">std</span>::istream&amp;);</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::istream&amp; <span class="title">read</span><span class="params">(<span class="built_in">std</span>::istream&amp;)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> thesis;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Since <strong>Grad</strong> class inherits from <strong>Core</strong> class, every member of <strong>Core</strong> is also a member of <strong>Grad</strong>, except for the <strong>constructor, assignment operator</strong>, and <strong>destructor</strong>. The <strong>Grad</strong> class also has its own members, such as the <strong>thesis</strong> and its own <strong>constructor</strong>s. It can also redefine members from the base class, such as the <strong>grade</strong> and <strong>read</strong> function. </p>
<p>The keyword <strong>public</strong> in <strong>public Core</strong> means that <strong>Grad</strong> inherits from <strong>Core</strong> is part of its interface rather than its implementation. In other words, the public interface to <strong>Core</strong> becomes part of the public interface to <strong>Grad</strong>. For example, if we have a <strong>Grad</strong> object, we can call its <strong>name</strong> member thought <strong>Grad</strong> doesnâ€™t define its own <strong>name</strong> function. </p>
<p>Beyond the four data members from the <strong>Core</strong> class,  <strong>Grad</strong> has a member <strong>thesis</strong> and calculates <strong>grade()</strong> using different algorithm. It have two constructors, and four member functions, two of which redefine the corresponding members of <strong>Core</strong>, and <strong>name</strong> and <strong>read_common</strong> functions. </p>
<h2 id="Protection-revisited"><a href="#Protection-revisited" class="headerlink" title="Protection revisited"></a>Protection revisited</h2><p>As it stands, four data members as well as the <strong>read_common</strong> function are inaccessible to member functions in <strong>Grad</strong> as they are <strong>private</strong> and only available to the <strong>Core</strong> members and its friends. But we do need these data members and <strong>read_common</strong> for defining the <strong>grade</strong> and <strong>read</strong> functions in the <strong>Grad</strong>. To achieve this goal, we rewrite the <strong>Core</strong> class using a protection lable:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Core</span>&#123;</span></span><br><span class="line"><span class="comment">// public members are available for users of the derived class</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Core();</span><br><span class="line">    Core(<span class="built_in">std</span>::istream&amp;);</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::istream&amp; <span class="title">read</span><span class="params">(<span class="built_in">std</span>::istream&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// protected members are available for member functions of the derived class but not available for users </span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::istream&amp; <span class="title">read_common</span><span class="params">(<span class="built_in">std</span>::istream&amp;)</span></span>;  </span><br><span class="line">    <span class="keyword">double</span> midterm, <span class="keyword">final</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; homework;</span><br><span class="line"></span><br><span class="line"><span class="comment">// only available for members of the class itself and its friends.</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> n;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>The <strong>protected</strong> members are available for derived classes but still inaccssible users of the classes. <strong>n</strong> is still private but <strong>Grad</strong> can access the name by calling its member function <strong>name</strong>.</p>
<h2 id="Operations"><a href="#Operations" class="headerlink" title="Operations"></a>Operations</h2><p>The next is to implement four constructors(each class has one default constructor and one constructor with arguments) and six operations including common functions <strong>name</strong>, <strong>read_common</strong>,  and <strong>read</strong> and <strong>grade</strong> for two class respectively. Weâ€™ll read the <strong>thesis</strong> grade closely after the final exam grade but precede the homework grades.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// name function</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">Core::name</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> n; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// grade function for Core</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Core::grade</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ::grade(midterm, <span class="keyword">final</span>, homework);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// read_common function</span></span><br><span class="line"><span class="function">istream&amp; <span class="title">Core::read_common</span><span class="params">(istream&amp; in)</span></span>&#123;</span><br><span class="line">    in &gt;&gt; n &gt;&gt; midterm &gt;&gt; <span class="keyword">final</span>;</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// read function for Core</span></span><br><span class="line"><span class="function">istream&amp; <span class="title">Core::read</span><span class="params">(istream&amp; in)</span></span>&#123;</span><br><span class="line">    read_common(in);</span><br><span class="line">    read_hw(in, homework);</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// read for Grad</span></span><br><span class="line"><span class="function">istream&amp; <span class="title">Grad::read</span><span class="params">(istream&amp; in)</span></span>&#123;</span><br><span class="line">    Core::read_common(in);</span><br><span class="line">    in &gt;&gt; thesis;</span><br><span class="line">    read_hw(in, Core::homework);</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// grade for Grad</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Grad::grade</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(Core::grade(), thesis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The <strong>Grad::grade</strong> function shows that we calculate the final grade as the lesser between the <strong>grade</strong> excluding thesis, and thesis. Though we can call members of <strong>Core</strong> directly, weâ€™d better explicitly call some functions for avoiding ambiguity. For example, if we donâ€™t explicitly call <strong>Core::grade()</strong>, the compiler may use the <strong>Grad::grade</strong> dirctly. </p>
<h2 id="Inheritance-and-constructors"><a href="#Inheritance-and-constructors" class="headerlink" title="Inheritance and constructors"></a>Inheritance and constructors</h2><p>Derived objects are constructed by(Koenig and Moo 2000):<br><em>1. Allocating space for the entire object (base-class members as well as derived members)</em><br><em>2. Calling the base-class constructor to initialize the base-class part(s) of the object</em><br><em>3. Initializing the members of the derived class as directed by the constructor initializer</em><br><em>4. Executing the body of the derived-class constructor, if any</em></p>
<p>Clearly, the constructor of a derived class not only constructs its own members but also constructs data members of the base class. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Core</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// default constructor for Core</span></span><br><span class="line">    Core(): midterm(<span class="number">0</span>), <span class="keyword">final</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// build a Core from an istream</span></span><br><span class="line">    Core(istream&amp; is)&#123; <span class="built_in">read</span>(is); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grad</span>:</span> <span class="keyword">public</span> Core&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// default constructor for Grad: first implicitly calls the default constructor Core::Core()</span></span><br><span class="line">    Grad(): thesis(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// build a Grad from istream: first implicitly calls Core::Core()</span></span><br><span class="line">    Grad(<span class="built_in">std</span>::istream&amp; is) &#123; <span class="built_in">read</span>(is); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>For example, when execute</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Grad g; <span class="comment">// create an empty object</span></span><br></pre></td></tr></table></figure>
<p>The computer allocates enough space to hold five data members for the Grad object, run the <strong>Core</strong> default constructor to initialize the data members in the <strong>Core</strong> part of <strong>g</strong>, and then run the default constructor of <strong>Grad</strong>. Again, when execute</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Grad <span class="title">g</span><span class="params">(<span class="built_in">cin</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>the computer will run the <strong>Core</strong> default constructor, followed by the <strong>Grad::Grad(istream&amp;)</strong> constructor to read values into five data memners.</p>
<h1 id="Polymorphism-and-virtual-functions"><a href="#Polymorphism-and-virtual-functions" class="headerlink" title="Polymorphism and virtual functions"></a>Polymorphism and virtual functions</h1><p>There is also a support function for the <strong>Student_info</strong> program, that is, the compare function that acts as the predicate of the <strong>std::sort</strong> algorithm. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> Core&amp; c1, <span class="keyword">const</span> Core&amp; c2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c1.name() &lt; c2.name();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>How does it work on the <strong>Grad</strong> class objects? For example</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Grad <span class="title">g</span><span class="params">(<span class="built_in">cin</span>)</span></span>;    <span class="comment">// read a Grad record</span></span><br><span class="line"><span class="function">Grad <span class="title">g2</span><span class="params">(<span class="built_in">cin</span>)</span></span>;   <span class="comment">// read a Grad record</span></span><br><span class="line"></span><br><span class="line"><span class="function">Core <span class="title">c</span><span class="params">(<span class="built_in">cin</span>)</span></span>;    <span class="comment">// read a Core record</span></span><br><span class="line"><span class="function">Core <span class="title">c2</span><span class="params">(<span class="built_in">cin</span>)</span></span>;   <span class="comment">// read a Core record</span></span><br><span class="line"></span><br><span class="line">compare(g, g2); <span class="comment">// compare two Grad records</span></span><br><span class="line">compare(c, c2); <span class="comment">// compare two Core records</span></span><br><span class="line">compare(g, c);  <span class="comment">// compare Grad record with a Core record</span></span><br></pre></td></tr></table></figure>
<p>The compare function can take two <strong>Core</strong> objects as well as two <strong>Grad</strong> objects, even one <strong>Core</strong> and one <strong>Grad</strong>. For the function body, it makes sence as any <strong>Grad</strong> object has a member <strong>name</strong>, which it inherits from the base. But why we can pass a <strong>Grad</strong> object to a function expecting a <strong>Core&amp;</strong>? The reason is that <strong>Grad</strong> is inherited from <strong>Core</strong> and hence has a <strong>Core</strong> part. Then, we can bind <strong>compare</strong>â€˜s reference parameters to the <strong>Core</strong> portions of <strong>Grad</strong> objects, as if we bind them to plain <strong>Core</strong> objects.</p>
<h2 id="Obtaining-a-value-without-knowing-the-objectâ€™s-type"><a href="#Obtaining-a-value-without-knowing-the-objectâ€™s-type" class="headerlink" title="Obtaining a value without knowing the objectâ€™s type"></a>Obtaining a value without knowing the objectâ€™s type</h2><p>The compare function described above works properly. However, if we intend to compare the grade rather than the name, the function seems inappropriate for <strong>Grad</strong> objects as two classes have different <strong>grade</strong> function. A right logical manner is that the compare function can invoke the right <strong>grade</strong> function according to the type of the object that we pass, only at the stage of run time. To support this kind of <strong>run time selection</strong>, C++ provides <strong>virtual</strong> functions:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Core</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">grade</span><span class="params">()</span> <span class="keyword">const</span></span>;   <span class="comment">// virtual added</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>When we call <strong>compare</strong>(grade-version), the implementation will determine which version of the <strong>grade</strong> should execute by looking at the actual type of the objects to which the reference <strong>c1</strong> and <strong>c2</strong> are bound. If the argument is <strong>Grad</strong>,then it calls <strong>Grad::grade</strong> and calls <strong>Core::grade</strong> otherwise. </p>
<p>Noting that the keyword <strong>virtual</strong> may be used only inside the class definition. If we seperate the declaration and definition, we do not need to repeatedly use it in the definition.  </p>
<h2 id="Dynamic-binding"><a href="#Dynamic-binding" class="headerlink" title="Dynamic binding"></a>Dynamic binding</h2><p>Another point about the <strong>virtual</strong> is that it is relevant only when the function is called through a reference or a pointer. If we call the function on behalf of the object, then we know the exact type of the object at compile time. In contrast, a reference or a pointer to a base class object may refer or point to a base-class object or to an object of a type derived from the base class. Assuming we write <strong>compare_grades</strong>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// incorrect implementation</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare_grades</span><span class="params">(Core c1, Core c2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c1.grade() &lt; c2.grade();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In this case, we know exactly that both two objects are <strong>Core</strong> type. Even we call the function with <strong>Grad</strong> objects, the <strong>Grad</strong> objects will be cut down to its <strong>Core</strong> part and a copy of that part will be passed to the <strong>compare_grades</strong> function. This case is known as <strong>statically bound</strong>, that is, the calls to <strong>Grad</strong> are bound at compile to <strong>Core::grade</strong>. Obviously, the <strong>dynamic binding</strong> is that the function is dynamically bound at run time. If we call a <strong>virtual</strong> function through a pointer or a reference, the version of <strong>virtual</strong> function to use depends on the type of the object which the reference or pointer is bound. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Core c;</span><br><span class="line">Grad g;</span><br><span class="line">Core* p;</span><br><span class="line">Core&amp; r = q;</span><br><span class="line"></span><br><span class="line">c.grade();  <span class="comment">// statically bound to Core::grade()  </span></span><br><span class="line">g.grade();  <span class="comment">// statically bound to Grad::grade()</span></span><br><span class="line">p-&gt;grade(); <span class="comment">// dynamically bound, depending on the type of the object to which p points</span></span><br><span class="line">r.grade();  <span class="comment">// dynamically bound, depending on the type of the object to which r refers</span></span><br></pre></td></tr></table></figure>

<p><em>The fact that we can use a derived type where a pointer or reference to the base is expected is an example of <strong>polymorphism</strong>, meaning <strong>of many form</strong>. When we call the <strong>virtual</strong> function by a pointer or reference, we make a polymorphic call.</em> Weâ€™ll make the <strong>read</strong> function <strong>virtual</strong> as well and then the version of the <strong>read</strong> function to be called depends on the type of the object on which it is invoked. </p>
<h2 id="Recap"><a href="#Recap" class="headerlink" title="Recap"></a>Recap</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Core</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Core(): midterm(<span class="number">0</span>), <span class="keyword">final</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    Core(<span class="built_in">std</span>::istream&amp; is) &#123; <span class="built_in">read</span>(is); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::istream&amp; <span class="title">read</span><span class="params">(<span class="built_in">std</span>::istream&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">grade</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// accessible to derived classes</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::istream&amp; <span class="title">read_common</span><span class="params">(<span class="built_in">std</span>::istream&amp;)</span></span>;</span><br><span class="line">    <span class="keyword">double</span> midterm, <span class="keyword">final</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; homework;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// accessible only to Core</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grad</span>:</span>: <span class="keyword">public</span> Core&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Grad(): thesis(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    Grad(<span class="built_in">std</span>::istream&amp; is) &#123; <span class="built_in">read</span>(is); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::istream&amp; <span class="title">read</span><span class="params">(<span class="built_in">std</span>::istream)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> thesis;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> Core&amp;, <span class="keyword">const</span> Core&amp;)</span></span>;</span><br></pre></td></tr></table></figure>

<h1 id="Using-inheritance-to-solve-our-problem"><a href="#Using-inheritance-to-solve-our-problem" class="headerlink" title="Using inheritance to solve our problem"></a>Using inheritance to solve our problem</h1><p>Now we can write our student grading prorgam described in chapter 9. The problem is how can we write a program that can handle with both <strong>Core</strong> objects and <strong>Grad</strong> objects. To achieve our goal, we need to eliminate these type dependencies(Koenig and Moo 2000):</p>
<p><em>1. The definition of the vector in which we store the elements as we read them</em><br><em>2. The definition of the local temporary into which we read the records</em><br><em>3. The read function</em><br><em>4. The grade function</em></p>
<p>Now weâ€™ll see how to solve these problems.</p>
<h2 id="Containers-of-virtually-unkown-type"><a href="#Containers-of-virtually-unkown-type" class="headerlink" title="Containers of virtually unkown type"></a>Containers of virtually unkown type</h2><p>Consider if we define a vector as follows:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;Core&gt; students;      <span class="comment">// must hold Core objects, not polymorphic types</span></span><br><span class="line">Core record;                <span class="comment">// Core object, not a type derived from Core</span></span><br></pre></td></tr></table></figure>
<p>It is impossible to hold the Grad objects as we explicitly declare that a vector hold objects of type <strong>Core</strong>. Then, if we call the <strong>read</strong> function or <strong>grade</strong> function we indeed call <strong>Core::read</strong> or <strong>Core::grade</strong>. However, we have mentioned in above section, if we call those functions through pointers or references, these functions are dynamically bound at run time, depending on the type of the object which the reference or pointer is bound. Therefore, a natural solution is that define a vector that stores the pointer to each element rather than the element itself.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;Core*&gt; students;</span><br><span class="line">Core* record;</span><br></pre></td></tr></table></figure>
<p>Howvever, this doesnâ€™t work as no one knows where the record points initially. If the computer executes data reading, the program would crash.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(record-&gt;<span class="built_in">read</span>(<span class="built_in">cin</span>)) &#123; <span class="comment">// crash! &#125;</span></span><br></pre></td></tr></table></figure>
<p>Now we provide a verbose solution to this problem: let users manually control the type of the object. We use lable <strong>U</strong> to represent that the type is a <strong>Core</strong> object, and use <strong>G</strong> to represent that the <strong>type</strong> is a <strong>Grad</strong> object. Before we implement this strategy, we should rewrite our <strong>compare</strong> function such that it can sort two <strong>pointer</strong>s. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare_Core_ptrs</span><span class="params">(<span class="keyword">const</span> Core* cp1, <span class="keyword">const</span> Core* cp2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> compare(*cp1, *cp2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Noting that we canâ€™t name this predicate as <strong>compare</strong> as we cannot pass an overloaded function as a template argument. Now, letâ€™s see the whole program:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// this work almost work</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Core*&gt; students;     <span class="comment">// store pointers, not objects</span></span><br><span class="line">    Core* record;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="built_in">string</span>::size_type maxlen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read and store the data</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; ch)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch == <span class="string">'U'</span>)</span><br><span class="line">            record = <span class="keyword">new</span> Core;  <span class="comment">// allocate a Core object   </span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            record = <span class="keyword">new</span> Grad;  <span class="comment">// allocate a Grad object</span></span><br><span class="line">        record-&gt;<span class="built_in">read</span>(<span class="built_in">cin</span>);      <span class="comment">// virtual call</span></span><br><span class="line">        maxlen = <span class="built_in">max</span>(maxlen, record-&gt;name().<span class="built_in">size</span>()); <span class="comment">// dereference</span></span><br><span class="line">        students.push_back(record);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pass the version of compare that works on pointers</span></span><br><span class="line">    sort(student.<span class="built_in">begin</span>(), student.<span class="built_in">end</span>(), compare_Core_ptrs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write the names and grades</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Core*&gt;::size_type i = <span class="number">0</span>; i != student.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; students[i]-&gt;name()</span><br><span class="line">             &lt;&lt; <span class="built_in">string</span>(maxlen + <span class="number">1</span> - students[i]-&gt;name.<span class="built_in">size</span>(), <span class="string">' '</span>); </span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">double</span> final_grade = students[i]-&gt;grade();</span><br><span class="line">        streamsize prec = <span class="built_in">cout</span>.precision();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; setprecision(<span class="number">3</span>) &lt;&lt; final_grade</span><br><span class="line">             &lt;&lt; setprecision(prec) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(domain_error e)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; e.what() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> student[i];  <span class="comment">// free the object allocating when reading</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Virtual-destructors"><a href="#Virtual-destructors" class="headerlink" title="Virtual destructors"></a>Virtual destructors</h2><p>Above program almost works. The only problem occurs when we <strong>delete</strong> the object. When we store each pointer, we store each as <strong>Core*</strong> though they may point to a <strong>Grad</strong>. Therefore, the <strong>delete</strong> operation can only delete pointers to <strong>Core</strong>. To solve this problem, we define a <strong>virtual</strong> destructor:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Core</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~Core() &#123;&#125;</span><br><span class="line">    <span class="comment">// as before</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><em>Now, when we execute <strong>delete students[i]</strong>, the destructor that will be run depends on the type of the object to which <strong>student[i]</strong> actually points. A <strong>virtual</strong> destructor is needed any time it is possible that an object of derived type is destroyed through a pointer to base.</em></p>
<h1 id="A-simple-handle-class"><a href="#A-simple-handle-class" class="headerlink" title="A simple handle class"></a>A simple handle class</h1><p>The above approach does solve the problem but seems complex. Users have to manage the pointers and memory properly to avoid potential bugs. we can use the technique <strong>handle class</strong> to encapsulate the pointer to <strong>Core</strong>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student_info</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// constructors and copy control</span></span><br><span class="line">    Student_info(): cp(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    Student_info(<span class="built_in">std</span>::istream&amp; is): cp(<span class="number">0</span>) &#123; <span class="built_in">read</span>(is); &#125;</span><br><span class="line">    Student_info(<span class="keyword">const</span> Student_info&amp;);</span><br><span class="line">    Student_info&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Student_info&amp;);</span><br><span class="line">    ~Student_info() &#123; <span class="keyword">delete</span> cp; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// operations</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::istream&amp; <span class="title">read</span><span class="params">(<span class="built_in">std</span>::istream&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cp) <span class="keyword">return</span> cp-&gt;name();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error(<span class="string">"unitialized Student"</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cp) <span class="keyword">return</span> cp-&gt;grade();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error(<span class="string">"unitialized Student"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">compare</span> <span class="params">(<span class="keyword">const</span> Student_info&amp; s1, <span class="keyword">const</span> Student_info&amp; s2)</span></span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> s1.name() &lt; s2.name(); &#125;</span><br><span class="line">    <span class="keyword">private</span>ï¼š</span><br><span class="line">        Core* cp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Now the <strong>Student_info</strong> object represents either a <strong>Core</strong> or <strong>Grad</strong>. This <strong>handle</strong> class hids the details of implementations related to pointers as used in above program, and provides an interface that is consistent with the <strong>Core</strong> and <strong>Grad</strong>. Users do not need to worry about memory management any more as all has been done by the handle class. The novelty is that we define the compare function as a <strong>static</strong> member which is associated with a class rather than a particular object.<br>We can call it through <strong>Student_info::compare()</strong> directly even without creating any object first. Therefore, <strong>static function member</strong> cannot access nonstatic data members of objects of the class as there is no object associated with the function and hence no members to use. </p>
<h2 id="Reading-the-handle"><a href="#Reading-the-handle" class="headerlink" title="Reading the handle"></a>Reading the handle</h2><p>The first constructor construct a <strong>nullptr</strong>. The second constructor constructs an object from the input stream, relying on the <strong>read</strong> function:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream&amp; <span class="title">Student_info::read</span><span class="params">(istream&amp; is)</span></span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> cp;      <span class="comment">// delete previous object, if any</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> ch;        <span class="comment">// get record type</span></span><br><span class="line">    is &gt;&gt; ch;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ch == <span class="string">'U'</span>)&#123;</span><br><span class="line">        cp = <span class="keyword">new</span> Core(is);  <span class="comment">// construct Core from istream</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        cp = <span class="keyword">new</span> Grad(is);  <span class="comment">// construct Grad from istream</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The <strong>read</strong> function allocate the space and construct the right type object according to the information from input stream. It starts by freeing the existing object (if any) to which the handle object was previously bound. It is worth noting that if <strong>cp</strong> is a <strong>nullptr</strong>, we still can use <strong>delete</strong> without causing any error. </p>
<h2 id="Copying-the-handle-objects"><a href="#Copying-the-handle-objects" class="headerlink" title="Copying the handle objects"></a>Copying the handle objects</h2><p>It also defines the copy constuctor and assignment operator. These two operations typically need to allocate new objects and then initialize or assign values from the object from which we are copying. But the problem is how can we know the type of the object from which we are copying? The object, i.e. <strong>cp</strong>, may point to a <strong>Core</strong> or a <strong>Grad</strong>.  The solution is to define a new <strong>virtual</strong> function:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Core</span>&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Student_info</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Core* <span class="title">clone</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> Core(*<span class="keyword">this</span>); &#125;</span><br><span class="line">    <span class="comment">// as before</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>The <strong>clone()</strong> function creates a new object that holds copies of the values in the original. The <strong>Core</strong> doesnâ€™t have a user-defined copy constructor but have a synthesized copy constructor which copies each member from the existing <strong>Core</strong> object into the newly created object. The member is inaccessible to users and non-derived classes. Therefore, we declare the <strong>Student_info</strong> as a friend. Then all members of the <strong>Student_info</strong> are friends of <strong>Core</strong>. The <strong>Grad</strong> class inherits this member, but will return a new <strong>Grad</strong>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grad</span>:</span> <span class="keyword">public</span> Core&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function">Grad* <span class="title">clone</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> Grad(*<span class="keyword">this</span>); &#125;</span><br><span class="line">    <span class="comment">// as before</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>In general,  when we redefine a member function from the base class, we keep the parameter list and the return type unchanged. However, if the base-class function returns a pointer (or reference) to a base class, then the derived-class function can return a pointer or reference to a corresponding derived class. </p>
<p>In addition to above, the derived class doesnâ€™t inherit the <strong>friend</strong> class from the base class. In this case, it is unnecessary to declare the <strong>Student_info</strong> as the <strong>friend</strong> class of <strong>Grad</strong> due to the fact that the <strong>Student_info</strong> class never refers to <strong>Grad::clone</strong> directly instead through the virtual function defined in <strong>Core</strong>.</p>
<p>The copy constructor and assignment operator are defined as follows:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Student_info::Student_info(<span class="keyword">const</span> Student_info&amp; s): cp(<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s.cp) cp = s.cp-&gt;clone();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student_info&amp; Student_info:: <span class="keyword">operator</span>=(<span class="keyword">const</span> Student_info&amp; s)&#123;</span><br><span class="line">    <span class="keyword">if</span>(&amp;s != <span class="keyword">this</span>)&#123;</span><br><span class="line">        <span class="keyword">delete</span> cp;</span><br><span class="line">        <span class="keyword">if</span>(s.cp)</span><br><span class="line">            cp = s.cp-&gt;clone();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cp = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>One may wonder that why we can access the private member <strong>cp</strong> of object <strong>s</strong>. It is because that <strong>private</strong> only restricts data access from other classes. In other words, if both objects are instances of the same class, they are allowed to access private members with each other. </p>
<h1 id="Using-the-handle-class"><a href="#Using-the-handle-class" class="headerlink" title="Using the handle class"></a>Using the handle class</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Student_info&gt; students;</span><br><span class="line">    Student_info record;</span><br><span class="line">    <span class="built_in">string</span>::size_type maxlen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read and store the data</span></span><br><span class="line">    <span class="keyword">while</span> (record.<span class="built_in">read</span>(<span class="built_in">cin</span>))&#123;</span><br><span class="line">        maxlen = <span class="built_in">max</span>(maxlen, record.name().<span class="built_in">size</span>());</span><br><span class="line">        students.push_back(record);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// alphabetize the student records</span></span><br><span class="line">    sort(students.<span class="built_in">begin</span>(), students.<span class="built_in">end</span>(), Student_info::compare);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write the names and grades</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Student_info&gt;::size_type i = <span class="number">0</span>;</span><br><span class="line">         i != students.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">             <span class="built_in">cout</span> &lt;&lt; students[i].name()</span><br><span class="line">             &lt;&lt; <span class="built_in">string</span>(maxlen + <span class="number">1</span> - students[i].name.<span class="built_in">size</span>(), <span class="string">' '</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">double</span> final_grade = students[i].grade();</span><br><span class="line">            streamsize prec = <span class="built_in">cout</span>.precision();</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; setprecision(<span class="number">3</span>) &lt;&lt; final_grade</span><br><span class="line">                 &lt;&lt; setprecision(prec) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (domain_error e)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; e.what() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Now the program takes either a undergraduate record or a graduate record. It first reads the character that says what kind of record we are about to read, then creates a new object and initializes it from input stream. Then it stores objects and deal with sorting, printing as same as the previous program. When it exits from the main, all created objects are deleted automatically through the destructor defined in the <strong>Student_info</strong> class. </p>
<h1 id="Subtleties"><a href="#Subtleties" class="headerlink" title="Subtleties"></a>Subtleties</h1><p>We are allowed to store <strong>Core</strong> or <strong>Grad</strong> objects into a <strong>vector<Core></strong> due to the fact that <strong>push_back</strong> function takes a reference to the <strong>vector</strong>â€˜s value type. But the result is that the vector only stores the <strong>Core</strong> part of a <strong>Grad</strong> object. </p>
<p>If we want to declare a <strong>virtual</strong> function, we must give it the same interface in the <strong>base</strong> and the <strong>derived</strong> classes.  </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://quantein.com/2018/05/06/Defining-abstract-data-types-Part-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liam">
      <meta itemprop="description" content="Stochastic Modelling Notes; Programming Notes">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Liam's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/05/06/Defining-abstract-data-types-Part-2/" class="post-title-link" itemprop="url">C++ - Defining abstract data types(Part 2)</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2018-05-06 18:13:50 / Modified: 21:30:46" itemprop="dateCreated datePublished" datetime="2018-05-06T18:13:50+08:00">2018-05-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Programming/" itemprop="url" rel="index"><span itemprop="name">Programming</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span></span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>NaN:aN</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>The full version of <strong>Vec</strong> class template described in <a href="http://quanttour.com/14/04/2018/C-Defining-abstract-data-types/" target="_blank" rel="noopener">C++ - Defining abstract data types</a> is presented below. </p>
<p><strong>Vec.h</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_VEC_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_VEC_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;	 // std::cout, std::endl</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt; 	 // std::size_t</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;     // std::max</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;	 // std::allocator, std::uninitialized_fill, std::uninitialized_copy</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">Vec</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// member types</span></span><br><span class="line">    <span class="keyword">typedef</span> T* iterator;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">const</span> T* const_iterator;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> size_type;</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// constructors</span></span><br><span class="line">    Vec() &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"calling default constructor"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Vec</span><span class="params">(size_type n, <span class="keyword">const</span> T&amp; t = T())</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"calling the explicit constructor"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        create(n, t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// copy constructor,</span></span><br><span class="line">    Vec(<span class="keyword">const</span> Vec&amp; v) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"calling copy constructor"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        create(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//assignment operator</span></span><br><span class="line">    Vec&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Vec&amp;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// destructor</span></span><br><span class="line">    ~Vec() &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"calling destructor"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        uncreate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// indexing operator</span></span><br><span class="line">    <span class="keyword">const</span> T&amp; <span class="keyword">operator</span>[](size_type i) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"calling operation[]"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> data[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// push_back function</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T&amp; t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(avail == limit)</span><br><span class="line">            grow();</span><br><span class="line">        unchecked_append(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// size function</span></span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> avail - data; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// begin(), end() function</span></span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> data; &#125;</span><br><span class="line">    <span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> data; &#125;</span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> avail; &#125;</span><br><span class="line">    <span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> avail; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    iterator data;  <span class="comment">// first element in the Vec</span></span><br><span class="line">    iterator avail; <span class="comment">// (one past) the last element in the Vec</span></span><br><span class="line">    iterator limit; <span class="comment">// (one past) the allocated memory</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// facilities for memory allocation</span></span><br><span class="line">    <span class="built_in">std</span>::allocator&lt;T&gt; alloc; <span class="comment">// object to handle memory allocation</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// allocate and initialize the underlying array</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">(size_type, <span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">(const_iterator, const_iterator)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// destroy the elements in the array and free the memory</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">uncreate</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// support functions for push_back</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">grow</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unchecked_append</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// initialize data members to nullptr</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">Vec</span>&lt;T&gt;:</span>:create()</span><br><span class="line">&#123;</span><br><span class="line">    data = avail = limit = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// create and initialize data members with a size and a value</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">Vec</span>&lt;T&gt;:</span>:create(size_type n, <span class="keyword">const</span> T&amp; val)</span><br><span class="line">&#123;</span><br><span class="line">    data = alloc.allocate(n);</span><br><span class="line">    limit = avail = data + n;</span><br><span class="line">    <span class="built_in">std</span>::uninitialized_fill(data, limit, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// create and initialize data members by copying values from an input sequence</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">Vec</span>&lt;T&gt;:</span>:create(const_iterator i, const_iterator j)</span><br><span class="line">&#123;</span><br><span class="line">    data = alloc.allocate(j - i);</span><br><span class="line">    limit = avail = <span class="built_in">std</span>::uninitialized_copy(i, j, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// destruct the class object using destroy and deallocate functions</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">Vec</span>&lt;T&gt;:</span>:uncreate()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!data)&#123;</span><br><span class="line">        <span class="comment">// destroy the elements in reverse order</span></span><br><span class="line">        iterator it = avail;</span><br><span class="line">        <span class="keyword">while</span>(it != data)</span><br><span class="line">            alloc.destroy(--it);</span><br><span class="line">        alloc.deallocate(data, limit - data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// reset pointers to indicate that Vec is empty again</span></span><br><span class="line">    data = limit = avail = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// assign values from right-hand operand to the left-hand operand</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Vec</span>&lt;T&gt;&amp; <span class="title">Vec</span>&lt;T&gt;:</span>:<span class="keyword">operator</span>= (<span class="keyword">const</span> Vec&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"calling operator= function"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check for self-assignment</span></span><br><span class="line">    <span class="keyword">if</span>(&amp;rhs != <span class="keyword">this</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// free the array in the left-hand side</span></span><br><span class="line">        uncreate();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// copy elements from the right-hand to the left-hand side</span></span><br><span class="line">        create(rhs.<span class="built_in">begin</span>(), rhs.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reallocate storage to hold more elements</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">Vec</span>&lt;T&gt;:</span>:grow()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// when growing, allocate twice as much as space as currently in use</span></span><br><span class="line">    size_type new_size = <span class="built_in">std</span>::<span class="built_in">max</span>(<span class="number">2</span>*(limit-data), <span class="keyword">ptrdiff_t</span>(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// allocate new space and copy existing elements to the new space</span></span><br><span class="line">    iterator new_data = alloc.allocate(new_size);</span><br><span class="line">    iterator new_avail = <span class="built_in">std</span>::uninitialized_copy(data, avail, new_data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// return the old space</span></span><br><span class="line">    uncreate();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reset pointers to point to the newly allocated space</span></span><br><span class="line">    data = new_data;</span><br><span class="line">    avail = new_avail;</span><br><span class="line">    limit = data + new_size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// add new element at the end of the vector</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">Vec</span>&lt;T&gt;:</span>:unchecked_append(<span class="keyword">const</span> T&amp; val)</span><br><span class="line">&#123;</span><br><span class="line">    alloc.construct(avail++, val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* GUARD_VEC_H */</span></span></span><br></pre></td></tr></table></figure>

<p><strong>Test</strong></p>
<p>Now, letâ€™s test our <strong>Vec</strong> class to see how does it work.</p>
<p><strong>main.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Vec.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        Vec&lt;<span class="keyword">int</span>&gt; v;		<span class="comment">// call default constructor</span></span><br><span class="line">        <span class="function">Vec&lt;<span class="keyword">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">10</span>, <span class="number">100</span>)</span></span>;	<span class="comment">// call explicit constructor</span></span><br><span class="line">        <span class="function">Vec&lt;<span class="keyword">int</span>&gt; <span class="title">v2</span><span class="params">(v1)</span></span>;	<span class="comment">// call copy constructor</span></span><br><span class="line">        v = v1;			<span class="comment">// call assignment operator</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// the destructor is expected to be called three times</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        Vec&lt;<span class="keyword">int</span>&gt; v;			<span class="comment">// call default constructor</span></span><br><span class="line">        <span class="keyword">if</span>(v.<span class="built_in">size</span>() == <span class="number">0</span>)&#123;		<span class="comment">// test size</span></span><br><span class="line">            v.push_back(<span class="number">10</span>);	<span class="comment">// test push_back function</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// test indexing operator</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"The first element is: "</span> &lt;&lt; v[<span class="number">0</span>] &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// call the destructor</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">Vec&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">5</span>, <span class="number">100</span>)</span></span>;	<span class="comment">// call explicit constructor</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// test iterator</span></span><br><span class="line">        <span class="keyword">for</span>(Vec&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); ++it)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; *(it) &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">        <span class="comment">// call the destructor</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Outputs</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">calling default constructor</span><br><span class="line">calling the explicit constructor</span><br><span class="line">calling copy constructor</span><br><span class="line">calling operator&#x3D; function</span><br><span class="line">calling destructor</span><br><span class="line">calling destructor</span><br><span class="line">calling destructor</span><br><span class="line"></span><br><span class="line">calling default constructor</span><br><span class="line">calling operation[]</span><br><span class="line">The first element is: 10</span><br><span class="line">calling destructor</span><br><span class="line"></span><br><span class="line">calling the explicit constructor</span><br><span class="line">100 100 100 100 100 </span><br><span class="line">calling destructor</span><br></pre></td></tr></table></figure>
<p>The test program generates outputs as expected. As mentioned in last post, the <strong>operator=</strong> function returns a reference to the new constructed class object can be more efficient than returning the value directly. The reason behind this is that returning a value unnecessarily calls the copy constructor and destructor. Letâ€™s verify this by evaluating following statements within the setting of returning by value:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vec&lt;<span class="keyword">int</span>&gt; v;			<span class="comment">// call default constructor</span></span><br><span class="line"><span class="function">Vec&lt;<span class="keyword">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">10</span>, <span class="number">100</span>)</span></span>;	<span class="comment">// call explicit constructor</span></span><br><span class="line">v = v1;			<span class="comment">// call assignment operator</span></span><br></pre></td></tr></table></figure>

<p><strong>Outputs</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">calling default constructor</span><br><span class="line">calling the explicit constructor</span><br><span class="line">calling operator&#x3D; function</span><br><span class="line">calling copy constructor</span><br><span class="line">calling destructor</span><br><span class="line">calling destructor</span><br><span class="line">calling destructor</span><br></pre></td></tr></table></figure>
<p>Comparing with the original version, the outputs are the same. However, the previous program evalutes four statements including a copy construction as well. This program only creates two objects: <strong>v</strong> and <strong>v1</strong>, but additionally calls the copy constructor and destructor once for each after calling the assignment operator. The results confirms our expectation. </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://quantein.com/2018/05/06/Accelerated-C-Solutions-to-Exercises-Chapter-11/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liam">
      <meta itemprop="description" content="Stochastic Modelling Notes; Programming Notes">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Liam's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/05/06/Accelerated-C-Solutions-to-Exercises-Chapter-11/" class="post-title-link" itemprop="url">Accelerated C++ Solutions to Exercises (Chapter 11)</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-05-06 17:54:19" itemprop="dateCreated datePublished" datetime="2018-05-06T17:54:19+08:00">2018-05-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2018-05-08 01:10:14" itemprop="dateModified" datetime="2018-05-08T01:10:14+08:00">2018-05-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Programming/" itemprop="url" rel="index"><span itemprop="name">Programming</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span></span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>NaN:aN</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Exercise-11-0"><a href="#Exercise-11-0" class="headerlink" title="Exercise 11-0"></a>Exercise 11-0</h1><p>Compile, execute, and test the programs in this chapter.</p>
<h2 id="Solution-amp-Results"><a href="#Solution-amp-Results" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>Please find the programs and analysis in <a href="http://quanttour.com/06/05/2018/Defining-abstract-data-types-Part-2/" target="_blank" rel="noopener">Defining abstract data types(Part 2)</a>.</p>
<h1 id="Exercise-11-1-11-2-11-3-11-4"><a href="#Exercise-11-1-11-2-11-3-11-4" class="headerlink" title="Exercise 11-1, 11-2, 11-3, 11-4"></a>Exercise 11-1, 11-2, 11-3, 11-4</h1><p>11-1: The Student_info structure that we defined in Chapter 9 did not define a copy constructor, assignment operator, or destructor. Why not?</p>
<p>11-2: That structure did define a default constructor. Why?</p>
<p>11-3: What does the synthesized assignment operator for Student_info objects do?</p>
<p>11-4: How many members does the synthesized Student_info destructor destroy?</p>
<h2 id="Solution-amp-Results-1"><a href="#Solution-amp-Results-1" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>Recalling the <strong>Student_info</strong> class:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_STUDENT_INFO</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_STUDENT_INFO</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student_info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Student_info ();					<span class="comment">// default constructor</span></span><br><span class="line">	Student_info (<span class="built_in">std</span>::istream &amp;);				<span class="comment">// constructor with argument</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> n; &#125;			<span class="comment">// inline member function return name</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">valid</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> !homework.empty(); &#125;            <span class="comment">// inline member function check state</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::istream &amp; <span class="title">read</span><span class="params">(<span class="built_in">std</span>::istream &amp;)</span></span>;			<span class="comment">// member function read in data</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">()</span> <span class="keyword">const</span></span>;					<span class="comment">// member function calculate final grade</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> n;</span><br><span class="line">    <span class="keyword">double</span> midterm, <span class="keyword">final</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; homework;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::istream &amp; <span class="title">read_hw</span><span class="params">(<span class="built_in">std</span>::istream &amp;, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;)</span></span>; <span class="comment">// nonmember function read data into a vector</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> Student_info &amp;, <span class="keyword">const</span> Student_info &amp;)</span></span>;	   <span class="comment">// nonmember function compare two string</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>If we donâ€™t explicitly define a copy constructor, assignment operator and destructor, the compiler will synthesizes default versions of the unspecified operation. In this case, members <strong>midterm, final</strong> are built-in type variables and hence are copied and assigned by copying or assigning their value. But the destructors for built-in types do nothing. Members <strong>string</strong> and <strong>vector<double></strong> are class type variables and hence are copied, assigned, or destoryed by calling the constructor, assignment operator, and destructor for the data element. It is known that both these two standard classes define the corresponding behaviours in their headers. Therefore, it is unnecessary to define these operations in our class again. When the computer evaluates an assignment, for example</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Student_info <span class="title">record</span><span class="params">(<span class="built_in">cin</span>)</span></span>;   <span class="comment">// construct from input stream</span></span><br><span class="line">Student_info record_copy;   <span class="comment">// construct an empty object</span></span><br><span class="line">record_copy = record;       <span class="comment">// assignment</span></span><br><span class="line">``` </span><br><span class="line">it calls the <span class="keyword">default</span> assignment operators <span class="keyword">for</span> each data member as <span class="keyword">if</span>: </span><br><span class="line">```c++</span><br><span class="line">n = record.n;               <span class="comment">// call assignment operator defined in the string class</span></span><br><span class="line">midterm = record.m;         <span class="comment">// assign values</span></span><br><span class="line"><span class="keyword">final</span> = record.<span class="keyword">final</span>;       <span class="comment">// assign values</span></span><br><span class="line">homework = record.homework; <span class="comment">// call assignment operator defined in the vector class</span></span><br></pre></td></tr></table></figure>
<p>These operations typically involves obliterating the values of the left-hand side operand and then copying values from right-hand side operand into the left-hand side operand. By analogy, we know how the synthesized copy constructor work. When a <strong>Student_info</strong> class object is destructed, the synthesized destructor detroyes its data members by calling their destructors respectively. For <strong>midterm</strong> and <strong>final</strong>, their destructors have no work to do. Therefore, the synthesized Student_info destructor destroyes two data members. </p>
<p>The compiler will synthesize a default constructor for us if and only if we donâ€™t explicitly define any constructors, even a copy constructor. In this case, we explicitly define a contructor with argument and hence no synthesized version for us. In addition, we do need a user-defined default constructor as the built-in types in local scope are undefined following the synthesized operation. </p>
<h1 id="Exercise-11-5"><a href="#Exercise-11-5" class="headerlink" title="Exercise 11-5"></a>Exercise 11-5</h1><p>Instrument the Student_info class to count how often objects are created, copied,assigned, and destroyed. Use this instrumented class to execute the student record programs from Chapter 6. Using the instrumented Student_info class will let you see how many copies the library algorithms are doing. Comparing the number of copies will let you estimate what proportion of the cost differences we saw are accounted for by the use of each library class. Do this instrumentation and analysis. </p>
<h2 id="Solution-amp-Results-2"><a href="#Solution-amp-Results-2" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>To be filled.</p>
<hr>
<h1 id="Exercise-11-6-11-7"><a href="#Exercise-11-6-11-7" class="headerlink" title="Exercise 11-6, 11-7"></a>Exercise 11-6, 11-7</h1><p>Add an operation to remove an element from a Vec and another to empty the entire Vec. These should behave analogously to the erase and clear operations on vectors.</p>
<p>Once youâ€™ve added erase and clear to Vec, you can use that class instead of vector in most of the earlier programs in this book. Rewrite the Student_info programs from Chapter 9 and the programs that work with character pictures from Chapter 5 to use Vecs instead of vectors.</p>
<h2 id="Solution-amp-Results-3"><a href="#Solution-amp-Results-3" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>The original version can be found in <a href="http://quanttour.com/06/05/2018/Defining-abstract-data-types-Part-2/" target="_blank" rel="noopener">C++ - Defining abstract data types(Part 2)</a>. The program below only shows the new contents including the <strong>erase</strong> functions and the <strong>clear</strong> function. </p>
<p><strong>Vec.h</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_VEC_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_VEC_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt; 	 </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">Vec</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// as before</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// erase function</span></span><br><span class="line">    <span class="function">iterator <span class="title">erase</span><span class="params">(iterator iter)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overloaded erase function</span></span><br><span class="line">    <span class="function">iterator <span class="title">erase</span><span class="params">(iterator beg, iterator <span class="built_in">end</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clear function</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; erase(<span class="built_in">begin</span>(), <span class="built_in">end</span>()); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// as before</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">Vec</span>&lt;T&gt;:</span>:iterator Vec&lt;T&gt;::erase(iterator iter)&#123;</span><br><span class="line">    <span class="keyword">if</span> (iter + <span class="number">1</span> != avail)</span><br><span class="line">        <span class="built_in">std</span>::uninitialized_copy(iter + <span class="number">1</span>, avail, iter);</span><br><span class="line">    --avail;</span><br><span class="line">    alloc.destroy(avail);</span><br><span class="line">    <span class="keyword">return</span> iter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">Vec</span>&lt;T&gt;:</span>:iterator Vec&lt;T&gt;::erase(iterator first, iterator last)&#123;</span><br><span class="line">    <span class="keyword">if</span>(last != avail)</span><br><span class="line">        <span class="built_in">std</span>::uninitialized_copy(last, avail, first);</span><br><span class="line">    iterator new_avail = avail - (last - first);</span><br><span class="line">    iterator it = new_avail;</span><br><span class="line">    <span class="keyword">while</span> (it != avail)</span><br><span class="line">        alloc.destroy(it++);</span><br><span class="line">    avail = new_avail;</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The first <strong>erase</strong> function takes one parameter, an iterator, and removes the element pointed by the iterator. The second <strong>erase</strong> function takes two iterators, denoting a range [first, last), and removes all elements in this range. Both <strong>erase</strong> functions return an iterator pointing to the new location of the element that followed the last element erased by the function call. Noting that the position of <strong>limit</strong> keeps unchanged and hence the capacity of this vector remains the same. I only destroy these elements but do not free the space because the destructor will free the space occupied by the range [data, limit). The <strong>clear</strong> function calls the erase function and erase all elements in the range [first(), end()). The test program below shows that all three members work as expected.</p>
<p><strong>mainfunction.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Vec.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Vec&lt;<span class="keyword">double</span>&gt; v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// stores 0-9 into the Vec</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i != <span class="number">10</span>; ++i)</span><br><span class="line">        v.push_back(i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// traverse</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The original list is: "</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i: v)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// erase one by one starting from begin()</span></span><br><span class="line">    Vec&lt;<span class="keyword">double</span>&gt;::iterator i = v.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span>(i != v.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        v.erase(i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i: v)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Vec&lt;<span class="keyword">double</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The size of v1 is: "</span> &lt;&lt; v1.<span class="built_in">size</span>() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// erase first 5 elements</span></span><br><span class="line">    v1.erase(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">begin</span>() + <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The size of v1 is: "</span> &lt;&lt; v1.<span class="built_in">size</span>() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The rest elements are: "</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i: v1)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clear the Vec</span></span><br><span class="line">    v1.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The size of v1 is: "</span> &lt;&lt; v1.<span class="built_in">size</span>() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Outputs</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">The original list is: 0 1 2 3 4 5 6 7 8 9 </span><br><span class="line">1 2 3 4 5 6 7 8 9 </span><br><span class="line">2 3 4 5 6 7 8 9 </span><br><span class="line">3 4 5 6 7 8 9 </span><br><span class="line">4 5 6 7 8 9 </span><br><span class="line">5 6 7 8 9 </span><br><span class="line">6 7 8 9 </span><br><span class="line">7 8 9 </span><br><span class="line">8 9 </span><br><span class="line">9 </span><br><span class="line"></span><br><span class="line">The size of v1 is: 10</span><br><span class="line">The size of v1 is: 5</span><br><span class="line">The rest elements are: 10 10 10 10 10 </span><br><span class="line">The size of v1 is: 0</span><br></pre></td></tr></table></figure>
<p>It is easy to rewrite the Student_info programs from Chapter 9 and the programs that work with character pictures from Chapter 5. No more discussion here.</p>
<hr>
<h1 id="Exercise-11-8"><a href="#Exercise-11-8" class="headerlink" title="Exercise 11-8"></a>Exercise 11-8</h1><p>Write a simplified version of the standard list class and its associated iterator.</p>
<h2 id="Solution-amp-Results-4"><a href="#Solution-amp-Results-4" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><h2 id="To-be-filled"><a href="#To-be-filled" class="headerlink" title="To be filled."></a>To be filled.</h2><h1 id="Exercise-11-9"><a href="#Exercise-11-9" class="headerlink" title="Exercise 11-9"></a>Exercise 11-9</h1><p>The grow function in Â§11.5.1/208 doubles the amount of memory each time it needsmore. Estimate the efficiency gains of this strategy. Once youâ€™ve predicted how much of a difference it makes, change the grow function appropriately and measure the difference.</p>
<h2 id="Solution-amp-Results-5"><a href="#Solution-amp-Results-5" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>There is an article written by the authors Andrew Koenig and Barbara E. Mooon about this topic <a href="http://www.drdobbs.com/c-made-easier-how-vectors-grow/184401375" target="_blank" rel="noopener">C++ Made Easier: How Vectors Grow</a>.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://quantein.com/2018/04/24/C-Implementations-Dynamic-Array-based-Stack/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liam">
      <meta itemprop="description" content="Stochastic Modelling Notes; Programming Notes">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Liam's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/24/C-Implementations-Dynamic-Array-based-Stack/" class="post-title-link" itemprop="url">C++ Implementation: Dynamic Array-based Stack</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-04-24 15:22:42" itemprop="dateCreated datePublished" datetime="2018-04-24T15:22:42+08:00">2018-04-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2018-05-30 11:58:06" itemprop="dateModified" datetime="2018-05-30T11:58:06+08:00">2018-05-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithms/" itemprop="url" rel="index"><span itemprop="name">Algorithms</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span></span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>NaN:aN</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>Stack</strong> is one of the rudimentary data structures that use pointers, with a main feature that it implements the <strong>Delete</strong> operation following <strong><em>last in, first out</em></strong> (i.e. <strong><em>LIFO</em></strong>). More specific, a <strong>stack</strong> is a dynamic set that allows <strong>Insert</strong> and <strong>Delete</strong> operations, which are typically named <strong>push</strong> and <strong>pop</strong> respectively. </p>
<p>The program given below illustrates an <strong>ADT</strong> named <strong>my_stack</strong>, which implements the <strong>stack</strong> based on a dynamic allocated array.<br><strong>my_stack</strong> is a class template and provides an interface that allows following operations:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">my_stack ms;        &#x2F;&#x2F; create a stack with fixed capacity 1000</span><br><span class="line">my_stack s(100);    &#x2F;&#x2F; create a stack with a user-supplied capacity </span><br><span class="line">s.get_capacity();   &#x2F;&#x2F; get the current capacity of s</span><br><span class="line">s.size();           &#x2F;&#x2F; get the number of elements contained in s</span><br><span class="line">s.empty();          &#x2F;&#x2F; check whether the stack is empty</span><br><span class="line">s.push();           &#x2F;&#x2F; insert an new element into the stack at the end of it</span><br><span class="line">s.pop();            &#x2F;&#x2F; delete the last inserted element from the stack, and return the deleted element</span><br><span class="line">s.top_element();    &#x2F;&#x2F; return the top element only</span><br></pre></td></tr></table></figure>
<p>Noting that the capacity of a stack means how many elements the stack can contain while the size means how many elements have the stack stored. </p>
<p><strong>stack implementation</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MYSTACK_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYSTACK_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;	// std::cout, std::endl</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;	// std::size_t</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;// std::domain_error</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">MyStack</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> size_type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// default constructor</span></span><br><span class="line">    MyStack(): top(<span class="number">0</span>), capacity(<span class="number">1000</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"default constructor"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        p = <span class="keyword">new</span> T[capacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// constructor with user-defined capacity</span></span><br><span class="line">    explicit MyStack(size_type t): top(0), capacity(t) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"constructor with user-defined size"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        p = <span class="keyword">new</span> T[capacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// copy constructor</span></span><br><span class="line">    MyStack(<span class="keyword">const</span> MyStack&amp; s): top(<span class="number">0</span>), capacity(s.capacity)&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"copy constructor"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        p = <span class="keyword">new</span> T[capacity];</span><br><span class="line">        T* temp = s.p;</span><br><span class="line">        <span class="keyword">while</span>(top != s.top)&#123;</span><br><span class="line">            p[top] = *temp;</span><br><span class="line">            ++top;</span><br><span class="line">            ++temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// assignment operator</span></span><br><span class="line">    MyStack&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> MyStack&amp; s)&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"assignment operator"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span>(&amp;s != <span class="keyword">this</span>)&#123;</span><br><span class="line">            <span class="built_in">clear</span>();</span><br><span class="line">            capacity = s.capacity;</span><br><span class="line">            p = <span class="keyword">new</span> T[capacity];</span><br><span class="line">            T* temp = s.p;</span><br><span class="line">            <span class="keyword">while</span>(top != s.top)&#123;</span><br><span class="line">                p[top] = *temp;</span><br><span class="line">                ++top;</span><br><span class="line">                ++temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// destructor</span></span><br><span class="line">    ~MyStack() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] p;</span><br><span class="line">        p = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        top = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// capacity: O(1)</span></span><br><span class="line">    <span class="function">size_type <span class="title">get_capacity</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> capacity; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// size: O(1)</span></span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> top; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// empty</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> top == <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// top_element: O(1)</span></span><br><span class="line">    <span class="function">T <span class="title">top_element</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> p[top - <span class="number">1</span>]; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// push element: O(1)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T&amp; t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(top == capacity)</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">std</span>::domain_error(<span class="string">"stack overflow"</span>);</span><br><span class="line">        p[top] = t;</span><br><span class="line">        ++top;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pop element and return the deleted element: O(1)</span></span><br><span class="line">    <span class="function">T <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(top == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">std</span>::domain_error(<span class="string">"stack underflow"</span>);</span><br><span class="line">        --top;</span><br><span class="line">        <span class="keyword">return</span> p[top];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	size_type top;		<span class="comment">// count the number of elements</span></span><br><span class="line">	size_type capacity;	<span class="comment">// capacity of the stack</span></span><br><span class="line">	T* p;				<span class="comment">// a hidden pointer to head</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* MYSTACK_H_ */</span></span></span><br></pre></td></tr></table></figure>

<p>The shortcoming of above stack is that it cannot grow automatically. Except constructors, each of member functions has constant complexity. The follwing program tests each operation listed above and shows that the my_stack works as expected. </p>
<p><strong>stack test</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * this program tests all operations that provided by the MyStack&lt;int&gt; class</span></span><br><span class="line"><span class="comment"> * created by Liam on: 27 Apr 2018</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;		// std::cout, std::endl</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;	// std::domain_error</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MyStack.h"</span>	<span class="comment">// MyStack</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::domain_error;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#123;	<span class="comment">// test default constructor</span></span><br><span class="line">        MyStack&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// test member capacity()</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"The capacity of the stack is: "</span> &lt;&lt; s.get_capacity() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// test member empty()</span></span><br><span class="line">        <span class="keyword">if</span>(s.empty())</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"The stack is empty\n"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// test member push(const T&amp; t)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i != <span class="number">10</span>; ++i)</span><br><span class="line">            s.push(i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// test member pop</span></span><br><span class="line">        <span class="keyword">while</span>(s.<span class="built_in">size</span>() != <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; s.pop() &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\n\n"</span>;</span><br><span class="line"></span><br><span class="line">    &#123;	<span class="comment">// test constructor with size</span></span><br><span class="line">        <span class="function">MyStack&lt;<span class="keyword">int</span>&gt; <span class="title">s</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i != s.get_capacity(); ++i)</span><br><span class="line">            s.push(i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// test the case of overflow</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            s.push(<span class="number">10</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(<span class="built_in">std</span>::domain_error e)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; e.what() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// test copy constructor</span></span><br><span class="line">        <span class="function">MyStack&lt;<span class="keyword">int</span>&gt; <span class="title">s_copy</span><span class="params">(s)</span></span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"The top element in MyStack is: "</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; s_copy.top_element() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// test assignment operator</span></span><br><span class="line">        s.pop();</span><br><span class="line">        s_copy = s;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(s_copy.<span class="built_in">size</span>() != <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; s_copy.pop() &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            s_copy.pop();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(domain_error e)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; e.what() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Outputs</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> constructor</span><br><span class="line">The capacity of the <span class="built_in">stack</span> is: <span class="number">1000</span></span><br><span class="line">The <span class="built_in">stack</span> is empty</span><br><span class="line"><span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">0</span> </span><br><span class="line"></span><br><span class="line">constructor with user-defined <span class="built_in">size</span></span><br><span class="line"><span class="built_in">stack</span> <span class="built_in">overflow</span></span><br><span class="line">copy constructor</span><br><span class="line">The top element in MyStack is: <span class="number">9</span></span><br><span class="line">assignment <span class="keyword">operator</span></span><br><span class="line"><span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">0</span> <span class="built_in">stack</span> underflow</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://quantein.com/2018/04/22/C-Making-class-objects-act-like-values/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liam">
      <meta itemprop="description" content="Stochastic Modelling Notes; Programming Notes">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Liam's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/22/C-Making-class-objects-act-like-values/" class="post-title-link" itemprop="url">C++ - Making class objects act like values</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-04-22 09:09:27" itemprop="dateCreated datePublished" datetime="2018-04-22T09:09:27+08:00">2018-04-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2018-04-23 23:24:39" itemprop="dateModified" datetime="2018-04-23T23:24:39+08:00">2018-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Programming/" itemprop="url" rel="index"><span itemprop="name">Programming</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span></span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>NaN:aN</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>As last chapter introduces, we can control what happens when objects are created, copied, assigned, and destroyed by defining special members. Now we intend to make class objects act like objects of built-in types through controlling more operations such as type conversion. A typical example is that the standard library class <strong>string</strong> provides rich set of operators and supports automatic conversions. Following the standard <strong>string</strong>, weâ€™ll write our own <strong>Str</strong> class. </p>
<h1 id="A-simple-string-class"><a href="#A-simple-string-class" class="headerlink" title="A simple string class"></a>A simple string class</h1><p>Analogous to the <strong>Vec</strong> class built in last chapter, we could write our <strong>Str</strong> based on dynamiclly allocated array. But it is also known that the standard <strong>string</strong> share many operations with the standard <strong>vector</strong> while the major difference is that a <strong>string</strong> is a container that only contains <strong>char</strong> elements. Therefore, we can design <strong>Str</strong> based on <strong>Vec</strong> rather than the lower level data structure. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Str</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> Vec&lt;<span class="keyword">char</span>&gt;::size_type size_type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// default constructor; create an empty Str</span></span><br><span class="line">    Str() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create a Str containing n copies of c</span></span><br><span class="line">    Str(size_type n, <span class="keyword">char</span> c): data(n, c) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create a Str from a null-terminated array of char</span></span><br><span class="line">    Str(<span class="keyword">const</span> <span class="keyword">char</span>* cp)&#123;</span><br><span class="line">        <span class="built_in">std</span>::copy(cp, cp + <span class="built_in">std</span>::<span class="built_in">strlen</span>(cp), <span class="built_in">std</span>::back_inserter(data));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create a Str from the range denoted by iterators b and e</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">In</span>&gt; <span class="title">Str</span>(<span class="title">In</span> <span class="title">b</span>, <span class="title">In</span> <span class="title">e</span>)&#123;</span></span><br><span class="line">        <span class="built_in">std</span>::copy(b, e, <span class="built_in">std</span>::back_inserter(data));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Vec&lt;<span class="keyword">char</span>&gt; data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>It can be observed that our <strong>Str</strong> is implemented through a hidden <strong>Vec<char></strong>. There are four constructors defined in above class. The first functon is a default constructor that creates an empty <strong>Str</strong> through invoking the <strong>Vec</strong> <strong>default constructor</strong>. It is worth noting that we have to explicitly define a default constructor thought it does exactly . If we donâ€™t define a default constructor,the compiler wonâ€™t synthesize one for us as there exist other constructors. The second constructor takes a size and a character and initializes the only data member <strong>data</strong> by invoking another <strong>Vec</strong> constructor that takes a size and a value. The third constructor allows us to create a string with passing an argument that is a pointer to char, that is, a null-terminated array of char. It uses the standard algorithm <strong>copy</strong> to copy the elements from the array of char, covering the range <strong>[cp, cp+std::strlen(cp))</strong> into <strong>data</strong>. <strong>cp</strong> points to the first character of the array and <strong>cp + std::strlen(cp)</strong>, where <strong>strlen(cp) returns the length of the array excluding the â€˜\0â€™</strong>, points to one past the last character in the array. Similarly, the last constructor creates a <strong>string</strong> by taking two input iterators that denotes a sequence of characters. But it is worth nothing that it is not a function but a function template. It accepts different kinds of iterators, which implies that it can construct a string object from various containers like the array of char, standard vector, standard list etc.. </p>
<p>We also observed that the <strong>Str</strong> doesnâ€™t define a copy constructor, assignment operator and default destructor. The synthesized operations call the corresponding members of <strong>Vec</strong> when we copy or assign or destruct the <strong>Str</strong> object. In fact, the <strong>Str</strong> class does no memory allocation and hence doesnâ€™t require a destructor. According to the rule of three, a class that needs no destructor doesnâ€™t need an explicit copy constructor or assignment operator either. </p>
<h1 id="Automatic-conversions"><a href="#Automatic-conversions" class="headerlink" title="Automatic conversions"></a>Automatic conversions</h1><p>In the case of the <strong>Str</strong> class, the conversions may happen when we assign a string literal to a string type object. For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Str t;    <span class="comment">// default initialize t</span></span><br><span class="line">t = <span class="string">"hello"</span>;    <span class="comment">// assign a new value to t</span></span><br></pre></td></tr></table></figure>
<p>The first statement creates an empty string and the second statement assigns the value of the right-hand side to the left-hand side. However, the left-hand side has type <strong>Str</strong> while the right-hand side has type <strong>const char*</strong>. In addition, we didnâ€™t define the assignment operator. How does the compiler evaluates this expression? It turns out that the compiler will call the constructor that takes the a <strong>const char*</strong>. In other words, the statement invokes the same constructor as the following statement:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Str <span class="title">t</span><span class="params">(<span class="string">"hello"</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>This example indicates that constructors also acts a <strong>user-defined conversion</strong> which determines how to transform to and from objects of class type. In generally, we define conversions by defining a constructor with a single argument. The above statement <strong>t = â€œhelloâ€;</strong> involves two steps: firstly, calling the <strong>Str(const char*)</strong> to construct an unnamed local temporary of type <strong>Str</strong> from the string literal; then calls the synthesized assignment operator to assign this temporary to <strong>t</strong>. </p>
<h1 id="Str-operations"><a href="#Str-operations" class="headerlink" title="Str operations"></a>Str operations</h1><p>Now we further extent the operations of our <strong>Str</strong> class such that a <strong>Str</strong> type string <strong>s</strong> supports following operations:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cin</span> &gt;&gt; s;    <span class="comment">// use the input operator to read a string</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s;   <span class="comment">// use the output operator to write a string</span></span><br><span class="line">s[i];        <span class="comment">// use the index operator to access a character</span></span><br><span class="line">s1 + s2;     <span class="comment">// use the addition operator to concatenate two strings</span></span><br></pre></td></tr></table></figure>

<h2 id="indexing-operator"><a href="#indexing-operator" class="headerlink" title="indexing operator"></a>indexing operator</h2><p>We have learned how to define a operator, such as <strong>operator=</strong>, in defining the <strong>Vec</strong> class. We can define these operators in a similar manner. All above operators are binary operators and hence each operator function takes two parameters, one of which may be implicit if the function is a member. We are familar with the indexing operator. Letâ€™s define it first:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Str</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// constructors as before</span></span><br><span class="line">    <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](size_type i) &#123; <span class="keyword">return</span> data[i]; &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](size_type i) <span class="keyword">const</span> &#123; <span class="keyword">return</span> data[i]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Vec&lt;<span class="keyword">char</span>&gt; data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>We define two operators to take the case that access elements of a const string into consideration. Details of the implementation go to the indexing operator defined in the <strong>Vec<char></strong>. </p>
<h2 id="input-and-output-operator"><a href="#input-and-output-operator" class="headerlink" title="input and output operator"></a>input and output operator</h2><p>Now letâ€™s think about how to implement the input operator <strong>&gt;&gt;</strong> and the output operator <strong>&lt;&lt;</strong>. The first problem is should these operators be members of a class? Due to the operator (e.g. &gt;&gt;) changes the state of a string, we might think it should be a member of the <strong>Str</strong>. But it is also known that the left operand is bound to the first parameter while the right operand is bound to the second parameter. Thus, </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cin</span> &gt;&gt; s;</span><br></pre></td></tr></table></figure>
<p>is equivalent to </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cin.operator &gt;&gt; (s);</span><br></pre></td></tr></table></figure>
<p>which calls the overloaded &gt;&gt; operator defined for the object <strong>cin</strong>. This implies that the operator should be a member of the <strong>istream</strong> class. However, we cannot define such operation as we donâ€™t have the definition of the <strong>istream</strong> class. If we define the operator in <strong>Str</strong>, it should invoke the input operation through</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.operation&gt;&gt; (<span class="built_in">cin</span>);</span><br></pre></td></tr></table></figure>
<p>or equivalently,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s &gt;&gt; cin;</span><br></pre></td></tr></table></figure>
<p>which obviously would flout the conventions used throughout the library. </p>
<p>Know then that both the input and output operators should be non-member functions. Letâ€™s declare two non-member functions:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::istream&amp; <span class="keyword">operator</span>&gt;&gt;(<span class="built_in">std</span>::istream&amp;, Str&amp;);</span><br><span class="line"><span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp;, <span class="keyword">const</span> Str&amp;);</span><br></pre></td></tr></table></figure>
<p>To write the output operator, we need to access each character stored in the <strong>Str</strong>. Therefore, the implementation could be</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="keyword">const</span> Str&amp; s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(Str::size_type i = <span class="number">0</span>; i != s.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        os &lt;&lt; s[i];</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>To use this function, we have to define the <strong>size</strong> member first</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Str</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> data.<span class="built_in">size</span>(); &#125;</span><br><span class="line">    <span class="comment">// as before</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Friends"><a href="#Friends" class="headerlink" title="Friends"></a>Friends</h3><p>Unlike the output operator, the input operator is a little bit complex. The logic is that each time read one character from the input stream and then add the character to our <strong>Str</strong>. The experience of using the standard <strong>string</strong> tells us that when reading data from the input stream, it discards the leading whitespace. Beyond this, we should also take into consider the case that there exist old values in the <strong>Str</strong>. Letâ€™s see how following code deal with these problems.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// this code won't compile quite yet</span></span><br><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; is, Str&amp; s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// obliterate existing value(s)</span></span><br><span class="line">    s.data.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read and discard leading whitespace</span></span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">while</span>(is.<span class="built_in">get</span>(c) &amp;&amp; <span class="built_in">isspace</span>(c))</span><br><span class="line">        ; <span class="comment">// nothing to do except testing the condition</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// if still something to read, do so until next whitespace character</span></span><br><span class="line">    <span class="keyword">if</span>(is) &#123;</span><br><span class="line">        <span class="keyword">do</span> s.data.push_back(c); </span><br><span class="line">        <span class="keyword">while</span>(is.<span class="built_in">get</span>(c) &amp;&amp; !<span class="built_in">isspace</span>(c));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if we read whitespace, then put it back on the stream</span></span><br><span class="line">        <span class="keyword">if</span>(is)</span><br><span class="line">            is.unget();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>the first step is to obliterate the old values. </li>
<li>the second step is to discard the leading whitespace. Two conditions control the while loop, one is that whether characters are available and another one is that whether the character read from the input stream is a space. The member function <strong>get</strong> extracts one character each time, if there exists characters, it returns the character and will be evaluated to <strong>true</strong>. If there no available character, it returns eof and will be evaluated to <strong>false</strong>. In summary, if the while loop ceases, there would be two situations, no character is available or the character is not a whitespace anymore. </li>
<li>then we perform reading process if there still available character in the input stream after step 2. The reading process calls the member function <strong>push_back</strong> to append one character one time. It stops if it reads nothing from the stream or encounters a whitespace. In the case that it encounters a whitespace, there might be other characters following the extracted whitespace. Therefore, we should put the extracted whitespace back on the stream. This is done by calling another member function of the <strong>istream</strong> class, that is, <strong>unget</strong> which decreases the current location by one character such that the extracted character can be extracted again next. </li>
</ol>
<p>The logic is perfect and we do solve the problems mentioned earlier. However, above code fails to compile due to that <strong>operator&gt;&gt;</strong> is not allowed to access the private data member <strong>data</strong> defined in the <strong>Str</strong>. We could add public member functions <strong>clear</strong> and <strong>push_back</strong> to our <strong>Str</strong> class like we did for our <strong>Vec</strong> class. But in this case, well solve this problem with an alternative method, using keyword <strong>friend</strong>.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Str</span>&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">std</span>::istream&amp; <span class="keyword">operator</span>&gt;&gt;(<span class="built_in">std</span>::istream&amp;, Str&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>A <strong>friend</strong> gives the function <strong>operator&gt;&gt;</strong> access and write rights to the private data members defined in the <strong>Str</strong> class. In other words, if making one function a <strong>friend</strong> of a class, we are saying that the function will be treated as a member (either public or private) by the class. Above code shows that we add the declaration of <strong>operator&gt;&gt;</strong> into the <strong>Str</strong> class and specify it is a friend of the class. </p>
<h2 id="Other-binary-operators"><a href="#Other-binary-operators" class="headerlink" title="Other binary operators"></a>Other binary operators</h2><p>We also consider that define the addition operator as a non-member function. The reason is that the addition operation doesnâ€™t change values of the left-hand operand as well as the right-hand operand. The result of the addition operation between two strings is a string that concatenates two strings. Thus, the return type shoule be <strong>Str</strong>. Therefore, the <strong>operator=</strong> may be declared as follows:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Str <span class="keyword">operator</span>+(<span class="keyword">const</span> Str&amp;, <span class="keyword">const</span> Str&amp;);</span><br></pre></td></tr></table></figure>
<p>After we complete writing the implementation, our program would supports the concatenation operation between two <strong>Str</strong>s through</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Str s1 = <span class="string">"xxx"</span>;</span><br><span class="line">Str s2 = <span class="string">"yyy"</span>;</span><br><span class="line">s1 = s1 + s2;</span><br></pre></td></tr></table></figure>
<p>Our experience tells us that we can concatenate two standard strings in an alternative form:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s1 += s2;</span><br></pre></td></tr></table></figure>
<p>Both two statements involve two processes: the right-hand side creates a new temporary object that is the concatenation of two strings, then the value of the constructed object is assigned to the left-hand side. The difference is that <strong>operator+=</strong> changes the value of left-hand operand. Therefore, we will define the <strong>operator+=</strong> as a public member of the <strong>Str</strong> class. Letâ€™s see how to define <strong>operator+=</strong> first</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Str</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Str&amp; <span class="keyword">operator</span>+=(<span class="keyword">const</span> Str&amp; s)&#123;</span><br><span class="line">        <span class="built_in">std</span>::copy(s.data.<span class="built_in">begin</span>(), s.data.<span class="built_in">end</span>(), <span class="built_in">std</span>::back_inserter(data));</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// as before</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Vec&lt;<span class="keyword">char</span>&gt; data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// as before</span></span><br><span class="line">Str <span class="keyword">operator</span>+(<span class="keyword">const</span> Str&amp;, <span class="keyword">const</span> Str&amp;);</span><br></pre></td></tr></table></figure>
<p>There is nothing new in above implementation of the <strong>operator+=</strong>. Now letâ€™s define the <strong>operator+</strong>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Str <span class="keyword">operator</span>+(<span class="keyword">const</span> Str&amp; s, <span class="keyword">const</span> Str&amp; t)&#123;</span><br><span class="line">    Str r = s;</span><br><span class="line">    r += t;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In the definition, we use the <strong>operator+=</strong> and the synthesized copy constructor to achieve the concatenation of two strings.  </p>
<h2 id="Mixed-type-expressions"><a href="#Mixed-type-expressions" class="headerlink" title="Mixed-type expressions"></a>Mixed-type expressions</h2><p>The standard library <strong>string</strong> class also allows us to concatenate a string literal and a string regardless there order. As a result, we get a new string type object. For our <strong>Str</strong> class, we have defined the concatenation <strong>operator</strong> that takes operands of type <strong>const Str&amp;</strong>. So, What would happen if following statement is evaluated:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Str greeting = <span class="string">"Hello, "</span> + name + <span class="string">"!"</span>; <span class="comment">// where **name** is a **Str** type object.</span></span><br></pre></td></tr></table></figure>
<p>an alternative and equivalent statement</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Str greeting = (<span class="string">"Hello, "</span> + name) + <span class="string">"!"</span>;</span><br></pre></td></tr></table></figure>
<p>We can observe that there are two forms of <strong>+</strong>. The first <strong>+</strong> takes a string literal as its first operand and a <strong>Str</strong> as its seconnd operand, while in the other, the left operand is a <strong>Str</strong> and the right operand is a string literal. We may think that we should define two additional <strong>operator+</strong> to handle these two case as the <strong>operator+</strong> defined above only takes two arguments that are both <strong>const Str&amp;</strong>. In fact, our <strong>Str</strong> class handles these expressions already, by means of calling the constructor that takes a <strong>const char*</strong>. This is because that the constructor is also a conversion operator that can convert a <strong>const char*</strong> to a <strong>Str</strong>. Letâ€™s see how exactly the <strong>Str</strong> deal with this statement:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="function">Str <span class="title">temp1</span><span class="params">(<span class="string">"Hello, "</span>)</span></span>;        <span class="comment">// call Str::Str(const char*)</span></span><br><span class="line"><span class="number">2.</span> Str temp2 = temp1 + name;    <span class="comment">// call operator+(const Str&amp;, const Str&amp;)</span></span><br><span class="line"><span class="number">3.</span> <span class="function">Str <span class="title">temp3</span><span class="params">(<span class="string">"!"</span>)</span></span>;              <span class="comment">// call Str::Str(const char*)</span></span><br><span class="line"><span class="number">4.</span> Str greeting = temp2 + temp3;<span class="comment">// call operator+(const Str&amp;, const Str&amp;)</span></span><br></pre></td></tr></table></figure>
<p>The implied conversion operations may be expensive due to multiple temporaries. But certainly, we still can explicitly define two additional versions o the <strong>operator+</strong> to deal with this case. </p>
<h2 id="Designing-binary-operators"><a href="#Designing-binary-operators" class="headerlink" title="Designing binary operators"></a>Designing binary operators</h2><p>There are some rules in defining binary operators(Koening and Moo 2000):</p>
<p><em>1. If a class supports type conversions, then it is usually good practice to define binary operators as nonmember functions. By doing so, we preserve symmetry between the operands.</em></p>
<p><em>2. If an operator is a member of a class, then that operatorâ€™s left operand cannot be the result of an automatic conversion.</em></p>
<p><em>3. The left operand of a nonmember operator, and the right operand of any operator, follow the same rules as any ordinary function argument: the operand can be any type that can be converted to the parameter type.</em></p>
<p><em>4. like the assignment operator itself, all the compound-assignment operators (e.g. +=) should be members of the class.</em></p>
<h2 id="Some-conversions-are-hazardous"><a href="#Some-conversions-are-hazardous" class="headerlink" title="Some conversions are hazardous"></a>Some conversions are hazardous</h2><p>Recalling the <strong>Vec</strong> class designed in last chapter, it contains a constructor that takes a size (and a value if supplied) (as shown below). </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Vec</span><span class="params">(size_type n, <span class="keyword">const</span> T&amp; t = T())</span> </span>&#123; create(n, t); &#125;</span><br></pre></td></tr></table></figure>
<p>The <strong>explicit</strong> specifies that the constructor can only construct an object explicitly. If we donâ€™t declare the <strong>Vec</strong> constructor as <strong>explicit</strong>, then we could implicitly create a Vec of a given size. To illustrate how useful the <strong>explicit</strong> is, letâ€™s see an example:<br>. It is crucial that consider about the type conversion when defining a single parameter constructor for a class.</p>
<h1 id="Conversion-operators"><a href="#Conversion-operators" class="headerlink" title="Conversion operators"></a>Conversion operators</h1><p>We have known that we can implicitly define conversion operations through defining constructors. Those cases typically involve that a class defines how to convert an object from a different type to the type of the class itself. In fact, class authors can also explicitly define <strong>conversion operators</strong>, which determines how to convert an object from its type to a target type.  </p>
<p>A <strong>conversion operator</strong> must be defined as a member of a class, begining with the keyword <strong>operator</strong> followed by the target type name. For example, </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">class <span class="title">Student_info</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>The <strong>conversion operator</strong> above defines that a <strong>Student_info</strong> can be converted to a <strong>double</strong> type object. The definition of <strong>operator</strong> would say how exactly create a <strong>double</strong> from a <strong>Student_info</strong>. For example, we can convert the class object to its corresponding final grade, and then use this property in calculating an average grade for a class.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;Student_info&gt; vs;</span><br><span class="line"><span class="comment">// fill up vs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> d = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> = <span class="number">0</span>; i != vs.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    d += vs[i]; <span class="comment">// vs[i] is automatically converted to double</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Average grade: "</span> &lt;&lt; d/vs.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>In fact, we use this kind conversion operator everytime when we write a loop that implicitly tests the value of an <strong>istream</strong>. See the example</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">cin</span> &gt;&gt; x) &#123; <span class="comment">/*...*/</span> &#125;</span><br></pre></td></tr></table></figure>
<p>is equivalent to</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">cin</span>) &#123; <span class="comment">/*...*/</span> &#125;</span><br></pre></td></tr></table></figure>
<p>It is known that the condition should be an expression that yields a value that is convertible to type <strong>bool</strong>. Using a value of any arithmetic or pointer type automatically converts the value to type <strong>bool</strong>, thus we can uses values of these type in the expression. But a <strong>iostream</strong> object neither an arithmetic type object nor a pointer type object. To makes the <strong>if condition</strong> works in above case, the standard library defines a conversion from type <strong>istream</strong> to <strong>void*</strong>, i.e. a pointer to <strong>void</strong>. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">istream::<span class="keyword">operator</span> <span class="keyword">void</span>* &#123;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The <strong>operator</strong> tests various status flags to to determine whether the <strong>istream</strong> is valid and return either 0 or an implementation-defined non-zero <strong>void*</strong> value to indicate the state of the stream. </p>
<p>It is necessary to explain the use of <strong>void*</strong>. A pointer to <strong>void</strong> is known as a <strong>universal pointer</strong> which can point to any type of object. We cannot deference such pointer because the type of the object to yield is unknown. But we can convert a <strong>void*</strong> to <strong>bool</strong>. </p>
<p>One might wonder why donâ€™t the <strong>istream</strong> define conversion operator to <strong>bool</strong> directly. The reason is that doing so allows the compiler to detect the following erroneous usage:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">cin</span> &lt;&lt; x; <span class="comment">// we should have to written cin &gt;&gt; x</span></span><br></pre></td></tr></table></figure>
<p>If the conversion operator converts a <strong>istream</strong> object to <strong>bool</strong>, this expression would convert <strong>cin</strong> to a <strong>bool</strong>, and thereby converts the bool to <strong>int</strong> again. As a result, the converted value is shifted left by a number of bits equal to the value of <strong>x</strong>. </p>
<h1 id="Conversions-and-memory-management"><a href="#Conversions-and-memory-management" class="headerlink" title="Conversions and memory management"></a>Conversions and memory management</h1><p>In this section, we think about the conversion that from a string type to a null-terminated arrays of characters. If we can successfully convert a string to an array of characters, we then can pass the string to a functions that requires and operates on null-terminated arrays. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Str</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// plausible, but problematic conversion operations</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="keyword">char</span>*();</span><br><span class="line">    <span class="keyword">operator</span> <span class="keyword">const</span> <span class="keyword">char</span>*() <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// as before</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Vec&lt;<span class="keyword">char</span>&gt; data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>If above code works, we then can write code such as</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Str S;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="function">ifstream <span class="title">in</span><span class="params">(s)</span></span>; <span class="comment">// wishful thinking: converts s and then open the stream named s</span></span><br></pre></td></tr></table></figure>
<p><em>(Noting that since c++11, <strong>ifstream</strong> allows us to open a file using either a string type name or a c-stype(i.e. null-termintated array) name.)</em></p>
<p>There are several difficulties in defining such operator: </p>
<ol>
<li>we canâ€™t simply return <strong>data</strong> as <strong>data</strong> is a <strong>Vec<char></strong> while we need an array of <strong>char</strong>.</li>
<li>if we design our <strong>Vec</strong> based on an array of <strong>char</strong>, we could return it as the converted result. However, doing so exposes the private data member, which violates the class <strong>Str</strong>â€˜s encapsulation. If users obtained a pointer to <strong>data</strong>, they could change the value of the string. In addition, if the string is destroyed, then the pointer becomes invalid and any related operations would be dengerous. </li>
</ol>
<p>To solve the encapsulation problem, we may provide only one conversion to <strong>const char*</strong>. To solve the dangling pointer problem, we may allocate a new space for a copy of the characters from data, and returning a pointer to this newly allocated space. By doing so, users can manage the allocated storage properly. However, this design probably doesnâ€™t work either because the conversion happens implicitly and hence no pointer is provided explicitly. </p>
<p>The standard <strong>string</strong> class takes a different approach that allows us to get a copy of the <strong>string</strong> in a character array but also makes them do explicitly. It defines three member functions to get a character array from a <strong>string</strong>. The first is <strong>c_str()</strong> which copies the contents of the <strong>string</strong> into a null-terminated <strong>char</strong> array. The <strong>string</strong> owns the array and users are expected not to delete the pointer. The data in the array are ephemeral and is only valid until the next call of a member function that might change the <strong>string</strong>. The second <strong>data()</strong> is like <strong>c_str</strong> except that it returns an array that is not null-terminated (c++11 releases this condition and hence data() and c_str() are synonym and return the same value). Finally, the <strong>copy</strong> function takes a <strong>char*</strong> and an integer as arguments, and copies as many characters as indicated by the integer into space pointed by the <strong>char*</strong>, which soace the user must allocate and free. These functions work as we expected. However, this type of <strong>coversions</strong> seems explicitly rather than implicitly. </p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://quantein.com/2018/04/15/Implementing-the-C-STL-Algorithms-Part-1-Simple-Find-Algorithms/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liam">
      <meta itemprop="description" content="Stochastic Modelling Notes; Programming Notes">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Liam's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/15/Implementing-the-C-STL-Algorithms-Part-1-Simple-Find-Algorithms/" class="post-title-link" itemprop="url">Implementing the C++ STL Algorithms-Part 1: Simple Find Algorithms</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-04-15 13:35:09" itemprop="dateCreated datePublished" datetime="2018-04-15T13:35:09+08:00">2018-04-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2018-04-16 15:51:37" itemprop="dateModified" datetime="2018-04-16T15:51:37+08:00">2018-04-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithms/" itemprop="url" rel="index"><span itemprop="name">Algorithms</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span></span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>NaN:aN</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="find-beg-end-val"><a href="#find-beg-end-val" class="headerlink" title="find(beg, end, val)"></a><strong>find(beg, end, val)</strong></h1><h2 id="Possible-implementation"><a href="#Possible-implementation" class="headerlink" title="Possible implementation"></a>Possible implementation</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">InputIterator</span> <span class="title">find</span>(<span class="title">InputIterator</span> <span class="title">beg</span>, <span class="title">InputIterator</span> <span class="title">end</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">val</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">while</span>(beg != <span class="built_in">end</span> &amp;&amp; *beg != val)</span><br><span class="line">        ++beg;</span><br><span class="line">    <span class="keyword">return</span> beg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Key-points"><a href="#Key-points" class="headerlink" title="Key points"></a>Key points</h2><ol>
<li>parameters <strong>beg</strong> and <strong>end</strong> are two <strong>Input iterators</strong>,denoting that the range searched is [beg, end). <strong>val</strong> is the value to search for in the range. </li>
<li>the algorithm returns an iterator to the first element in the range [beg, end) equal to <strong>val</strong>. If no such element is found, the function returns <strong>end</strong>. </li>
<li><strong>pointer</strong>s are random access iterators and hence are also valid input iterators. Therefore, the algorithm can also be applied to the built-in <strong>array</strong>. </li>
<li>complexity: linear</li>
</ol>
<h2 id="Test-program"><a href="#Test-program" class="headerlink" title="Test program"></a>Test program</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test my find algorithm</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;			// cout, endl</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;			// vector</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;			// strlen</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"my_algorithms.h"</span>	        <span class="comment">// my_find</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>; 	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">find</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">strlen</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// to find an int type element in a vector</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec&#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">87</span>, <span class="number">9</span>, <span class="number">35</span>, <span class="number">77</span>, <span class="number">60</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = my_find(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">60</span>);</span><br><span class="line">    <span class="keyword">if</span>(it != vec.<span class="built_in">end</span>())</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Element is found in vec: "</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Element is not found in vec"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// to find an char type element in an array</span></span><br><span class="line">    <span class="keyword">char</span> arr[] = <span class="string">"computational"</span>;</span><br><span class="line">    <span class="keyword">char</span>* p = my_find(arr, arr+<span class="built_in">strlen</span>(arr), <span class="string">'u'</span>);</span><br><span class="line">    <span class="keyword">if</span>(p != arr+<span class="built_in">strlen</span>(arr))</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Element is found in arr: "</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Element is not found in arr"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Outputs</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Element is found in vec: 60</span><br><span class="line">Element is found in arr: u</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="find-if-beg-end-UnaryPred"><a href="#find-if-beg-end-UnaryPred" class="headerlink" title="find_if(beg, end, UnaryPred)"></a><strong>find_if(beg, end, UnaryPred)</strong></h1><h2 id="Possible-implementation-1"><a href="#Possible-implementation-1" class="headerlink" title="Possible implementation"></a>Possible implementation</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">UnaryPred</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">InputIterator</span> <span class="title">my_find_if</span>(<span class="title">InputIterator</span> <span class="title">beg</span>, <span class="title">InputIterator</span> <span class="title">end</span>, <span class="title">UnaryPred</span> <span class="title">pred</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">while</span>(beg != <span class="built_in">end</span> &amp;&amp; !pred(*beg))</span><br><span class="line">        ++beg;</span><br><span class="line">    <span class="keyword">return</span> beg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Key-points-1"><a href="#Key-points-1" class="headerlink" title="Key points"></a>Key points</h2><ol>
<li><strong>beg</strong> and <strong>end</strong> are two <strong>Input iterators</strong> denoting that the range searched is [beg, end). <strong>UnaryPred</strong> is a predicate on elements in the range. Each time it takes one of the elements, and then returns a value convertible to <strong>bool</strong>. </li>
<li>the algorithm returns an iterator to the first element in the range for which the <strong>pred</strong> returns <strong>true</strong>. If there is no such element, the function returns <strong>end</strong>. </li>
<li>there is no way to copy, assign, or pass a function as an argument directly due to a function is not an object. In fact, when we pass a function, the compiler uses the pointer to function instead of using the function directly. In addition, we can call a pointer to a function with or withour deferencing the pointer. Therefore, in this function template, the argument can either be a function â€œobjectâ€, that is, <strong>UnaryPred pred</strong>; or a function pointer, that is, <strong>UnaryPred* pred</strong>; or a function reference, that is, <strong>UnaryPred&amp; pred</strong>. All these three cases allows us to call the function through <strong>pred(*beg)</strong>.</li>
<li>complexity: linear </li>
</ol>
<h2 id="Test-program-1"><a href="#Test-program-1" class="headerlink" title="Test program"></a>Test program</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;			// cout, endl</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;			// vector</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;			// strlen</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;			// isupper</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"my_algorithms.h"</span>	        <span class="comment">// my_find_if</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>; 	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">find</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">strlen</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">isupper</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the predication 1</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsEven</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the predication 2</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Isupper</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> &amp;c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">isupper</span>(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// find the first even number in vec</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec&#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">87</span>, <span class="number">9</span>, <span class="number">35</span>, <span class="number">77</span>, <span class="number">60</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = my_find_if(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), IsEven);</span><br><span class="line">    <span class="keyword">if</span>(it != vec.<span class="built_in">end</span>())</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"The first even number in vec is: "</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"There is no even number in vec"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find the first upper-case letter in arr</span></span><br><span class="line">    <span class="keyword">char</span> arr[] = <span class="string">"abceFghI"</span>;</span><br><span class="line">    <span class="keyword">char</span>* p = my_find_if(arr, arr + <span class="built_in">strlen</span>(arr), Isupper);</span><br><span class="line">    <span class="keyword">if</span>(p != arr + <span class="built_in">strlen</span>(arr))</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"The first upper-case letter in arr is: "</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"There is no upper-case letter in arr"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Outputs</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The first even number in vec is: 2</span><br><span class="line">The first upper-case letter in arr is: F</span><br></pre></td></tr></table></figure>

<h1 id="find-if-not-beg-end-UnaryPred"><a href="#find-if-not-beg-end-UnaryPred" class="headerlink" title="find_if_not(beg, end, UnaryPred)"></a><strong>find_if_not(beg, end, UnaryPred)</strong></h1><h2 id="Possible-implementation-2"><a href="#Possible-implementation-2" class="headerlink" title="Possible implementation"></a>Possible implementation</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">UnaryPred</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">InputIterator</span> <span class="title">my_find_if_not</span>(<span class="title">InputIterator</span> <span class="title">beg</span>, <span class="title">InputIterator</span> <span class="title">end</span>, <span class="title">UnaryPred</span> <span class="title">pred</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">while</span>(beg != <span class="built_in">end</span> &amp;&amp; pred(*beg))</span><br><span class="line">        ++beg;</span><br><span class="line">    <span class="keyword">return</span> beg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In contrary to the <strong>find_if</strong> algorithm, this function returns an iterator to the first element in the range for which <strong>pred</strong> returns <strong>false</strong>. If <strong>pred</strong> returns <strong>true</strong> for all elements, the function returns <strong>end</strong>. </p>
<h2 id="Test-program-2"><a href="#Test-program-2" class="headerlink" title="Test program"></a>Test program</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;			// cout, endl</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;			// vector</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"my_algorithms.h"</span>	        <span class="comment">// my_find_if_not</span></span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsEven</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> i % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// find the first even number in vec</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec&#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">87</span>, <span class="number">9</span>, <span class="number">35</span>, <span class="number">77</span>, <span class="number">60</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = my_find_if_not(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), IsEven);</span><br><span class="line">    <span class="keyword">if</span>(it != vec.<span class="built_in">end</span>())</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"The first odd number in vec is: "</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"There is no odd number in vec"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Outputs</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The first odd number in vec is: 87</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="count-beg-end-UnaryPred"><a href="#count-beg-end-UnaryPred" class="headerlink" title="count(beg, end, UnaryPred)"></a><strong>count(beg, end, UnaryPred)</strong></h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Liam</p>
  <div class="site-description" itemprop="description">Stochastic Modelling Notes; Programming Notes</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">59</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/quantliam" title="GitHub â†’ https:&#x2F;&#x2F;github.com&#x2F;quantliam" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/yanshijiutu@gmail.com" title="E-Mail â†’ yanshijiutu@gmail.com"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Liam</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">Symbols count total: </span>
    <span title="Symbols count total">NaNm</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">Reading time total &asymp;</span>
    <span title="Reading time total">NaN:aN</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
