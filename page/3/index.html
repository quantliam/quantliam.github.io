<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Times New Roman:300,300italic,400,400italic,700,700italic|Courier New:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"quantein.com","root":"/","scheme":"Muse","version":"7.7.2","exturl":false,"sidebar":{"position":"right","display":"post","padding":60,"offset":12,"onmobile":true},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Stochastic Modelling Notes; Programming Notes">
<meta property="og:type" content="website">
<meta property="og:title" content="Liam&#39;s Blog">
<meta property="og:url" content="http://quantein.com/page/3/index.html">
<meta property="og:site_name" content="Liam&#39;s Blog">
<meta property="og:description" content="Stochastic Modelling Notes; Programming Notes">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Liam">
<meta property="article:tag" content="Stochastic Modelling Notes; Programming Notes">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://quantein.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false
  };
</script>

  <title>Liam's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Liam's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">If history repeats itself, and the unexpected always happens, how incapable must Man be of learning from experience?—George Bernard Shaw.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="search-pop-overlay">
  <div class="popup search-popup">
      <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

  </div>
</div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/quantliam" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://quantein.com/2018/04/14/C-Defining-abstract-data-types/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liam">
      <meta itemprop="description" content="Stochastic Modelling Notes; Programming Notes">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Liam's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/14/C-Defining-abstract-data-types/" class="post-title-link" itemprop="url">C++ - Defining abstract data types (Part 1)</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-04-14 20:59:23" itemprop="dateCreated datePublished" datetime="2018-04-14T20:59:23+08:00">2018-04-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2018-05-07 09:17:14" itemprop="dateModified" datetime="2018-05-07T09:17:14+08:00">2018-05-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Programming/" itemprop="url" rel="index"><span itemprop="name">Programming</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span></span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>NaN:aN</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="The-vector-class"><a href="#The-vector-class" class="headerlink" title="The vector class"></a>The vector class</h1><p>This chapter mainly teaches us about how to define our own “vec” class follwing the standard library <strong>vector</strong> class template. Specifically, our vec class will provide an interface that allows following operations:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// construct a vector of T type</span></span><br><span class="line"><span class="built_in">vector</span>&lt;T&gt; v;        <span class="comment">// empty vector</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;T&gt; <span class="title">v</span><span class="params">(<span class="number">100</span>)</span></span>;   <span class="comment">// vector with 100 elements</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// obtain the names of the types used by the vector</span></span><br><span class="line"><span class="built_in">vector</span>&lt;T&gt;::const_iterator b, e;</span><br><span class="line"><span class="built_in">vector</span>&lt;T&gt;::size_type i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// use size and the index operator to look at each element in the vector</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i != v.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; v[i].name();   <span class="comment">// if T has a member name</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// return iterators positioned on the first and one past the last element</span></span><br><span class="line">b = v.<span class="built_in">begin</span>();</span><br><span class="line">e = v.<span class="built_in">end</span>();</span><br></pre></td></tr></table></figure>
<h1 id="Implementing-the-Vec-class"><a href="#Implementing-the-Vec-class" class="headerlink" title="Implementing the Vec class"></a>Implementing the Vec class</h1><p>The standard library <strong>vector</strong> is a class template. Similarly, we define a class template to represent our vector to hold various types. We are familar with how to define a function template, now let’s see how to define a class template.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">Vec</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// interface</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// implementation</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Similar to the definition of a function template, a class template begins with the keyword <strong>template</strong> follwed by the template parameters list. In this case, there is one type parameter named <strong>T</strong>. Then we define the class as we did before, assuming that there will be <strong>public</strong> and <strong>private</strong> parts to write our interface and implementation respectively. </p>
<p>Now we consider the data members for our vector class. Vector is a container that can hold multiple elements. A natural solution goes to a dynamically allocated array. So what information we need for the implementation of our <strong>Vec</strong> class? The functions <strong>begin, end</strong> and <strong>size</strong> imply that we might need to store the address of the initial element, one past the address of the last element  and the number of elements. But once we know the address of the first element and one past the last element, we could compute the size easily. Let’s add two data members:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">Vec</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// interface</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* data;    <span class="comment">// first element in the Vec</span></span><br><span class="line">    T* limit;   <span class="comment">// one past the last element in the Vec</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Constructors"><a href="#Constructors" class="headerlink" title="Constructors"></a>Constructors</h2><p>From the interface we intend to provide, we know we need to define at least two constructors, </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// construct a vector of T type</span></span><br><span class="line">Vec&lt;T&gt; v;        <span class="comment">// using default constructor</span></span><br><span class="line"><span class="function">Vec&lt;T&gt; <span class="title">v</span><span class="params">(<span class="number">100</span>)</span></span>;   <span class="comment">// using constructor that takes a size</span></span><br></pre></td></tr></table></figure>
<p>The default constructor leads to an empty <strong>Vec</strong> and hence there is no need to allocate space to hold the elements. Two data members can be initialized to null pointers. For the constructor that takes a size, we should allocate certain amount of storage for holding the elements. Two data members will be initialized to the corresponding addresses of that space. Each element will be initialized to a value given by the default constructor of Type <strong>T</strong>. There is also a case that users provide the initial values for the elements, for example</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Vec&lt;T&gt; <span class="title">v</span><span class="params">(<span class="number">100</span>, <span class="number">1</span>)</span></span>;   <span class="comment">// using constructor that takes a size and an initial value</span></span><br></pre></td></tr></table></figure>
<p>If so, we would initialize each element with the provided value. The constructor that takes a size and an initial value can be regarded as the special case of the constructor that only takes a size. The code below shows the definition of the constructors:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">Vec</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    Vec() &#123; create() &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Vec</span><span class="params">(size_type n, <span class="keyword">const</span> T&amp; val = T())</span> </span>&#123; create(n, val); &#125;</span><br><span class="line">    <span class="comment">// remaining interface</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* data</span><br><span class="line">    T* limit;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>As we haven’t talk about how to dynamically allocate space for our object, the details of implementations of each constructor will be discussed later. What we need to know here is that the constructors call another function <strong>create</strong> to initialize our data members and the elements. For the default constructor, <strong>create()</strong> initializes all data members to null pointers. For the second constructor, <strong>create(n, val)</strong> allocates enough space, and initializes all data members as well as each element with size <strong>n</strong> and value <strong>val</strong>. The second constructor takes two arguments, one is the size <strong>n</strong> and another is the value that to use in initializing the elements. </p>
<p>If there is no user-supplied value, <strong>val</strong> is assigned with an default value given by the default constructor of type <strong>T</strong>. One may speculate that if <strong>T</strong> is built-in type and the vector is allocated at local scope, then the elements are uninitialized as default-initializing an built-in object gives it an undefined value. However, we also know that when we create a standard vector<int> with size only, the compiler initializes each element to 0. So, where there might be problems? Let’s do a simple experiment first.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>; 	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="keyword">int</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> m;</span><br><span class="line">    <span class="keyword">double</span> n = <span class="keyword">double</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">'\n'</span> &lt;&lt; y &lt;&lt; <span class="string">'\n'</span>  &lt;&lt; m &lt;&lt; <span class="string">'\n'</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Outputs</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1954310794</span><br><span class="line">0</span><br><span class="line">-2.2854e+251</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>From above example, we observe that a built-in type local variable is undefined in the case of default initialization. In contrast, <strong>int()</strong> and <strong>double()</strong> doesn’t default initialize the corresponding objects, but performs <strong>value-initialization</strong>. This means that <strong>T()</strong> only invokes default constructor if it is user-declared and otherwise it performs value-initialization. If <strong>T</strong> is built-in type, objects are zero initialized. </p>
<p>It also has been observed that we use a keyword <strong>explicit</strong> as the begining of the definition of the second constructor. This keyword only makes sence when the constructor takes a single argument, that is, the size. It indicates that the compiler will use the constructor only in the case that the user expressly invokes the constructor. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Vec&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">100</span>)</span></span>; <span class="comment">// ok, explicitly construct the Vec from an int</span></span><br><span class="line">Vec&lt;<span class="keyword">int</span>&gt; v = <span class="number">100</span>; <span class="comment">// error: implicitly comstruct the Vec and copy</span></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">More about the **<span class="keyword">explicit</span>** will be discussed in chapter <span class="number">12.</span> </span><br><span class="line"></span><br><span class="line">## Type definitions</span><br><span class="line">This section defines types <span class="keyword">for</span> our **Vec** <span class="class"><span class="keyword">class</span> <span class="title">including</span> **<span class="title">const_iterator</span>, <span class="title">iterator</span>, <span class="title">size_type</span>** <span class="title">and</span> **<span class="title">value_type</span>**. <span class="title">It</span> <span class="title">is</span> <span class="title">known</span> <span class="title">that</span> <span class="title">our</span> **<span class="title">Vec</span>** <span class="title">class</span> <span class="title">is</span> <span class="title">build</span> <span class="title">upon</span> <span class="title">the</span> <span class="title">dynamic</span> <span class="title">allocated</span> <span class="title">array</span>. <span class="title">In</span> <span class="title">addition</span>, <span class="title">pointers</span> <span class="title">supports</span> <span class="title">the</span> <span class="title">random</span>-<span class="title">access</span>-<span class="title">iterator</span> <span class="title">operations</span>. <span class="title">Therefore</span>, <span class="title">we</span> <span class="title">can</span> <span class="title">define</span> <span class="title">the</span> <span class="title">types</span> **<span class="title">iterator</span>** <span class="title">and</span> **<span class="title">const_iterator</span>** <span class="title">based</span> <span class="title">on</span> <span class="title">pointers</span>. <span class="title">For</span> **<span class="title">size_type</span>**, <span class="title">we</span> <span class="title">can</span> <span class="title">define</span> <span class="title">based</span> <span class="title">on</span> **<span class="title">size_t</span>**. <span class="title">Apparently</span>, <span class="title">The</span> **<span class="title">value_type</span>** <span class="title">is</span> **<span class="title">T</span>**. <span class="title">Now</span> <span class="title">let</span>'<span class="title">s</span> <span class="title">see</span> <span class="title">the</span> <span class="title">code</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">```<span class="title">c</span>++</span></span><br><span class="line"><span class="class"><span class="title">template</span> &lt;class T&gt; <span class="title">class</span> <span class="title">Vec</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> T* iterator;                </span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">const</span> T* const_iterator;   </span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line"></span><br><span class="line">    Vec() &#123; create(); &#125; </span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Vec</span><span class="params">(size_type n, <span class="keyword">const</span> T&amp; val = T())</span> </span>&#123; create(n, val); &#125;</span><br><span class="line">    <span class="comment">// remaining interface</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    iterator data;</span><br><span class="line">    iterator limit;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Index-and-size"><a href="#Index-and-size" class="headerlink" title="Index and size"></a>Index and size</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i != v.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; v[i].name();   <span class="comment">// if T has a member name</span></span><br></pre></td></tr></table></figure>
<p>The <strong>size</strong> function returns a value that represents the number of elements in a <strong>Vec</strong>. </p>
<p>The indexing operation is supported through the subscript operator <strong>[]</strong> and hence we should define an overloaded operator as we define other function: it has a name, takes arguments, and specifies a return type. </p>
<p>The name of such operator is obtained by appending the symbol <strong>[]</strong> to the word <strong>operator</strong>, that is, <strong>operator[]</strong>. </p>
<p>If the operator is a function that is not a member function, then the function has as many arguments as the operator has operands. The first argument is bound to the left bound and the second is bound to the right operand. If the operator is defined as a member function, its left operand is implicitly bound to the object on which the operator invoked. In this case, the subscript operator is typically a member function. We can call it with <strong>v[i]</strong>, meaning that <strong>v</strong> is the object on which it operates and <strong>i</strong> is an argument that should has type <strong>Vec::size_type</strong>.</p>
<p>As for the return type, the operator function ought to return a reference to the element in the <strong>Vec</strong>. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">Vec</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> T* iterator;                </span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">const</span> T* const_iterator;   </span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line"></span><br><span class="line">    Vec() &#123; create(); &#125; </span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Vec</span><span class="params">(size_type n, <span class="keyword">const</span> T&amp; val = T())</span> </span>&#123; create(n, val); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// operations: size and index</span></span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> limit - data; &#125;</span><br><span class="line"></span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](size_type i) &#123; <span class="keyword">return</span> data[i]; &#125;</span><br><span class="line">    <span class="keyword">const</span> T&amp; <span class="keyword">operator</span>[](size_type i) <span class="keyword">const</span> &#123; <span class="keyword">return</span> data[i] &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    iterator data;</span><br><span class="line">    iterator limit;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>There are sevral key points here:</p>
<ol>
<li>the result of (limit - data) has type <strong>ptrdiff_T</strong>, which is converted to <strong>size_type</strong>.</li>
<li>taking the <strong>size</strong> of a <strong>Vec</strong> doesn’t change the <strong>Vec</strong> and hence we define it as a <strong>const</strong> member. </li>
<li>we define two version of the operator function: one for <strong>const Vec</strong> objects and the other for nonconst <strong>Vec</strong>. It seems impossible to overload the operator function as both version have same parameter list. However, as mentioned above, the object itself is also an implicit argument to the function. Therefore, one function takes the <strong>const Vec</strong> object as an argument while the other one takes the nonconst <strong>Vec</strong> object as an argument.</li>
</ol>
<h2 id="Operations-that-return-iterators"><a href="#Operations-that-return-iterators" class="headerlink" title="Operations that return iterators"></a>Operations that return iterators</h2><p>Next is to define member functions <strong>begin()</strong> and <strong>end()</strong>. Similar to the operator function, we need to define two versions for both functions, one version returns <strong>const_iterator</strong> so that users cannot modify the <strong>Vec</strong> by operating on the iterator; another one returns an iterator that is not restricted by qualifier <strong>const</strong>, so that users can write elements into the <strong>Vec</strong> through the iterator if they want to. The improved code is shown below.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">Vec</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> T* iterator;                </span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">const</span> T* const_iterator;   </span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line"></span><br><span class="line">    Vec() &#123; create(); &#125; </span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Vec</span><span class="params">(size_type n, <span class="keyword">const</span> T&amp; val = T())</span> </span>&#123; create(n, val); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// operations: size and index</span></span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> limit - data; &#125;</span><br><span class="line"></span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](size_type i) &#123; <span class="keyword">return</span> data[i]; &#125;</span><br><span class="line">    <span class="keyword">const</span> T&amp; <span class="keyword">operator</span>[](size_type i) <span class="keyword">const</span> &#123; <span class="keyword">return</span> data[i] &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// function to return iterators</span></span><br><span class="line">    iterator <span class="built_in">begin</span>() &#123; <span class="keyword">return</span> data; &#125;</span><br><span class="line">    <span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> data; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> limit; &#125;</span><br><span class="line">    <span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> limit; &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    iterator data;</span><br><span class="line">    iterator limit;</span><br><span class="line">&#125;;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"># Copy control</span><br><span class="line">In chapter <span class="number">9</span>, we have learned how to initialize a <span class="class"><span class="keyword">class</span> <span class="title">object</span> <span class="title">when</span> <span class="title">it</span> <span class="title">is</span> <span class="title">created</span>. <span class="title">But</span> <span class="title">we</span> <span class="title">haven</span>'<span class="title">t</span> <span class="title">talked</span> <span class="title">about</span> <span class="title">what</span> <span class="title">happens</span> <span class="title">when</span> <span class="title">a</span> <span class="title">class</span> <span class="title">object</span> <span class="title">is</span> <span class="title">copied</span>, <span class="title">assigned</span> <span class="title">and</span> <span class="title">destroyed</span>. <span class="title">When</span> <span class="title">we</span> <span class="title">define</span> <span class="title">the</span> **<span class="title">Student_info</span>** <span class="title">class</span>, <span class="title">we</span> <span class="title">didn</span>'<span class="title">t</span> <span class="title">define</span> <span class="title">these</span> <span class="title">operations</span> <span class="title">as</span> <span class="title">well</span>. <span class="title">We</span> <span class="title">can</span> <span class="title">presume</span> <span class="title">that</span> <span class="title">the</span> <span class="title">compiler</span> <span class="title">will</span> <span class="title">synthesize</span> <span class="title">definitions</span> <span class="title">for</span> <span class="title">us</span>. <span class="title">Now</span> <span class="title">this</span> <span class="title">section</span> <span class="title">focus</span> <span class="title">on</span> <span class="title">how</span> <span class="title">can</span> <span class="title">we</span> <span class="title">define</span> <span class="title">these</span> <span class="title">operations</span> <span class="title">and</span> <span class="title">how</span> <span class="title">the</span> <span class="title">synthesized</span> <span class="title">operations</span> <span class="title">exactly</span> <span class="title">work</span>.</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">## <span class="title">Copy</span> <span class="title">constructor</span></span></span><br><span class="line"><span class="class"><span class="title">Two</span> <span class="title">ways</span> <span class="title">to</span> <span class="title">implicitly</span> <span class="title">copy</span> <span class="title">a</span> <span class="title">class</span> <span class="title">object</span>:</span> one is that passing an object by value to a function; the other way is that returning an object by value. For example</span><br><span class="line">```c++</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">double</span> d;</span><br><span class="line">d = median(v);  <span class="comment">// copy v into the parameter in median</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> <span class="built_in">line</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; words = split(<span class="built_in">line</span>); <span class="comment">// copy the return from split into words</span></span><br></pre></td></tr></table></figure>
<p>Sometimes we also explicitly copy an object, for example using it to initialize another object.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;Student_info&gt; vs;</span><br><span class="line"><span class="built_in">vector</span>&lt;Student_info&gt; vs_copy = vs;  <span class="comment">// copy vs into vs_copy</span></span><br></pre></td></tr></table></figure>

<p>Both above copy behaviors are controlled by a special constructor called the <strong>copy constructor</strong>. </p>
<p><strong>copy constructor</strong> is also a member function that has the same name as the name of class. It takes a single argument that has the same type as the class itself. In addition, the parameter is a const reference to the object to pass due to that the <strong>copy constructor</strong> should not change the object being copied from. Therefore, we can declare the <strong>copy constructor</strong> as shown below</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">Vec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Vec (<span class="keyword">const</span> Vec&amp; v); <span class="comment">// copy constructor</span></span><br><span class="line">    <span class="comment">// as before</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>When we copy a class object, we’ll need to allocate new space and then copy the contents from the source into the newly allocated storage. This is because we do not intend to change the object being copied from. For example, if we simple copy two data members, we may change the value of the elements due to the fact that the copied pointers still points to the elements contained in the object being copied from. As with the constructors, we will ask the overloaded <strong>create</strong> function to manage the memory and the details of the copy operations.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">Vec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Vec (<span class="keyword">const</span> Vec&amp; v) &#123; create(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>()); &#125;; </span><br><span class="line">    <span class="comment">// as before</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Assignment"><a href="#Assignment" class="headerlink" title="Assignment"></a>Assignment</h2><p>Like the <strong>subscript operator</strong>, the <strong>assignment operator =</strong> needs to be defined for providing us the assignment operations. The name of the <strong>assignment operator</strong> function is <strong>operator=</strong>. The argument taken by such operator function is as same as the argument taken by copy constructor above. What about the return type? We return a reference to the left operand. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">Vec</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    Vec&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> Vec&amp;);</span><br><span class="line">    <span class="comment">// as before</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>It is worth noting the difference between <strong>assignment</strong> and the copy constructor. <strong>assignment</strong> always involves obliterating an existing value of the left-hand side, and then replacing it with a new value, i.e. the right-side hand. What they have in common is that both of them need to assign each of the data values. As mentioned above, we cannot assign the value of pointers to the left-hand side because that doing so would bring potential change for the right-hand side. </p>
<p>There might be another problem when using the assignment operator, that is how to handle self-assignment. For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">x</span><span class="params">(<span class="number">100</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">x = x;</span><br></pre></td></tr></table></figure>
<p>The assignment operator function will firstly obliterate the value of left-hand side then assign the value of right-hand side to the left-hand side. However, once we destroy the elements and free the space, we cannot create a new object that has the same value as the right-hand side due to both sides operands refer to the same space. To avoid this case, we add a if statement before implemeting the assignment. The code below gives the implementation of the assignment operator function:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Vec</span>&lt;T&gt;&amp; <span class="title">Vec</span>&lt;T&gt;:</span>:<span class="keyword">operator</span>= (<span class="keyword">const</span> Vec&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// check for self-assignment</span></span><br><span class="line">    <span class="keyword">if</span>(&amp;rhs != <span class="keyword">this</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// free the array in the left-hand side</span></span><br><span class="line">        uncreate();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// copy elements from the right-hand to the left-hand side</span></span><br><span class="line">        create(rhs.<span class="built_in">begin</span>(), rhs.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The code above introduces several new ideas:</p>
<p>First, the <strong>operator=</strong> is defined as a function template and the type parameter infers from the type parameter of the class template <strong>Vec</strong>. </p>
<p>Second, the return type as well as the function name are defined explicitly due to that this member function is defined outside the class. The declaration uses <strong>Vec&amp;</strong> rather than <strong>Vec<T>&amp;</strong> is due to that the type parameter is implicit when we are within the scope of the template. This also explains why we use the function name <strong>Vec<T>::operator=</strong>. Once we specifies that the function is a member of class <strong>Vec<T></strong>, we can omit the type parameter when defines its parameter <strong>const Vec&amp; rhs</strong>.</p>
<p>Third, the if condition uses a keyword <strong>this</strong> to test whether the assigment happens between two same objects. <strong>this</strong> is a pointer that points to the object of which <strong>operator=</strong> is a member. It is valid only inside a member function. Hence, the condition means that if the address of the object (left-hand side) is as same as the address (denoted by &amp;rhs) of the right-hand object, the assignment behavior won’t be executed.</p>
<p>Forth, if the leff-hand operand and the right-hand operand are not the same object, we destroy the elements and free the space first through <strong>uncreate()</strong> and then allocate new space and copy values from <strong>rhs</strong> like what the <strong>copy constructor</strong> does. </p>
<p>Finally, it is necessary to explain why we intend to return a reference to the left-side object. Why not return <strong>void</strong> directly? Why don’t we return a value? <a href="https://stackoverflow.com/questions/3105798/why-must-the-copy-assignment-operator-return-a-reference-const-reference?utm_medium=organic&utm_source=google_rich_qa&utm_campaign=google_rich_qa" target="_blank" rel="noopener">Move to see more discussion</a>. </p>
<p>One reason is that to keep consistent with the default setting of the C++ compiler in regarding to the built-assignment operator. Another reason is that setting the return type to <strong>void</strong> doesn’t allow continues assignment. For example,</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">x</span><span class="params">(<span class="number">100</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; y, z;</span><br><span class="line">y = z = x;  <span class="comment">// continues assignment</span></span><br></pre></td></tr></table></figure>

<p>Apparently, we don’t have to return a reference, instead we can return a value. Let’s take an example, </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Vec&lt;<span class="keyword">int</span>&gt; <span class="title">x</span><span class="params">(<span class="number">100</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; y;</span><br><span class="line">y = x; <span class="comment">// calls assignment operator once, calls copy constructor once, calls destructor once</span></span><br></pre></td></tr></table></figure>
<p>It can be presumed that returning an object involves calling three functions: first, assignment operator function is called and a temporary object is created, then, the return statement calls copy constructor to create a new object, finally, the destructor is called to destroy the temporary value and free the space. We’ll introduce the destructor later and will pose an experiment to verify these expectations. </p>
<h3 id="Assignment-is-not-initialization"><a href="#Assignment-is-not-initialization" class="headerlink" title="Assignment is not initialization"></a>Assignment is not initialization</h3><p>Now we can summarize the difference between <strong>initialization</strong> and <strong>assignment</strong>. It can be observed that the operator <strong>=</strong> has different effect in various contexts. The default setting of <strong>=</strong> invokes <strong>copy constructor</strong> and then creating a new object,which is another form of <strong>initialization</strong>. The <strong>operator=</strong> described above invokes assignment that always obliterates the privious value first. </p>
<p>Initialization happens</p>
<ol>
<li>In variable declaration<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> y;  <span class="comment">// default initialization</span></span><br></pre></td></tr></table></figure></li>
<li>For function parameters on entry to a function<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">median(v);  <span class="comment">// the parameter is copy-initialized</span></span><br></pre></td></tr></table></figure></li>
<li>For the return value of a function on return from the function<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> <span class="built_in">line</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; words = split(<span class="built_in">line</span>); <span class="comment">// the return value is copy-initialized, the variable is then copy-initialized</span></span><br></pre></td></tr></table></figure></li>
<li>In constructor initializers<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> url_ch = <span class="string">"@#$%^&amp;**(("</span>;   <span class="comment">// copy initialization</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">spaces</span><span class="params">(url_ch.<span class="built_in">size</span>(), <span class="string">' '</span>)</span></span>; <span class="comment">// direct initialization</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>Let’s see another example</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">split</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;)</span></span>; <span class="comment">// function declaration</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v;   <span class="comment">// default initialization</span></span><br><span class="line"></span><br><span class="line">v = split(<span class="built_in">line</span>); <span class="comment">// on entry, initialization of split's parameter from line; on exit, both initialization of the return value and assignment to v</span></span><br></pre></td></tr></table></figure>

<p>The <strong>split</strong> function returns an object of type <strong>vector<string></strong>. As analysed above, it involves calling both copy constructor (at the call site) and the assignment operator function.</p>
<h2 id="Destructor"><a href="#Destructor" class="headerlink" title="Destructor"></a>Destructor</h2><p>It is known that when we allocate a space with <strong>new</strong>, we should destroy the values and free the space with <strong>delete</strong>. Therefore, it is necessary to define a member function to do the same job. In general, the destructor will be called automatically when:</p>
<ol>
<li>a local variable go out of scope.</li>
<li>members of an object are destryoed when the object of which they are a part is destroyed.</li>
<li>elements in a container are destoryed when the container is destroyed.</li>
<li>the delete operator applied to an object.</li>
<li>temporary objects are destroyed. </li>
</ol>
<p>Taking an example, </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">split</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ret;</span><br><span class="line">    <span class="comment">// split str into words and store in ret</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The variable <strong>ret</strong> is destroyed when the implementation encounters the return statement because it goes out of the scope. Now let’s see how to define a destructor:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">Vec</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    ~Vec() &#123; uncreate() &#125;;</span><br><span class="line">    <span class="comment">// as before</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The name of the <strong>destructor</strong> is as same as the name of the class itself, but prefixed by a tilde(~). There is no arguments taken by the <strong>destructor</strong>. To destroy the object and free the space, the <strong>destructor</strong> calls the <strong>uncreate()</strong> function, which is similar to the behavior of the <strong>assignment operator</strong> in obliterating the previous value. </p>
<h1 id="Default-operations"><a href="#Default-operations" class="headerlink" title="Default operations"></a>Default operations</h1><p>What happens if we do not explicitly define a <strong>copy constructor, assignment operator, or destructor</strong>? In such case, the compiler will synthesizes default versions of the unspecified operation. Some general rules(koening and Moo 2000):</p>
<p><em>1. the default version are defined to operate recursively-copying, assigning or destroying each data element according to the appropriate rules for the type of that data element.</em><br><em>2. Members that are of class type are copied, assigned, or destoryed by calling the constructor, assignment operator, and destructor for the data element</em>.<br><em>3. Members that are of built-in type are copied and assigned by copying or assigning their value. The destructor for built-in types has no work to do-even if the type is a pointer. Destoring a pointer through the default constructor doesn’t free the space at which the pointer points, resulting a memory leak as the occupied space is impossible to free.</em></p>
<p>Recalling the <strong>Student_info</strong> class defined in chapter 9:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student_info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student_info ();						<span class="comment">// default constructor</span></span><br><span class="line">    Student_info (<span class="built_in">std</span>::istream &amp;);				<span class="comment">// constructor with argument</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> n; &#125;			<span class="comment">// inline member function return name</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">valid</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> !homework.empty(); &#125;            <span class="comment">// inline member function check state</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::istream &amp; <span class="title">read</span><span class="params">(<span class="built_in">std</span>::istream &amp;)</span></span>;			<span class="comment">// member function read in data</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">()</span> <span class="keyword">const</span></span>;					<span class="comment">// member function calculate final grade</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> n;</span><br><span class="line">    <span class="keyword">double</span> midterm, <span class="keyword">final</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; homework;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>If we copy an object of <strong>Student_info</strong>, the synthesized copy constructor copies four data members. It invokes the <strong>string, vector</strong> copy constructors to copy the member <strong>name</strong> and <strong>homework</strong>s respectively. It copies the two <strong>double</strong> values, <strong>midterm, final</strong>, directly. Similar procedures happen when we do assignment. </p>
<p>Noting that if a class defines any constructor explicitly, either a constructor or a copy constructor, the compiler will not synthesize a default constructor for that class. It is wise to provide a default constructor for the data type that to be used as a data member of a class that relies on the synthsized default constructor. We explicitly provide the default constructor in above class <strong>Student_info</strong>.</p>
<p>If a class needs a destructor, it almost surely needs a copy constructor as well as assignment operator. To control every copy of object of class T, we should define:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">T::T(); <span class="comment">// one or more constructors, perhaps with arguments</span></span><br><span class="line">T::~T(); <span class="comment">// the destructor</span></span><br><span class="line">T::T(<span class="keyword">const</span> T&amp;); <span class="comment">// the copy constructor</span></span><br><span class="line">T::<span class="keyword">operator</span>= (<span class="keyword">const</span> T&amp;); <span class="comment">// the assignment operator</span></span><br></pre></td></tr></table></figure>

<h1 id="Dynamic-Vecs"><a href="#Dynamic-Vecs" class="headerlink" title="Dynamic Vecs"></a>Dynamic Vecs</h1><p>This section focus on designing a dynamic <strong>Vec</strong> class through providing the <strong>push_back</strong> function which we are familiar with when using the standard <strong>vector</strong>. Theoretically, the <strong>push_back</strong> function can allocate new space to hold one more element and then we copy all elements into the new space while constructing a new last element from the argument to <strong>push_back</strong>. However, doing so would be inefficient when we call the <strong>push_back</strong> many times. One strategy is to allocate more storage than we need when necessary, that is, when we exhaust the preallocate storage. Specifically, each time the <strong>push_back</strong> allocate new space, it allocate twice as much as the current space. </p>
<p>For example, if we create a <strong>Vec</strong> with 100 elements, then call the <strong>push_back</strong> function for the first time, it will allocate a new space that can hold 200 elements. It then copies the original 100 elements into the new space with constructing the last element from the argument. There are still more space left for holding 99 elements more and hence the function do not need to allocate more space in next 99 calls. Moreover, the extral space keep uninitialized. </p>
<p>What we need to track is the address of the first element, the one past of the last constructed element, and the end of the new allocate storage(i.e. one past the available element). We’ll denote these address with three pointers, <strong>data, avail, limit</strong> respectively. The range [data, avail) contains all elements while the range [avail, limit) is the uninitialized storage. Now let’s write the <strong>push_back</strong> function:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">Vec</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T&amp; val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(avail == limit)      <span class="comment">// get space if needed</span></span><br><span class="line">            grow();</span><br><span class="line">        unchecked_append(val);  <span class="comment">// append the new element</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        iterator data;  <span class="comment">// as before, the pointer to the first element in the Vec</span></span><br><span class="line">        iterator avail; <span class="comment">// pointer to one past the last constructed element</span></span><br><span class="line">        iterator limit; <span class="comment">// now points to one past the available element</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// rest of the class interface and implementation as before</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>grow()</strong> will double the space for us. <strong>unchecked_append(val)</strong> constructs the last element from the argument to <strong>push_back</strong> function. Correspondingly, we refresh the data members.</p>
<h1 id="Flexible-memory-management"><a href="#Flexible-memory-management" class="headerlink" title="Flexible memory management"></a>Flexible memory management</h1><p>We have basically completed the design of our <strong>Vec</strong> class template. However, we haven’t talked about the real implementation, that is, how exactly allocate new space. As memtioned in chapter 10, we can dynamically manage memory through built-in operators <strong>new</strong> and <strong>delete</strong> (or <strong>new[]</strong> and <strong>delete[]</strong>). However, there are several shortcomings if we use such operators to manage memory for our <strong>Vec</strong> class.</p>
<ol>
<li>if we use <strong>new[]</strong>, it always initialize every element of a <strong>T</strong> array by using <strong>T::T()</strong>. If we want to initialize ourselves, we would have to initialize each element twice. </li>
<li>if <strong>push_back</strong> allocates new space, we want to keep the range [avail, limit) uninitialized. However, if we use <strong>new[]</strong>, we cannot control this anymore. </li>
</ol>
<p>The standard header <memory> provides a class named <strong>allocator<T></strong>, that allocates a block of uninitialized memory that intended to contain objects of type <strong>T</strong> and returns a pointer to the initial element of that memory. In addition, <strong>allocator<T></strong> also defines members including functions to construct objects, destroy obejcts and deallocate the memory. Therefore, programmers can manage the allocated space directly and determine the unitialized space. Here introduces four member functions and two non-member functions of the <strong>allocator</strong> class:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">allocator</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">T* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deallocator</span><span class="params">(T*, <span class="keyword">size_t</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">construct</span><span class="params">(T*, <span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(T*)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line">template&lt;class Out, class T&gt; void uninitialized_fill(Out, Out, const T&amp;);</span><br><span class="line">template&lt;class In, class Out&gt; Out uninitialized_copy(In, In, Out);</span><br></pre></td></tr></table></figure>
<ol>
<li><p>the <strong>allocate</strong> member allocates typed but uninitialized storage to hold the requested number of elements. It returns a pointer that has type <strong>T</strong> and denotes the initial address of the storage. </p>
</li>
<li><p>the <strong>deallocator</strong> frees this uninitialized storage with taking the pointer given by <strong>allocate</strong> and the size.</p>
</li>
<li><p><strong>construct</strong> and <strong>destroy</strong>  construct or destroy a single object in the uninitialized space. </p>
</li>
<li><p>the first algorithm <strong>uninitialized_fill</strong> fills this uninitialized space with value from the third argument. The first two arguments denote the range of the space that to be filled. </p>
</li>
<li><p>the second algorithm <strong>uninitialized_copy</strong> copies values from a sequence specified by the first two arguments into a target sequence denoted by the third argument. The range pointed by the third argument should large enough to hold all elements contained in the range specified by the first two arguments. It finally returns a pointer to one past the last constructed element. </p>
</li>
<li><p>both two algorithms assumes that the target range contains raw storage rather than elements that already hold values. </p>
</li>
</ol>
<p>To obtain an <strong>allocator</strong> of the right type at the compiler time, we’ll add to our <strong>Vec</strong> class an <strong>allocator<T></strong> member. By doing so, we can use above member functions to provide efficient and flexible memory management for our <strong>Vec</strong> class. </p>
<h1 id="The-final-Vec-class"><a href="#The-final-Vec-class" class="headerlink" title="The final Vec class"></a>The final Vec class</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">Vec</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// member types</span></span><br><span class="line">    <span class="keyword">typedef</span> T* iterator;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">const</span> T* const_iterator;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// constructors</span></span><br><span class="line">    Vec() &#123; create(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Vec</span><span class="params">(size_type n, <span class="keyword">const</span> T&amp; t = T())</span> </span>&#123; create(n, t); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// copy constructor, assignment operator, destructor</span></span><br><span class="line">    Vec(<span class="keyword">const</span> Vec&amp; v) &#123; create(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>()); &#125;</span><br><span class="line">    Vec&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Vec&amp;); </span><br><span class="line">    ~Vec() &#123; uncreate(); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// indexing operator</span></span><br><span class="line">    <span class="keyword">const</span> T&amp; <span class="keyword">operator</span>[](size_type i) <span class="keyword">const</span> &#123; <span class="keyword">return</span> data[i]; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// push_back function</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T&amp; t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(avail == limit)</span><br><span class="line">            grow();</span><br><span class="line">        unchecked_append(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// size function</span></span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> avail - data; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// begin(), end() function</span></span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> data; &#125;</span><br><span class="line">    <span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> data; &#125;</span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> avail; &#125;</span><br><span class="line">    <span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> avail; &#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    iterator data;  <span class="comment">// first element in the Vec</span></span><br><span class="line">    iterator avail; <span class="comment">// (one past) the last element in the Vec</span></span><br><span class="line">    iterator limit; <span class="comment">// (one past) the allocated memory</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// facilities for memory allocation</span></span><br><span class="line">    allocator&lt;T&gt; alloc; <span class="comment">// object to handle memory allocation</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// allocate and initialize the underlying array</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">(size_type, <span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">(const_iterator, <span class="keyword">const</span> iterator)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// destroy the elements in the array and free the memory</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">uncreate</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// support functions for push_back</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">grow</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unchecked_append</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>We should note that there are four conditions (aka. <strong>class invariants</strong>) that guarantees a valid <strong>Vec</strong>:</p>
<ol>
<li><strong>data</strong> points at our initial element, if we have any, and is zero otherwise.</li>
<li><strong>data &lt;= avail &lt;= limit</strong>.</li>
<li>Elements  have been constructed in the range[data, avail).</li>
<li>Elements have not been constructed in the range[avail, limit).</li>
</ol>
<p>Now the next is to write the implementation of different version of <strong>create</strong> functions while maintaining above <strong>class invariants</strong>. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">Vec</span>&lt;T&gt;:</span>:create()</span><br><span class="line">&#123;</span><br><span class="line">    data = avail = limit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">Vec</span>&lt;T&gt;:</span>:create(size_type n, <span class="keyword">const</span> T&amp; val)</span><br><span class="line">&#123;</span><br><span class="line">    data = alloc.allocate(n);</span><br><span class="line">    limit = avail = data + n;</span><br><span class="line">    uninitialized_fill(data, limit, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">Vec</span>&lt;T&gt;:</span>:create(const_iterator i, const_iterator, j)</span><br><span class="line">&#123;</span><br><span class="line">    data = alloc.allocate(j - i);</span><br><span class="line">    limit = avail = uninitialized_copy(i, j, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The first version of <strong>create</strong> is used for initializing an empty <strong>Vec</strong>. The second one that takes a size and a value creates a Vec by allocating enough memory to hold <strong>n</strong> elements through <strong>alloc.allocate(n)</strong>, and initializes all elements with <strong>val</strong> by applying the algorithm <strong>uninitialized_fill</strong>. The third version is used for <strong>copy-initialization</strong>, which takes two iterators that denote the sequence from which to copy. It calls <strong>uninitialized_copy</strong> algorithm to copy all values of the elements in [i, j) into [data, avail).</p>
<p>The <strong>destructor</strong> calls the <strong>uncreate</strong> member to destroy the elements and free the space that allocated by <strong>create</strong>. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">Vec</span>&lt;T&gt;:</span>:uncreate()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!data)&#123;</span><br><span class="line">        <span class="comment">// destroy the elements in reverse order</span></span><br><span class="line">        iterator it = avail;</span><br><span class="line">        <span class="keyword">while</span>(it != data)</span><br><span class="line">            alloc.destroy(--it);</span><br><span class="line">        alloc.deallocate(data, limit - data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// reset pointers to indicate that Vec is empty again</span></span><br><span class="line">    data = limit = avail = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The <strong>uncreate</strong> function first checks whether the <strong>data</strong> is 0. This is because that <strong>alloc.deallocate</strong> requires a non-zero pointer. There are two steps to destruct the <strong>Vec</strong>: the first step is that calling the <strong>destroy</strong> function to destroy each object contained in the Vec; the second step is that calling <strong>deallocate</strong> function to free the previous allocated storage. As <strong>deallocate</strong> doesn’t destroy elements in an array, it is crucial to call <strong>destroy</strong> function first which calls the <strong>destructor</strong> of the target element to release resource that might be occupied by the target element. It is known that there is no destructor for built-in types, so how does the <strong>destroy</strong> function work? It is presumed that the destroy function treats <strong>built-in</strong> objects and other objects in different manner. It still needs further research. </p>
<p>Finally, we write functions to support our <strong>push_back</strong> member.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">Vec</span>&lt;T&gt;:</span>:grow()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// when growing, allocate twice as much as space as currently in use</span></span><br><span class="line">    size_type new_size = <span class="built_in">max</span>(<span class="number">2</span>*(limit-data), <span class="keyword">ptrdiff_t</span>(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// allocate new space and copy existing elements to the new space</span></span><br><span class="line">    iterator new_data = alloc.allocate(new_size);</span><br><span class="line">    iterator new_avail = uninitialized_copy(data, avail, new_data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// return the old space</span></span><br><span class="line">    uncreate();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reset pointers to point to the newly allocated space</span></span><br><span class="line">    data = new_data;</span><br><span class="line">    avail = new_avail;</span><br><span class="line">    limit = data + new_size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// assumes avail points at allocated, but uninitialized space</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">Vec</span>&lt;T&gt;:</span>:unchecked_append(<span class="keyword">const</span> T&amp; val)</span><br><span class="line">&#123;</span><br><span class="line">    alloc.construct(avail++, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we have really completed our <strong>Vec</strong> class. The next post presents some tests on our <strong>Vec</strong> type from different perspectives. </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://quantein.com/2018/04/12/Accelerated-C-Solutions-to-Exercises-Chapter-10/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liam">
      <meta itemprop="description" content="Stochastic Modelling Notes; Programming Notes">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Liam's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/12/Accelerated-C-Solutions-to-Exercises-Chapter-10/" class="post-title-link" itemprop="url">Accelerated C++ Solutions to Exercises(Chapter 10)</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-04-12 13:24:45" itemprop="dateCreated datePublished" datetime="2018-04-12T13:24:45+08:00">2018-04-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2018-05-06 17:53:19" itemprop="dateModified" datetime="2018-05-06T17:53:19+08:00">2018-05-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Programming/" itemprop="url" rel="index"><span itemprop="name">Programming</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span></span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>NaN:aN</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Exercise-10-0"><a href="#Exercise-10-0" class="headerlink" title="Exercise 10-0"></a>Exercise 10-0</h1><p>Compile, execute, and test the programs in this chapter.</p>
<h2 id="Solution-amp-Results"><a href="#Solution-amp-Results" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>Please click here <a href="http://quanttour.com/10/04/2018/C-Managing-memory-and-low-level-data-structures/" target="_blank" rel="noopener">Managing memory and low-level data structures</a> for codes and analysis.</p>
<hr>
<h1 id="Exercise-10-1"><a href="#Exercise-10-1" class="headerlink" title="Exercise 10-1"></a>Exercise 10-1</h1><p>Rewrite the student-grading program from §9.6/166 to generate letter grades.</p>
<h2 id="Solution-amp-Results-1"><a href="#Solution-amp-Results-1" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>Since the letter grades function computes a letter grade based on a numerical grade, I would like to add it as a non-member function of the <strong>Student_info</strong> class to avoid repetitively computing the final grade. When need calculate the letter grades, we simply call the function as follows:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> final_grade = it-&gt;grade(); <span class="comment">// it is a pointer to the Student_info object</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; letter_grade(final_grade); <span class="comment">// print the letter grade</span></span><br></pre></td></tr></table></figure>
<p>or</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; letter_grade(it-&gt;grade());</span><br></pre></td></tr></table></figure>

<p>All files are presented at below including <strong>mainfunction.cpp, Student_info.h, Student_info.cpp, grade.h, grade.cpp</strong>. </p>
<p><strong>mainfunction.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Accelerated C++ Solutions Exercises 10-1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;		// to get the declaration of max, sort</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;		// to get the declaration of setprecision</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;		// to get the declaration of streamsize</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;    	// to get the declatation of domain_error</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;		// to get the declaration of string</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;		// to get the declaration of vector</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span>	<span class="comment">// to get the declaration of Student_info</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;					<span class="keyword">using</span> <span class="built_in">std</span>::setprecision;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;				<span class="keyword">using</span> <span class="built_in">std</span>::sort;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;				<span class="keyword">using</span> <span class="built_in">std</span>::streamsize;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::domain_error;   		        <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">max</span>;					<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::fixed;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Student_info&gt; students;</span><br><span class="line">    Student_info record;</span><br><span class="line">    <span class="built_in">string</span>::size_type maxlen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read and store all the records, and find the length of the longest name</span></span><br><span class="line">    <span class="keyword">while</span>(record.<span class="built_in">read</span>(<span class="built_in">cin</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        maxlen = <span class="built_in">max</span>(maxlen, record.name().<span class="built_in">size</span>());</span><br><span class="line">        students.push_back(record);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// alphabetize the records</span></span><br><span class="line">    sort(students.<span class="built_in">begin</span>(), students.<span class="built_in">end</span>(), compare);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write each line of outpurs</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Student_info&gt;::const_iterator it = students.<span class="built_in">begin</span>();</span><br><span class="line">            it != students.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// write the name, blanks</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (*it).name() &lt;&lt; <span class="built_in">string</span>(maxlen + <span class="number">1</span> - (*it).name().<span class="built_in">size</span>(), <span class="string">' '</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// compute and write the final grade</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">double</span> final_grade = (*it).grade();</span><br><span class="line">            streamsize prec = <span class="built_in">cout</span>.precision();</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">1</span>) &lt;&lt; final_grade &lt;&lt; setprecision(prec);</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">'\t'</span> &lt;&lt; letter_grade(final_grade); <span class="comment">// new added</span></span><br><span class="line">        &#125; <span class="keyword">catch</span>(domain_error e)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; e.what();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Student_info.h</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_STUDENT_INFO</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_STUDENT_INFO</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student_info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Student_info ();				<span class="comment">// default constructor</span></span><br><span class="line">	Student_info (<span class="built_in">std</span>::istream &amp;);			<span class="comment">// constructor with argument</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> n; &#125;		<span class="comment">// inline member function return name</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">valid</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> !homework.empty(); &#125;    <span class="comment">// inline member function check state</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::istream &amp; <span class="title">read</span><span class="params">(<span class="built_in">std</span>::istream &amp;)</span></span>;		<span class="comment">// member function read in data</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">()</span> <span class="keyword">const</span></span>;				<span class="comment">// member function calculate final grade</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> n;</span><br><span class="line">    <span class="keyword">double</span> midterm, <span class="keyword">final</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; homework;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::istream &amp; <span class="title">read_hw</span><span class="params">(<span class="built_in">std</span>::istream &amp;, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;)</span></span>;  <span class="comment">// nonmember function read data into a vector</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> Student_info &amp;, <span class="keyword">const</span> Student_info &amp;)</span></span>;       <span class="comment">// nonmember function compare two string</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">letter_grade</span><span class="params">(<span class="keyword">double</span>)</span></span>; <span class="comment">// new added: nonmember function gives a letter grade</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>Student_info.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"grade.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::istream;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// construct an empty Student_info object</span></span><br><span class="line">Student_info::Student_info (): midterm(<span class="number">0</span>), <span class="keyword">final</span>(<span class="number">0</span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// construct one by reading from input stream</span></span><br><span class="line">Student_info::Student_info (<span class="built_in">std</span>::istream &amp; in) &#123; <span class="built_in">read</span>(in); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// member function read data from input stream</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::istream &amp; <span class="title">Student_info::read</span><span class="params">(<span class="built_in">std</span>::istream &amp;in)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// reads and store the student's name, midterm and final exam grades</span></span><br><span class="line">    in &gt;&gt; n &gt;&gt; midterm &gt;&gt; <span class="keyword">final</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reads and store all homework grades</span></span><br><span class="line">    read_hw(in, homework);</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// member function grade</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Student_info::grade</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ::grade(midterm, <span class="keyword">final</span>, homework);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// nonmember function compare</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> Student_info &amp;x, <span class="keyword">const</span> Student_info &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.name() &lt; y.name();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// nonmember function read_hw</span></span><br><span class="line"><span class="function">istream &amp; <span class="title">read_hw</span><span class="params">(istream &amp;in, <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;hw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (in)&#123;</span><br><span class="line">        <span class="comment">//get rid of previous contents</span></span><br><span class="line">        hw.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// read homework grades</span></span><br><span class="line">        <span class="keyword">double</span> x;</span><br><span class="line">        <span class="keyword">while</span>(in &gt;&gt; x)</span><br><span class="line">            hw.push_back(x);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// clear the stream so that input will work for the next student</span></span><br><span class="line">        in.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// new added: non-member function to calculate the letter grade</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">letter_grade</span><span class="params">(<span class="keyword">double</span> grade)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// range posts for numberic grades</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">double</span> numbers[] = &#123;<span class="number">97</span>, <span class="number">94</span>, <span class="number">90</span>, <span class="number">87</span>, <span class="number">84</span>, <span class="number">80</span>, <span class="number">77</span>, <span class="number">74</span>, <span class="number">70</span>, <span class="number">60</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// name for the letter grades</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> letters[] = &#123;<span class="string">"A+"</span>, <span class="string">"A"</span>, <span class="string">"A-"</span>, <span class="string">"B+"</span>,</span><br><span class="line">                                          <span class="string">"B"</span>, <span class="string">"B-"</span>, <span class="string">"C+"</span>, <span class="string">"C"</span>, <span class="string">"C-"</span>, <span class="string">"D"</span>, <span class="string">"F"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// compute the number of grades given the size of the array</span></span><br><span class="line">    <span class="comment">// and the size of a single element</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> ngrades = <span class="keyword">sizeof</span>(numbers)/<span class="keyword">sizeof</span>(*numbers);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// given a numberic grade, find the associated letter grade</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; ngrades; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (grade &gt;= numbers[i])</span><br><span class="line">            <span class="keyword">return</span> letters[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"?\?\?"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>grade.h</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_GRADE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_GRADE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">median</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>grade.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"grade.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::domain_error;  <span class="keyword">using</span> <span class="built_in">std</span>::istream;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;        <span class="keyword">using</span> <span class="built_in">std</span>::sort;</span><br><span class="line"></span><br><span class="line"><span class="comment">// grade function 1</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">double</span> midterm, <span class="keyword">double</span> <span class="keyword">final</span>, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;hw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hw.empty())</span><br><span class="line">        <span class="keyword">throw</span> domain_error(<span class="string">"student has done no homework"</span>);</span><br><span class="line">    <span class="keyword">return</span> grade(midterm, <span class="keyword">final</span>, median(hw));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// grade function 2</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">double</span> midterm, <span class="keyword">double</span> <span class="keyword">final</span>, <span class="keyword">double</span> homework)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.2</span>*midterm + <span class="number">0.4</span>*<span class="keyword">final</span> + <span class="number">0.4</span>*homework;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compute the median of vector&lt;double&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">median</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// check whether the vec is empty</span></span><br><span class="line">    <span class="keyword">if</span> (vec.<span class="built_in">begin</span>() == vec.<span class="built_in">end</span>())</span><br><span class="line">        <span class="keyword">throw</span> domain_error(<span class="string">"median of an empty vector"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sort the grades</span></span><br><span class="line">    sort(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// compute the median homework grade</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;::difference_type <span class="built_in">size</span> = vec.<span class="built_in">end</span>() - vec.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;::const_iterator mid = vec.<span class="built_in">begin</span>() + <span class="built_in">size</span>/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">size</span> % <span class="number">2</span> == <span class="number">0</span> ? (*mid + *(mid - <span class="number">1</span>))/<span class="number">2</span> : *mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Test</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Inputs:</span><br><span class="line"></span><br><span class="line">Robin 90 87 79 88 81 73 45</span><br><span class="line">Brendan 70 69 88 100 91 75 66</span><br><span class="line">Arsenii 99 87 89 88 74 90 70</span><br><span class="line">Liam 83 66 100 76 87 91 78</span><br><span class="line"></span><br><span class="line">Outputs:</span><br><span class="line"></span><br><span class="line">Arsenii 89.8	B+</span><br><span class="line">Brendan 76.8	C</span><br><span class="line">Liam    77.8	C+</span><br><span class="line">Robin   84.4	B</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Exercise-10-2-10-3"><a href="#Exercise-10-2-10-3" class="headerlink" title="Exercise 10-2, 10-3"></a>Exercise 10-2, 10-3</h1><p>10-2: Rewrite the median function from §8.1.1/140 so that we can call it with either a vector or a built-in array. The function should allow containers of any arithmetic type.</p>
<p>10-3: Write a test program to verify that the median function operates correctly. Ensure that calling median does not change the order of the elements in the container.</p>
<h2 id="Solution-amp-Results-2"><a href="#Solution-amp-Results-2" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>There are two requirements: first is that, the median function can calculate the median value by taking either a vector or built-in array; second is that, the container can be container of any arithmetic type. </p>
<p>Apparently, our median function should be a function template. The first condition implies that the parameters should be two pointers that denote the range of inputs. Unlike the standard vector, built-in array doesn’t provide member functions like <strong>begin()</strong> and <strong>end()</strong>. We cannot simply pass the name of the built-in array to the median function as the name of the array is mere the pointer to the initial element. Alternatively, we can denote its range with [arr, arr+n), where <strong>arr</strong> is the name of the array and <strong>n</strong> is the size of the array. The first type parameter of our tempalte represents the type of supplied pointers and will be inferred from the supplied pointers in the process of instantiation. </p>
<p>The second condition implies that the type of the elements contained in the container should be supplied as we cannot infer the value type from pointers. Therefore, another type parameter of the function template represents the value type of the container and will be infered from the third function parameter, which is defined as any element of the container. As the following declaration shows, <strong>Pointer</strong> and <strong>T</strong> represents the pointer type and value type. The function defines three parameters, first two of which denotes the range of inputs while the third is a <strong>const reference</strong> to the first element contained in the container. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Pointer</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">median</span>(<span class="title">Pointer</span> <span class="title">begin</span>, <span class="title">Pointer</span> <span class="title">end</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">initialElement</span>);</span></span><br></pre></td></tr></table></figure>

<p>Once we have the pointers, we can implement the algorithm as with the previous version. But to avoid changing the original sequence, we’d better construct a new vector to hold the input sequence. The code below gives the full program. I test it by calling the function template with a standard vector and a built-in array that contains the same elements as the vector. As expected, they yield same median value. If changing the value type to <strong>int</strong>, the function template works as well. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;	// std::vector</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;	// std::cout, std::endl</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;	// std::domain_error</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;	// copy</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;	// size_t</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;			<span class="keyword">using</span> <span class="built_in">std</span>::<span class="keyword">size_t</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;			<span class="keyword">using</span> <span class="built_in">std</span>::copy;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::domain_error;	        <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Pointer</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">median</span>(<span class="title">Pointer</span> <span class="title">begin</span>, <span class="title">Pointer</span> <span class="title">end</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">initialElement</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">begin</span> == <span class="built_in">end</span>)</span><br><span class="line">        <span class="keyword">throw</span> domain_error(<span class="string">"median of an empty container"</span>);</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;T&gt; <span class="title">v</span><span class="params">(<span class="built_in">begin</span>, <span class="built_in">end</span>)</span></span>;</span><br><span class="line">    <span class="keyword">typename</span> <span class="built_in">vector</span>&lt;T&gt;::difference_type <span class="built_in">size</span> = v.<span class="built_in">end</span>() - v.<span class="built_in">begin</span>();</span><br><span class="line">    sort(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">typename</span> <span class="built_in">vector</span>&lt;T&gt;::const_iterator mid = v.<span class="built_in">begin</span>() + <span class="built_in">size</span>/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">size</span> % <span class="number">2</span> == <span class="number">0</span> ? (*mid + *(mid<span class="number">-1</span>)) / <span class="number">2</span> : *mid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; vec&#123;<span class="number">53</span>, <span class="number">56</span>, <span class="number">23</span>, <span class="number">78</span>, <span class="number">90</span>, <span class="number">89</span>, <span class="number">34</span>, <span class="number">12</span>, <span class="number">41</span>, <span class="number">48</span>&#125;;</span><br><span class="line">    <span class="keyword">size_t</span> n = vec.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">double</span> arr[n];</span><br><span class="line">    copy(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), arr);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; median(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), vec[<span class="number">0</span>]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; median(arr, arr + n, arr[<span class="number">0</span>]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Test Results</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">50.5</span><br><span class="line">50.5</span><br></pre></td></tr></table></figure>


<hr>
<h1 id="Exercise-10-4-10-5-10-6"><a href="#Exercise-10-4-10-5-10-6" class="headerlink" title="Exercise 10-4, 10-5, 10-6"></a>Exercise 10-4, 10-5, 10-6</h1><p>10-4: Write a class that implements a list that holds strings.</p>
<p>10-5: Write a bidirectional iterator for your String_list class.</p>
<p>10-6: Test the class by rewriting the split function to put its output into a String_list.</p>
<h2 id="Solution-amp-Results-3"><a href="#Solution-amp-Results-3" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><h3 id="define-the-String-list-class"><a href="#define-the-String-list-class" class="headerlink" title="define the String_list class"></a>define the <strong>String_list</strong> class</h3><p>The standard <strong>list</strong> provides all the possible operations and what we need to do is merely to encapsulate our data, a <strong>list<string></strong>, by hiding the data and instead providing an appropriate interface. I intend to implement a subset of the <strong>list<string></strong> class. Specifically, we can use the <strong>String_list</strong> class as follows:</p>
<p><strong>Interface</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; construct an empty container</span><br><span class="line">String_list s;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; construct a container with a size and a value</span><br><span class="line">String_list s1(10, &quot;Hello&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; return iterator to begining and end</span><br><span class="line">s1.begin();</span><br><span class="line">s1.end();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; construct a container with a range</span><br><span class="line">String_list s2(s1.begin(), s1.end());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; copy construct a container</span><br><span class="line">String_list s3(s2);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; assignment</span><br><span class="line">s &#x3D; s1;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; check the status of the container</span><br><span class="line">s1.empty();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; check the size</span><br><span class="line">s1.size();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; clear</span><br><span class="line">s1.chear();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; add one element to end</span><br><span class="line">s1.push_back(&quot;Hello&quot;);</span><br></pre></td></tr></table></figure>
<p>All these operations are obvious and we can directly work with <strong>list<string></strong> in our implementations. You can add more operations to this <strong>String_list</strong> class as long as the operations are supported by the standard <strong>list</strong> class. Let’s see how our <strong>String_list</strong> class is implemented:</p>
<p><strong>String_list.h</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> STRING_LIST_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STRING_LIST_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String_list</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; container;</span><br><span class="line">    container SL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> container::iterator iterator;</span><br><span class="line">    <span class="keyword">typedef</span> container::const_iterator const_iterator;</span><br><span class="line">    <span class="keyword">typedef</span> container::value_type value_type;</span><br><span class="line">    <span class="keyword">typedef</span> container::size_type size_type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// default constructor: construct an empty String_list</span></span><br><span class="line">    String_list() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// constructor that takes a size and a value</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">String_list</span><span class="params">(size_type n, <span class="keyword">const</span> value_type&amp; val = value_type())</span>: <span class="title">SL</span><span class="params">(n, val)</span> </span>&#123;&#125;</span><br><span class="line">    String_list(const_iterator beg, const_iterator <span class="built_in">end</span>): SL(beg, <span class="built_in">end</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bidirectional iterator and const bidirectional iterator</span></span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> SL.<span class="built_in">begin</span>(); &#125;</span><br><span class="line">    <span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> SL.cbegin(); &#125;</span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> SL.<span class="built_in">end</span>(); &#125;</span><br><span class="line">    <span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> SL.cend(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// empty</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> SL.empty(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// size</span></span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> SL.<span class="built_in">size</span>(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clear</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; SL.<span class="built_in">clear</span>(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// push_back</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> value_type&amp; v)</span> </span>&#123; SL.push_back(v); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* STRING_LIST_H_ */</span></span></span><br></pre></td></tr></table></figure>
<p>It is worth noting that the class defines three constructors but ignores the copy constructor, assignment operator and the destructor. As a result, the compiler will synthesize copy constructor, assignment operator and destructor for us. The synthesized operations depend on the definition of the data member. For example, the compiler will synthesize the copy constructor by calling the default copy constructor of the <strong>list<string></strong> class. Therefore, we do not need to worry about that. The synthesized operations also work on the default constructor. I explicitly define the default constructor because that we need other constructors. If we didn’t explicitly define the default constructor, the compiler won’t synthesize for us due to the existence of other constructors. </p>
<p>Another point is that the class implicitly supports the conversion from a string literal to a string type. This property is inherent in the standard <strong>string</strong> class and is further explained in chapter 12. </p>
<p>The last point is that the iterator returned by <strong>begin()</strong> and <strong>end()</strong> are all bidirectional iterator. This has been defined in the standard <strong>list</strong> class. We can traverse forward or backward the container and access or rewrite the elements using the returned iterators. </p>
<h3 id="rewrite-the-split-function"><a href="#rewrite-the-split-function" class="headerlink" title="rewrite the split function"></a>rewrite the split function</h3><p>The original split function copies its output into the output stream directly. We can replace the outstream object with our <strong>String_list</strong>. Rather than passing an <strong>ostream_iterator<string></strong> as the argument to the split function, we can pass a reference to the container as the argument.<br>Therefore, the declaration of the revisied split function is:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">container</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">split</span>(<span class="title">const</span> <span class="title">std</span>:</span>:<span class="built_in">string</span> &amp;, container&amp;);</span><br></pre></td></tr></table></figure>
<p>Then we can store each seperated word into the container by calling its <strong>push_back</strong> function. Please see the code below:</p>
<p><strong>Split.h</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_SPLIT_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_SPLIT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"String_list.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// true if the argument is whitespace, false otherwise</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">space</span><span class="params">(<span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">isspace</span>(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// false is the argument is whitespace, true otherwise</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">not_space</span><span class="params">(<span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !<span class="built_in">isspace</span>(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// template declaration and definition</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">container</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">split</span>(<span class="title">const</span> <span class="title">std</span>:</span>:<span class="built_in">string</span> &amp;str, container&amp; c)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">string</span>::const_iterator iter;</span><br><span class="line"></span><br><span class="line">    iter i = str.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span>(i != str.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ignore leading spaces</span></span><br><span class="line">        i = <span class="built_in">std</span>::find_if(i, str.<span class="built_in">end</span>(), not_space);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// find end of next word</span></span><br><span class="line">        iter j = <span class="built_in">std</span>::find_if(i, str.<span class="built_in">end</span>(), space);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// copy the characters in [i,j) and store into container</span></span><br><span class="line">        <span class="keyword">if</span>(i != str.<span class="built_in">end</span>())</span><br><span class="line">            c.push_back(<span class="built_in">std</span>::<span class="built_in">string</span>(i, j));</span><br><span class="line">        i = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* GUARD_SPLIT_H */</span></span></span><br></pre></td></tr></table></figure>

<h3 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h3><p>I wrote a test program to test each members of our <strong>String_list</strong> class and the revised <strong>split</strong> function.</p>
<p><strong>main.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;		// std::cin, endl, cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;		// std::string</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"String_list.h"</span>        <span class="comment">// String_list</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"split.h"</span>		<span class="comment">// split</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// construct an empty container</span></span><br><span class="line">    String_list words;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// test the empty function</span></span><br><span class="line">    <span class="keyword">if</span>(words.empty())</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"This is an empty container\n"</span></span><br><span class="line">                <span class="string">"Please enter a sentence: "</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// test the split function, and the push_back member of the String_list</span></span><br><span class="line">    <span class="built_in">string</span> <span class="built_in">line</span>;</span><br><span class="line">    <span class="keyword">while</span> (getline(<span class="built_in">cin</span>, <span class="built_in">line</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        split(<span class="built_in">line</span>, words);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"There are "</span> &lt;&lt; words.<span class="built_in">size</span>() &lt;&lt; <span class="string">" word(s) in total: "</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i: words) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// test bidirectional iterators</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\nprint all words in reverse order: "</span>;</span><br><span class="line">    String_list::iterator rbeg = --words.<span class="built_in">end</span>();</span><br><span class="line">    String_list::iterator rend = --words.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span>(rbeg != rend)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *rbeg-- &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// test the constructor that takes two input iterators</span></span><br><span class="line">    <span class="function">String_list <span class="title">words_copy</span><span class="params">(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>())</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(!words_copy.empty())&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"\nThe size of the container is: "</span> &lt;&lt; words_copy.<span class="built_in">size</span>();</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"\nThe elements contained in the String_list are: "</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> i: words_copy)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// test the clear function</span></span><br><span class="line">    words.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">if</span>(words.empty())</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"\nThe container now is empty again"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// test the constructor that takes a size and a value</span></span><br><span class="line">    <span class="function">String_list <span class="title">words_new</span><span class="params">(<span class="number">10</span>, <span class="string">"Hello"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// test the default copy constructor</span></span><br><span class="line">    <span class="function">String_list <span class="title">words_new_copy</span><span class="params">(words_new)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\nThe container contains: "</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i: words_new_copy) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// test the default assignment operator</span></span><br><span class="line">    words = words_new;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\nNow the container words contains: "</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i: words) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The program above is pretty straightforward and gives following results as expected:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">This is an empty container</span><br><span class="line">Please enter a sentence: Stack is one of the rudimentary data structures that use pointers</span><br><span class="line">There are 11 word(s) in total: Stack is one of the rudimentary data structures that use pointers </span><br><span class="line">print all words in reverse order: pointers use that structures data rudimentary the of one is Stack </span><br><span class="line">The size of the container is: 11</span><br><span class="line">The elements contained in the String_list are: Stack is one of the rudimentary data structures that use pointers </span><br><span class="line">The container now is empty again</span><br><span class="line">The container contains: Hello Hello Hello Hello Hello Hello Hello </span><br><span class="line">Now the container words contains: Hello Hello Hello Hello Hello Hello Hello</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>Koenig, A. and Moo, B.E., 2000. Accelerated C++.</p>
<p>Lippman, S.B., Lajoie, J. and Moo, B.E., 2013. C++ Primer, 5th edt.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://quantein.com/2018/04/10/C-Managing-memory-and-low-level-data-structures/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liam">
      <meta itemprop="description" content="Stochastic Modelling Notes; Programming Notes">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Liam's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/10/C-Managing-memory-and-low-level-data-structures/" class="post-title-link" itemprop="url">C++ - Managing memory and low-level data structures</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-04-10 13:42:55" itemprop="dateCreated datePublished" datetime="2018-04-10T13:42:55+08:00">2018-04-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2018-05-05 15:30:58" itemprop="dateModified" datetime="2018-05-05T15:30:58+08:00">2018-05-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Programming/" itemprop="url" rel="index"><span itemprop="name">Programming</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span></span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>NaN:aN</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Pointers"><a href="#Pointers" class="headerlink" title="Pointers"></a>Pointers</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p><strong>pointer</strong> is a compound type that points to another base type object. <strong>A pointer</strong> is a value that represents the address of the object that it points to. What is the address of an object? The address of an object denotes the part of the computer’s memory that contains the object. For example, if <strong>x</strong> is an object, then <strong>&amp;x</strong> is the address of <strong>x</strong> and <strong>&amp;</strong> is the <strong>address operator</strong>. Further, if <strong>p</strong> is a pointer, then <strong>*p</strong> is the value of the object that <strong>p</strong> points to and * is the <strong>deference operator</strong>. </p>
<p>We are familar with these two operators<strong>&amp;</strong> and *, however, may feel comfused about their meanings. Generally, these rules can be summarized as follows:</p>
<ol>
<li><p>when the <strong>&amp;</strong> is used as part of a declaration, e.g.</p>
<pre><code>int i = 10;
int &amp;x = i;</code></pre><p> <strong>&amp;</strong> follows a type and <strong>x</strong> is a reference.</p>
</li>
<li><p>when the <strong>&amp;</strong> is used as in an expression, e.g.</p>
<pre><code>int *p = &amp;i;</code></pre><p> <strong>&amp;</strong> acts as an <strong>address operator</strong>.</p>
</li>
<li><p>when the <strong><em>*</em></strong> is used as part of a declaration, e.g.</p>
<pre><code>int *p = &amp;i;</code></pre><p> <strong><em>*</em></strong> follows a type and <strong>p</strong> is a pointer.</p>
</li>
<li><p>when the <strong><em>*</em></strong> is used in an expression, e.g.</p>
<pre><code>int i = *p;
*p = i;</code></pre><p> it acts as an <strong>deference operator</strong> and yields the value of the object that <strong>p</strong> points to.</p>
</li>
</ol>
<p>It can be observed that a <strong>pointer</strong> can indirect access the value an object like a <strong>reference</strong>. However, a <strong>reference</strong> itself is not an object while a <strong>pointer</strong> itself is an object. From the third rule above, we know how to define a <strong>pointer</strong>. For example</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p;</span><br></pre></td></tr></table></figure>
<p><strong>p</strong> is a <strong>pointer</strong> that points to <strong>int</strong> type object. In other words, <strong>p</strong> has type <strong>int*</strong>. As other built-in types, a <strong>pointer</strong> might point to an unknown object unless we initialize it. Typically,we can initialize a pointer as a <strong>null pointer</strong> which means that the pointer does’t point to any object. There are several ways to do this:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="number">0</span>;         <span class="comment">// the constant 0 can be converted to a pointer type</span></span><br><span class="line"><span class="keyword">int</span> *p = <span class="literal">nullptr</span>;   <span class="comment">// c++11 supports</span></span><br><span class="line"><span class="keyword">int</span> *p = <span class="literal">NULL</span>;      <span class="comment">// must include header &lt;cstdlib&gt;</span></span><br></pre></td></tr></table></figure>
<p>These three statements lead to an equivalent result. If we want to assign other values to a pointer, typically we uses the address-of operator:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;i; <span class="comment">// p points to i</span></span><br><span class="line"><span class="keyword">int</span> *q = &amp;j; <span class="comment">// q points to j</span></span><br><span class="line">p = q;       <span class="comment">// p points to j now</span></span><br></pre></td></tr></table></figure>

<h2 id="Pointers-to-functions"><a href="#Pointers-to-functions" class="headerlink" title="Pointers to functions"></a>Pointers to functions</h2><p>It is known that functions are not objects and hence there is no way to copy or assign them, or to pass them as arguments directly. But we do “pass” functions as arguments in previous chapter, for example, the <a href="http://quanttour.com/22/03/2018/C-Using-library-algorithms-Part-2/" target="_blank" rel="noopener">write_analysis</a> function (see declaration below) takes function as its second parameter. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_analysis</span><span class="params">(<span class="built_in">std</span>::ostream &amp;out, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">double</span> analysis(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Student_info&gt; &amp;),</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Student_info&gt; &amp;did,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Student_info&gt; &amp;didnt)</span></span>;</span><br></pre></td></tr></table></figure>
<p>In fact this is achieved by taking the address of a function, that is, the pointer to the function. Let’s go into some details about the <strong>pointers</strong> to functions.</p>
<p>The syntax to define a pointer to function is, for example</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (*fp)(<span class="keyword">int</span>);</span><br></pre></td></tr></table></figure>
<p>Then, if we deference <strong>fp</strong> and call it with <strong>int</strong> argument, the result is an <strong>int</strong> type value.<br>Another fact is that what we can do with a function is to take its address or call it. Therefore, when we use a function but is not to call it, we are assumed to be take its address, either using <strong>&amp;</strong> or not. For example,</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">next</span> <span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// these two statements are equivalent</span></span><br><span class="line">fp = next;</span><br><span class="line">fp = &amp;next;</span><br></pre></td></tr></table></figure>
<p>Further, when we call the next function with an int variable i, </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// these two statements are equivalent</span></span><br><span class="line"><span class="keyword">int</span> x = fp(i);</span><br><span class="line"><span class="keyword">int</span> x = (*fp)(i);</span><br></pre></td></tr></table></figure>
<p>Finally, when we have a function that takes another function as a parameter, the compiler will translate the parameter to be a pointer. Taking the <strong>write_analysis</strong> as an example, the parameter</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">analysis</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Student_info&gt; &amp;)</span></span></span><br></pre></td></tr></table></figure>
<p>is in fact equivalent to </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> (*analysis)(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Student_info&gt; &amp;)</span><br></pre></td></tr></table></figure>
<p>As shown below, when we “pass” another function as an argument, <strong>analysis</strong> points to a function named <strong>median_analysis</strong>. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">analysis = median_analysis; <span class="comment">// == analysis = &amp;median_analysis</span></span><br></pre></td></tr></table></figure>

<p>What if we want to write a function that returns a function pointer?<br>The simplest way is to use type alias</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">double</span> <span class="params">(*analysis_fp)</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;Student_info&gt;&amp;)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>analysis_fp</strong> is the name of the type of a pointer to function. Then</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// get_analysis_ptr returns a pointer to an analysis function</span></span><br><span class="line"><span class="function">analysis_fp <span class="title">get_analysis_ptr</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>declares a function <strong>get_analysis_ptr()</strong> that returns a pointer to an analysis function. This statement is equivalent to</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> (*get_analysis_ptr()) (<span class="keyword">const</span> <span class="built_in">vector</span>&lt;Student_info&gt; &amp;);</span><br></pre></td></tr></table></figure>
<p>From this, we can see that <strong>get_analysis_ptr</strong> has a parameter list and hence it is a function. In addition, there is an <strong><em>*</em></strong> before it, which indicates that the function returns a pointer. Furthermore, the returned pointer also has a parameter list and hence the returned pointer points to a function that takes parameter <strong>const vector<Student_info> &amp;</strong> and returns a <strong>double</strong> type value. </p>
<p>Now let’s look at an example</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">In</span>, <span class="title">class</span> <span class="title">Pred</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">In</span> <span class="title">find_if</span>(<span class="title">In</span> <span class="title">begin</span>, <span class="title">In</span> <span class="title">end</span>, <span class="title">Pred</span> <span class="title">f</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">begin</span> != <span class="built_in">end</span> &amp;&amp; !f(*<span class="built_in">begin</span>))</span><br><span class="line">        ++<span class="built_in">begin</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">begin</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Suppose we have a predicate function</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_negative</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Let’s instanitialize the template with a vector named <strong>v</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator i = find_if(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), is_negative)</span><br></pre></td></tr></table></figure>
<p>We use <strong>is_negative</strong> instead of <strong>&amp;is_negative</strong> due to that the name of the function turns into a pointer to the function autimatially. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Arrays</span><br><span class="line">**Array** is part of the core language rather than part of the standard library. An **array** is a kind of container that similar to a **vector**, but has fixed length. When we create an **array** object, we should specify the length of the array. For example, we can create an array that contains three elements</span><br><span class="line">&#96;&#96;&#96;c++</span><br><span class="line">double coords[3];</span><br></pre></td></tr></table></figure>
<p>Alternatively, we can use a <strong>const</strong> object to denote the size of the array</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> NDim = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">double</span> coords[NDim];</span><br></pre></td></tr></table></figure>
<p><strong>size_t</strong> is a fundamental unsigned integer type that can be used to represent the size of an array. It is defined in the header <strong><cstddef></strong>. The reason to use <strong>size_t</strong> is that <strong>array</strong> is not a class type and has no member function like <strong>size_type</strong>. It is worth noting that we use <strong>const</strong> to ensure <strong>Ndim</strong> is fixed and known at compilation time. </p>
<p><strong>coords</strong> is the name of the array, and in fact it is a pointer that points to the first element of the array. Hence, we can assign a value to the first element through</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*coords = <span class="number">1.5</span>; <span class="comment">// set the initial element of coords to 1.5</span></span><br></pre></td></tr></table></figure>

<h2 id="Pointer-arithmetic"><a href="#Pointer-arithmetic" class="headerlink" title="Pointer arithmetic"></a>Pointer arithmetic</h2><p>Another fact is that a <strong>pointer</strong> is a random access iterator. Therefore, we can access the <strong>m</strong>th element (if available) through </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*(coords + m)</span><br></pre></td></tr></table></figure>
<p>The pointer that points to one past the last element is <strong>coords + NDim</strong>. In other words, [coords, coords + NDim) denotes the range of address of the array. </p>
<p>Now, if we want to copy all elements of the array into a vector named <strong>v</strong>, we can use the copy algorithm as shown as follows</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; v;</span><br><span class="line">copy(coords, coords + NDim, back_inserter(v));</span><br></pre></td></tr></table></figure>
<p>Alternatively, we can construct <strong>v</strong> directly as a copy of the elements in <strong>coords</strong> using </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">v</span><span class="params">(coords, coords + NDim)</span></span>;</span><br></pre></td></tr></table></figure>
<p>C++ 2011 library provides <strong>begin</strong> and <strong>end</strong> functions to get the initial pointer and the off-the-end pointer:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *beg = <span class="built_in">begin</span>(coords);   <span class="comment">// points to the initial elements</span></span><br><span class="line"><span class="keyword">int</span> *last = <span class="built_in">end</span>(coords);    <span class="comment">// points to one past the last element</span></span><br><span class="line">···</span><br><span class="line"></span><br><span class="line">Similar to **difference_type**, **<span class="keyword">ptrdiff_t</span>** is an <span class="keyword">signed</span> itegeral type that represents the distance between two **pointers**. **<span class="keyword">ptrdiff_t</span>** is also defined in the header &lt;cstddef&gt;. </span><br><span class="line"></span><br><span class="line">## Indexing</span><br><span class="line">It is known now that **array** supports random access iterators and naturally supports indexing. Therefore, the **n**th emelent (if available) is **coords[n]** and ***coords = coords[0]**.</span><br><span class="line"></span><br><span class="line">## Array initialization</span><br><span class="line">Array supports <span class="built_in">list</span> initialization, <span class="keyword">for</span> example</span><br><span class="line">```c++</span><br><span class="line"><span class="comment">// these two statements have same effect</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>If we don’t specify the number of elements contained in the array, compiler will infer the number from the number of the supplied the initializers. But if we specify the number exactly, the number of initializers must not exceed the specified size. So, what if we specifies the size but provides initializers less than the specified number?</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>Then, the compiler will value initialize the rest elements. In this case, the elements have built-in type <strong>int</strong> and hence are set to 0. </p>
<h1 id="String-literals-revisited"><a href="#String-literals-revisited" class="headerlink" title="String literals revisited"></a>String literals revisited</h1><p>As we mentioned earlier, String literals are not <strong>string</strong>s. In fact, a string literal is an array of <strong>const char</strong> with one more element, i.e. ‘\0’ ,than the number of characters in the literal. <strong>‘\0’</strong> is a null character. Therefore, when we create a string literal, we should specify the size one larger than it should be for the purpose of holding the extral null character. For example, a string literal <strong>Hello</strong> is created through</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// two ways to initialize a string literal</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> hello[] = &#123;<span class="string">'H'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>, <span class="string">'\0'</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> hello[<span class="number">6</span>] = <span class="string">"Hello"</span>;</span><br></pre></td></tr></table></figure>
<p>The null character marks the end of the literal. When we want to get the number of characters excluding the null character, we can use the function <strong>strlen</strong> defined in <cstring>. The <strong>strlen</strong> might has following implementation</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Exanple implementation of standard-library function</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">strlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> <span class="built_in">size</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (*p++ != <span class="string">'\0'</span>)</span><br><span class="line">        ++<span class="built_in">size</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">size</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Now, if we want to copy the string literal <strong>Hello</strong> into a string type object, we can use</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// three equivalent ways to copy the string literal into a string</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(hello)</span></span>; <span class="comment">// variable hello represents "Hello"</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"Hello"</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(hello, hello + <span class="built_in">strlen</span>(hello))</span></span>; <span class="comment">// treats hello as the begin iterator</span></span><br></pre></td></tr></table></figure>

<h2 id="Initializing-arrays-of-character-pointer"><a href="#Initializing-arrays-of-character-pointer" class="headerlink" title="Initializing arrays of character pointer"></a>Initializing arrays of character pointer</h2><p><em>Essentially, a string literal is just a convenient way of writing the address of the initial character of a null-terminated sequence of characters</em>. Now let’s look at an example that shows how to generate an appropriate letter grade according to a numeric grade. The letter grades and numeric grades have following mapping relations:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">If the grade is at least  97  94  90  87  84  80  77  74  70  60  0</span><br><span class="line">then the letter grade is  A+  A   A-  B+  B   B-  C+  C   C-  D   F</span><br></pre></td></tr></table></figure>
<p>The program is shown below and let’s analyse it step by step.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">letter_grade</span><span class="params">(<span class="keyword">double</span> grade)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// range posts for numberic grades</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">double</span> numbers[] = &#123;<span class="number">97</span>, <span class="number">94</span>, <span class="number">90</span>, <span class="number">87</span>, <span class="number">84</span>, <span class="number">80</span>, <span class="number">77</span>, <span class="number">74</span>, <span class="number">70</span>, <span class="number">60</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// name for the letter grades</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> letters[] = &#123;<span class="string">"A+"</span>, <span class="string">"A"</span>, <span class="string">"A-"</span>, <span class="string">"B+"</span></span><br><span class="line">                                          <span class="string">"B"</span>, <span class="string">"B-"</span>, <span class="string">"C+"</span>, <span class="string">"C"</span>, <span class="string">"C-"</span>, <span class="string">"D"</span>, <span class="string">"F"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// compute the number of grades given the size of the array</span></span><br><span class="line">    <span class="comment">// and the size of a single element</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> ngrades = <span class="keyword">sizeof</span>(numbers)/<span class="keyword">sizeof</span>(*numbers);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// given a numberic grade, find the associated letter grade</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; ngrades; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (grade &gt;= numbers[i])</span><br><span class="line">            <span class="keyword">return</span> letters[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"?\?\?"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The function itself takes a double type value (i.e. a numeric grade), and returns a string (i.e. a letter grade). The first step is to construct two objects that hold the numeric grades and the letter grades, respectively. It is simple if we use <strong>vector</strong> or <strong>list</strong> or <strong>map</strong> as we know the numeric grade <strong>int</strong> type and the letter grade is <strong>string</strong> type. What if we use <strong>array</strong>? There is nothing new if we use <strong>string</strong> type, for example,</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">string</span> letters[] = &#123;<span class="string">"A+"</span>, <span class="string">"A"</span>, <span class="string">"A-"</span>, <span class="string">"B+"</span>, <span class="string">"B"</span>, <span class="string">"B-"</span>, <span class="string">"C+"</span>, <span class="string">"C"</span>, <span class="string">"C-"</span>, <span class="string">"D"</span>, <span class="string">"F"</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>But if we treat each letter grade as a a sequence of characters, we can store them as the program shows</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> letters[] = &#123;<span class="string">"A+"</span>, <span class="string">"A"</span>, <span class="string">"A-"</span>, <span class="string">"B+"</span>, <span class="string">"B"</span>, <span class="string">"B-"</span>, <span class="string">"C+"</span>, <span class="string">"C"</span>, <span class="string">"C-"</span>, <span class="string">"D"</span>, <span class="string">"F"</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>It can be observed that:</p>
<ol>
<li>the <strong>static</strong> means that the object is initialized only once and exists in the whole process till the program terminates. </li>
<li>the <strong>letters</strong> is an array of <strong>const pointers</strong> to <strong>const char</strong>. Each element is a string literal, i.e. an alternative way of writing the address of the initial character. Therefore, each element is in fact can be regarded as a pointer that points to the initial letter of the string literal. For example, <strong>letters[0]</strong> gives the first letter grade <strong>A+</strong> while <strong>*(letters[0])</strong> gives the initial letter of the first letter grade as <strong>letters[0]</strong> is a pointer as well. </li>
<li>The first <strong>const</strong> means that the array elements are constant. The second <strong>const</strong> means that the address are constant. </li>
<li>the next statement introduces <strong>sizeof</strong> which is a function that returns a <strong>size_t</strong> type value indicating how much memory an object occupied. Therefore, <strong>sizeof(numbers)</strong> gives the number of bytes that the object <strong>numbers</strong> while <strong>sizeof(*numbers)</strong> yields the number of bytes that each element consumes. The result of the division yields a value that is the number of elements contained in the object (i.e. array numbers). </li>
<li>finally, using a for statement a corresponding letter grade according to the input. If there exists such a grade, return it, otherwise, return <strong>???</strong>. </li>
</ol>
<h1 id="Arguments-to-main"><a href="#Arguments-to-main" class="headerlink" title="Arguments to main"></a>Arguments to main</h1><p>As mentioned in chapter 0, the main function can take arguments like other functions if it defines parameters. A conventional way is to pass a sequence of stings to <strong>main</strong> as an argument. For example, when we pass <strong>say Hello, world</strong> as an argument, the program give outputs</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, world</span><br></pre></td></tr></table></figure>
<p>How to achieve this? This is done by giving two parameters: </p>
<ol>
<li>an <strong>int</strong> type parameter named <strong>argc</strong> which is a value that denotes the number of pointers that pointed by <strong>argv</strong>.</li>
<li>another one is named as <strong>argv</strong> which is a pointer to a pointer to char.  For example, the pointer <strong>letters</strong> described above. <strong>letters</strong> points to the initial element, that is, the pointer to char <strong>A</strong> as the pointer to a string literal points to the initial char of the sequence. Therefore, we can define this parameter as</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* argv[]</span><br></pre></td></tr></table></figure>
<p>or</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char** argv</span><br></pre></td></tr></table></figure>
<p>These two expression are equivalent. Now, let’s look at the <strong>main</strong> with arguments <strong>argc</strong> and <strong>argv</strong>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// if there are arguments, write them</span></span><br><span class="line">    <span class="keyword">if</span>(argv &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// declare i outside the for because we need it after the loop </span></span><br><span class="line">        <span class="keyword">int</span> i;  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// write all but the last entry and argv[i] is a char* </span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; argc - <span class="number">1</span>; ++i)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; argv[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// write the last entry but not a space</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; argv[i] &lt;&lt; <span class="built_in">endl</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Assuming we pass <strong>Hello, world</strong> as an argument, <strong>argc</strong> will be 3 (why ?) and <strong>argv</strong> points to the first element, that is, another pointer to “Hello,” that is, character <strong>‘H’</strong>. <strong>argv[0]</strong> can be regarded as the name (i.e. pointer again) of the first string literal, and hence we can access each string literal through <strong>argv[i]</strong>, where <strong>i &lt; argc</strong>. </p>
<p>You might wonder that why <strong>argc</strong> is 3 and why we use range [1, argv) rather than [0, argv) as we did before? This is because when we pass arguments, the program name will be automatically passed as one element. Specifically, if we pass sequence <strong>please give me a number</strong>, there will be 5 string literal in total, but <strong>argc = 6</strong> because: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">argv points to pointer argv[0] points to &quot;program name&quot;</span><br><span class="line">                       argv[1] points to &quot;please&quot; </span><br><span class="line">                       argv[2] points to &quot;give&quot; </span><br><span class="line">                       argv[3] points to &quot;me&quot; </span><br><span class="line">                       argv[4] points to &quot;a&quot; </span><br><span class="line">                       argv[5] points to &quot;number&quot;</span><br></pre></td></tr></table></figure>
<p>This shows why we use the range [1, argv) to access each element. </p>
<h1 id="Reading-and-writing-files"><a href="#Reading-and-writing-files" class="headerlink" title="Reading and writing files"></a>Reading and writing files</h1><p>By now, we are familar with four <strong>iostream</strong> class objects <strong>cin, cout, clog,</strong> and <strong>cerr</strong>. This part introduces another <strong>IO</strong> facilitiy <strong>ifstream</strong> and <strong>ofstream</strong> class to deal with multiple input and output files. Specifically, the <strong>ofstream</strong> class object allows us to write data into a file, while <strong>iftream</strong> allows us to read data from a file. We can use these objects like what we operate on <strong>cin</strong> and <strong>cout</strong> such as that they also support <strong>&lt;&lt;</strong> and <strong>&gt;&gt;</strong> operators as well as <strong>getline</strong>. </p>
<p>When defining an <strong>ifstream</strong> or <strong>oftream</strong> object, we can associate the object with a file that we intend to write or read. Naturally we supply the file name which can be a <strong>string</strong> (C++11) or a <strong>string literal</strong>. This can be done either on construction or by calling member function <strong>open</strong>. For example,</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// two ways to open a file named s</span></span><br><span class="line"><span class="function">ifstream <span class="title">in</span><span class="params">(s)</span></span>;</span><br><span class="line">ifstream.<span class="built_in">open</span>(s);</span><br></pre></td></tr></table></figure>

<p>The below program shows how to copy the contents of a file named <strong>in</strong> to a file named <strong>out</strong>.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">infile</span><span class="params">(<span class="string">"in"</span>)</span></span>;</span><br><span class="line">    <span class="function">ofstream <span class="title">outfile</span><span class="params">(<span class="string">"out"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">while</span> (getline(infile, s))</span><br><span class="line">        outfile &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The first statement creates an <strong>ifstream</strong> object <strong>infile</strong> and associates it with a file named <strong>in</strong>. Similarly, the second statement creates an <strong>ofstream</strong> object <strong>outfile</strong> and associates it with a file named <strong>out</strong>. Both file names are string literals, i.e. pointers to the initial character of null-terminated array. If file <strong>in</strong> doesn’t exist, there won’t be a file <strong>in</strong> being created. However, if <strong>out</strong> doesn’t exist, it will be create to hold the outputs. </p>
<p>If we don’t want to use string literal as name, one solution is to store the name in a <strong>string</strong> and use member function <strong>c_str</strong> to get the pointer to the array that contains a null-terminated sequence of characters (i.e., a C-string) representing the current value of the string object_ <a href="http://www.cplusplus.com/reference/string/string/c_str/" target="_blank" rel="noopener">Reference to std::string::c_str</a>. For example, <strong>file</strong> is a string variable that contains the name of a file to be read, we then associate the file with a <strong>ifstream</strong> object through</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">infile</span><span class="params">(file.c_str())</span></span>;</span><br></pre></td></tr></table></figure>

<p>Finally, let’s look at another program that produces a copy of all files whose names are given as arguments to main.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fail_count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// for each file in the input list</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; argc; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">ifstream <span class="title">in</span><span class="params">(argv[i])</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if it exits, write its contents, otherwise generate an error message</span></span><br><span class="line">        <span class="keyword">if</span>(in)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> s;</span><br><span class="line">            <span class="keyword">while</span>(getline(in, s))</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cerr</span> &lt;&lt; <span class="string">"cannot open file "</span> &lt;&lt; argv[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            ++fail_count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fail_count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The program logic is simple: first get a name from the arguments <strong>argv</strong>, then open a same name file; if the file exists, the contents of it will be written on the output device, but if there is no such file, count and record such case with a variable <strong>fail_count</strong>; finally, returns <strong>fail_count</strong>, by then, the value of <strong>fail_count</strong> represents the number of non-existent files; if <strong>fail_count</strong> is not 0, it indicates that the program terminates abnormally.</p>
<p>It is worth noting that when a <strong>ifstream</strong> object fails to associate the corresponding file, the state of the input stream is set to fail. Therefore, the if condition <strong>if(in)</strong> is very useful and helpful for us to check whether our operations on the file are valid.  </p>
<h1 id="Three-kinds-of-memory-management"><a href="#Three-kinds-of-memory-management" class="headerlink" title="Three kinds of memory management"></a>Three kinds of memory management</h1><p>The first kind is called <strong>automatic</strong> memory management: the system allocates memory for a local variable when it executes the variable’s definition, and deallocates that memory automatically at the end of the block that contains the definition. Therefore, we should note that once a variable has been dealloated, any pointers to it are invalid. For example,</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// this function deliberately yields an invalid pointer</span></span><br><span class="line"><span class="comment">// it is intended as a negative example-don't do this!</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">invalid_pointer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">return</span> &amp;x;  <span class="comment">// instant disaster</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This function intends to return the address of local variable <strong>x</strong>. However, the return statement ends the execution of the block and hence deallocates the memory of <strong>x</strong>, resulting that <strong>&amp;x</strong> is invalid. To solve this problem, we can use another kine memory management, i.e. statically allocated.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This function is completely legitimate</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">pointer_to_static</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">return</span> &amp;x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>When a local object is specified as <strong>static</strong>, it is created only the first time when its definition is executed and won’t be destroied until meet the end of the program. Therefore, the function returns a valid pointer of object <strong>x</strong>.</p>
<p>The shortcoming of this kind memory management is that each call of such function obtains the same pointer. If we want to get a different pointer each time, we can choose an alternative memory management, the <strong>dynamic allocation</strong>. </p>
<p>If <strong>T</strong> is an object type, then <strong>new T</strong> is an expression that</p>
<ol>
<li>allocates an <strong>T</strong> type object </li>
<li>default-initializes the object</li>
<li>yields a pointer to this newly allocated object</li>
<li>the object exists since it is created till either the end of the program or the execution of <strong>delete p</strong>, where <strong>p</strong> is a copy of the pointer returned by the expression. </li>
</ol>
<p>For example,</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// allocate an unnamed object of type int, and initialize it to 42</span></span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">42</span>);</span><br></pre></td></tr></table></figure>
<p>We can change the value of the object by manipulating the <strong>pointer p</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// change the object to 43</span></span><br><span class="line">++*p;</span><br></pre></td></tr></table></figure>
<p>If we want to delete it, we do</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// after this execution, the occupied memory is freed and p becomes an invalid pointer</span></span><br><span class="line"><span class="keyword">delete</span> p;</span><br></pre></td></tr></table></figure>

<p>Now let’s revisit the problem we met above and write a function that can return different pointer each time</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">pointer_to_dynamic</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This function returns a brand new pointer each time. But do not forget to release the memory through <strong>delete p</strong>. </p>
<h2 id="Allocating-and-deallocating-an-array"><a href="#Allocating-and-deallocating-an-array" class="headerlink" title="Allocating and deallocating an array"></a>Allocating and deallocating an array</h2><p>By analogy, we can allocate an array that contains <strong>T</strong> type values. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T* p = <span class="keyword">new</span> T[n];</span><br></pre></td></tr></table></figure>
<p><strong>n</strong> is a non-negative integral value and <strong>new T[n]</strong> allocates an array of <strong>n</strong> objects of type <strong>T</strong>. There is also a returned <strong>pointer</strong> that points to the initial element of the array. Each object of the array is default-initialized. This means that if <strong>T</strong> is a built-in type, then the elements are undefined while if <strong>T</strong> is a class type, then the elements are initialized by the default constructor defined in that class type. </p>
<p>If <strong>n</strong> equals to 0, then the <strong>new</strong> return a valid <strong>off-the-end</strong> pointer as there is no element contained in the array. To deallocate the memory, we use <strong>delete[] p</strong>. Here is an example</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">T* p = <span class="keyword">new</span> T[n];</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;T&gt; <span class="title">v</span><span class="params">(p, p + n)</span></span>; <span class="comment">// copy elements in the array to vector</span></span><br><span class="line"><span class="keyword">delete</span>[] p;</span><br></pre></td></tr></table></figure>

<p>The <strong>new</strong> allocates an array and stay around until that the program terminates or executes the <strong>delete[]</strong>. Before deallocating the array, the system destroys each element in reverse order. Let’s look at a function</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">duplicate_share</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// allocate enough space; remember to add one for the null</span></span><br><span class="line">    <span class="keyword">size_t</span> length = <span class="built_in">strlen</span>(p) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span>* result = <span class="keyword">new</span> <span class="keyword">char</span>[length];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// copy into our newly allocated space and return pointer to first element</span></span><br><span class="line">    copy(p, p + length, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This function takes a pointer to char as an argument and returns a point to char. It actually copy all chars from one string literal into a new string literal. Firstly, it allocates memory for the new array of chars, then apply copy algorithm to copy each char in the original array into the newly created array. Noting that <strong>strlen</strong> gives the number of non-null characters contained in a string literal. However, when we allocate the memory for a new string literal, we need to add one position more for holding the null-character. As for the deallocation of dynamic allocation, we will discuss more in next chapter. </p>
<hr>
<h1 id="Test-examples"><a href="#Test-examples" class="headerlink" title="Test examples"></a>Test examples</h1><p>Now I test severl programs analysed above. The first program tests <strong>arguments to main</strong> and <strong>letter_grade</strong> function.</p>
<p><strong>Test_1.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;		// to get the declaration of cout, endl</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;		// to get the declaration of string</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;		// to get the declaration of size_t</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>; 	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;  <span class="keyword">using</span> <span class="built_in">std</span>::<span class="keyword">size_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// function declaration</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">letter_grade</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main function with non-empty parameter list</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// if there are arguments, write them</span></span><br><span class="line">    <span class="keyword">if</span>(argc &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// declare i outside the for because we need it after the loop</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// write all but the last entry and argv[i] is a char*</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; argc - <span class="number">1</span>; ++i)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; argv[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// write the last entry but not a space</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; argv[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"my letter grade is: "</span> &lt;&lt; letter_grade(<span class="number">75</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">letter_grade</span><span class="params">(<span class="keyword">double</span> grade)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// range posts for numberic grades</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">double</span> numbers[] = &#123;<span class="number">97</span>, <span class="number">94</span>, <span class="number">90</span>, <span class="number">87</span>, <span class="number">84</span>, <span class="number">80</span>, <span class="number">77</span>, <span class="number">74</span>, <span class="number">70</span>, <span class="number">60</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// name for the letter grades</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> letters[] = &#123;<span class="string">"A+"</span>, <span class="string">"A"</span>, <span class="string">"A-"</span>, <span class="string">"B+"</span>,</span><br><span class="line">                                            <span class="string">"B"</span>, <span class="string">"B-"</span>, <span class="string">"C+"</span>, <span class="string">"C"</span>, <span class="string">"C-"</span>, <span class="string">"D"</span>, <span class="string">"F"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// compute the number of grades given the size of the array</span></span><br><span class="line">    <span class="comment">// and the size of a single element</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> ngrades = <span class="keyword">sizeof</span>(numbers)/<span class="keyword">sizeof</span>(*numbers);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// given a numberic grade, find the associated letter grade</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; ngrades; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (grade &gt;= numbers[i])</span><br><span class="line">            <span class="keyword">return</span> letters[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"?\?\?"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Test Results</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Inputs</span><br><span class="line"></span><br><span class="line">command line arguments: please tell me the true</span><br><span class="line">numeric grade: 75</span><br><span class="line"></span><br><span class="line">Outputs</span><br><span class="line"></span><br><span class="line">please tell me the truth</span><br><span class="line">my letter grade is: C-</span><br></pre></td></tr></table></figure>

<p>The second program produces a copy of all files whose names are given as arguments to main. </p>
<p><strong>test_2.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;		// to get the declaration of cout, endl, cerr</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;		// to get the declaration string getline</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;		// to get the declaration of ifstream</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cerr</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::getline; <span class="keyword">using</span> <span class="built_in">std</span>::ifstream;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fail_count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// for each file in the input list</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; argc; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">ifstream <span class="title">in</span><span class="params">(argv[i])</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if it exits, write its contents, otherwise generate an error message</span></span><br><span class="line">        <span class="keyword">if</span>(in)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> s;</span><br><span class="line">            <span class="keyword">while</span>(getline(in, s))</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cerr</span> &lt;&lt; <span class="string">"cannot open file "</span> &lt;&lt; argv[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            ++fail_count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fail_count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>I firstly create a file named <strong>in</strong> and write following sequences into it</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">what are you going to do</span><br><span class="line">to be or not to be</span><br><span class="line">that is a question</span><br></pre></td></tr></table></figure>

<p>Then I set the commond line arguments as: please tell me the truth in<br>Once I click the run button, the program below gives following results</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cannot open file please</span><br><span class="line">cannot open file tell</span><br><span class="line">cannot open file me</span><br><span class="line">cannot open file the</span><br><span class="line">cannot open file truth</span><br><span class="line">what are you going to do</span><br><span class="line">to be or not to be</span><br><span class="line">that is a question</span><br></pre></td></tr></table></figure>

<p>The last program tests that we can use the <strong>duplicate_share</strong> function to produce a copy of a sequence of characters. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;	// to get the declaration of cout,</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;	// to get the declaration of strlen</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;	// to get the declaration of size_t</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;// to get the declaration of copy</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>; 	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">strlen</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="keyword">size_t</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::copy;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">duplicate_share</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// allocate enough space; remember to add one for the null</span></span><br><span class="line">    <span class="keyword">size_t</span> length = <span class="built_in">strlen</span>(p) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span>* result = <span class="keyword">new</span> <span class="keyword">char</span>[length];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// copy into our newly allocated space and return pointer to first element</span></span><br><span class="line">    copy(p, p + length, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// constructe an array</span></span><br><span class="line">	<span class="keyword">char</span> s[] = <span class="string">"computational"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get a copy</span></span><br><span class="line">	<span class="keyword">char</span>* s_copy = duplicate_share(s);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// verify the copy</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; s_copy &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The program works as we expected and gives results</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">computational</span><br></pre></td></tr></table></figure>

<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://quantein.com/2018/04/08/Accelerated-C-Solutions-to-Exercises-Chapter-9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liam">
      <meta itemprop="description" content="Stochastic Modelling Notes; Programming Notes">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Liam's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/08/Accelerated-C-Solutions-to-Exercises-Chapter-9/" class="post-title-link" itemprop="url">Accelerated C++ Solutions to Exercises(Chapter 9)</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-04-08 15:41:47" itemprop="dateCreated datePublished" datetime="2018-04-08T15:41:47+08:00">2018-04-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2018-04-09 23:21:39" itemprop="dateModified" datetime="2018-04-09T23:21:39+08:00">2018-04-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Programming/" itemprop="url" rel="index"><span itemprop="name">Programming</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span></span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>NaN:aN</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Exercise-9-0"><a href="#Exercise-9-0" class="headerlink" title="Exercise 9-0"></a>Exercise 9-0</h1><p>Compile, execute, and test the programs in this chapter.</p>
<h2 id="Solution-amp-Results"><a href="#Solution-amp-Results" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>Please find the solution and analysis in <a href="http://quanttour.com/06/04/2018/C-Defining-new-types/" target="_blank" rel="noopener">Defining new types</a>.</p>
<h1 id="Exercise-9-1"><a href="#Exercise-9-1" class="headerlink" title="Exercise 9-1"></a>Exercise 9-1</h1><p>Reimplement the Student_info class so that it calculates the final grade when reading the student’s record, and stores that grade in the object. Reimplement the grade function to use this precomputed value.</p>
<h2 id="Solution-amp-Results-1"><a href="#Solution-amp-Results-1" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>A similar program has been completed in <a href="http://quanttour.com/11/03/2018/Accelerated-C-Solutions-to-Exercises-Chapter-4-Part-2/" target="_blank" rel="noopener">exercise 4-6</a>. Now I’ll write a new grading program based on class type. The strategy can be logically divided into three parts:</p>
<ol>
<li>abstract data members</li>
<li>design interface and write member functions</li>
<li>access Control </li>
</ol>
<h3 id="data-members-and-constructors"><a href="#data-members-and-constructors" class="headerlink" title="data members and constructors"></a>data members and constructors</h3><p>The original program uses a class type that has four data members: <strong>name, midterm, final and homework</strong>. This exercise requires us to store the final grade in the class object, which implies that we need another data member <strong>grade</strong> representing the final grade. There seems no need to store <strong>midterm, fina and homework</strong> anymore due to that the final grade is computed when reading the student’s record. I didn’t remove them merely as theoretically these information should be kept for a student. Now, we have part of our new class type</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student_info</span>&#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> n;</span><br><span class="line">    <span class="keyword">double</span> midterm, <span class="keyword">final</span>, g;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; homework;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// to be filled by defining/declaring member functions </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>The first I considered was to define <strong>constructors</strong> when desigining an proper interface. The purpose is to allow us to initialize the class object through:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Student_info record;        <span class="comment">// create an empty object</span></span><br><span class="line"><span class="function">Student_info <span class="title">record</span><span class="params">(<span class="built_in">cin</span>)</span></span>;   <span class="comment">// create and initialize an object by reading from input stream</span></span><br></pre></td></tr></table></figure>
<p>The first one needs a default constructor that is responsible for initializing data members. Following code shows their declarations and definitions that are put outside the class. </p>
<p><strong>declaring constructors</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Student_info ();        <span class="comment">// construct an empty object </span></span><br><span class="line">Student_info (<span class="built_in">std</span>::istream &amp;); <span class="comment">// construct an object by reading from istream</span></span><br></pre></td></tr></table></figure>
<p><strong>defining constructors</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Student_info::Student_info(): midterm(<span class="number">0</span>), <span class="keyword">final</span>(<span class="number">0</span>), g(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">Student_info::Student_info (<span class="built_in">std</span>::istream &amp; in) &#123; <span class="built_in">read</span>(in); &#125;</span><br><span class="line">``` </span><br><span class="line">Nothing that all three **<span class="keyword">double</span>** type variables are value-initialized to <span class="number">0</span> <span class="keyword">while</span> **homework** is initialized by <span class="keyword">default</span> constructor of **<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;** type, leading to an empty **homework**.</span><br><span class="line"></span><br><span class="line">##<span class="meta"># other member functions and protection</span></span><br><span class="line">The next is to define a member function to <span class="built_in">read</span> data into the <span class="class"><span class="keyword">class</span> <span class="title">object</span>. <span class="title">The</span> <span class="title">declaration</span> <span class="title">is</span> <span class="title">as</span> <span class="title">same</span> <span class="title">as</span> <span class="title">the</span> <span class="title">previous</span> <span class="title">one</span>:</span></span><br><span class="line">```c++</span><br><span class="line"><span class="function"><span class="built_in">std</span>::istream &amp; <span class="title">read</span><span class="params">(<span class="built_in">std</span>::istream &amp;)</span></span>;</span><br></pre></td></tr></table></figure>
<p>When we define the <strong>read</strong> member, we should meet the requirement that computing the final grade in the process of reading. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream &amp; <span class="title">Student_info::read</span><span class="params">(istream &amp;is)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// reads and store the student's name, midterm and final exam grades</span></span><br><span class="line">    is &gt;&gt; n &gt;&gt; midterm &gt;&gt; <span class="keyword">final</span>;</span><br><span class="line">    <span class="keyword">if</span> (is)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// reads and store all homework grades</span></span><br><span class="line">        read_hw(is, homework);</span><br><span class="line">        g = !homework.empty() ? ::grade(midterm, <span class="keyword">final</span>, homework) : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Noting that I deal with the case of empty homework with an <strong>if</strong> statement which computes the final grade if the homwork is not empty and otherwise sets the final grade to 0. The purpose is to avoid the exception when reading data. Alternatively, I define extra two functions to check the validity of final grade and “catch” the state of the object. These two functions are defined inside the class</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">valid</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> !homework.empty(); &#125;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">state</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> valid() ? <span class="string">"valid"</span> : <span class="string">"invalid: student has done no homework"</span>; &#125;</span><br></pre></td></tr></table></figure>
<p>This allows users to seperate valid records and invalid records. </p>
<p>Finally, we define members to get the <strong>name</strong> and <strong>grade</strong> for the purpose that prevents users access data members directly. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> n; &#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> g; &#125;</span><br></pre></td></tr></table></figure>
<p>All member functions except <strong>read</strong> and <strong>constructors</strong> are not allowed to change data members by adding qualifier <strong>const</strong> after the parameter list. To seperate the data abstraction and interface, we control access using specifier <strong>public</strong> and <strong>private</strong>. </p>
<h3 id="Organize-files"><a href="#Organize-files" class="headerlink" title="Organize files"></a>Organize files</h3><p>Now let’s complete the header file <strong>Student_info.h</strong> and the corresponding source file.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_STUDENT_INFO</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_STUDENT_INFO</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student_info</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// constructors</span></span><br><span class="line">    Student_info ();</span><br><span class="line">    Student_info (<span class="built_in">std</span>::istream &amp;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// member functions to check state</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">valid</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> !homework.empty(); &#125;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">state</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> valid() ? <span class="string">"valid"</span> : <span class="string">"invalid: student has done no homework"</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// member functions read and functions to get name, grade and</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> n; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> g; &#125;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::istream &amp; <span class="title">read</span><span class="params">(<span class="built_in">std</span>::istream &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> n;</span><br><span class="line">    <span class="keyword">double</span> midterm, <span class="keyword">final</span>, g;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; homework;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// nonmember functions</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> Student_info &amp;, <span class="keyword">const</span> Student_info &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::istream &amp; <span class="title">read_hw</span><span class="params">(<span class="built_in">std</span>::istream &amp;, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>Student_info.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"grade.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>; 		<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::istream;		<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::domain_error;</span><br><span class="line"></span><br><span class="line"><span class="comment">// construct one by reading from input stream</span></span><br><span class="line">Student_info::Student_info(): midterm(<span class="number">0</span>), <span class="keyword">final</span>(<span class="number">0</span>), g(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">Student_info::Student_info (<span class="built_in">std</span>::istream &amp; in) &#123; <span class="built_in">read</span>(in); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// member function read</span></span><br><span class="line"><span class="function">istream &amp; <span class="title">Student_info::read</span><span class="params">(istream &amp;is)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// reads and store the student's name, midterm and final exam grades</span></span><br><span class="line">    is &gt;&gt; n &gt;&gt; midterm &gt;&gt; <span class="keyword">final</span>;</span><br><span class="line">    <span class="keyword">if</span> (is)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// reads and store all homework grades</span></span><br><span class="line">        read_hw(is, homework);</span><br><span class="line">        g = !homework.empty() ? ::grade(midterm, <span class="keyword">final</span>, homework) : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// nonmember function compare two strings</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> Student_info &amp;x, <span class="keyword">const</span> Student_info &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.name() &lt; y.name();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// nonmember function read data into a vector</span></span><br><span class="line"><span class="function">istream &amp; <span class="title">read_hw</span><span class="params">(istream &amp;in, <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;hw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// read homework grades</span></span><br><span class="line">    hw.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">    <span class="keyword">while</span>(in &gt;&gt; x)</span><br><span class="line">        hw.push_back(x);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clear the stream so that input will work for the next student</span></span><br><span class="line">    in.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Now we can write the main function.</p>
<p><strong>mainfunction.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;		// to get the declaration of max, sort</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;		// to get the declaration of setprecision</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;		// to get the declaration of cin, cout, endl</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;		// to get the declaration of domain_error</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;		// to get the declaration of string</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;		// to get the declaration of vector</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span>	<span class="comment">// to get the declaration of Student_info</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;					<span class="keyword">using</span> <span class="built_in">std</span>::setprecision;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;				<span class="keyword">using</span> <span class="built_in">std</span>::sort;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;				<span class="keyword">using</span> <span class="built_in">std</span>::streamsize;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::domain_error;		        <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">max</span>;					<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Student_info&gt; students;</span><br><span class="line">    Student_info record;</span><br><span class="line">    <span class="built_in">string</span>::size_type maxlen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read and store all the records, and find the length of the longest name</span></span><br><span class="line">    <span class="keyword">while</span>(record.<span class="built_in">read</span>(<span class="built_in">cin</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        maxlen = <span class="built_in">max</span>(maxlen, record.name().<span class="built_in">size</span>());</span><br><span class="line">        students.push_back(record);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// alphabetize the records</span></span><br><span class="line">    sort(students.<span class="built_in">begin</span>(), students.<span class="built_in">end</span>(), compare);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write each line of outpurs</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Student_info&gt;::const_iterator it = students.<span class="built_in">begin</span>();</span><br><span class="line">            it != students.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// write the name, blanks</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (*it).name() &lt;&lt; <span class="built_in">string</span>(maxlen + <span class="number">1</span> - (*it).name().<span class="built_in">size</span>(), <span class="string">' '</span>);</span><br><span class="line">        <span class="comment">// compute and write the final grade</span></span><br><span class="line">        <span class="keyword">double</span> final_grade = (*it).grade();</span><br><span class="line">        streamsize prec = <span class="built_in">cout</span>.precision();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; setprecision(<span class="number">3</span>) &lt;&lt; final_grade &lt;&lt; setprecision(prec);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!(*it).valid())</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="built_in">string</span>(<span class="number">4</span>,<span class="string">' '</span>) &lt;&lt; (*it).state() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>There is nothing new except that I deal with exception with member functions <strong>valid()</strong> and <strong>state()</strong> instead the <strong>try</strong> block. </p>
<p>Finally, I present the header file and source file that contains overloaded grade function and median function. </p>
<p><strong>grade.h</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_GRADE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_GRADE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">median</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>grade.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"grade.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::domain_error;  <span class="keyword">using</span> <span class="built_in">std</span>::istream;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;        <span class="keyword">using</span> <span class="built_in">std</span>::sort;</span><br><span class="line"></span><br><span class="line"><span class="comment">// grade function 1</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">double</span> midterm, <span class="keyword">double</span> <span class="keyword">final</span>, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;hw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hw.empty())</span><br><span class="line">        <span class="keyword">throw</span> domain_error(<span class="string">"student has done no homework"</span>);</span><br><span class="line">    <span class="keyword">return</span> grade(midterm, <span class="keyword">final</span>, median(hw));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// grade function 2</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">double</span> midterm, <span class="keyword">double</span> <span class="keyword">final</span>, <span class="keyword">double</span> homework)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.2</span>*midterm + <span class="number">0.4</span>*<span class="keyword">final</span> + <span class="number">0.4</span>*homework;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compute the median of vector&lt;double&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">median</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// check whether the vec is empty</span></span><br><span class="line">    <span class="keyword">if</span> (vec.<span class="built_in">begin</span>() == vec.<span class="built_in">end</span>())</span><br><span class="line">        <span class="keyword">throw</span> domain_error(<span class="string">"median of an empty vector"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sort the grades</span></span><br><span class="line">    sort(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// compute the median homework grade</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;::difference_type <span class="built_in">size</span> = vec.<span class="built_in">end</span>() - vec.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;::const_iterator mid = vec.<span class="built_in">begin</span>() + <span class="built_in">size</span>/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">size</span> % <span class="number">2</span> == <span class="number">0</span> ? (*mid + *(mid - <span class="number">1</span>))/<span class="number">2</span> : *mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Inputs</span><br><span class="line"></span><br><span class="line">Nqacg 32.4444 16.3838 43</span><br><span class="line">Kmgsk 89.2525 14.7374 32</span><br><span class="line">Awhof 73.7071 73.8485 </span><br><span class="line">Thyyp 92.7172 47.5556 </span><br><span class="line">Zvxxc 66.9091 69.6162 0</span><br><span class="line">Asezo 67.8182 32.6364 10</span><br><span class="line">Evawh 77.798 54.9596 13</span><br><span class="line">Qhwir 75.4242 93.5758 </span><br><span class="line">Nbcpz 71.6263 75.8182 47</span><br><span class="line">Dbevs 67.4949 75.3434 31</span><br><span class="line"></span><br><span class="line">Outputs</span><br><span class="line"></span><br><span class="line">Asezo 30.6</span><br><span class="line">Awhof 0    invalid: student has done no homework</span><br><span class="line">Dbevs 56</span><br><span class="line">Evawh 42.7</span><br><span class="line">Kmgsk 36.5</span><br><span class="line">Nbcpz 63.5</span><br><span class="line">Nqacg 30.2</span><br><span class="line">Qhwir 0    invalid: student has done no homework</span><br><span class="line">Thyyp 0    invalid: student has done no homework</span><br><span class="line">Zvxxc 41.2</span><br></pre></td></tr></table></figure>

<p>Users can rewrite the main function to generate a better formatted report according to their own preference, using member functions <strong>valid()</strong> and <strong>state()</strong>.</p>
<hr>
<h1 id="Exercise-9-2"><a href="#Exercise-9-2" class="headerlink" title="Exercise 9-2"></a>Exercise 9-2</h1><p>If we define the name function as a plain, nonconst member function, what other functions in our system must change and why?</p>
<h2 id="Solution-amp-Results-2"><a href="#Solution-amp-Results-2" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>If we define the <strong>name</strong> function as a nonconst member function, we need to change the <strong>compare</strong> function as well.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> Student_info &amp;x, <span class="keyword">const</span> Student_info &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.name() &lt; y.name();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>See from the <strong>compare</strong> function above, the arguments are passed by reference to <strong>const</strong> objects. In other words, the <strong>compare</strong> function treats <strong>Student_info</strong> object as <strong>const</strong>. If it calls non-const member functions (i.e. name()), there is no guarantee that it doesn’t modify the object, which is a potential conflict with its definition. THerefore, this is not allowed by the compiler. To correct it, we can remove the qualifer <strong>const</strong> to release its restriction on arguments as shown below.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(Student_info &amp;x, Student_info &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.name() &lt; y.name();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Exercise-9-3-9-4"><a href="#Exercise-9-3-9-4" class="headerlink" title="Exercise 9-3, 9-4"></a>Exercise 9-3, 9-4</h1><p>9-3: Our grade function was written to throw an exception if a user tried to calculate agrade for a Student_info object whose values had not yet been read. Users who care are expected to catch this exception. Write a program that triggers the exception but does not catch it. Write a program that catches the exception.</p>
<p>9-4: Rewrite your program from the previous exercise to use the valid function, thereby avoiding the exception altogether.</p>
<h2 id="Solution-amp-Results-3"><a href="#Solution-amp-Results-3" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>The key is to use member function <strong>valid()</strong> to avoid the exception. This exercise is simple and hence no further analysis. I only write the main function here and please find other files in <a href="http://quanttour.com/06/04/2018/C-Defining-new-types/" target="_blank" rel="noopener">Defining new types</a>.</p>
<p><strong>Trigger the exception</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::domain_error;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Student_info record;</span><br><span class="line">	record.grade();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>catch the exception</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::domain_error;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Student_info record;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">    record.grade();</span><br><span class="line">    &#125;<span class="keyword">catch</span>(domain_error e)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; e.what();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>avoid the exception</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::domain_error;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Student_info <span class="title">record</span> <span class="params">(<span class="built_in">cin</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(record.valid())</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; record.grade();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Exercise-9-5"><a href="#Exercise-9-5" class="headerlink" title="Exercise 9-5"></a>Exercise 9-5</h1><p>Write a class and associated functions to generate grades for students who take thecourse for pass/fail credit. Assume that only the midterm and final grades matter, and that astudent passes with an average exam score greater than 60. The report should list the students in alphabetical order, and indicate P or F as the grade.</p>
<h2 id="Solution-amp-Results-4"><a href="#Solution-amp-Results-4" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>My strategy is to define a new <strong>grade</strong> function:</p>
<p><strong>declaration</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">grade</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>definition</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">Student_info::grade</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (midterm + <span class="keyword">final</span>)/<span class="number">2</span> &gt; <span class="number">60</span> ? <span class="string">"P"</span> : <span class="string">"F"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>So, when calling this member, it gives the letter grade <strong>P</strong> or <strong>F</strong>. The revised class type is defined as follows</p>
<p><strong>Student_info.h</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_STUDENT_INFO</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_STUDENT_INFO</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student_info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student_info ();						<span class="comment">// default constructor</span></span><br><span class="line">    Student_info (<span class="built_in">std</span>::istream &amp;);				<span class="comment">// constructor with argument</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> n; &#125;			<span class="comment">// inline member function return name</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::istream &amp; <span class="title">read</span><span class="params">(<span class="built_in">std</span>::istream &amp;)</span></span>;			<span class="comment">// member function read in data</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">grade</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> n;</span><br><span class="line">    <span class="keyword">double</span> midterm, <span class="keyword">final</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::istream &amp; <span class="title">read_hw</span><span class="params">(<span class="built_in">std</span>::istream &amp;, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;)</span></span>; <span class="comment">// nonmember function read data into a vector</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> Student_info &amp;, <span class="keyword">const</span> Student_info &amp;)</span></span>;	   <span class="comment">// nonmember function compare two string</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">**Student_info.cpp**</span><br><span class="line">```c++</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>; 		<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::istream;</span><br><span class="line"></span><br><span class="line"><span class="comment">// construct an empty Student_info object</span></span><br><span class="line">Student_info::Student_info (): midterm(<span class="number">0</span>), <span class="keyword">final</span>(<span class="number">0</span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// construct one by reading from input stream</span></span><br><span class="line">Student_info::Student_info (<span class="built_in">std</span>::istream &amp; in) &#123; <span class="built_in">read</span>(in); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// member function read data from input stream</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::istream &amp; <span class="title">Student_info::read</span><span class="params">(<span class="built_in">std</span>::istream &amp;in)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// reads and store the student's name, midterm and final exam grades</span></span><br><span class="line">    in &gt;&gt; n &gt;&gt; midterm &gt;&gt; <span class="keyword">final</span>;</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// member function grade</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">Student_info::grade</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (midterm + <span class="keyword">final</span>)/<span class="number">2</span> &gt; <span class="number">60</span> ? <span class="string">"P"</span> : <span class="string">"F"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// nonmember function compare</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> Student_info &amp;x, <span class="keyword">const</span> Student_info &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.name() &lt; y.name();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Noting that there is no computations as previous version. What we need to do is merely to remove the needless code.</p>
<p>Finally, I present the test function followed by the test results</p>
<p><strong>mainfunction.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;		// to get the declaration of max, sort</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;		// to get the declaration of string</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;		// to get the declaration of vector</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span>	<span class="comment">// to get the declaration of Student_info</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;				<span class="keyword">using</span> <span class="built_in">std</span>::sort;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;				<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">max</span>;					<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Student_info&gt; students;</span><br><span class="line">    Student_info record;</span><br><span class="line">    <span class="built_in">string</span>::size_type maxlen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read and store all the records, and find the length of the longest name</span></span><br><span class="line">    <span class="keyword">while</span>(record.<span class="built_in">read</span>(<span class="built_in">cin</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        maxlen = <span class="built_in">max</span>(maxlen, record.name().<span class="built_in">size</span>());</span><br><span class="line">        students.push_back(record);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// alphabetize the records</span></span><br><span class="line">    sort(students.<span class="built_in">begin</span>(), students.<span class="built_in">end</span>(), compare);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write each line of outpurs</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Student_info&gt;::const_iterator it = students.<span class="built_in">begin</span>();</span><br><span class="line">            it != students.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// write the name, blanks</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (*it).name() &lt;&lt; <span class="built_in">string</span>(maxlen + <span class="number">1</span> - (*it).name().<span class="built_in">size</span>(), <span class="string">' '</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// compute and write the final grade</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (*it).grade() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Test</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Inputs</span><br><span class="line"></span><br><span class="line">Xdvdr 55.404 28.7778</span><br><span class="line">Qlyys 91.9192 60.0404</span><br><span class="line">Iutlc 12.9697 61.202</span><br><span class="line">Jygsc 58.2424 99.5657</span><br><span class="line">Wxilm 85.0606 57.2424</span><br><span class="line">Lshfy 34.8687 65.9697</span><br><span class="line">Ujruj 41.8182 89.6364</span><br><span class="line">Orbac 3.58586 56.8788</span><br><span class="line">Fyhub 99 65.2828</span><br><span class="line"></span><br><span class="line">Outputs</span><br><span class="line"></span><br><span class="line">Fyhub P</span><br><span class="line">Iutlc F</span><br><span class="line">Jygsc P</span><br><span class="line">Lshfy F</span><br><span class="line">Orbac F</span><br><span class="line">Qlyys P</span><br><span class="line">Qzaen P</span><br><span class="line">Ujruj P</span><br><span class="line">Wxilm P</span><br><span class="line">Xdvdr F</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Exercise-9-6"><a href="#Exercise-9-6" class="headerlink" title="Exercise 9-6"></a>Exercise 9-6</h1><p>Rewrite the grading program for the pass/fail students so that the report shows all the students who passed, followed by all the students who failed.</p>
<h2 id="Solution-amp-Results-5"><a href="#Solution-amp-Results-5" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>One possible solution is that using ths standard library algorithm <strong>stable_partition</strong> to rearrange the elements (i.e. student records) such that all passing grades preceds all failing grades. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stable_partition(students.<span class="built_in">begin</span>(), students.<span class="built_in">end</span>(), pgrade);</span><br></pre></td></tr></table></figure>
<p>The <strong>pgrade</strong> is defined as follows</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">fgrade</span><span class="params">(<span class="keyword">const</span> Student_info &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.grade() &lt; <span class="number">60</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">pgrade</span><span class="params">(<span class="keyword">const</span> Student_info &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !fgrade(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>These two function can be declared in the file <strong>Student_info.h</strong> as nonmember function( see <a href="http://quanttour.com/06/04/2018/C-Defining-new-types/" target="_blank" rel="noopener">Defining new types</a>). I’ll present the main function and a simple test in below part.</p>
<p><strong>mainfunction.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;		// to get the declaration of max, sort</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;			// to get the declaration of setprecision</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;			// to get the declaration of streamsize</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;		// to get the declaration of stable_partition</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;			// to get the declaration of string</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;			// to get the declaration of vector</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span>	<span class="comment">// to get the declaration of Student_info</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;				<span class="keyword">using</span> <span class="built_in">std</span>::setprecision;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;				<span class="keyword">using</span> <span class="built_in">std</span>::streamsize;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">max</span>;					<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::stable_partition;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Student_info&gt; students;</span><br><span class="line">    Student_info record;</span><br><span class="line">    <span class="built_in">string</span>::size_type maxlen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read and store all the records, and find the length of the longest name</span></span><br><span class="line">    <span class="keyword">while</span>(record.<span class="built_in">read</span>(<span class="built_in">cin</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        maxlen = <span class="built_in">max</span>(maxlen, record.name().<span class="built_in">size</span>());</span><br><span class="line">        students.push_back(record);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// students who passed followed by all student who failed</span></span><br><span class="line">    stable_partition(students.<span class="built_in">begin</span>(), students.<span class="built_in">end</span>(), pgrade);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write each line of outpurs</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Student_info&gt;::const_iterator it = students.<span class="built_in">begin</span>();</span><br><span class="line">            it != students.<span class="built_in">end</span>() ; ++it)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((*it).valid())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// write the name, blanks</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; (*it).name() &lt;&lt; <span class="built_in">string</span>(maxlen + <span class="number">1</span> - (*it).name().<span class="built_in">size</span>(), <span class="string">' '</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// compute and write the final grade</span></span><br><span class="line">            <span class="keyword">double</span> final_grade = (*it).grade();</span><br><span class="line">            streamsize prec = <span class="built_in">cout</span>.precision();</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; setprecision(<span class="number">3</span>) &lt;&lt; final_grade &lt;&lt; setprecision(prec) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Test</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">Inputs</span><br><span class="line"></span><br><span class="line">Nmlox 42.3434 61.0808 66</span><br><span class="line">Mljwc 39.2727 80.3636 62</span><br><span class="line">Omzml 78.9596 39.8283 42</span><br><span class="line">Buvdm 20.7273 26.8384 35</span><br><span class="line">Lczfw 14.6162 72.1717 75</span><br><span class="line">Bloic 50.2525 60.798 44</span><br><span class="line">Hewvl 59.4646 98.4141 73</span><br><span class="line">Nunsg 95.1414 95.9596 8</span><br><span class="line">Gkaqw 97.7071 85.6263 93</span><br><span class="line">Isohi 49.3434 21.9293 63</span><br><span class="line">Tduzm 92.1111 18.4343 31</span><br><span class="line">Koede 82.404 36.0101 75</span><br><span class="line">Igfab 57.6061 90.9899 15</span><br><span class="line">Ejtaa 93.0404 27.8586 28</span><br><span class="line">Iwhgb 97.6364 44.3333 4</span><br><span class="line">Frbhw 40.7677 68.4747 19</span><br><span class="line">Hsskh 9.44444 90.2121 25</span><br><span class="line">Yvyel 2 20.6566 67</span><br><span class="line">Ktnaa 95.596 19.8586 84</span><br><span class="line">Pdjjb 37.5455 68.303 57</span><br><span class="line"></span><br><span class="line">Outputs</span><br><span class="line"></span><br><span class="line">Mljwc 64.8</span><br><span class="line">Lczfw 61.8</span><br><span class="line">Hewvl 80.5</span><br><span class="line">Nunsg 60.6</span><br><span class="line">Gkaqw 91</span><br><span class="line">Koede 60.9</span><br><span class="line">Ktnaa 60.7</span><br><span class="line">Nmlox 59.3</span><br><span class="line">Omzml 48.5</span><br><span class="line">Buvdm 28.9</span><br><span class="line">Bloic 52</span><br><span class="line">Isohi 43.8</span><br><span class="line">Tduzm 38.2</span><br><span class="line">Igfab 53.9</span><br><span class="line">Ejtaa 41</span><br><span class="line">Iwhgb 38.9</span><br><span class="line">Frbhw 43.1</span><br><span class="line">Hsskh 48</span><br><span class="line">Yvyel 35.5</span><br><span class="line">Pdjjb 57.6</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Exercise-9-7"><a href="#Exercise-9-7" class="headerlink" title="Exercise 9-7"></a>Exercise 9-7</h1><p>The read_hw function §4.1.3/57 solves a general problem (reading a sequence ofvalues into a vector) even though its name suggests that it should be part of theimplementation of Student_info. Of course, we could change its name—but suppose,instead, that you wanted to integrate it with the rest of the Student_info code, in order to clarify that it was not intended for public access despite its apparent generality? How would you do so?</p>
<h2 id="Solution-amp-Results-6"><a href="#Solution-amp-Results-6" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>My solution is to add the <strong>read_hw</strong> as the member function. To control the access, I specify the member as <strong>private</strong>. Accordingly, the revised <strong>Student_info.h</strong> is</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_STUDENT_INFO</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_STUDENT_INFO</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student_info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student_info ();				    <span class="comment">// default constructor</span></span><br><span class="line">    Student_info (<span class="built_in">std</span>::istream &amp;);		    <span class="comment">// constructor with argument</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> n; &#125;	    <span class="comment">// inline member function return name</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">valid</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> !homework.empty(); &#125;<span class="comment">// inline member function check state</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::istream &amp; <span class="title">read</span><span class="params">(<span class="built_in">std</span>::istream &amp;)</span></span>;	    <span class="comment">// member function read in data</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">()</span> <span class="keyword">const</span></span>;			    <span class="comment">// member function calculate final grade</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> n;</span><br><span class="line">    <span class="keyword">double</span> midterm, <span class="keyword">final</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; homework;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// private member function read data into a vector</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::istream &amp; <span class="title">read_hw</span><span class="params">(<span class="built_in">std</span>::istream &amp;, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// nonmember function compare two string</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> Student_info &amp;, <span class="keyword">const</span> Student_info &amp;)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>Correspondingly, when we define the <strong>read_hw</strong> outside the class, we need to specify the name scope using <strong>Student_info::read_hw</strong>. The new read_hw is given below</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream &amp; <span class="title">Student_info::read_hw</span><span class="params">(istream &amp;in, <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;hw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (in)&#123;</span><br><span class="line">        <span class="comment">//get rid of previous contents</span></span><br><span class="line">        hw.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// read homework grades</span></span><br><span class="line">        <span class="keyword">double</span> x;</span><br><span class="line">        <span class="keyword">while</span>(in &gt;&gt; x)</span><br><span class="line">            hw.push_back(x);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// clear the stream so that input will work for the next student</span></span><br><span class="line">        in.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>All other files keep unchanged and can be found in <a href="http://quanttour.com/06/04/2018/C-Defining-new-types/" target="_blank" rel="noopener">Defining new types</a>.</p>
<hr>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>Koenig, A. and Moo, B.E., 2000. Accelerated C++.</p>
<p>Lippman, S.B., Lajoie, J. and Moo, B.E., 2013. C++ Primer, 5th edt.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://quantein.com/2018/04/06/C-Defining-new-types/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liam">
      <meta itemprop="description" content="Stochastic Modelling Notes; Programming Notes">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Liam's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/06/C-Defining-new-types/" class="post-title-link" itemprop="url">C++ - Defining new types</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-04-06 13:50:00" itemprop="dateCreated datePublished" datetime="2018-04-06T13:50:00+08:00">2018-04-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2018-04-09 16:34:38" itemprop="dateModified" datetime="2018-04-09T16:34:38+08:00">2018-04-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Programming/" itemprop="url" rel="index"><span itemprop="name">Programming</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span></span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>NaN:aN</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Rewrite-Student-info-in-class-type"><a href="#Rewrite-Student-info-in-class-type" class="headerlink" title="Rewrite Student_info in class type"></a>Rewrite Student_info in class type</h1><p>In chapter 4, we learned how to organize data with a single data structure:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student_info</span>&#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">double</span> midterm, <span class="keyword">final</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; homework;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>The type <strong>Stuent_info</strong> holds information including <strong>name, midterm, final exam grades and a bunch of homework grades</strong> for a student. It help us to easily access the information of one student. Then, we wrote several functions to compute final grades based on the objects of such type. However, our program that uses such data type has several limitations</p>
<ol>
<li><p>users of our program have to follow some conventions. If we want to use a newly created object of <strong>Student_info</strong>, we need to ensure that we have read data into it. If one want to check whether the object contains information, he can only look at the actual data members in it. This requires users knowing well about the iternal structure of such type that the object belongs to. In other words, if I am a user but not a programmer, I need to learn each details about how to implement such type in a program. </p>
</li>
<li><p>there is no data protection mechanism. Users might want to keep students’ information unchanged once read in. However, we don’t provide such mechanism in the original program. </p>
</li>
<li><p>There is no universal interface for users. Function such as <strong>read**</strong> is closely connected with a <strong>Student_info</strong> object as they can change the state of an object. We might like to put them into a single header file for providing convenience for other users. However, we don’t have such structure that provids a universal interface for users. </p>
</li>
</ol>
<p>Now we learn how to deal with these problems with a new data type-class. <strong>class</strong> type is a mechanism that combines related data values into a data structure. It is an abstract data type that similar to <strong>Student_info</strong>. But it also provides an interface that allows us to operate an object, e.g. an <strong>Student_info</strong>, while hiding all deatils of the object. </p>
<p>For example, we are familar with <strong>vector<double></strong> which is a class that provides a set of operations, such as <strong>push_back, erase</strong> for users. But we don’t know how exactly these functions are implemented. </p>
<h2 id="Member-function"><a href="#Member-function" class="headerlink" title="Member function"></a>Member function</h2><p>As analysed above, we may don’t need some details of the students’ information as well as how <strong>read</strong> function deal with these information. What users need to know is how to use the relevant functions. Therefore, we need to design such interface.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student_info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">double</span> midterm, <span class="keyword">final</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; homework;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::istream &amp; <span class="title">read</span><span class="params">(<span class="built_in">std</span>::istream &amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Let’s say we have such an <strong>Student_info</strong> object named <strong>record</strong>. It has four data members <strong>name, midterm, final and homework</strong>. In addition, there are two member functions named <strong>read and grade</strong> which let us to read a record from an input stream and calculate the final grade for the object. Now, though we didn’t define any such structure before, we can presume how to use it. By the analogy of other class such as <strong>vector<double></strong>, I can store information for one student by calling its member function <strong>read</strong>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">record.<span class="built_in">read</span>(<span class="built_in">cin</span>);</span><br></pre></td></tr></table></figure>
<p>Again, we can calculate the final grade for <strong>record</strong> by calling member function <strong>grade()</strong>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">record.grade();</span><br></pre></td></tr></table></figure>
<p>Member functions can be defined inside or outside the class definition. Member functions defined inside are implicitly <strong>inline</strong> to avoid function call overhead. Apparently, member functions above are declared only and defined outside of the class. Let’s look at the <strong>read</strong> function:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream &amp; <span class="title">Student_info::read</span><span class="params">(istream &amp;in)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    in &gt;&gt; name &gt;&gt; midterm &gt;&gt; <span class="keyword">final</span>;</span><br><span class="line">    read_hw(in, homework);</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Comparing with the original version:</p>
<ol>
<li>the name of the function is <strong>Student_info::read</strong> because it is declared inside of and as a member of <strong>Student_info</strong>. </li>
<li>we don’t need to pass the <strong>Student_info</strong> object as an argument to the function as the function is a member of <strong>Student_info</strong>. </li>
<li>the member function can access data members directly using <strong>name, midterm etc.</strong> instead of <strong>record.name, record.midterm etc.</strong>.</li>
</ol>
<p>Now let’s look at the <strong>grade</strong> member:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Student_info::grade</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>  ::grade(midterm, <span class="keyword">final</span>, homework);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>It is similar to the <strong>read</strong> member in terms of putting <strong>::</strong> in front of the name and accessing data members without any qualification. But there are two differences:</p>
<p>First, putting <strong>::</strong> in front of <strong>grade</strong> when call it means that the <strong>grade</strong> function is a version that is not a member of class <strong>Student_info</strong>. Second, we put a qualifier <strong>const</strong> after the parameter list. What’s that mean? Recalling the original version</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">const</span> Student_info &amp;)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>We pass <strong>Student_info</strong> object by reference to const to avoid changing the argument to pass. In the new version, we don’t need to pass the <strong>Student_info* object any more as the function itself is a member function. Therefore, we add the **const</strong> after the parameter list for the same purpose, that is, to avoid changing the state of data members of the <strong>Student_info</strong> object. Noting that, the class object may not be created with <strong>const</strong> but is referenced to <strong>const</strong> in a function. Then, the function treat the object as if it were <strong>const</strong>. </p>
<h2 id="Protection"><a href="#Protection" class="headerlink" title="Protection"></a>Protection</h2><p>Though we provide interface for our class, users still can access data members directly and might meddle the implementation unintentionally. Therefore it is probably sensible to restrict users’ rights such that they can only access data members  through member functions. The idea behind this process (i.e. data hiding) is called <strong>encapsulation</strong>. C++ supports <strong>encapsulation</strong> with two <strong>access specifiers</strong>(aka. protection lables): </p>
<ol>
<li><strong>public specifier</strong>. Members defined after a keyword <strong>public</strong> are accessible to all parts of the program. This is typically used to specify members that define the interface to the class. </li>
<li><strong>private specifier</strong>. Members defined after a keyword <strong>private</strong> are accessible to the member functions of the class only. This is typically used to specify members that involves the implementation. </li>
</ol>
<p>Therefore, we can change our class as follows:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student_info</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// interface goes here</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::istream &amp; <span class="title">read</span><span class="params">(<span class="built_in">std</span>::istream &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// implementation goes here</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">double</span> midterm, <span class="keyword">final</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; homework;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>As explained above, We have specified member functions as public and data memmers as private. It has been noted that we use keyword <strong>class</strong> instead <strong>struct</strong> to define the <strong>class</strong> type. Both two keywords are ok for defining a <strong>class</strong> type. The only difference is the default access level. A class may define members before its first protection lable. if we use <strong>class</strong>, those members are default <strong>private</strong> while if we use <strong>struct</strong>, those members are default <strong>public</strong>. Accordingly, the class defined above is equivalent to</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student_info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">double</span> midterm, <span class="keyword">final</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; homework;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::istream &amp; <span class="title">read</span><span class="params">(<span class="built_in">std</span>::istream &amp;)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>In general, if we don’t intend to restrict data access, we use <strong>struct</strong>. But if we intend to have private members, we use <strong>class</strong>.</p>
<h2 id="Accessor-functions"><a href="#Accessor-functions" class="headerlink" title="Accessor functions"></a>Accessor functions</h2><p>Now we have successfully hidden data memebers but the problem next is that We fail to access <strong>name</strong> as well. We can set member <strong>name</strong> to <strong>public</strong>, however, what we really need is only the <strong>read access</strong> rather than <strong>write access</strong>. Alternatively, we can write another member function that returns the <strong>name</strong> but is not allowed to rewrite the <strong>name</strong> object.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student_info</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// interface goes here</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::istream &amp; <span class="title">read</span><span class="params">(<span class="built_in">std</span>::istream &amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> n; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// implementation goes here</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> n;</span><br><span class="line">    <span class="keyword">double</span> midterm, <span class="keyword">final</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; homework;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>As mentioned above, member functions defined inside are implicitly <strong>inline</strong> to avoid function call overhead. In this class, we define member <strong>name</strong> inside the class to imply compiler that this member function should be expanded inline at anywhere it is called. </p>
<p>Functions such as <strong>name</strong> are often called <strong>accessor functions</strong>. It seems that such function breaks the encapsulation that we were trying to achieve. Therefore, such function is privided only when <strong>accessor</strong>s are part of the abtract interface of the class. In this case, the abtraction is that of a student and a corresponding final grade. Obviously, <strong>name</strong> is part of the abstract interface. </p>
<p>Accordingly, the <strong>compare</strong> function changes to:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> Student_info &amp; x, Student_info &amp; y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.name() &lt; y.name();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Testing-for-empty"><a href="#Testing-for-empty" class="headerlink" title="Testing for empty"></a>Testing for empty</h2><p>There is another problem we may concern when using such <strong>class</strong> object. For example, if we call the member <strong>grade</strong> without calling <strong>read</strong> first, we would get an <strong>exception</strong> due to <strong>homework</strong> is empty. A traditional solution is to catch the exception and let users know what leads to the exception. But again, this may require users knowing about the iternal structure of the class object. Alternatively, we can provide a public member function named <strong>valid</strong>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">class <span class="title">Student_info</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">valid</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> !homework.empty(); &#125;</span><br><span class="line">    <span class="comment">// as before</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This member function tells the state of the object: if <strong>valid</strong> function returns true, it indicates that the object contains valid data, i.e. at least one homework grade; if <strong>valid</strong> returns false, it indicates the object is invalid for computing the final grades as there is no any homework grade. Users can check the state of the class object before the <strong>grade</strong> function call, thereby avoiding a potential exception. </p>
<h2 id="Constructors"><a href="#Constructors" class="headerlink" title="Constructors"></a>Constructors</h2><p>It is known that when we create an object, it should be default initialized or assigned with an appropriate value. For example, when we define a <strong>string</strong> without an initializer, we get an empty <strong>string</strong>. So, what happens when we create a class object?</p>
<p>The <strong>class</strong> type supports defining how to initialize an class onject through <strong>constructors</strong> which are special member functions. There is no way to explicitly call <strong>constructors</strong>. Instead creating an class object automatically calls an appropriate constructor as a side effect. </p>
<p><em>If we do not define any constructors, the compiler will synthesize one for us. The synthesized constructor initializes the data member to a value depending on how the object is created. Specifically, if a class object is created as a local variable, then the data members will be default initialized. If a class object is used to initialize a container element, either as a side effect of adding new element to a <strong>map</strong>, or as the elements of container defined to have a given size, then the member will be value-initialized determined by a class type itself.</em> </p>
<p>The rules below summarize how a class type initializes its data members:</p>
<ol>
<li><p><em>if an object is of a class type that defines one or more constructors, then the appropriate constructor determines how data memebers will be initialized.</em></p>
</li>
<li><p><em>if an object is of built-in type, then value-initializing it sets it to zero, and default-initializing it gives it an undefined value.</em> </p>
</li>
<li><p><em>In the case that an object is of a class type that doesn’t define any constructor, value- or default-initializing the object value, or default-initializes each of its data members. This process will be recursive if any data member is of a class type with its own constructor</em>.</p>
</li>
</ol>
<p>In our example, the <strong>Student_info</strong> class type is the case 3. If we define a local variable that is of such class type, <strong>n and homework</strong> are default-initialized and concequently yields an empty string and vector respectively. However, default-initializing <strong>midterm and final</strong> leads to undefined values. To ensure all data members have sensible values at all times, we should define constructors for our class type. Let’s look at two constructors:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student_info</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student_info ();     <span class="comment">// construct an empty Student_info object</span></span><br><span class="line">    Student_info (<span class="built_in">std</span>::istream);  <span class="comment">// construct one by reading from input stream</span></span><br><span class="line">    <span class="comment">// as before</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We add two public members functions that are both named <strong>Student_info</strong> , that is, the name of the class type itself, and both have no <strong>return type</strong>. These two features distinguish <strong>constructors</strong> from other member functions. It can also be observed that constructors has two different versions, the first constructor of which takes no argument while the second takes input stream object as argument. Corresponding, we can write our code like</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Student_info s;          <span class="comment">// an empty Student_info</span></span><br><span class="line"><span class="function">Student_info <span class="title">s2</span><span class="params">(<span class="built_in">cin</span>)</span></span>;    <span class="comment">// initialize s2 by reading from cin</span></span><br></pre></td></tr></table></figure>

<h3 id="The-default-constructor"><a href="#The-default-constructor" class="headerlink" title="The default constructor"></a>The default constructor</h3><p>The first constructor</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student_info s;</span><br></pre></td></tr></table></figure>
<p>is known as <strong>default constructor</strong> which takes no arguments and ensures that all data members are normally initialized through:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student_info::Student_info(): midterm(<span class="number">0</span>), <span class="keyword">final</span>(<span class="number">0</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>This definition uses new syntax: the contents between <strong>:</strong> and <strong>{</strong> are a sequence of initializers which initializes each given data member with the value that appears inside of the corresponding parenthese. This default constructor doesn’t explictly initialize <strong>n</strong> and <strong>homework</strong> members as they are initialized implicitly. In specific, <strong>n</strong> is initialized by the <strong>string</strong> default constructor and <strong>homework</strong> is initialized by the <strong>vector</strong> default constructor. </p>
<p>When we create a new class object, the implementation proceeds following steps:</p>
<ol>
<li>allocates memory to hold the object</li>
<li>initializes the object as the constructor defines</li>
<li>executes the constructor body</li>
</ol>
<p>The implementation initializes every data member of every object even if some members are not explicitly initialized with the constructor initializer list. </p>
<h3 id="Constructors-with-arguments"><a href="#Constructors-with-arguments" class="headerlink" title="Constructors with arguments"></a>Constructors with arguments</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student_info::Student_info(istream &amp;is) &#123; <span class="built_in">read</span>(is); &#125;</span><br></pre></td></tr></table></figure>
<p>There is no initializer provided for each data member and hence <strong>n</strong> and <strong>homework</strong> will be initialized by the default constructors for <strong>string</strong> and <strong>vector</strong>, respectively. But <strong>midterm</strong> and <strong>fianl</strong> are undefined if the object is default-initialized otherwise are value-initialized to 0. Nevertheless, the function body gives new values to these data members by calling <strong>read</strong> function. </p>
<h2 id="Class-based-grading-program"><a href="#Class-based-grading-program" class="headerlink" title="Class-based grading program"></a>Class-based grading program</h2><p>Now we have successfully defined a class-based <strong>Student_info</strong> type. Apparently, using the class is different from using the original structure. Therefore, the last step is to rewrite the main function and organsize files.</p>
<p><strong>mainfunction.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;		// to get the declaration of max, sort</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;		// to get the declaration of setprecision</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;		// to get the declaration of streamsize</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;		// to get the declatation of domain_error</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;		// to get the declaration of string</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;		// to get the declaration of vector</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span>	<span class="comment">// to get the declaration of Student_info</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"grade.h"</span>		<span class="comment">// to get the declatation of grading functions</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;					<span class="keyword">using</span> <span class="built_in">std</span>::setprecision;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;				<span class="keyword">using</span> <span class="built_in">std</span>::sort;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;				<span class="keyword">using</span> <span class="built_in">std</span>::streamsize;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::domain_error;		        <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">max</span>;					<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Student_info&gt; students;</span><br><span class="line">    Student_info record;</span><br><span class="line">    <span class="built_in">string</span>::size_type maxlen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read and store all the records, and find the length of the longest name</span></span><br><span class="line">    <span class="keyword">while</span>(record.<span class="built_in">read</span>(<span class="built_in">cin</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        maxlen = <span class="built_in">max</span>(maxlen, record.name().<span class="built_in">size</span>());</span><br><span class="line">        students.push_back(record);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// alphabetize the records</span></span><br><span class="line">    sort(students.<span class="built_in">begin</span>(), students.<span class="built_in">end</span>(), compare);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write each line of outpurs</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Student_info&gt;::const_iterator it = students.<span class="built_in">begin</span>();</span><br><span class="line">    	it != students.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// write the name, blanks</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (*it).name() &lt;&lt; <span class="built_in">string</span>(maxlen + <span class="number">1</span> - (*it).name().<span class="built_in">size</span>(), <span class="string">' '</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// compute and write the final grade</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">double</span> final_grade = (*it).grade();</span><br><span class="line">            streamsize prec = <span class="built_in">cout</span>.precision();</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; setprecision(<span class="number">3</span>) &lt;&lt; final_grade &lt;&lt; setprecision(prec);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(domain_error e)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; e.what();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Student_info.h</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_STUDENT_INFO</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_STUDENT_INFO</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student_info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student_info ();						<span class="comment">// default constructor</span></span><br><span class="line">    Student_info (<span class="built_in">std</span>::istream &amp;);				<span class="comment">// constructor with argument</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> n; &#125;		        <span class="comment">// inline member function return name</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">valid</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> !homework.empty(); &#125;            <span class="comment">// inline member function check state</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::istream &amp; <span class="title">read</span><span class="params">(<span class="built_in">std</span>::istream &amp;)</span></span>;			<span class="comment">// member function read in data</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">()</span> <span class="keyword">const</span></span>;					<span class="comment">// member function calculate final grade</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> n;</span><br><span class="line">    <span class="keyword">double</span> midterm, <span class="keyword">final</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; homework;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::istream &amp; <span class="title">read_hw</span><span class="params">(<span class="built_in">std</span>::istream &amp;, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;)</span></span>; <span class="comment">// nonmember function read data into a vector</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> Student_info &amp;, <span class="keyword">const</span> Student_info &amp;)</span></span>;      <span class="comment">// nonmember function compare two string</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>Student_info.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"grade.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>; <span class="keyword">using</span> <span class="built_in">std</span>::istream;</span><br><span class="line"></span><br><span class="line"><span class="comment">// construct an empty Student_info object</span></span><br><span class="line">Student_info::Student_info (): midterm(<span class="number">0</span>), <span class="keyword">final</span>(<span class="number">0</span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// construct one by reading from input stream</span></span><br><span class="line">Student_info::Student_info (<span class="built_in">std</span>::istream &amp; in) &#123; <span class="built_in">read</span>(in); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// member function read data from input stream</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::istream &amp; <span class="title">Student_info::read</span><span class="params">(<span class="built_in">std</span>::istream &amp;in)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// reads and store the student's name, midterm and final exam grades</span></span><br><span class="line">    in &gt;&gt; n &gt;&gt; midterm &gt;&gt; <span class="keyword">final</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reads and store all homework grades</span></span><br><span class="line">    read_hw(in, homework);</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// member function grade</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Student_info::grade</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ::grade(midterm, <span class="keyword">final</span>, homework);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// nonmember function compare</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> Student_info &amp;x, <span class="keyword">const</span> Student_info &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.name() &lt; y.name();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// nonmember function read_hw</span></span><br><span class="line"><span class="function">istream &amp; <span class="title">read_hw</span><span class="params">(istream &amp;in, <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;hw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (in)&#123;</span><br><span class="line">        <span class="comment">//get rid of previous contents</span></span><br><span class="line">        hw.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// read homework grades</span></span><br><span class="line">        <span class="keyword">double</span> x;</span><br><span class="line">        <span class="keyword">while</span>(in &gt;&gt; x)</span><br><span class="line">            hw.push_back(x);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// clear the stream so that input will work for the next student</span></span><br><span class="line">        in.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>grade.h</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_GRADE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_GRADE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">median</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>grade.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"grade.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::domain_error;  <span class="keyword">using</span> <span class="built_in">std</span>::istream;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;        <span class="keyword">using</span> <span class="built_in">std</span>::sort;</span><br><span class="line"></span><br><span class="line"><span class="comment">// grade function 1</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">double</span> midterm, <span class="keyword">double</span> <span class="keyword">final</span>, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;hw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hw.empty())</span><br><span class="line">        <span class="keyword">throw</span> domain_error(<span class="string">"student has done no homework"</span>);</span><br><span class="line">    <span class="keyword">return</span> grade(midterm, <span class="keyword">final</span>, median(hw));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// grade function 2</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">double</span> midterm, <span class="keyword">double</span> <span class="keyword">final</span>, <span class="keyword">double</span> homework)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.2</span>*midterm + <span class="number">0.4</span>*<span class="keyword">final</span> + <span class="number">0.4</span>*homework;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compute the median of vector&lt;double&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">median</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// check whether the vec is empty</span></span><br><span class="line">    <span class="keyword">if</span> (vec.<span class="built_in">begin</span>() == vec.<span class="built_in">end</span>())</span><br><span class="line">        <span class="keyword">throw</span> domain_error(<span class="string">"median of an empty vector"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sort the grades</span></span><br><span class="line">    sort(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// compute the median homework grade</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;::difference_type <span class="built_in">size</span> = vec.<span class="built_in">end</span>() - vec.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;::const_iterator mid = vec.<span class="built_in">begin</span>() + <span class="built_in">size</span>/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">size</span> % <span class="number">2</span> == <span class="number">0</span> ? (*mid + *(mid - <span class="number">1</span>))/<span class="number">2</span> : *mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Inputs</span><br><span class="line"></span><br><span class="line">Robin 90 87 79 88 81 73 45</span><br><span class="line">Brendan 70 69 88 100 91 75 66</span><br><span class="line">Arsenii 99 87 89 88 74 90 70</span><br><span class="line">Liam 83 66 100 76 87 91 78</span><br><span class="line"></span><br><span class="line">Outputs</span><br><span class="line"></span><br><span class="line">Arsenii 89.8</span><br><span class="line">Brendan 76.8</span><br><span class="line">Liam    77.8</span><br><span class="line">Robin   84.4</span><br></pre></td></tr></table></figure>

<p>The program works as same as the original program and delivers same results. </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://quantein.com/2018/04/04/Accelerated-C-Solutions-to-Exercises-Chapter-8-Part-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liam">
      <meta itemprop="description" content="Stochastic Modelling Notes; Programming Notes">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Liam's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/04/Accelerated-C-Solutions-to-Exercises-Chapter-8-Part-2/" class="post-title-link" itemprop="url">Accelerated C++ Solutions to Exercises(Chapter 8 Part 2)</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-04-04 19:46:44" itemprop="dateCreated datePublished" datetime="2018-04-04T19:46:44+08:00">2018-04-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2018-04-05 14:51:34" itemprop="dateModified" datetime="2018-04-05T14:51:34+08:00">2018-04-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Programming/" itemprop="url" rel="index"><span itemprop="name">Programming</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span></span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>NaN:aN</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Exercise-8-3"><a href="#Exercise-8-3" class="headerlink" title="Exercise 8-3"></a>Exercise 8-3</h1><p>As we learned in §4.1.4/58, it can be expensive to return (or pass) a container by value. Yet the median function that we wrote in §8.1.1/140 passes the vector by value. Could we rewrite the median function to operate on iterators instead of passing the vector? If we did so, what would you expect the performance impact to be?</p>
<h2 id="Solution-amp-Results"><a href="#Solution-amp-Results" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>Yes, we can rewrite the median function without passing the vector. See the median funtion template below</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// median function template</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">In</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">In</span>:</span>:<span class="function">value_type <span class="title">median</span><span class="params">(In <span class="built_in">begin</span>, In <span class="built_in">end</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">begin</span> == <span class="built_in">end</span>)</span><br><span class="line">        <span class="keyword">throw</span> domain_error(<span class="string">"median of an empty vector"</span>);</span><br><span class="line"></span><br><span class="line">    sort(<span class="built_in">begin</span>, <span class="built_in">end</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typename</span> In::difference_type <span class="built_in">size</span> = <span class="built_in">end</span> - <span class="built_in">begin</span>;</span><br><span class="line">    In mid = <span class="built_in">begin</span> + <span class="built_in">size</span>/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">size</span> % <span class="number">2</span> == <span class="number">0</span> ? (*mid + *(mid - <span class="number">1</span>))/<span class="number">2</span> : *mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The type parameter of the function template is <strong>In</strong> which will be infered from two arguments, i.e. two iterators that denote the range of a sequence. In addition, The <strong>Iterator::value_type</strong> gives the type of the element the iterator can point to. Therefore, we can set the return type using</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typename In::value_type</span><br></pre></td></tr></table></figure>
<p>If the container is <strong>vector<double></strong>, this expression is equivalent to</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;double&gt;::iterator::value_type</span><br></pre></td></tr></table></figure>
<p>In the original version, all computations are based on values of type <strong>size_type</strong>. But now we don’t have such information anymore. Instead we can do computations with iterators. Firstly, we checks whether the container is empty using <strong>begin == end</strong>. The <strong>sort</strong> function is applied as same as that in the original version. Then we get the “size” of the container using <strong>end - begin</strong>, which gives the distance between the first element and one past the last elements. The result of such computation has type <strong>difference_type</strong> which is in fact a signed integer value. </p>
<p>Once we have the “size”, we can get the position of the mid point. Finally we can compute the median by accessing elements via dereference operation on iterators. One might wonder that why we get the position of the mid point using <strong>begin + size/2</strong> rather than <strong>(begin + end)/2</strong>? This is because iterators doesn’t support additive operation between two iterators, but they (random access iterators) do support additive operation between an iterator and an integer value. </p>
<p>Now let’s perform following test and check what happens:</p>
<p><strong>test program</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;	// to get the declaration of cout, endl</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;	// to get the declaration of vector</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;	// to get the declaration of domain_error</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;	// to get the declaration of sort</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::domain_error;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::sort;</span><br><span class="line"></span><br><span class="line"><span class="comment">// print function template</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">print</span>(<span class="title">T</span> &amp;<span class="title">contianer</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *(contianer.<span class="built_in">begin</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">typename</span> T::const_iterator i = contianer.<span class="built_in">begin</span>() + <span class="number">1</span>; i != contianer.<span class="built_in">end</span>(); ++i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; *i;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// median function template</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">In</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">In</span>:</span>:<span class="function">value_type <span class="title">median</span><span class="params">(In <span class="built_in">begin</span>, In <span class="built_in">end</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">begin</span> == <span class="built_in">end</span>)</span><br><span class="line">        <span class="keyword">throw</span> domain_error(<span class="string">"median of an empty vector"</span>);</span><br><span class="line"></span><br><span class="line">    sort(<span class="built_in">begin</span>, <span class="built_in">end</span>);</span><br><span class="line">    <span class="keyword">typename</span> In::difference_type <span class="built_in">size</span> = <span class="built_in">end</span> - <span class="built_in">begin</span>;</span><br><span class="line">    In mid = <span class="built_in">begin</span> + <span class="built_in">size</span>/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">size</span> % <span class="number">2</span> == <span class="number">0</span> ? (*mid + *(mid - <span class="number">1</span>))/<span class="number">2</span> : *mid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// print a sequence</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; vec&#123;<span class="number">9</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Original sequence: "</span>;</span><br><span class="line">    <span class="built_in">print</span>(vec);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get the median of the original sequence</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The median value is: "</span> &lt;&lt; median(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>()) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// print the new sequence</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Now the sequence becomes: "</span>;</span><br><span class="line">    <span class="built_in">print</span>(vec);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>results</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Original sequence: 9 6 8 3 5 7 1 2</span><br><span class="line">The median value is: 5.5</span><br><span class="line">Now the sequence becomes: 1 2 3 5 6 7 8 9</span><br></pre></td></tr></table></figure>
<p>The results show that we successfully compute the median value but change the original sequence due to operate on the original container directly. This is the cost that calling by reference instead of calling by value. </p>
<h1 id="Exercise-8-4"><a href="#Exercise-8-4" class="headerlink" title="Exercise 8-4"></a>Exercise 8-4</h1><p>Implement the swap function that we used in §8.2.5/148. Why did we call swap rather than exchange the values of *beg and *end directly? Hint: Try it and see.</p>
<h2 id="Solution-amp-Results-1"><a href="#Solution-amp-Results-1" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swap(*<span class="built_in">begin</span>++, *<span class="built_in">end</span>);</span><br></pre></td></tr></table></figure>
<p>To swap two elements, generally we can write </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">T temp &#x3D; *begin;</span><br><span class="line">*begin &#x3D; *end;</span><br><span class="line">*end &#x3D; x;</span><br><span class="line">++begin;</span><br></pre></td></tr></table></figure>
<p>where <strong>T</strong> is the type of the elements <strong>begin</strong> refers to.<br>Clearly, the key to solution is how to determine <strong>T</strong>. One way is to deduce the type from the varaible automatically using <strong>auto</strong> (or decltype) specifier. Another way is to use <strong>value_type</strong> to get the type of the element the iterator can point to. I tried both two methods and the test program is shown below</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;		// to get the declaration of cout, endl</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;	        // to get the declaration of swap</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;		// to get the declaration of vector</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line"></span><br><span class="line"><span class="comment">// print function template</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">print</span>(<span class="title">T</span> &amp;<span class="title">t</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">typename</span> T::const_iterator i = t.<span class="built_in">begin</span>(); i != t.<span class="built_in">end</span>(); ++i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// original reverse function template</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Bi</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">reverse_ori</span>(<span class="title">Bi</span> <span class="title">begin</span>, <span class="title">Bi</span> <span class="title">end</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">begin</span> != <span class="built_in">end</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        --<span class="built_in">end</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">begin</span> != <span class="built_in">end</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            swap(*<span class="built_in">begin</span>++, *<span class="built_in">end</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// revised reverse function version 1: using auto</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Bi</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">reverse_v1</span>(<span class="title">Bi</span> <span class="title">begin</span>, <span class="title">Bi</span> <span class="title">end</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">begin</span> != <span class="built_in">end</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        --<span class="built_in">end</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">begin</span> != <span class="built_in">end</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> temp = *<span class="built_in">begin</span>;</span><br><span class="line">            *<span class="built_in">begin</span> = *<span class="built_in">end</span>;</span><br><span class="line">            *<span class="built_in">end</span> = temp;</span><br><span class="line">            ++<span class="built_in">begin</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// revised reverse function version 2: using value_type</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Bi</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">reverse_v2</span>(<span class="title">Bi</span> <span class="title">begin</span>, <span class="title">Bi</span> <span class="title">end</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Bi::value_type valueType;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">begin</span> != <span class="built_in">end</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        --<span class="built_in">end</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">begin</span> != <span class="built_in">end</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            valueType temp = *<span class="built_in">begin</span>;</span><br><span class="line">            *<span class="built_in">begin</span> = *<span class="built_in">end</span>;</span><br><span class="line">            *<span class="built_in">end</span> = temp;</span><br><span class="line">            ++<span class="built_in">begin</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reverse</span></span><br><span class="line">    reverse_ori(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">print</span>(vec);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reverse again</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    reverse_v1(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">print</span>(vec);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reverse again</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    reverse_v2(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">print</span>(vec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This program gives following outputs</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">9</span><br><span class="line">8</span><br><span class="line">7</span><br><span class="line">6</span><br><span class="line">5</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line"></span><br><span class="line">10</span><br><span class="line">9</span><br><span class="line">8</span><br><span class="line">7</span><br><span class="line">6</span><br><span class="line">5</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>We have seen that both three method works fine, but why we use <strong>swap</strong>? The major limitation of other two methods is that they both copies objects to and from a variable, which may be not allowed for some highlevel objects. Also, it is not inefficient to do if we can avoid performing copies. The sandard <strong>swap</strong> algorithm is also an template and hence can determine the elements type automatically. As far as I know, it doesn’t rely on such <strong>temp</strong> variable as other two methods. I’ll give more explanations about <strong>swap</strong> once I know how exactly it works. </p>
<h1 id="Exercise-8-5"><a href="#Exercise-8-5" class="headerlink" title="Exercise 8-5"></a>Exercise 8-5</h1><p>Reimplement the gen_sentence and xref functions from Chapter 7 to use output iterators rather than writing their output directly to a vector<string> . Test these new versions by writing programs that attach the output iterator directly to the standard output,and by storing the results in a list<string> and a vector<string>.</p>
<h2 id="Solution-amp-Results-2"><a href="#Solution-amp-Results-2" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>To be updated. </p>
<h1 id="Exercise-8-6"><a href="#Exercise-8-6" class="headerlink" title="Exercise 8-6"></a>Exercise 8-6</h1><p>Suppose that m has type map&lt;int, string&gt; , and that we encounter a call to copy(m.begin(), m.end(), back_inserter(x)). What can we say about the type of x ? What if the call were copy(x.begin(), x.end(), back_inserter(m)) instead?</p>
<h2 id="Solution-amp-Results-3"><a href="#Solution-amp-Results-3" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy(m.<span class="built_in">begin</span>(), m.<span class="built_in">end</span>(), back_inserter(x));</span><br></pre></td></tr></table></figure>
<p>This statement copy all elements of <strong>m</strong> into the destination sequence <strong>x</strong> via <strong>back_inserter</strong>. It is known that <strong>x</strong> should support <strong>push_back</strong> member function. In addition, the elements contained in <strong>m</strong> have type <strong>pair&lt;int, string&gt;</strong>. Therefore, <strong>x</strong> should be a container that has type <strong>c&lt;pair&lt;int, string&gt;&gt;</strong>. Standard contaniers that meet the first condition include <strong>vector, list, deque, string</strong>. But <strong>string</strong> can only store string literals. In summary, I presume that <strong>x</strong> can be</p>
<ol>
<li>vector&lt;pair&lt;int, string&gt;&gt;</li>
<li>list&lt;pair&lt;int, string&gt;&gt;</li>
<li>deque&lt;pair&lt;int, string&gt;&gt;</li>
</ol>
<p>To verify my expectation, I write a test program shown as below:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;		// to get the declaration of cout, endl</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;		// to get the declaration of vector</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;		// to get the declaration of string</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;			// to get the declaration of list</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;		// to get the declaration of deque</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;			// to get the declaration of map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;	        // to get the declaration of copy</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;		// to get the declaration of back_inserter</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;		// to get the declaration of pair</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::copy;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">map</span>;		<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">list</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::pair;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">deque</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::back_inserter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">print</span>(<span class="title">T</span> &amp;<span class="title">t</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">typename</span> T::const_iterator i = t.<span class="built_in">begin</span>(); i != t.<span class="built_in">end</span>(); ++i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i-&gt;first &lt;&lt; <span class="string">' '</span> &lt;&lt; i-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; element;</span><br><span class="line">    <span class="built_in">vector</span>&lt;element&gt; x;</span><br><span class="line">    <span class="built_in">list</span>&lt;element&gt; y;</span><br><span class="line">    <span class="built_in">deque</span>&lt;element&gt; z;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; m&#123;&#123;<span class="number">1</span>, <span class="string">"abc"</span>&#125;, &#123;<span class="number">2</span>, <span class="string">"bcd"</span>&#125;, &#123;<span class="number">3</span>, <span class="string">"def"</span>&#125;, &#123;<span class="number">4</span>, <span class="string">"hig"</span>&#125;, &#123;<span class="number">5</span>, <span class="string">"klm"</span>&#125;&#125;;</span><br><span class="line">    copy(m.<span class="built_in">begin</span>(), m.<span class="built_in">end</span>(), back_inserter(x));</span><br><span class="line">    copy(m.<span class="built_in">begin</span>(), m.<span class="built_in">end</span>(), back_inserter(y));</span><br><span class="line">    copy(m.<span class="built_in">begin</span>(), m.<span class="built_in">end</span>(), back_inserter(z));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(x);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">print</span>(y);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">print</span>(z);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The results show that all these three types of container work fine for the copy algorithm.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1 abc</span><br><span class="line">2 bcd</span><br><span class="line">3 def</span><br><span class="line">4 hig</span><br><span class="line">5 klm</span><br><span class="line"></span><br><span class="line">1 abc</span><br><span class="line">2 bcd</span><br><span class="line">3 def</span><br><span class="line">4 hig</span><br><span class="line">5 klm</span><br><span class="line"></span><br><span class="line">1 abc</span><br><span class="line">2 bcd</span><br><span class="line">3 def</span><br><span class="line">4 hig</span><br><span class="line">5 klm</span><br></pre></td></tr></table></figure>

<p>For the second function call</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy(x.<span class="built_in">begin</span>(), x.<span class="built_in">end</span>(), back_inserter(m));</span><br></pre></td></tr></table></figure>
<p>I presume it doesn’t work because <strong>map</strong> doesn’t have member function <strong>push_back</strong>. We can correct this function call as</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy(x.<span class="built_in">begin</span>(), x.<span class="built_in">end</span>(), inserter(m, m.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>
<p>If we add follow statements to above program</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;element&gt; n&#123;&#123;<span class="number">10</span>, <span class="string">"abcd"</span>&#125;, &#123;<span class="number">20</span>, <span class="string">"bcde"</span>&#125;, &#123;<span class="number">30</span>, <span class="string">"defh"</span>&#125;&#125;;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::iterator it = m.<span class="built_in">end</span>();</span><br><span class="line">copy(n.<span class="built_in">begin</span>(), n.<span class="built_in">end</span>(), inserter(m, it));</span><br><span class="line"><span class="built_in">print</span>(m);</span><br></pre></td></tr></table></figure>
<p>The modified program gives results as expected</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1 abc</span><br><span class="line">2 bcd</span><br><span class="line">3 def</span><br><span class="line">4 hig</span><br><span class="line">5 klm</span><br><span class="line">10 abcd</span><br><span class="line">20 bcde</span><br><span class="line">30 defh</span><br></pre></td></tr></table></figure>
<p>Noting that, though we insert at the position where <strong>m.end()</strong> denotes, the new element may not appear starting from the end of the map. This is because that the <strong>map</strong> automatically sorts elements according to the values of <strong>key</strong>s. </p>
<hr>
<h1 id="Exercise-8-7"><a href="#Exercise-8-7" class="headerlink" title="Exercise 8-7"></a>Exercise 8-7</h1><p>Why doesn’t the max function use two template parameters, one for each argument type?</p>
<h2 id="Solution-amp-Results-4"><a href="#Solution-amp-Results-4" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>Let’s write the max function using two template parameters:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">P</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">P</span> <span class="title">max</span>(<span class="title">const</span> <span class="title">T</span>&amp; <span class="title">left</span>, <span class="title">const</span> <span class="title">P</span>&amp; <span class="title">right</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">return</span> left &gt; right ? left : right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The biggest problem is how can we correctly set the return type. There are two types <strong>T</strong> and <strong>P</strong>. If we set return type as <strong>T</strong>, the value returned may has type <strong>P</strong>, and vice versa. Concequently, type coversion happens. However, the result of type conversion depends on the range of the values that the types permit. For example, we call the max function as follows</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">max</span>(<span class="number">3500.9</span>, <span class="string">'a'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>If we set return type <strong>P</strong>, what happens of this program is unknown. </p>
<p>Therefore, such function template is non-practical and may lead to fatal errors. </p>
<hr>
<h1 id="Exercise-8-8"><a href="#Exercise-8-8" class="headerlink" title="Exercise 8-8"></a>Exercise 8-8</h1><p>n the binary_search function in §8.2.6/148, why didn’t we write (begin + end)/ 2 instead of the more complicated begin + (end - begin) /2 ?</p>
<h2 id="Solution-amp-Results-5"><a href="#Solution-amp-Results-5" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>This is because that iterators doesn’t support additive operation between two iterators. For random access iterators, they do support arithmetic operator <strong>+</strong> and <strong>-</strong> between an iterator and an ineger value, e.g.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iterator_i + integer_j</span><br><span class="line">integer_j + iterator_i</span><br><span class="line">iterator_i - integer_j</span><br></pre></td></tr></table></figure>
<p>In addition, they support substracting an iterator from another, e.g.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iterator_i - iterator_j</span><br></pre></td></tr></table></figure>
<p>Such operation yields an value of type <strong>difference_type</strong>, which in fact is an signed integer. Therefore, it is legal to do</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">begin</span> + (<span class="built_in">end</span> - <span class="built_in">begin</span>) /<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>as such expression is in fact the additive operation between an iterator and an iteger value.</p>
<p>But it makes no sence to do</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="built_in">begin</span> + <span class="built_in">end</span>)/ <span class="number">2</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>Koenig, A. and Moo, B.E., 2000. Accelerated C++.</p>
<p>Lippman, S.B., Lajoie, J. and Moo, B.E., 2013. C++ Primer, 5th edt.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://quantein.com/2018/04/03/Accelerated-C-Solutions-to-Exercises-Chapter-8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liam">
      <meta itemprop="description" content="Stochastic Modelling Notes; Programming Notes">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Liam's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/03/Accelerated-C-Solutions-to-Exercises-Chapter-8/" class="post-title-link" itemprop="url">Accelerated C++ Solutions to Exercises(Chapter 8 Part 1)</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-04-03 17:13:19" itemprop="dateCreated datePublished" datetime="2018-04-03T17:13:19+08:00">2018-04-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2018-04-05 14:51:13" itemprop="dateModified" datetime="2018-04-05T14:51:13+08:00">2018-04-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Programming/" itemprop="url" rel="index"><span itemprop="name">Programming</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span></span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>NaN:aN</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Exercise-8-0"><a href="#Exercise-8-0" class="headerlink" title="Exercise 8-0"></a>Exercise 8-0</h1><p>Compile, execute, and test the programs in this chapter.</p>
<h2 id="Solution-amp-Results"><a href="#Solution-amp-Results" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>Please find the programs and analysis on <a href="http://quanttour.com/02/04/2018/C-Writing-generic-functions/" target="_blank" rel="noopener">Writing generic functions</a>. </p>
<h1 id="Exercise-8-1"><a href="#Exercise-8-1" class="headerlink" title="Exercise 8-1"></a>Exercise 8-1</h1><p>Note that the various analysis functions we wrote in §6.2/110 share the same behavior; they differ only in terms of the functions they call to calculate the final grade. Write a template function, parameterized by the type of the grading function, and use that function to evaluate the grading schemes.</p>
<h2 id="Solution-amp-Results-1"><a href="#Solution-amp-Results-1" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>To parameterize the type of the grading function, I define the type parameter of the analysis function template as <strong>Fun</strong>. Then what we need to do is replacing all revelant functions with <strong>f</strong> which is a variable that has type <strong>Fun</strong>. See the function template below:</p>
<p>New <strong>grades_analysis.h</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_GRADES_ANALYSIS_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_GRADES_ANALYSIS_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"gradingSchemes.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Fun</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">double</span> <span class="title">analysis</span>(<span class="title">const</span> <span class="title">std</span>:</span>:<span class="built_in">vector</span>&lt;Student_info&gt; &amp;students, Fun &amp;f)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; grades;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">std</span>::transform(students.<span class="built_in">begin</span>(), students.<span class="built_in">end</span>(), <span class="built_in">std</span>::back_inserter(grades), f);</span><br><span class="line">	<span class="keyword">return</span> median(grades);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* GUARD_GRADES_ANALYSIS_H */</span></span></span><br></pre></td></tr></table></figure>
<p>The next step is to rewrite the <strong>write_analysis</strong> function as the original one defines a parameter to take various analysis functions. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_WRITE_ANALYSIS_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_WRITE_ANALYSIS_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"grades_analysis.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Fun</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">write_analysis</span>(<span class="title">std</span>:</span>:ostream &amp;out, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name, Fun &amp;f,</span><br><span class="line">		<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Student_info&gt; &amp;did,</span><br><span class="line">		<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Student_info&gt; &amp;didnt)</span><br><span class="line">&#123;</span><br><span class="line">    out &lt;&lt; name &lt;&lt; <span class="string">": median(did) = "</span> &lt;&lt; analysis(did, f)</span><br><span class="line">        &lt;&lt; <span class="string">": median(didnt) = "</span> &lt;&lt; analysis(didnt, f) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* GUARD_WRITE_ANALYSIS_H */</span></span></span><br></pre></td></tr></table></figure>

<p>Its necessary to put both declaration and definition into the header file for both two function templates due to the fact that they are required to be visible to the compiler in the point of instantiation.</p>
<p>Now we can pass different grading functions directly to the <strong>write_analysis</strong> function to generate analysis reports. </p>
<p><strong>mainfunction.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;			// to get the declaration of cin, cout, endl</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;			// to get the declaration of vector</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span>		<span class="comment">// to get the declaration of Student_info</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"did_all_hw.h"</span>			<span class="comment">// to get the declatation of the predicate on students' records</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"write_analysis.h"</span>		<span class="comment">// to get the declaration of write_analysis function</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"gradingSchemes.h"</span>		<span class="comment">// to get the declarations of various grading functions</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;		<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// students who did and didn't do all their homework</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;Student_info&gt; did, didnt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read the student records and partition time</span></span><br><span class="line">    Student_info student;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">read</span>(<span class="built_in">cin</span>, student))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(did_all_hw(student))</span><br><span class="line">            did.push_back(student);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            didnt.push_back(student);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// verify thatthe analyses will show us something</span></span><br><span class="line">    <span class="keyword">if</span>(did.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"No student did all the homework!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(didnt.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Every student did all the homework!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// do the analysis</span></span><br><span class="line">    write_analysis(<span class="built_in">cout</span>, <span class="string">"median"</span>,  median_grade_aux, did, didnt);</span><br><span class="line">    write_analysis(<span class="built_in">cout</span>, <span class="string">"average"</span>, average_grade, did, didnt);</span><br><span class="line">    write_analysis(<span class="built_in">cout</span>, <span class="string">"median of homework turned in"</span>, optimistic_median, did, didnt);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Other files are keep unchanged and can be found below. </p>
<p><strong>did_all_hw.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;		// to get the declaration of find</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span>	<span class="comment">// to get the declaration of Student_info</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"did_all_hw.h"</span>		<span class="comment">// to get the declaration of did_all_hw itself</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">find</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">did_all_hw</span><span class="params">(<span class="keyword">const</span> Student_info &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="built_in">find</span>(s.homework.<span class="built_in">begin</span>(), s.homework.<span class="built_in">end</span>(), <span class="number">0</span>)) == s.homework.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>did_all_hw.h</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_DID_ALL_HW_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_DID_ALL_HW_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">did_all_hw</span><span class="params">(<span class="keyword">const</span> Student_info &amp;s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* GUARD_DID_ALL_HW_H */</span></span></span><br></pre></td></tr></table></figure>
<p><strong>gradingSchemes.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;		// to get the declaration of remove_copy</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;		// to get the declaration of accumulate</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;		// to get the declaration of domain_error</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;		// to get the declaration of vector</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span>	<span class="comment">// to get the declaration of Student_info</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"gradingSchemes.h"</span>     <span class="comment">// to get the declaration of all functions here to keep consistent</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::domain_error;  <span class="keyword">using</span> <span class="built_in">std</span>::istream;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;        <span class="keyword">using</span> <span class="built_in">std</span>::sort;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::accumulate;</span><br><span class="line"></span><br><span class="line"><span class="comment">// final grade function returns weighted average of midterm exam grade,</span></span><br><span class="line"><span class="comment">// final exam grade, and homework grade which will be computed</span></span><br><span class="line"><span class="comment">// using different methods depending on grading schemes</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">double</span> midterm, <span class="keyword">double</span> <span class="keyword">final</span>, <span class="keyword">double</span> homework)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.2</span>*midterm + <span class="number">0.4</span>*<span class="keyword">final</span> + <span class="number">0.4</span>*homework;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fundermental functions 1: returns the median value of vector&lt;double&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">median</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// get the size of the vector</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;::size_type vec_size;</span><br><span class="line">    vec_size <span class="built_in">size</span> = vec.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check whether the empty is empty</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span> == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> domain_error(<span class="string">"median of an empty vector"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sort the grades</span></span><br><span class="line">    sort(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// compute the median homework grade</span></span><br><span class="line">    vec_size mid = <span class="built_in">size</span>/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">size</span> % <span class="number">2</span> == <span class="number">0</span> ? (vec[mid] + vec[mid - <span class="number">1</span>])/<span class="number">2</span> : vec[mid];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fundermental functions 2: returns the average value of vector&lt;double&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">average</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// check whether the empty is empty</span></span><br><span class="line">    <span class="keyword">if</span> (v.empty())</span><br><span class="line">    &#123;   <span class="keyword">throw</span> domain_error(<span class="string">"average of an empty vector"</span>);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> accumulate(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">0.0</span>) / v.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// grading scheme 1: final grade is based on the median homework grade</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">median_grade</span><span class="params">(<span class="keyword">const</span> Student_info &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> median_grade(s.midterm, s.<span class="keyword">final</span>, s.homework);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// grading scheme 1: overloaded median_grade function</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">median_grade</span><span class="params">(<span class="keyword">double</span> midterm, <span class="keyword">double</span> <span class="keyword">final</span>, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;hw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hw.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> domain_error(<span class="string">"student has done no homework"</span>);</span><br><span class="line">    <span class="keyword">return</span> grade(midterm, <span class="keyword">final</span>, median(hw));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// grading scheme 1: auxiliary median_grade function</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">median_grade_aux</span><span class="params">(<span class="keyword">const</span> Student_info &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> median_grade(s);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (domain_error)&#123;</span><br><span class="line">        <span class="comment">// students who did no homework at all, get 0 homework grade</span></span><br><span class="line">        <span class="keyword">return</span> grade(s.midterm, s.<span class="keyword">final</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// grading scheme 2: final grade is based on average homework grades</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">average_grade</span><span class="params">(<span class="keyword">const</span> Student_info &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> grade(s.midterm, s.<span class="keyword">final</span>, average(s.homework));</span><br><span class="line">    &#125;<span class="keyword">catch</span> (domain_error)&#123;</span><br><span class="line">        <span class="comment">// students who did no homework at all, get 0 homework grade</span></span><br><span class="line">        <span class="keyword">return</span> grade(s.midterm, s.<span class="keyword">final</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// grading scheme 3: final grade is based on median of the completed homework grades,</span></span><br><span class="line"><span class="comment">// and students who did no homework at all will get 0 homework grade</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">optimistic_median</span><span class="params">(<span class="keyword">const</span> Student_info &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; nonzero;</span><br><span class="line">    remove_copy(s.homework.<span class="built_in">begin</span>(), s.homework.<span class="built_in">end</span>(), back_inserter(nonzero), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(nonzero.empty())</span><br><span class="line">        <span class="keyword">return</span> grade(s.midterm, s.<span class="keyword">final</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> grade(s.midterm, s.<span class="keyword">final</span>, median(nonzero));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>gradingSchemes.h</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_GRADING_SCHEMES_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_GRADING_SCHEMES_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">double</span> midterm, <span class="keyword">double</span> <span class="keyword">final</span>, <span class="keyword">double</span> homework)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">median</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; vec)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">average</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;v)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">median_grade</span><span class="params">(<span class="keyword">const</span> Student_info &amp;s)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">median_grade</span><span class="params">(<span class="keyword">double</span> midterm, <span class="keyword">double</span> <span class="keyword">final</span>, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;hw)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">median_grade_aux</span><span class="params">(<span class="keyword">const</span> Student_info &amp;s)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">average_grade</span><span class="params">(<span class="keyword">const</span> Student_info &amp;s)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">optimistic_median</span><span class="params">(<span class="keyword">const</span> Student_info &amp;s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* GUARD_GRADING_SCHEMES_H */</span></span></span><br></pre></td></tr></table></figure>

<p><strong>Student_info.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>; 	<span class="keyword">using</span> <span class="built_in">std</span>::istream;</span><br><span class="line"></span><br><span class="line"><span class="comment">// argument to the function sort</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> Student_info &amp;x, <span class="keyword">const</span> Student_info &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.name &lt; y.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// read the info</span></span><br><span class="line"><span class="function">istream &amp; <span class="title">read</span><span class="params">(istream &amp;is, Student_info &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// reads and store the student's name, midterm and final exam grades</span></span><br><span class="line">    is &gt;&gt; s.name &gt;&gt; s.midterm &gt;&gt; s.<span class="keyword">final</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reads and store all homework grades</span></span><br><span class="line">    read_hw(is, s.homework);</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// read all homework grades</span></span><br><span class="line"><span class="function">istream &amp; <span class="title">read_hw</span><span class="params">(istream &amp;in, <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;hw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (in)&#123;</span><br><span class="line">        <span class="comment">//get rid of previous contents</span></span><br><span class="line">        hw.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// read homework grades</span></span><br><span class="line">        <span class="keyword">double</span> x;</span><br><span class="line">        <span class="keyword">while</span>(in &gt;&gt; x)</span><br><span class="line">            hw.push_back(x);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// clear the stream so that input will work for the next student</span></span><br><span class="line">        in.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Student_info.h</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_Student_info</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_Student_info</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student_info</span>&#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">double</span> midterm, <span class="keyword">final</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; homework;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> Student_info &amp;, <span class="keyword">const</span> Student_info &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::istream &amp; <span class="title">read</span><span class="params">(<span class="built_in">std</span>::istream &amp;, Student_info &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::istream &amp; <span class="title">read_hw</span><span class="params">(<span class="built_in">std</span>::istream &amp;, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>I tested this program using the same inputs as we did in <a href="http://quanttour.com/22/03/2018/C-Using-library-algorithms-Part-2/" target="_blank" rel="noopener">A simple test</a>.  It gives the same results as the original progam</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">median: median(did) &#x3D; 46.1475: median(didnt) &#x3D; 42.9273</span><br><span class="line">average: median(did) &#x3D; 45.4202: median(didnt) &#x3D; 44.3273</span><br><span class="line">median of homework turned in: median(did) &#x3D; 46.1475: median(didnt) &#x3D; 52.1273</span><br><span class="line">&#96;&#96;&#96;  </span><br><span class="line"></span><br><span class="line"># Exercise 8-2</span><br><span class="line">Implement the following library algorithms, which we used in Chapter 6 and describedin §6.5&#x2F;121. Specify what kinds of iterators they require. Try to minimize the number of distinct iterator operations that each function requires. After you have finished your implementation, see §B.3&#x2F;321 to see how well you did.</span><br></pre></td></tr></table></figure>
<p>equal(b, e, d)                 search(b, e, b2, e2)<br>find(b, e, t)                  find_if(b, e, p)<br>copy(b, e, d)                  remove_copy(b, e, d, t)<br>remove_copy_if(b, e, d, p)     remove(b, e, t)<br>transform(b, e, d, f)          partition(b, e, p)<br>accumulate(b, e, t)</p>
<pre><code>
## Solution &amp; Results
To be updated. 


</code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://quantein.com/2018/04/02/C-Writing-generic-functions/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liam">
      <meta itemprop="description" content="Stochastic Modelling Notes; Programming Notes">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Liam's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/02/C-Writing-generic-functions/" class="post-title-link" itemprop="url">C++ - Writing generic functions</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-04-02 14:41:58" itemprop="dateCreated datePublished" datetime="2018-04-02T14:41:58+08:00">2018-04-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2018-04-03 17:10:25" itemprop="dateModified" datetime="2018-04-03T17:10:25+08:00">2018-04-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Programming/" itemprop="url" rel="index"><span itemprop="name">Programming</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span></span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>NaN:aN</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Generic-function-an-example"><a href="#Generic-function-an-example" class="headerlink" title="Generic function - an example"></a>Generic function - an example</h1><p><em>Generic functions are functions written in a way that is independent of any particular type. When we use a generic program, we supply the type(s) or value(s) on which that instance of the program will operate</em>(Lippman etc. 2012). In C++, we can create generic functions by defining <strong>template function</strong>s, allowing writing a single definition for a family of functions or types that behave similarly but have different types of paratmters. The only difference can be summarized as parameters, namely, <strong>template parameters</strong>. Take the median function as an example, its template can be defined as follows.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">median</span>(<span class="title">vector</span>&lt;T&gt; <span class="title">v</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="built_in">vector</span>&lt;T&gt;::size_type vec_sz;</span><br><span class="line"></span><br><span class="line">    vec_sz <span class="built_in">size</span> = v.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">size</span> == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> domain_error(<span class="string">"median of an empty vector"</span>);</span><br><span class="line"></span><br><span class="line">    sort(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    vec_sz mid = <span class="built_in">size</span>/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">size</span> % <span class="number">2</span> ? (v[mid] + v[mid - <span class="number">1</span>])/<span class="number">2</span> : v[mid];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>From the definition, we observe</p>
<ol>
<li>A <strong>template</strong> starts with keyword <strong>template</strong> followed by <strong>type parameter(s)</strong> enclosed by a pair of angle brackets. </li>
<li><strong>type parameter(s)</strong> define the names that can be used within the scope of the function. They refer to types, not variables. In other words, the types of template parameters can be regarded as variables that have types specified by <strong>type parameters(s)</strong>. </li>
<li><strong>type parameter(s)</strong> are specified following the keyword <strong>class</strong> or <strong>typename</strong>. </li>
<li>the <strong>template</strong> tells implementation that <strong>vector<T>::size_type</strong> is the name of a type by adding keyword <strong>typename</strong> before. </li>
</ol>
<p>When we call <strong>median</strong> and pass a <strong>template argument</strong> vector<int>, the implementation will create and compile an instance of the function as if the function <strong>median(vector<int>)</strong>. This is so called <strong>template instantiation</strong>. But how is the template compiled?</p>
<p>When the compiler encounters the definition of a template, it doesn’t generate code. It generates only when the template is instantiated. Remembering that when we call a function, we need to supply only its declaration. But if we want to call the template, we need to supply not only its declaration but also its definition in order to instantiate it. Therefore, the header file of a template generally includes the source file also via a <strong>#include</strong> or directly. I found an article <a href="https://www.codeproject.com/Articles/3515/How-To-Organize-Template-Source-Code" target="_blank" rel="noopener">How To Organize Template Source Code</a>, where gives detailed explinations on how to organize template source code and three solutions.</p>
<p>Due to the feature of generating code during instantiation, compilation errors may occur during three stages:</p>
<ol>
<li>the first stage is when we compile the template itself. But the compiler can only detect some syntax errors like forgetting a semicolon, misspelling a variable name etc..</li>
<li>the second stage is when we use a template, before it is instantiated. The compiler typically will check that whether the number of the arguments is appropriate, whether two arguments that are supposed to have the same type do so.</li>
<li>the type-related errors mostly occurs during the third stage when the template is instantiated. Though implementations manage instantiation on their own ways, the type-related errors may be reported at link time due to that implementations assume the type is possibly defined in other unit and hence leave it to linker to resolve. </li>
</ol>
<p>In fact, we have applied many templates in previous programs, such as <strong>vector</strong> and <strong>list</strong>, and all standard library algorithms. </p>
<h1 id="Algorithms-and-iterators"><a href="#Algorithms-and-iterators" class="headerlink" title="Algorithms and iterators"></a>Algorithms and iterators</h1><p>As shown in above example, the template is type independent. However, it is also clear that the function to instantiate requires its argument supporting all operations included in the function. In above case, the types stored in the vectors that are passed to the median function must support addition and division. </p>
<p>The standard algorithms are not limited by the type of containers and obviously are data-structure independent function templates. It is known that the parameters taken by algorithms includes iterators and others. This implies that iterators to pass should support certain operations used inside of the algorithms. But we also know that some containers may support operations that others do not. For example, <strong>vector</strong> support random access elements via iterators while <strong>list</strong> doesn’t. Therefore, it is important  to restrict the right of iterators depending on operations that an algorithm include and operations different containers support. For this reason, the library defines five <strong>iterator categories</strong> with specifying the collection of iterator operations for each category. By doing so, we know exactly what effect of an algorithm can have on an container and which container can use which algorithms. </p>
<h2 id="Sequential-read-only-access"><a href="#Sequential-read-only-access" class="headerlink" title="Sequential read-only access"></a>Sequential read-only access</h2><p>Some algorithms only require iterators that can access elements sequentially. For example, the <strong>find</strong> algorithm:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">In</span>, <span class="title">class</span> <span class="title">X</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">In</span> <span class="title">find</span>(<span class="title">In</span> <span class="title">beg</span>, <span class="title">In</span> <span class="title">end</span>, <span class="title">const</span> <span class="title">X</span> &amp;<span class="title">x</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">begin</span> != <span class="built_in">end</span> &amp;&amp; *<span class="built_in">begin</span> != x)</span><br><span class="line">        ++<span class="built_in">begin</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">begin</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The iterators of type <strong>In</strong> access elements sequentially via<br>operations <strong><em>*</em></strong>, <strong>++</strong>. Also, they can be compared using <strong>!=</strong>. Alternatively,</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">In</span>, <span class="title">class</span> <span class="title">X</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">In</span> <span class="title">find</span>(<span class="title">In</span> <span class="title">begin</span>, <span class="title">In</span> <span class="title">end</span>, <span class="title">const</span> <span class="title">X</span> &amp;<span class="title">x</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">begin</span> == <span class="built_in">end</span> || *<span class="built_in">begin</span> == x)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">begin</span>;</span><br><span class="line">    <span class="built_in">begin</span>++;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">find</span>(<span class="built_in">begin</span>, <span class="built_in">end</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This version of <strong>find</strong> uses another strategy, recursively calling itself. We have observed that the iterators may also need to support operations <strong>++</strong>(postfix) and <strong>==</strong>. </p>
<p>Furthermore, the iterators ought to support member access via <strong>-&gt;</strong>, e.g. it-&gt;first. It has the same effect as <strong>(*it).first</strong>. </p>
<p>In summary, iterators that offers sequential read-only access to elements of a container should supports <strong>++</strong>(both prefix and postfix), <strong>==</strong> and <strong>!=</strong>, <strong><em>*</em></strong> and <strong>-&gt;</strong>. Such iterators are named as <strong>input iterators</strong>. All standard container meet the requirements of <strong>input iterator</strong>.</p>
<h2 id="Sequential-write-only-access"><a href="#Sequential-write-only-access" class="headerlink" title="Sequential write-only access"></a>Sequential write-only access</h2><p>Some algorithms may require write elements of a sequence via iterators, for example</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">In</span>, <span class="title">class</span> <span class="title">Out</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Out</span> <span class="title">copy</span>(<span class="title">In</span> <span class="title">begin</span>, <span class="title">In</span> <span class="title">end</span>, <span class="title">Out</span> <span class="title">dest</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">begin</span> != <span class="built_in">end</span>)</span><br><span class="line">        *dest++ = *<span class="built_in">begin</span>++;</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The <strong>copy</strong> algorithm takes three iterators, the first two of which denote the range of a sequence to copy while the third iterator denotes the initial position of the destination. The iterators of type <strong>In</strong> offer sequential read-only access to elements and hence are input iterators. The type <strong>Out</strong> gives the third iterator the ability to write elements via <strong>*dest =</strong> and <strong>dest++</strong>. As with the <strong>find</strong> algorithm above, such iterators should also support <strong>++dest</strong>. </p>
<p>The fact that iterators of type <strong>Out</strong> are used for output only also implies that </p>
<ol>
<li><p>each element pointed by the iterator is written a value only once and then the iterator is incremented.</p>
</li>
<li><p>the iterator can not be incremented twice without assignments to the elements that it refers to. </p>
</li>
</ol>
<p>In summary, such iterators are <strong>output iterators</strong>. All standard containers as well as <strong>back_inserter</strong> meet the requirements of <strong>output iterator</strong>. Noting that in this function, the left side deference operator is used to write to the underlying elements while the right side deference operator is used to read the underlying elements only. </p>
<h2 id="Sequential-read-write-access"><a href="#Sequential-read-write-access" class="headerlink" title="Sequential read-write access"></a>Sequential read-write access</h2><p>There is another situation that we want to both read and write the elements of a sequence, but only sequentially. For example</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">For</span>, <span class="title">class</span> <span class="title">X</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">replace</span>(<span class="title">For</span> <span class="title">beg</span>, <span class="title">For</span> <span class="title">end</span>, <span class="title">const</span> <span class="title">X</span> &amp;<span class="title">x</span>, <span class="title">const</span> <span class="title">X</span> &amp;<span class="title">y</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">while</span> (beg != <span class="built_in">end</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (*beg == x)</span><br><span class="line">            *beg = y;</span><br><span class="line">        ++beg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The <strong>replace</strong> algorithm examines each element in the range [beg, end) and assigns value y to those elements that are equal to x. Apparently, iterators of type <strong>For</strong> should support all operations supported by an input operator as well as an output operator. Moreover, they can read and write the same elements multiple times. Such a type is a <strong>forward iterator</strong>. Some operations that such a type need to support are</p>
<ol>
<li><strong>*it</strong> (for both reading and writing)</li>
<li><strong>++</strong> (both prefix and postfix)</li>
<li><strong>== and !=</strong></li>
<li><strong>-&gt;</strong></li>
</ol>
<p>All standard containers meet the requirements of <strong>forward iterator</strong>.</p>
<h2 id="Reversible-access"><a href="#Reversible-access" class="headerlink" title="Reversible access"></a>Reversible access</h2><p>All above iterators access elements in a container in a forward sequence. But some functions may require get elements in reverse order, for example</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Bi</span>&gt; <span class="title">void</span> <span class="title">reverse</span>(<span class="title">Bi</span> <span class="title">begin</span>, <span class="title">Bi</span> <span class="title">end</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">begin</span> != <span class="built_in">end</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        --<span class="built_in">end</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">begin</span> != <span class="built_in">end</span>)</span><br><span class="line">            swap (*<span class="built_in">begin</span>++, *<span class="built_in">end</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The iterators of type <strong>Bi</strong> moves backward from <strong>end</strong> to <strong>begin</strong> via <strong>–</strong>. Then, the <strong>swap</strong> algorithm exchanges values of two elements. Such iterators meet all requirements of <strong>forward iterator</strong> and support <strong>–</strong> (both prefix and postfix). They are <strong>bidirectional iterators</strong>. All standard containers meet the requirements of <strong>bidirectional iterators</strong>.</p>
<h2 id="Random-access"><a href="#Random-access" class="headerlink" title="Random access"></a>Random access</h2><p>All above iterators access elements in a forward or backward sequence, however, some functions need to access elements starting from arbitrary positions. For example</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Ran</span>, <span class="title">class</span> <span class="title">X</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">binary_search</span>(<span class="title">Ran</span> <span class="title">begin</span>, <span class="title">Ran</span> <span class="title">end</span>, <span class="title">const</span> <span class="title">X</span> &amp;<span class="title">x</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">begin</span> &lt; <span class="built_in">end</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// find the midpoint of the range</span></span><br><span class="line">        Ran mid = <span class="built_in">begin</span> + (<span class="built_in">end</span> - <span class="built_in">begin</span>)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// see which part of the range contains x; keep looking only in that part</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt; *mid)</span><br><span class="line">            <span class="built_in">end</span> = mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (*mid &lt;x)</span><br><span class="line">            <span class="built_in">begin</span> = mid + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if we got here, then *mid == x so we are done</span></span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The <strong>binary search</strong> algorithm looks for a particular element in a sorted container. It always starts to search from the middle point of a sequence, which relies on the ability to do arithmetic on iterators. Such an iterator is called a <strong>random access iterator</strong>. Specifically, if <strong>p</strong> and <strong>q</strong> are random access iterators, they should support all operations that a <strong>bidirectional iterator</strong> supports, as well as following arithmetic operations</p>
<ol>
<li><strong>p + n, p - n, n + p</strong></li>
<li><strong>p-q</strong></li>
<li><strong>p[n]</strong> (equivalent to *(p + n)) </li>
<li><strong>p &gt; q, p &lt; q, p &lt;= q, p &gt;= q</strong></li>
</ol>
<p>Standard <strong>sort</strong> algorithm requires random-access iterators. Therefore, <strong>vector</strong> and <strong>string</strong> can use standard <strong>sort</strong> function as their iterators are <strong>random-access iterators</strong>. <strong>list</strong> iterators are not <strong>random-access iterators</strong> and hence <strong>list</strong> defines its own member <strong>sort</strong> instead of using the standard <strong>sort</strong>. </p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>From above analysis, we know that <strong>forward, bidirectional and random-access iterators</strong> are also valid <strong>input iterators</strong> as they all meet the requirements of <strong>input iterator</strong>. In addition, all <strong>forward, bidirectional and random-access iterators</strong> that are not constant iterators are also valid <strong>output iterators</strong>. </p>
<p>From the perspective of containers, different category of iterator makes some containers distinct, for example, <strong>list</strong> iterators are <strong>bidirectional iterators</strong>, <strong>forward_list</strong> iterators are <strong>forward_iterators</strong>, <strong>vector</strong> and <strong>string</strong> iterators are <strong>random access iterators</strong>.</p>
<p>But why we need <strong>input/output iterator</strong>? One reason is that not all iterators are assicoated with containers. For example, <strong>back_inserter()</strong> is an iterator that meet and only meet the requirements of <strong>output iterator</strong>. </p>
<p>Another typical example is that the standard library provides iterators that can be bound to input and output streams, namely, <strong>istream_iterator</strong> and <strong>ostream_iterator</strong>.<br>Apparently, <strong>istream_iterator</strong> is <strong>input iterator</strong> that allows us to read successive elements from an input stream.<br><strong>ostream_iterator</strong> is <strong>output iterator</strong> that allows us to write sequentially to an output stream.  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="comment">// read ints from the standard input and append them to v</span></span><br><span class="line">copy(istream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cin</span>), istream_iterator&lt;<span class="keyword">int</span>&gt;(), back_insert(v));</span><br></pre></td></tr></table></figure>
<p>This example shows that the first <strong>istream_iterator</strong> is bound to <strong>cin</strong> and expects to read values of type <strong>int</strong>. But the second <strong>istream_iterator</strong> is not bound to any file.<br>This is because istream_iterator type has a default value with a sepcial property such that any <strong>istream_iterator</strong> that has reached end-of-file or is an error state will appear to be equal to the default value. Therefore, we can use the default value of a <strong>istream_iterator</strong> together with the first input iterator to denote the sequence in the input stream. </p>
<p>Similarly, we can use <strong>ostream_iterator</strong> to write elements to an output stream. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// write the elements of v each separated from the other by a space</span></span><br><span class="line">copy(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), ostream_iterator&lt;<span class="keyword">int</span>&gt; (<span class="built_in">cout</span>, <span class="string">" "</span>));</span><br></pre></td></tr></table></figure>
<p>This statement uses <strong>copy</strong> algorithm to copy the vector <strong>v</strong> onto the standard output. <strong>ostream_iterator</strong> is bound to <strong>cout</strong> with an additional argument, that is, a space in this case. This additional argument specifies a value to be written after each element and typically is a string literal. </p>
<h1 id="Rewrite-the-split-function"><a href="#Rewrite-the-split-function" class="headerlink" title="Rewrite the split function"></a>Rewrite the split function</h1><p>Now we apply the new knowledge learned above to rewrite the <strong>split</strong> function as a template such that it is data-structure independent. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Out</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">split</span>(<span class="title">const</span> <span class="title">string</span> &amp;<span class="title">str</span>, <span class="title">Out</span> <span class="title">os</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">string</span>::const_iterator iter;</span><br><span class="line"></span><br><span class="line">    iter i = str.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span>(i != str.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ignore leading spaces</span></span><br><span class="line">        i = find_if(i, str.<span class="built_in">end</span>(), not_space);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// find end of next word</span></span><br><span class="line">        iter j = find_if(i, str.<span class="built_in">end</span>(), space);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// copy the characters in [i,j)</span></span><br><span class="line">        <span class="keyword">if</span>(i != str.<span class="built_in">end</span>())</span><br><span class="line">            *os++ = <span class="built_in">string</span>(i, j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This function has return type <strong>void</strong>, i.e. nothing to return. If we want to store each word contained in a line of inputs into a vector<string>, we just need to pass an output iterator. This is also true for a list<string>. For example</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// list&lt;string&gt; words;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; words;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> <span class="built_in">line</span>;</span><br><span class="line">    <span class="keyword">while</span>(getline(<span class="built_in">cin</span>, <span class="built_in">line</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        split(<span class="built_in">line</span>, back_inserter(words));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::const_iterator it = words.<span class="built_in">begin</span>(); it != words.<span class="built_in">end</span>(); ++it)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Alternatively, we may write all words onto the standard output directly. I take this as an exercise and present a complete program below. </p>
<p><strong>mainfunction.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"split.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>; 		<span class="keyword">using</span> <span class="built_in">std</span>::ostream_iterator;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>; 		<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;		<span class="keyword">using</span> <span class="built_in">std</span>::back_inserter;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> <span class="built_in">line</span>;</span><br><span class="line">    <span class="keyword">while</span> (getline(<span class="built_in">cin</span>, <span class="built_in">line</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        split(<span class="built_in">line</span>, ostream_iterator&lt;<span class="built_in">string</span>&gt;(<span class="built_in">cout</span>, <span class="string">"\n"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>split.h</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_SPLIT_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_SPLIT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// true if the argument is whitespace, false otherwise</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">space</span><span class="params">(<span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">isspace</span>(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// false is the argument is whitespace, true otherwise</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">not_space</span><span class="params">(<span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !<span class="built_in">isspace</span>(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// template declaration and definition</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Out</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">split</span>(<span class="title">const</span> <span class="title">std</span>:</span>:<span class="built_in">string</span> &amp;str, Out os)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">string</span>::const_iterator iter;</span><br><span class="line"></span><br><span class="line">    iter i = str.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span>(i != str.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ignore leading spaces</span></span><br><span class="line">        i = <span class="built_in">std</span>::find_if(i, str.<span class="built_in">end</span>(), not_space);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// find end of next word</span></span><br><span class="line">        iter j = <span class="built_in">std</span>::find_if(i, str.<span class="built_in">end</span>(), space);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// copy the characters in [i,j)</span></span><br><span class="line">        <span class="keyword">if</span>(i != str.<span class="built_in">end</span>())</span><br><span class="line">            *os++ = <span class="built_in">std</span>::<span class="built_in">string</span>(i, j);</span><br><span class="line">    i = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* GUARD_SPLIT_H */</span></span></span><br></pre></td></tr></table></figure>

<p>Noting that I didn’t separate the definition and declaration of the split template to make them be visible to compiler in the point of instantiation.</p>
<p>Let’s type some words</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">what </span><br><span class="line">a </span><br><span class="line">beautiful </span><br><span class="line">name</span><br></pre></td></tr></table></figure>
<p>The results are as expected</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">what</span><br><span class="line">what</span><br><span class="line">a</span><br><span class="line">a</span><br><span class="line">beautiful</span><br><span class="line">beautiful</span><br><span class="line">name</span><br><span class="line">name</span><br></pre></td></tr></table></figure>
<p>Again type</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">what a beautiful name</span><br></pre></td></tr></table></figure>
<p>The program gives</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">what</span><br><span class="line">a</span><br><span class="line">beautiful</span><br><span class="line">name</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://quantein.com/2018/03/31/Accelerated-C-Solutions-to-Exercises-Chapter-7-Part-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liam">
      <meta itemprop="description" content="Stochastic Modelling Notes; Programming Notes">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Liam's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/03/31/Accelerated-C-Solutions-to-Exercises-Chapter-7-Part-2/" class="post-title-link" itemprop="url">Accelerated C++ Solutions to Exercises(Chapter 7 Part 2)</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-03-31 18:03:01" itemprop="dateCreated datePublished" datetime="2018-03-31T18:03:01+08:00">2018-03-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2018-04-05 14:52:40" itemprop="dateModified" datetime="2018-04-05T14:52:40+08:00">2018-04-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Programming/" itemprop="url" rel="index"><span itemprop="name">Programming</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span></span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>NaN:aN</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Exercise-7-5"><a href="#Exercise-7-5" class="headerlink" title="Exercise 7-5"></a>Exercise 7-5</h1><p>Reimplement the grammar program using a list as the data structure in which webuild the sentence.</p>
<h2 id="Solutions-amp-Results"><a href="#Solutions-amp-Results" class="headerlink" title="Solutions &amp; Results"></a>Solutions &amp; Results</h2><p>There is no any other differences between the list-based version and the vector-based version except that we replace <strong>vector</strong>s with <strong>list</strong>s literally, and hence No further discussion about this exercise. The original program can be found here <a href="http://quanttour.com/28/03/2018/C-Using-associative-containers-Part-2/" target="_blank" rel="noopener">Example 3</a>.</p>
<h1 id="Exercise-7-6"><a href="#Exercise-7-6" class="headerlink" title="Exercise 7-6"></a>Exercise 7-6</h1><p>Reimplement the gen_sentence program using two vectors: One will hold the fullyunwound, generated sentence, and the other will hold the rules and will be used as a stack.Do not use any recursive calls.</p>
<h2 id="Solution-amp-Results"><a href="#Solution-amp-Results" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>To be updated. </p>
<h1 id="Exercise-7-7"><a href="#Exercise-7-7" class="headerlink" title="Exercise 7-7"></a>Exercise 7-7</h1><p>Change the driver for the cross-reference program so that it writes line if there is only one line and lines otherwise.</p>
<h2 id="Solution-amp-Results-1"><a href="#Solution-amp-Results-1" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>The solution is to add and check a condition that whether the vector where holds line numbers only contain one line number. If there is only one line number, we use <strong>line</strong> else use <strong>lines</strong>. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((it-&gt;second).<span class="built_in">size</span>() == <span class="number">1</span>)</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"line:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"lines:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>I only present the revised file here and please find other file in <a href="http://quanttour.com/30/03/2018/Accelerated-C-Solutions-to-Exercises-Chapter-7/" target="_blank" rel="noopener">Exercise 7-4</a>.</p>
<p><strong>mainfunction.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;		// to get the declaration of map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;	// to get the declaration of string</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;	// to get the declaration of vector</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;	// to get the declaration of cin, cout, endl;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;	// to get the declaration of ostringstream</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;	// to get the declaration of isspace</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"split.h"</span>	<span class="comment">// to get the declaration of function split</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"xref.h"</span>	<span class="comment">// to get the declaration of xref</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">map</span>;				<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;				<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;			<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>:: <span class="built_in">ostringstream</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">isspace</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// call xret using split by default</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; ret = xref(<span class="built_in">cin</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set the length for each line of outputs</span></span><br><span class="line">    <span class="built_in">string</span>::size_type line_length = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write the result</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;::const_iterator it = ret.<span class="built_in">begin</span>(); it != ret.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// write the word</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">" occurs on "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((it-&gt;second).<span class="built_in">size</span>() == <span class="number">1</span>)</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"line:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"lines:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// followed by one or more line numbers</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator line_it = it-&gt;second.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *line_it;	<span class="comment">// write the first line number</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// scan the rest line numbers</span></span><br><span class="line">        ++line_it;</span><br><span class="line">        <span class="built_in">ostringstream</span> os;</span><br><span class="line">        <span class="keyword">while</span>(line_it != it-&gt;second.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// store line numbers into ostringstream object</span></span><br><span class="line">            os &lt;&lt; <span class="string">", "</span> &lt;&lt; *line_it;</span><br><span class="line">            ++line_it;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// get the contents from line_numbers</span></span><br><span class="line">        <span class="built_in">string</span> line_numbers = os.str();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// write each line of outputs</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">string</span>::size_type i = <span class="number">0</span>; i != line_numbers.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; line_numbers[i];</span><br><span class="line">            <span class="keyword">if</span>((i + <span class="number">1</span>) % line_length == <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// write a blank line to separate each words</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>I use the inputs as same as inputs used in exercise 7-4 and get following results, showing the effect of above changes.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ABC occurs on lines:</span><br><span class="line">1, 2, 3, 4, 5, 6, 7, </span><br><span class="line">8, 9, 10, 11, 12, 13</span><br><span class="line">, 14, 15, 16, 17, 18</span><br><span class="line">, 19, 20, 21</span><br><span class="line">DEF occurs on line:</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<h1 id="Exercise-7-8"><a href="#Exercise-7-8" class="headerlink" title="Exercise 7-8"></a>Exercise 7-8</h1><p>Change the cross-reference program to find all the URLs in a file, and write all the lines<br>on which each distinct URL occurs.</p>
<h2 id="Solution-amp-Results-2"><a href="#Solution-amp-Results-2" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>Please find the program and analysis in <a href="http://quanttour.com/27/03/2018/C-Using-associative-containers/" target="_blank" rel="noopener">Example 2-Test 2</a>. </p>
<h1 id="Exercise-7-9"><a href="#Exercise-7-9" class="headerlink" title="Exercise 7-9"></a>Exercise 7-9</h1><p>(difficult) The implementation of nrand in §7.4.4/135 will not work for arguments greater than RAND_MAX. Usually, this restriction is no problem, because RAND_MAX is often the largest possible integer anyway. Nevertheless, there are implementations under which RAND_MAX is much smaller than the largest possible integer. For example, it is not uncommon for RAND_MAX to be 32767 (2^15 -1) and the largest possible integer to be 2147483647 (2^31 -1). Reimplement nrand so that it works well for all values of n.</p>
<h2 id="Solution-amp-Results-3"><a href="#Solution-amp-Results-3" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>Recalling <strong>nrand</strong> function</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nrand</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span> || n &gt; RAND_MAX)</span><br><span class="line">        <span class="keyword">throw</span> domain_error(<span class="string">"Argument to nrand is out of range"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> bucket_size = RAND_MAX /n;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> r = rand() / bucket_size;</span><br><span class="line">    <span class="keyword">while</span>(r &gt;= n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>nrand</strong> generates a random numbers in the range [0, n). The idea behind this function is that we divide the range[0, n<em>(RAND_MAX/n)) into *</em>n** pieces of equal size. Assuming <strong>RAND_MAX = 32767</strong>, <strong>n = 1000</strong>, random numbers <strong>r</strong> and random numbers generated from <strong>rand()</strong> have following relationships:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">r (values)                   rand() (values of the range)</span><br><span class="line"></span><br><span class="line">0                            [0, 32)</span><br><span class="line">1                            [32, 64)</span><br><span class="line">2                            [64, 96)</span><br><span class="line">...                          ...</span><br><span class="line">999                          [31968, 32000)</span><br></pre></td></tr></table></figure>
<p>To be continued.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://quantein.com/2018/03/30/Accelerated-C-Solutions-to-Exercises-Chapter-7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liam">
      <meta itemprop="description" content="Stochastic Modelling Notes; Programming Notes">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Liam's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/03/30/Accelerated-C-Solutions-to-Exercises-Chapter-7/" class="post-title-link" itemprop="url">Accelerated C++ Solutions to Exercises(Chapter 7 Part 1)</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-03-30 09:40:46" itemprop="dateCreated datePublished" datetime="2018-03-30T09:40:46+08:00">2018-03-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2018-03-31 18:00:28" itemprop="dateModified" datetime="2018-03-31T18:00:28+08:00">2018-03-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Programming/" itemprop="url" rel="index"><span itemprop="name">Programming</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span></span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>NaN:aN</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Exercise-7-0"><a href="#Exercise-7-0" class="headerlink" title="Exercise 7-0"></a>Exercise 7-0</h1><p>Compile, execute, and test the programs in this chapter.</p>
<h2 id="Solution-amp-Results"><a href="#Solution-amp-Results" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>Please find the programs and detailed analysis in <a href="http://quanttour.com/27/03/2018/C-Using-associative-containers/" target="_blank" rel="noopener">Example 1, 2</a> and <a href="http://quanttour.com/27/03/2018/C-Using-associative-containers/" target="_blank" rel="noopener">Example 3</a>.</p>
<h1 id="Exercise-7-1"><a href="#Exercise-7-1" class="headerlink" title="Exercise 7-1"></a>Exercise 7-1</h1><p>Extend the program from §7.2/124 to produce its output sorted by occurrence count.That is, the output should group all the words that occur once, followed by those that occur twice, and so on.</p>
<h2 id="Solution-amp-Results-1"><a href="#Solution-amp-Results-1" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>The key to the solution is building a map from occurrence numbers to corresponding words. The original program builds a map from each distinct word to its occurrence numbers. Therefore, we can simply inverse the original map. But noting there may be more than one words have the same occurrence numbers. The revised program is shown below:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;		// to get the declaration of cin, cout, endl</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;		// to get the declaration of vector</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;		// to get the declaration of string</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;			// to get the declaration of map</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>; 	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">map</span>;		<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// store each word and an associated counter</span></span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; counters;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read the input, keeping track of each word and how often we see it</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; s)</span><br><span class="line">    &#123;</span><br><span class="line">        ++counters[s];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sort words stored in counters according to the occurence count</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt; sorted_counters;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::const_iterator it = counters.<span class="built_in">begin</span>(); it != counters.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    &#123;</span><br><span class="line">        sorted_counters[it-&gt;second].push_back(it-&gt;first);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write the words and associated counts</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Words and their associated counts:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::const_iterator it = counters.<span class="built_in">begin</span>(); it != counters.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">"\t"</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write a blank line to separate the outputs of two maps</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write occurrence count followed by the corresponding words</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Occurrence count and the  corresponding words:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt;::const_iterator it = sorted_counters.<span class="built_in">begin</span>(); it != sorted_counters.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; it-&gt;first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::const_iterator i = (it-&gt;second).<span class="built_in">begin</span>(); i != (it-&gt;second).<span class="built_in">end</span>(); ++i)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt;  <span class="string">' '</span> &lt;&lt; *i;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>It can be observed that the <strong>value</strong>s of the original map are stored into the new map as <strong>key</strong>s while the <strong>key</strong>s are stored as <strong>value</strong>s in the new map. In addition, we specify <strong>vector<string></strong> to hold more words that have same occurrence numbers. Now let’s type some words and check the results.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Inputs:</span><br><span class="line"></span><br><span class="line">a dog and a cat</span><br><span class="line">cat is good dog is bad</span><br><span class="line">human is ugly </span><br><span class="line"></span><br><span class="line">Outputs:</span><br><span class="line"></span><br><span class="line">Words and their associated counts:</span><br><span class="line">a	    2</span><br><span class="line">and	    1</span><br><span class="line">bad	    1</span><br><span class="line">cat	    2</span><br><span class="line">dog	    2</span><br><span class="line">good	1</span><br><span class="line">human	1</span><br><span class="line">is	    3</span><br><span class="line">ugly	1</span><br><span class="line"></span><br><span class="line">Occurrence count and the  corresponding words:</span><br><span class="line">1 and bad good human ugly</span><br><span class="line">2 a cat dog</span><br><span class="line">3 is</span><br></pre></td></tr></table></figure>
<p>Yeah, it correctly sorts the words according to their occurrence numbers. </p>
<hr>
<h1 id="Exercise-7-2"><a href="#Exercise-7-2" class="headerlink" title="Exercise 7-2"></a>Exercise 7-2</h1><p>Extend the program in §4.2.3/64 to assign letter grades by ranges:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A   90-100</span><br><span class="line">B   80-89.99...</span><br><span class="line">C   70-79.99...</span><br><span class="line">D   60-69.99...</span><br><span class="line">F   &lt; 60</span><br></pre></td></tr></table></figure>
<p>The output should list how many students fall into each category.</p>
<h2 id="Solution-amp-Results-2"><a href="#Solution-amp-Results-2" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>The key to solution is building a map from the letter grades, <strong>A, B, C, D, F</strong>, to the number of students who have the corresponding final grades. Therefore, the map can be defined as:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; grades_count;</span><br></pre></td></tr></table></figure>
<p>The strategy can be divided into four steps:</p>
<ol>
<li>read students’ information</li>
<li>calculate final grade for each student</li>
<li>check the range of each final grade and get a letter grade (i.e. the <strong>key</strong>)</li>
<li>increment the <strong>value</strong> associated with the <strong>key</strong> returned in step 3</li>
</ol>
<p>Step 1 and step 2 are familar. </p>
<p>Step 3 needs a function on the final grade. I uses a simple <strong>if-else</strong> statement to complete it:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">letter_grade</span><span class="params">(<span class="keyword">double</span> &amp;grade)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(grade &lt; <span class="number">0</span> || grade &gt; <span class="number">100</span>)</span><br><span class="line">        <span class="keyword">throw</span> domain_error(<span class="string">"grade is outside of[0, 100]"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (grade &gt;= <span class="number">90</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"A"</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(grade &gt;= <span class="number">80</span> &amp;&amp; grade &lt; <span class="number">90</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"B"</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(grade &gt;= <span class="number">70</span> &amp;&amp; grade &lt; <span class="number">80</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"C"</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(grade &gt;= <span class="number">60</span> &amp;&amp; grade &lt; <span class="number">70</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"D"</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"F"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step 4 is accomplished by the statement:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">++grades_count[letter_grade(final_grade)];</span><br></pre></td></tr></table></figure>
<p><strong>letter_grade(final_grade)</strong> returns a letter grade based on the function above. Then, the map <strong>grades_count</strong> stores (if it is new ) the letter as the key and returns the associated value. Finally, applies <strong>++</strong> operator to increment the associated value, showing the counting process. </p>
<h3 id="The-complete-program"><a href="#The-complete-program" class="headerlink" title="The complete program"></a>The complete program</h3><p>The complete program is displayed below including files: <strong>mainfunction.cpp, grade.cpp, grade.h, Student_info.cpp and Student_info.h</strong>.</p>
<p><strong>mainfunction.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;		// to get the declaration of cin, cout, endl</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;		// to get the declaration of domain_error</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;		// to get the declaration of string</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;		// to get the declaration of vector</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;			// to get the declaration of map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span>	<span class="comment">// to get the declaration of Student_info</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"grade.h"</span>		<span class="comment">// to get the declaration of grade</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;			<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;			<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::domain_error;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">map</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">letter_grade</span><span class="params">(<span class="keyword">double</span> &amp;grade)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(grade &lt; <span class="number">0</span> || grade &gt; <span class="number">100</span>)</span><br><span class="line">        <span class="keyword">throw</span> domain_error(<span class="string">"grade is outside of[0, 100]"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (grade &gt;= <span class="number">90</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"A"</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(grade &gt;= <span class="number">80</span> &amp;&amp; grade &lt; <span class="number">90</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"B"</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(grade &gt;= <span class="number">70</span> &amp;&amp; grade &lt; <span class="number">80</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"C"</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(grade &gt;= <span class="number">60</span> &amp;&amp; grade &lt; <span class="number">70</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"D"</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"F"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// read and store all the records</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;Student_info&gt; students;</span><br><span class="line">    Student_info record;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">read</span>(<span class="built_in">cin</span>, record))</span><br><span class="line">    &#123;</span><br><span class="line">        students.push_back(record);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; grades_count;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Student_info&gt;::size_type i = <span class="number">0</span>; i != students.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// compute each final grade letter grades and counting the letter grades</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">double</span> final_grade = grade(students[i]);</span><br><span class="line">            ++grades_count[letter_grade(final_grade)];</span><br><span class="line">        &#125; <span class="keyword">catch</span>(domain_error e)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; e.what();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::const_iterator it = grades_count.<span class="built_in">begin</span>();</span><br><span class="line">            it != grades_count.<span class="built_in">end</span>(); ++it)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">'\t'</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>grade.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"grade.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::domain_error;  <span class="keyword">using</span> <span class="built_in">std</span>::istream;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;        <span class="keyword">using</span> <span class="built_in">std</span>::sort;</span><br><span class="line"></span><br><span class="line"><span class="comment">// grade function 1</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">const</span> Student_info &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> grade(s.midterm, s.<span class="keyword">final</span>, s.homework);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// grade function 2</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">double</span> midterm, <span class="keyword">double</span> <span class="keyword">final</span>, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;hw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hw.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> domain_error(<span class="string">"student has done no homework"</span>);</span><br><span class="line">    <span class="keyword">return</span> grade(midterm, <span class="keyword">final</span>, median(hw));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// grade function 3</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">double</span> midterm, <span class="keyword">double</span> <span class="keyword">final</span>, <span class="keyword">double</span> homework)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.2</span>*midterm + <span class="number">0.4</span>*<span class="keyword">final</span> + <span class="number">0.4</span>*homework;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compute the median of vector&lt;double&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">median</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// get the size of the vector</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;::size_type vec_size;</span><br><span class="line">    vec_size <span class="built_in">size</span> = vec.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check whether the empty is empty</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span> == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> domain_error(<span class="string">"median of an empty vector"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sort the grades</span></span><br><span class="line">    sort(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// compute the median homework grade</span></span><br><span class="line">    vec_size mid = <span class="built_in">size</span>/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">size</span> % <span class="number">2</span> == <span class="number">0</span> ? (vec[mid] + vec[mid - <span class="number">1</span>])/<span class="number">2</span> : vec[mid];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>grade.h</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_grade_h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_grade_h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// grade.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">const</span> Student_info &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">(<span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">median</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>Student.info</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Student_info.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>; <span class="keyword">using</span> <span class="built_in">std</span>::istream;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> Student_info &amp;x, <span class="keyword">const</span> Student_info &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.name &lt; y.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">istream &amp; <span class="title">read</span><span class="params">(istream &amp;is, Student_info &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// reads and store the student's name, midterm and final exam grades</span></span><br><span class="line">    is &gt;&gt; s.name &gt;&gt; s.midterm &gt;&gt; s.<span class="keyword">final</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reads and store all homework grades</span></span><br><span class="line">    read_hw(is, s.homework);</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">istream &amp; <span class="title">read_hw</span><span class="params">(istream &amp;in, <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;hw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (in)&#123;</span><br><span class="line">        <span class="comment">//get rid of previous contents</span></span><br><span class="line">        hw.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// read homework grades</span></span><br><span class="line">        <span class="keyword">double</span> x;</span><br><span class="line">        <span class="keyword">while</span>(in &gt;&gt; x)</span><br><span class="line">            hw.push_back(x);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// clear the stream so that input will work for the next student</span></span><br><span class="line">        in.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Student_info.h</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_Student_info</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_Student_info</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student_info</span>&#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">double</span> midterm, <span class="keyword">final</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; homework;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> Student_info &amp;, <span class="keyword">const</span> Student_info &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::istream &amp; <span class="title">read</span><span class="params">(<span class="built_in">std</span>::istream &amp;, Student_info &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::istream &amp; <span class="title">read_hw</span><span class="params">(<span class="built_in">std</span>::istream &amp;, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="Performance-Test"><a href="#Performance-Test" class="headerlink" title="Performance Test"></a>Performance Test</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Inputs:</span><br><span class="line"></span><br><span class="line">Phqgh 24.7879 58.6263 64.0505</span><br><span class="line">Nlfdx 95.4242 27.3636 91.0404</span><br><span class="line">Cxggb 16.1818 95.4747 26.7172</span><br><span class="line">Uxwfn 35.9495 3.11111 22.3333</span><br><span class="line">Tkjpr 68.4747 44.6263 57.3737</span><br><span class="line">Pnrvy 16.3535 90.4242 88.0606</span><br><span class="line">Syycq 5.90909 29.7071 50.0606</span><br><span class="line">Ffmzn 84.5455 56.404 66.7677</span><br><span class="line">Vwsre 23.3737 38.1818 82.2929</span><br><span class="line">Fxtls 4.30303 77.0606 73.8687</span><br><span class="line">Dpooe 29.7778 73.9798 12.8687</span><br><span class="line">Ejuvp 55.7475 31.5253 50.5051</span><br><span class="line">Poeyl 91.0707 37.5758 87.5354</span><br><span class="line">Jvrvi 21.8889 22.4646 6.30303</span><br><span class="line">Hwqnq 55.101 59.2424 37.4848</span><br><span class="line">Jjloo 91.3636 74.202 96.2121</span><br><span class="line">Whmsn 34.5354 99.1818 38</span><br><span class="line">Sfzkv 48.8384 7.21212 10.1717</span><br><span class="line">Lyjyh 51 49.1919 56.9899</span><br><span class="line">Nkkuf 89.0202 95.8586 93.4343</span><br><span class="line"></span><br><span class="line">Outputs:</span><br><span class="line"></span><br><span class="line">A	1</span><br><span class="line">B	1</span><br><span class="line">C	1</span><br><span class="line">D	5</span><br><span class="line">F	12</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Exercise-7-3"><a href="#Exercise-7-3" class="headerlink" title="Exercise 7-3"></a>Exercise 7-3</h1><p>The cross-reference program from §7.3/126 could be improved: As it stands, if a word occurs more than once on the same input line, the program will report that line multiple times. Change the code so that it detects multiple occurrences of the same line number and inserts the line number only once. </p>
<h2 id="Solution-amp-Results-3"><a href="#Solution-amp-Results-3" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>In the original program, we built a map from each distinct word to the line numbers in which the word appears. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, vector&lt;int&gt; &gt; xref(istream &amp;in,</span><br><span class="line">        vector&lt;string&gt; find_words(const string &amp;))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> <span class="built_in">line</span>;</span><br><span class="line">    <span class="keyword">int</span> line_number = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read the next line</span></span><br><span class="line">    <span class="keyword">while</span>(getline(in, <span class="built_in">line</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        ++line_number;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// break the input line into words</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; words = find_words(<span class="built_in">line</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// remember that each word occurs on the current line</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::const_iterator it = words.<span class="built_in">begin</span>(); it != words.<span class="built_in">end</span>();</span><br><span class="line">                ++it)</span><br><span class="line">        &#123;</span><br><span class="line">            ret[*it].push_back(line_number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>However, the line numbers for each word may repeatedly recorded. To avoid this problem, one solution is to check whether the line number has already been recorded. If the line number has been recorded, we ignore it, otherwise, we store it into the vector. We do not need to check all elements in the vector instead we only check the last stored line number. This is because that if a line number is repeatedly recorded, two elements (i.e. same line numbers) must be adjacent. Therefore, I add <strong>if</strong> statement as follows:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(ret[*it].empty() || *(ret[*it].<span class="built_in">end</span>() - <span class="number">1</span>) != line_number)</span><br><span class="line">    ret[*it].push_back(line_number);</span><br></pre></td></tr></table></figure>
<p>I’ll give the complete program as well as test results in next exercise.</p>
<h1 id="Exercise-7-4"><a href="#Exercise-7-4" class="headerlink" title="Exercise 7-4"></a>Exercise 7-4</h1><p>The output produced by the cross-reference program will be ungainly if the input file is large. Rewrite the program to break up the output if the lines get too long.</p>
<h2 id="Solution-amp-Results-4"><a href="#Solution-amp-Results-4" class="headerlink" title="Solution &amp; Results"></a>Solution &amp; Results</h2><p>The key to the solution is managing the length of each line of outputs. Theoretically, the strategy can be divided into three steps:</p>
<ol>
<li>convert all line numbers (except the first one) associated with a word into <strong>string</strong>s. </li>
<li>count the number of characters that have been written.</li>
<li>when the predetermined length of a line is reached, write a new line. </li>
</ol>
<p>The first two steps seems tedious to us. Fortunately, we can use <strong>stringstream</strong> objects to accomplish these easily.</p>
<p><strong>stringstream</strong> is a stream class defined standard library. It provides <strong>IO</strong> facilities that operate on strings. For example, <strong>ostringstream</strong> object uses a string buffer to hold a sequences of characters for printing all outputs together. In addition, the sequence of characters can be accessed directly as a string object, using member function str. In this case, I define such an object <strong>os</strong> to hold all line numbers as well as additional spaces between two line numbers. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os &lt;&lt; <span class="string">", "</span> &lt;&lt; *line_it;</span><br></pre></td></tr></table></figure>
<p><strong>line_it</strong> is an iterator that refers to one of line numbers stored in a vector.</p>
<p>Once all line numbers have been stored into <strong>os</strong>, we can access all contents to be written as a string object.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> line_numbers = os.str();</span><br></pre></td></tr></table></figure>

<p>Now, the next is to print all line numbers in one or more lines depending on the predetermined length of one line. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="built_in">string</span>::size_type i = <span class="number">0</span>; i != line_numbers.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; line_numbers[i];</span><br><span class="line">    <span class="keyword">if</span>((i + <span class="number">1</span>) % line_length == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>When <strong>i+1</strong>th element (i.e. <strong>line_number[i]</strong>)<br>is written, the <strong>if statement</strong> check that if the number of characters that have been written equals to the length (or multiple lengths) of a line, a newline character is inserted into the output stream.</p>
<h3 id="A-complete-program"><a href="#A-complete-program" class="headerlink" title="A complete program"></a>A complete program</h3><p>I integerated the changes described in exercise 7-3 and this exercise into a new program including files: <strong>mainfunction.cpp, xref.cpp, xref.h, split.cpp, split.h</strong>.</p>
<p><strong>mainfunction.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;		// to get the declaration of map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;	// to get the declaration of string</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;	// to get the declaration of vector</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;	// to get the declaration of cin, cout, endl;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;	// to get the declaration of ostringstream</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;	// to get the declaration of isspace</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"split.h"</span>	<span class="comment">// to get the declaration of function split</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"xref.h"</span>	<span class="comment">// to get the declaration of xref</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">map</span>;				<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;				<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;			<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>:: <span class="built_in">ostringstream</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">isspace</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// call xret using split by default</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; ret = xref(<span class="built_in">cin</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set the length for each line of outputs</span></span><br><span class="line">    <span class="built_in">string</span>::size_type line_length = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write the result</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;::const_iterator it = ret.<span class="built_in">begin</span>(); it != ret.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// write the word</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">" occurs on line(s):"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// followed by one or more line numbers</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator line_it = it-&gt;second.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *line_it;	<span class="comment">// write the first line number</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// scan the rest line numbers</span></span><br><span class="line">        ++line_it;</span><br><span class="line">        <span class="built_in">ostringstream</span> os;</span><br><span class="line">        <span class="keyword">while</span>(line_it != it-&gt;second.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// store line numbers into ostringstream object</span></span><br><span class="line">            os &lt;&lt; <span class="string">", "</span> &lt;&lt; *line_it;</span><br><span class="line">            ++line_it;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// get the contents from line_numbers</span></span><br><span class="line">        <span class="built_in">string</span> line_numbers = os.str();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// write each line of outputs</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">string</span>::size_type i = <span class="number">0</span>; i != line_numbers.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; line_numbers[i];</span><br><span class="line">            <span class="keyword">if</span>((i + <span class="number">1</span>) % line_length == <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// write a blank line to separate each words</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>xref.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;	// to get the decalration of istream</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;		// to get the declaration of map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;	// to get the declaration of vector</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;	// to get the declaration of string</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"split.h"</span>	<span class="comment">// to get the declaration of split</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"xref.h"</span>	<span class="comment">// to get the declatation of xref</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">map</span>;		<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::istream;</span><br><span class="line"></span><br><span class="line">map&lt;string, vector&lt;int&gt; &gt; xref(istream &amp;in,</span><br><span class="line">        vector&lt;string&gt; find_words(const string &amp;))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> <span class="built_in">line</span>;</span><br><span class="line">    <span class="keyword">int</span> line_number = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read the next line</span></span><br><span class="line">    <span class="keyword">while</span>(getline(in, <span class="built_in">line</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        ++line_number;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// break the input line into words</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; words = find_words(<span class="built_in">line</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// remember that each word occurs on the current line</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::const_iterator it = words.<span class="built_in">begin</span>(); it != words.<span class="built_in">end</span>();</span><br><span class="line">                ++it)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ret[*it].empty() || *(ret[*it].<span class="built_in">end</span>() - <span class="number">1</span>) != line_number)</span><br><span class="line">                ret[*it].push_back(line_number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>xref.h</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_XREF_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_XREF_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"split.h"</span></span></span><br><span class="line"></span><br><span class="line">std::map&lt;std::string, std::vector&lt;int&gt; &gt; xref(std::istream &amp;,</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">find_words</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;)</span> </span>= split);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/*GUARD_XREF_H */</span></span></span><br></pre></td></tr></table></figure>

<p><strong>split.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;		// to get the declarartion of vector</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;		// to get the declaration of string</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;	// to get the declaration of find_if</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"split.h"</span>		<span class="comment">// to get the declaration of split</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::find_if;</span><br><span class="line"></span><br><span class="line"><span class="comment">// true if the argument is whitespace, false otherwise</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">space</span><span class="params">(<span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">isspace</span>(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// false if the argument is whitesapce, true otherwise</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">not_space</span><span class="params">(<span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !<span class="built_in">isspace</span>(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// function extracts words from a line of input</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">split</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">string</span>::const_iterator iter;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ret;</span><br><span class="line"></span><br><span class="line">    iter i = str.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span> (i != str.<span class="built_in">end</span>())&#123;</span><br><span class="line">        <span class="comment">// ignore leading blanks</span></span><br><span class="line">        i = find_if(i, str.<span class="built_in">end</span>(), not_space);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// find end of next word</span></span><br><span class="line">        iter j = find_if(i, str.<span class="built_in">end</span>(), space);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// copy the characters in [i,j)</span></span><br><span class="line">        <span class="keyword">if</span>(i != str.<span class="built_in">end</span>())</span><br><span class="line">            ret.push_back(<span class="built_in">string</span>(i, j));</span><br><span class="line">        i = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>split.h</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_SPLIT_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_SPLIT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">space</span><span class="params">(<span class="keyword">char</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">not_space</span><span class="params">(<span class="keyword">char</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">split</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* GUARD_SPLIT_H */</span></span></span><br></pre></td></tr></table></figure>

<h3 id="Performance-test"><a href="#Performance-test" class="headerlink" title="Performance test"></a>Performance test</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Inputs:</span><br><span class="line"></span><br><span class="line">ABC</span><br><span class="line">ABC DEF DEF</span><br><span class="line">ABC</span><br><span class="line">ABC ABC</span><br><span class="line">ABC</span><br><span class="line">ABC</span><br><span class="line">ABC</span><br><span class="line">ABC</span><br><span class="line">ABC</span><br><span class="line">ABC</span><br><span class="line">ABC</span><br><span class="line">ABC</span><br><span class="line">ABC</span><br><span class="line">ABC</span><br><span class="line">ABC</span><br><span class="line">ABC</span><br><span class="line">ABC</span><br><span class="line">ABC</span><br><span class="line">ABC</span><br><span class="line">ABC</span><br><span class="line">ABC</span><br><span class="line"></span><br><span class="line">Outputs:</span><br><span class="line"></span><br><span class="line">ABC occurs on line(s):</span><br><span class="line">1, 2, 3, 4, 5, 6, 7, </span><br><span class="line">8, 9, 10, 11, 12, 13</span><br><span class="line">, 14, 15, 16, 17, 18</span><br><span class="line">, 19, 20, 21</span><br><span class="line">DEF occurs on line(s):</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p>From this test, we observe that</p>
<ol>
<li>if one word appears more than one times in the same line, the line number is only recorded once. This shows the change described in exercise 7-3 works well.</li>
<li>once a line of outputs exceeds 20 characters, it wraps. This verifies the solution given above. </li>
</ol>
<p>Noting that I also change the program such that it always writes line numbers starting from a new line. </p>
<hr>
<p>To be continued.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Liam</p>
  <div class="site-description" itemprop="description">Stochastic Modelling Notes; Programming Notes</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">59</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/quantliam" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;quantliam" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/yanshijiutu@gmail.com" title="E-Mail → yanshijiutu@gmail.com"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Liam</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">Symbols count total: </span>
    <span title="Symbols count total">NaNm</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">Reading time total &asymp;</span>
    <span title="Reading time total">NaN:aN</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
