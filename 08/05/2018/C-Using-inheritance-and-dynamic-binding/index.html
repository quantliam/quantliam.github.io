<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="C++,Notes," />










<meta name="description" content="InheritanceIn this chapter, we intend to extend our grading program such that it meets the new requirements: students can take undergraduate or graduate credit while graduate students have to write a">
<meta name="keywords" content="C++,Notes">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ - Using inheritance and dynamic binding">
<meta property="og:url" content="http://www.quanttour.com/08/05/2018/C-Using-inheritance-and-dynamic-binding/index.html">
<meta property="og:site_name" content="Liam&#39;s Blog">
<meta property="og:description" content="InheritanceIn this chapter, we intend to extend our grading program such that it meets the new requirements: students can take undergraduate or graduate credit while graduate students have to write a">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2018-05-12T13:43:30.309Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C++ - Using inheritance and dynamic binding">
<meta name="twitter:description" content="InheritanceIn this chapter, we intend to extend our grading program such that it meets the new requirements: students can take undergraduate or graduate credit while graduate students have to write a">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.quanttour.com/08/05/2018/C-Using-inheritance-and-dynamic-binding/"/>





  <title>C++ - Using inheritance and dynamic binding | Liam's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Liam's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">If history repeats itself, and the unexpected always happens, how incapable must Man be of learning from experience?â€”George Bernard Shaw.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.quanttour.com/08/05/2018/C-Using-inheritance-and-dynamic-binding/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liam">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Liam's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">C++ - Using inheritance and dynamic binding</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-08T13:37:57+08:00">
                08-05-2018
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Programming/" itemprop="url" rel="index">
                    <span itemprop="name">Programming</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  3,689
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  23
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Inheritance"><a href="#Inheritance" class="headerlink" title="Inheritance"></a>Inheritance</h1><p>In this chapter, we intend to extend our grading program such that it meets the new requirements: students can take undergraduate or graduate credit while graduate students have to write a thesis in addition to the homework and exams. In other words, a record for graduate credit is the same as for undergraduate credit except that it has extra properties related to the thesis. This problem can be abstracted and solved by a mechanism called <strong>inheritance</strong>, which is one of the cornerstones of OOP. </p>
<p>Specifically, weâ€™ll write two classes, the first class is the abstraction of the core requirements and is named <strong>Core</strong> while the second class represents the requirements for graduate credit and hence named <strong>Grad</strong>. The <strong>Grad</strong> class captures extra requirements but has same core requirements as the <strong>Core</strong> class. Therefore, We write two classes such that the <strong>Grad</strong> class can inherit the properties from the <strong>Core</strong> class. Typically, we say that the <strong>Grad</strong> class is derived from or inherits from the <strong>base</strong> class, i.e. the <strong>Core</strong> class here. letâ€™s see how to define these two classes:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Core</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Core();</span><br><span class="line">    Core(<span class="built_in">std</span>::istream&amp;);</span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">istream&amp; <span class="title">read</span><span class="params">(<span class="built_in">std</span>::istream&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">istream&amp; <span class="title">read_common</span><span class="params">(<span class="built_in">std</span>::istream&amp;)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> n;</span><br><span class="line">    <span class="keyword">double</span> midterm, final;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; homework;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grad</span>:</span> <span class="keyword">public</span> Core&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Grad();</span><br><span class="line">    Grad(<span class="built_in">std</span>::istream&amp;);</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">istream&amp; <span class="title">read</span><span class="params">(<span class="built_in">std</span>::istream&amp;)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> thesis;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Since <strong>Grad</strong> class inherits from <strong>Core</strong> class, every member of <strong>Core</strong> is also a member of <strong>Grad</strong>, except for the <strong>constructor, assignment operator</strong>, and <strong>destructor</strong>. The <strong>Grad</strong> class also has its own members, such as the <strong>thesis</strong> and its own <strong>constructor</strong>s. It can also redefine members from the base class, such as the <strong>grade</strong> and <strong>read</strong> function. </p>
<p>The keyword <strong>public</strong> in <strong>public Core</strong> means that <strong>Grad</strong> inherits from <strong>Core</strong> is part of its interface rather than its implementation. In other words, the public interface to <strong>Core</strong> becomes part of the public interface to <strong>Grad</strong>. For example, if we have a <strong>Grad</strong> object, we can call its <strong>name</strong> member thought <strong>Grad</strong> doesnâ€™t define its own <strong>name</strong> function. </p>
<p>Beyond the four data members from the <strong>Core</strong> class,  <strong>Grad</strong> has a member <strong>thesis</strong> and calculates <strong>grade()</strong> using different algorithm. It have two constructors, and four member functions, two of which redefine the corresponding members of <strong>Core</strong>, and <strong>name</strong> and <strong>read_common</strong> functions. </p>
<h2 id="Protection-revisited"><a href="#Protection-revisited" class="headerlink" title="Protection revisited"></a>Protection revisited</h2><p>As it stands, four data members as well as the <strong>read_common</strong> function are inaccessible to member functions in <strong>Grad</strong> as they are <strong>private</strong> and only available to the <strong>Core</strong> members and its friends. But we do need these data members and <strong>read_common</strong> for defining the <strong>grade</strong> and <strong>read</strong> functions in the <strong>Grad</strong>. To achieve this goal, we rewrite the <strong>Core</strong> class using a protection lable:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Core</span>&#123;</span></span><br><span class="line"><span class="comment">// public members are available for users of the derived class</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Core();</span><br><span class="line">    Core(<span class="built_in">std</span>::istream&amp;);</span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">istream&amp; <span class="title">read</span><span class="params">(<span class="built_in">std</span>::istream&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// protected members are available for member functions of the derived class but not available for users </span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">istream&amp; <span class="title">read_common</span><span class="params">(<span class="built_in">std</span>::istream&amp;)</span></span>;  </span><br><span class="line">    <span class="keyword">double</span> midterm, final;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; homework;</span><br><span class="line"></span><br><span class="line"><span class="comment">// only available for members of the class itself and its friends.</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> n;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>The <strong>protected</strong> members are available for derived classes but still inaccssible users of the classes. <strong>n</strong> is still private but <strong>Grad</strong> can access the name by calling its member function <strong>name</strong>.</p>
<h2 id="Operations"><a href="#Operations" class="headerlink" title="Operations"></a>Operations</h2><p>The next is to implement four constructors(each class has one default constructor and one constructor with arguments) and six operations including common functions <strong>name</strong>, <strong>read_common</strong>,  and <strong>read</strong> and <strong>grade</strong> for two class respectively. Weâ€™ll read the <strong>thesis</strong> grade closely after the final exam grade but precede the homework grades.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// name function</span></span><br><span class="line"><span class="built_in">string</span> Core::name() <span class="keyword">const</span> &#123; <span class="keyword">return</span> n; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// grade function for Core</span></span><br><span class="line"><span class="keyword">double</span> Core::grade() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ::grade(midterm, final, homework);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// read_common function</span></span><br><span class="line">istream&amp; Core::read_common(istream&amp; in)&#123;</span><br><span class="line">    in &gt;&gt; n &gt;&gt; midterm &gt;&gt; final;</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// read function for Core</span></span><br><span class="line">istream&amp; Core::read(istream&amp; in)&#123;</span><br><span class="line">    read_common(in);</span><br><span class="line">    read_hw(in, homework);</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// read for Grad</span></span><br><span class="line">istream&amp; Grad::read(istream&amp; in)&#123;</span><br><span class="line">    Core::read_common(in);</span><br><span class="line">    in &gt;&gt; thesis;</span><br><span class="line">    read_hw(in, Core::homework);</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// grade for Grad</span></span><br><span class="line"><span class="keyword">double</span> Grad::grade() <span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> min(Core::grade(), thesis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The <strong>Grad::grade</strong> function shows that we calculate the final grade as the lesser between the <strong>grade</strong> excluding thesis, and thesis. Though we can call members of <strong>Core</strong> directly, weâ€™d better explicitly call some functions for avoiding ambiguity. For example, if we donâ€™t explicitly call <strong>Core::grade()</strong>, the compiler may use the <strong>Grad::grade</strong> dirctly. </p>
<h2 id="Inheritance-and-constructors"><a href="#Inheritance-and-constructors" class="headerlink" title="Inheritance and constructors"></a>Inheritance and constructors</h2><p>Derived objects are constructed by(Koenig and Moo 2000):<br><em>1. Allocating space for the entire object (base-class members as well as derived members)</em><br><em>2. Calling the base-class constructor to initialize the base-class part(s) of the object</em><br><em>3. Initializing the members of the derived class as directed by the constructor initializer</em><br><em>4. Executing the body of the derived-class constructor, if any</em></p>
<p>Clearly, the constructor of a derived class not only constructs its own members but also constructs data members of the base class.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Core</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// default constructor for Core</span></span><br><span class="line">    Core(): midterm(<span class="number">0</span>), final(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// build a Core from an istream</span></span><br><span class="line">    Core(istream&amp; is)&#123; read(is); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grad</span>:</span> <span class="keyword">public</span> Core&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// default constructor for Grad: first implicitly calls the default constructor Core::Core()</span></span><br><span class="line">    Grad(): thesis(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// build a Grad from istream: first implicitly calls Core::Core()</span></span><br><span class="line">    Grad(<span class="built_in">std</span>::istream&amp; is) &#123; read(is); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>For example, when execute<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Grad g; <span class="comment">// create an empty object</span></span><br></pre></td></tr></table></figure></p>
<p>The computer allocates enough space to hold five data members for the Grad object, run the <strong>Core</strong> default constructor to initialize the data members in the <strong>Core</strong> part of <strong>g</strong>, and then run the default constructor of <strong>Grad</strong>. Again, when execute<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Grad <span class="title">g</span><span class="params">(<span class="built_in">cin</span>)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>the computer will run the <strong>Core</strong> default constructor, followed by the <strong>Grad::Grad(istream&amp;)</strong> constructor to read values into five data memners.</p>
<h1 id="Polymorphism-and-virtual-functions"><a href="#Polymorphism-and-virtual-functions" class="headerlink" title="Polymorphism and virtual functions"></a>Polymorphism and virtual functions</h1><p>There is also a support function for the <strong>Student_info</strong> program, that is, the compare function that acts as the predicate of the <strong>std::sort</strong> algorithm.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> Core&amp; c1, <span class="keyword">const</span> Core&amp; c2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c1.name() &lt; c2.name();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>How does it work on the <strong>Grad</strong> class objects? For example<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Grad <span class="title">g</span><span class="params">(<span class="built_in">cin</span>)</span></span>;    <span class="comment">// read a Grad record</span></span><br><span class="line"><span class="function">Grad <span class="title">g2</span><span class="params">(<span class="built_in">cin</span>)</span></span>;   <span class="comment">// read a Grad record</span></span><br><span class="line"></span><br><span class="line"><span class="function">Core <span class="title">c</span><span class="params">(<span class="built_in">cin</span>)</span></span>;    <span class="comment">// read a Core record</span></span><br><span class="line"><span class="function">Core <span class="title">c2</span><span class="params">(<span class="built_in">cin</span>)</span></span>;   <span class="comment">// read a Core record</span></span><br><span class="line"></span><br><span class="line">compare(g, g2); <span class="comment">// compare two Grad records</span></span><br><span class="line">compare(c, c2); <span class="comment">// compare two Core records</span></span><br><span class="line">compare(g, c);  <span class="comment">// compare Grad record with a Core record</span></span><br></pre></td></tr></table></figure></p>
<p>The compare function can take two <strong>Core</strong> objects as well as two <strong>Grad</strong> objects, even one <strong>Core</strong> and one <strong>Grad</strong>. For the function body, it makes sence as any <strong>Grad</strong> object has a member <strong>name</strong>, which it inherits from the base. But why we can pass a <strong>Grad</strong> object to a function expecting a <strong>Core&amp;</strong>? The reason is that <strong>Grad</strong> is inherited from <strong>Core</strong> and hence has a <strong>Core</strong> part. Then, we can bind <strong>compare</strong>â€˜s reference parameters to the <strong>Core</strong> portions of <strong>Grad</strong> objects, as if we bind them to plain <strong>Core</strong> objects.</p>
<h2 id="Obtaining-a-value-without-knowing-the-objectâ€™s-type"><a href="#Obtaining-a-value-without-knowing-the-objectâ€™s-type" class="headerlink" title="Obtaining a value without knowing the objectâ€™s type"></a>Obtaining a value without knowing the objectâ€™s type</h2><p>The compare function described above works properly. However, if we intend to compare the grade rather than the name, the function seems inappropriate for <strong>Grad</strong> objects as two classes have different <strong>grade</strong> function. A right logical manner is that the compare function can invoke the right <strong>grade</strong> function according to the type of the object that we pass, only at the stage of run time. To support this kind of <strong>run time selection</strong>, C++ provides <strong>virtual</strong> functions:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Core</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">grade</span><span class="params">()</span> <span class="keyword">const</span></span>;   <span class="comment">// virtual added</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>When we call <strong>compare</strong>(grade-version), the implementation will determine which version of the <strong>grade</strong> should execute by looking at the actual type of the objects to which the reference <strong>c1</strong> and <strong>c2</strong> are bound. If the argument is <strong>Grad</strong>,then it calls <strong>Grad::grade</strong> and calls <strong>Core::grade</strong> otherwise. </p>
<p>Noting that the keyword <strong>virtual</strong> may be used only inside the class definition. If we seperate the declaration and definition, we do not need to repeatedly use it in the definition.  </p>
<h2 id="Dynamic-binding"><a href="#Dynamic-binding" class="headerlink" title="Dynamic binding"></a>Dynamic binding</h2><p>Another point about the <strong>virtual</strong> is that it is relevant only when the function is called through a reference or a pointer. If we call the function on behalf of the object, then we know the exact type of the object at compile time. In contrast, a reference or a pointer to a base class object may refer or point to a base-class object or to an object of a type derived from the base class. Assuming we write <strong>compare_grades</strong>:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// incorrect implementation</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare_grades</span><span class="params">(Core c1, Core c2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c1.grade() &lt; c2.grade();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>In this case, we know exactly that both two objects are <strong>Core</strong> type. Even we call the function with <strong>Grad</strong> objects, the <strong>Grad</strong> objects will be cut down to its <strong>Core</strong> part and a copy of that part will be passed to the <strong>compare_grades</strong> function. This case is known as <strong>statically bound</strong>, that is, the calls to <strong>Grad</strong> are bound at compile to <strong>Core::grade</strong>. Obviously, the <strong>dynamic binding</strong> is that the function is dynamically bound at run time. If we call a <strong>virtual</strong> function through a pointer or a reference, the version of <strong>virtual</strong> function to use depends on the type of the object which the reference or pointer is bound.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Core c;</span><br><span class="line">Grad g;</span><br><span class="line">Core* p;</span><br><span class="line">Core&amp; r = q;</span><br><span class="line"></span><br><span class="line">c.grade();  <span class="comment">// statically bound to Core::grade()  </span></span><br><span class="line">g.grade();  <span class="comment">// statically bound to Grad::grade()</span></span><br><span class="line">p-&gt;grade(); <span class="comment">// dynamically bound, depending on the type of the object to which p points</span></span><br><span class="line">r.grade();  <span class="comment">// dynamically bound, depending on the type of the object to which r refers</span></span><br></pre></td></tr></table></figure></p>
<p><em>The fact that we can use a derived type where a pointer or reference to the base is expected is an example of <strong>polymorphism</strong>, meaning <strong>of many form</strong>. When we call the <strong>virtual</strong> function by a pointer or reference, we make a polymorphic call.</em> Weâ€™ll make the <strong>read</strong> function <strong>virtual</strong> as well and then the version of the <strong>read</strong> function to be called depends on the type of the object on which it is invoked. </p>
<h2 id="Recap"><a href="#Recap" class="headerlink" title="Recap"></a>Recap</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Core</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Core(): midterm(<span class="number">0</span>), final(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    Core(<span class="built_in">std</span>::istream&amp; is) &#123; read(is); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="function">istream&amp; <span class="title">read</span><span class="params">(<span class="built_in">std</span>::istream&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">grade</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// accessible to derived classes</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="function">istream&amp; <span class="title">read_common</span><span class="params">(<span class="built_in">std</span>::istream&amp;)</span></span>;</span><br><span class="line">    <span class="keyword">double</span> midterm, final;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; homework;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// accessible only to Core</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grad</span>:</span>: <span class="keyword">public</span> Core&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Grad(): thesis(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    Grad(<span class="built_in">std</span>::istream&amp; is) &#123; read(is); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">istream&amp; <span class="title">read</span><span class="params">(<span class="built_in">std</span>::istream)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> thesis;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> Core&amp;, <span class="keyword">const</span> Core&amp;)</span></span>;</span><br></pre></td></tr></table></figure>
<h1 id="Using-inheritance-to-solve-our-problem"><a href="#Using-inheritance-to-solve-our-problem" class="headerlink" title="Using inheritance to solve our problem"></a>Using inheritance to solve our problem</h1><p>Now we can write our student grading prorgam described in chapter 9. The problem is how can we write a program that can handle with both <strong>Core</strong> objects and <strong>Grad</strong> objects. To achieve our goal, we need to eliminate these type dependencies(Koenig and Moo 2000):</p>
<p><em>1. The definition of the vector in which we store the elements as we read them</em><br><em>2. The definition of the local temporary into which we read the records</em><br><em>3. The read function</em><br><em>4. The grade function</em></p>
<p>Now weâ€™ll see how to solve these problems.</p>
<h2 id="Containers-of-virtually-unkown-type"><a href="#Containers-of-virtually-unkown-type" class="headerlink" title="Containers of virtually unkown type"></a>Containers of virtually unkown type</h2><p>Consider if we define a vector as follows:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;Core&gt; students;      <span class="comment">// must hold Core objects, not polymorphic types</span></span><br><span class="line">Core record;                <span class="comment">// Core object, not a type derived from Core</span></span><br></pre></td></tr></table></figure></p>
<p>It is impossible to hold the Grad objects as we explicitly declare that a vector hold objects of type <strong>Core</strong>. Then, if we call the <strong>read</strong> function or <strong>grade</strong> function we indeed call <strong>Core::read</strong> or <strong>Core::grade</strong>. However, we have mentioned in above section, if we call those functions through pointers or references, these functions are dynamically bound at run time, depending on the type of the object which the reference or pointer is bound. Therefore, a natural solution is that define a vector that stores the pointer to each element rather than the element itself.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;Core*&gt; students;</span><br><span class="line">Core* record;</span><br></pre></td></tr></table></figure></p>
<p>Howvever, this doesnâ€™t work as no one knows where the record points initially. If the computer executes data reading, the program would crash.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(record-&gt;read(<span class="built_in">cin</span>)) &#123; <span class="comment">// crash! &#125;</span></span><br></pre></td></tr></table></figure></p>
<p>Now we provide a verbose solution to this problem: let users manually control the type of the object. We use lable <strong>U</strong> to represent that the type is a <strong>Core</strong> object, and use <strong>G</strong> to represent that the <strong>type</strong> is a <strong>Grad</strong> object. Before we implement this strategy, we should rewrite our <strong>compare</strong> function such that it can sort two <strong>pointer</strong>s.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare_Core_ptrs</span><span class="params">(<span class="keyword">const</span> Core* cp1, <span class="keyword">const</span> Core* cp2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> compare(*cp1, *cp2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Noting that we canâ€™t name this predicate as <strong>compare</strong> as we cannot pass an overloaded function as a template argument. Now, letâ€™s see the whole program:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// this work almost work</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Core*&gt; students;     <span class="comment">// store pointers, not objects</span></span><br><span class="line">    Core* record;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="built_in">string</span>::size_type maxlen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read and store the data</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; ch)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch == <span class="string">'U'</span>)</span><br><span class="line">            record = <span class="keyword">new</span> Core;  <span class="comment">// allocate a Core object   </span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            record = <span class="keyword">new</span> Grad;  <span class="comment">// allocate a Grad object</span></span><br><span class="line">        record-&gt;read(<span class="built_in">cin</span>);      <span class="comment">// virtual call</span></span><br><span class="line">        maxlen = max(maxlen, record-&gt;name().size()); <span class="comment">// dereference</span></span><br><span class="line">        students.push_back(record);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pass the version of compare that works on pointers</span></span><br><span class="line">    sort(student.begin(), student.end(), compare_Core_ptrs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write the names and grades</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Core*&gt;::size_type i = <span class="number">0</span>; i != student.size(); ++i)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; students[i]-&gt;name()</span><br><span class="line">             &lt;&lt; <span class="built_in">string</span>(maxlen + <span class="number">1</span> - students[i]-&gt;name.size(), <span class="string">' '</span>); </span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">double</span> final_grade = students[i]-&gt;grade();</span><br><span class="line">        streamsize prec = <span class="built_in">cout</span>.precision();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; setprecision(<span class="number">3</span>) &lt;&lt; final_grade</span><br><span class="line">             &lt;&lt; setprecision(prec) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(domain_error e)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; e.what() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> student[i];  <span class="comment">// free the object allocating when reading</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Virtual-destructors"><a href="#Virtual-destructors" class="headerlink" title="Virtual destructors"></a>Virtual destructors</h2><p>Above program almost works. The only problem occurs when we <strong>delete</strong> the object. When we store each pointer, we store each as <strong>Core*</strong> though they may point to a <strong>Grad</strong>. Therefore, the <strong>delete</strong> operation can only delete pointers to <strong>Core</strong>. To solve this problem, we define a <strong>virtual</strong> destructor:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Core</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~Core() &#123;&#125;</span><br><span class="line">    <span class="comment">// as before</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><em>Now, when we execute <strong>delete students[i]</strong>, the destructor that will be run depends on the type of the object to which <strong>student[i]</strong> actually points. A <strong>virtual</strong> destructor is needed any time it is possible that an object of derived type is destroyed through a pointer to base.</em></p>
<h1 id="A-simple-handle-class"><a href="#A-simple-handle-class" class="headerlink" title="A simple handle class"></a>A simple handle class</h1><p>The above approach does solve the problem but seems complex. Users have to manage the pointers and memory properly to avoid potential bugs. we can use the technique <strong>handle class</strong> to encapsulate the pointer to <strong>Core</strong>:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student_info</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// constructors and copy control</span></span><br><span class="line">    Student_info(): cp(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    Student_info(<span class="built_in">std</span>::istream&amp; is): cp(<span class="number">0</span>) &#123; read(is); &#125;</span><br><span class="line">    Student_info(<span class="keyword">const</span> Student_info&amp;);</span><br><span class="line">    Student_info&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Student_info&amp;);</span><br><span class="line">    ~Student_info() &#123; <span class="keyword">delete</span> cp; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// operations</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="function">istream&amp; <span class="title">read</span><span class="params">(<span class="built_in">std</span>::istream&amp;)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cp) <span class="keyword">return</span> cp-&gt;name();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error(<span class="string">"unitialized Student"</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">grade</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cp) <span class="keyword">return</span> cp-&gt;grade();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error(<span class="string">"unitialized Student"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">compare</span> <span class="params">(<span class="keyword">const</span> Student_info&amp; s1, <span class="keyword">const</span> Student_info&amp; s2)</span></span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> s1.name() &lt; s2.name(); &#125;</span><br><span class="line">    <span class="keyword">private</span>ï¼š</span><br><span class="line">        Core* cp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>Now the <strong>Student_info</strong> object represents either a <strong>Core</strong> or <strong>Grad</strong>. This <strong>handle</strong> class hids the details of implementations related to pointers as used in above program, and provides an interface that is consistent with the <strong>Core</strong> and <strong>Grad</strong>. Users do not need to worry about memory management any more as all has been done by the handle class. The novelty is that we define the compare function as a <strong>static</strong> member which is associated with a class rather than a particular object.<br>We can call it through <strong>Student_info::compare()</strong> directly even without creating any object first. Therefore, <strong>static function member</strong> cannot access nonstatic data members of objects of the class as there is no object associated with the function and hence no members to use. </p>
<h2 id="Reading-the-handle"><a href="#Reading-the-handle" class="headerlink" title="Reading the handle"></a>Reading the handle</h2><p>The first constructor construct a <strong>nullptr</strong>. The second constructor constructs an object from the input stream, relying on the <strong>read</strong> function:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">istream&amp; Student_info::read(istream&amp; is)&#123;</span><br><span class="line">    <span class="keyword">delete</span> cp;      <span class="comment">// delete previous object, if any</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> ch;        <span class="comment">// get record type</span></span><br><span class="line">    is &gt;&gt; ch;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ch == <span class="string">'U'</span>)&#123;</span><br><span class="line">        cp = <span class="keyword">new</span> Core(is);  <span class="comment">// construct Core from istream</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        cp = <span class="keyword">new</span> Grad(is);  <span class="comment">// construct Grad from istream</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>The <strong>read</strong> function allocate the space and construct the right type object according to the information from input stream. It starts by freeing the existing object (if any) to which the handle object was previously bound. It is worth noting that if <strong>cp</strong> is a <strong>nullptr</strong>, we still can use <strong>delete</strong> without causing any error. </p>
<h2 id="Copying-the-handle-objects"><a href="#Copying-the-handle-objects" class="headerlink" title="Copying the handle objects"></a>Copying the handle objects</h2><p>It also defines the copy constuctor and assignment operator. These two operations typically need to allocate new objects and then initialize or assign values from the object from which we are copying. But the problem is how can we know the type of the object from which we are copying? The object, i.e. <strong>cp</strong>, may point to a <strong>Core</strong> or a <strong>Grad</strong>.  The solution is to define a new <strong>virtual</strong> function:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Core</span>&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Student_info</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Core* <span class="title">clone</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> Core(*<span class="keyword">this</span>); &#125;</span><br><span class="line">    <span class="comment">// as before</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>The <strong>clone()</strong> function creates a new object that holds copies of the values in the original. The <strong>Core</strong> doesnâ€™t have a user-defined copy constructor but have a synthesized copy constructor which copies each member from the existing <strong>Core</strong> object into the newly created object. The member is inaccessible to users and non-derived classes. Therefore, we declare the <strong>Student_info</strong> as a friend. Then all members of the <strong>Student_info</strong> are friends of <strong>Core</strong>. The <strong>Grad</strong> class inherits this member, but will return a new <strong>Grad</strong>:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grad</span>:</span> <span class="keyword">public</span> Core&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function">Grad* <span class="title">clone</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> Grad(*<span class="keyword">this</span>); &#125;</span><br><span class="line">    <span class="comment">// as before</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>In general,  when we redefine a member function from the base class, we keep the parameter list and the return type unchanged. However, if the base-class function returns a pointer (or reference) to a base class, then the derived-class function can return a pointer or reference to a corresponding derived class. </p>
<p>In addition to above, the derived class doesnâ€™t inherit the <strong>friend</strong> class from the base class. In this case, it is unnecessary to declare the <strong>Student_info</strong> as the <strong>friend</strong> class of <strong>Grad</strong> due to the fact that the <strong>Student_info</strong> class never refers to <strong>Grad::clone</strong> directly instead through the virtual function defined in <strong>Core</strong>.</p>
<p>The copy constructor and assignment operator are defined as follows:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Student_info::Student_info(<span class="keyword">const</span> Student_info&amp; s): cp(<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s.cp) cp = s.cp-&gt;clone();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student_info&amp; Student_info:: <span class="keyword">operator</span>=(<span class="keyword">const</span> Student_info&amp; s)&#123;</span><br><span class="line">    <span class="keyword">if</span>(&amp;s != <span class="keyword">this</span>)&#123;</span><br><span class="line">        <span class="keyword">delete</span> cp;</span><br><span class="line">        <span class="keyword">if</span>(s.cp)</span><br><span class="line">            cp = s.cp-&gt;clone();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cp = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>One may wonder that why we can access the private member <strong>cp</strong> of object <strong>s</strong>. It is because that <strong>private</strong> only restricts data access from other classes. In other words, if both objects are instances of the same class, they are allowed to access private members with each other. </p>
<h1 id="Using-the-handle-class"><a href="#Using-the-handle-class" class="headerlink" title="Using the handle class"></a>Using the handle class</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Student_info&gt; students;</span><br><span class="line">    Student_info record;</span><br><span class="line">    <span class="built_in">string</span>::size_type maxlen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read and store the data</span></span><br><span class="line">    <span class="keyword">while</span> (record.read(<span class="built_in">cin</span>))&#123;</span><br><span class="line">        maxlen = max(maxlen, record.name().size());</span><br><span class="line">        students.push_back(record);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// alphabetize the student records</span></span><br><span class="line">    sort(students.begin(), students.end(), Student_info::compare);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write the names and grades</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Student_info&gt;::size_type i = <span class="number">0</span>;</span><br><span class="line">         i != students.size(); ++i)&#123;</span><br><span class="line">             <span class="built_in">cout</span> &lt;&lt; students[i].name()</span><br><span class="line">             &lt;&lt; <span class="built_in">string</span>(maxlen + <span class="number">1</span> - students[i].name.size(), <span class="string">' '</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">double</span> final_grade = students[i].grade();</span><br><span class="line">            streamsize prec = <span class="built_in">cout</span>.precision();</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; setprecision(<span class="number">3</span>) &lt;&lt; final_grade</span><br><span class="line">                 &lt;&lt; setprecision(prec) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (domain_error e)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; e.what() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Now the program takes either a undergraduate record or a graduate record. It first reads the character that says what kind of record we are about to read, then creates a new object and initializes it from input stream. Then it stores objects and deal with sorting, printing as same as the previous program. When it exits from the main, all created objects are deleted automatically through the destructor defined in the <strong>Student_info</strong> class. </p>
<h1 id="Subtleties"><a href="#Subtleties" class="headerlink" title="Subtleties"></a>Subtleties</h1><p>We are allowed to store <strong>Core</strong> or <strong>Grad</strong> objects into a <strong>vector<core></core></strong> due to the fact that <strong>push_back</strong> function takes a reference to the <strong>vector</strong>â€˜s value type. But the result is that the vector only stores the <strong>Core</strong> part of a <strong>Grad</strong> object. </p>
<p>If we want to declare a <strong>virtual</strong> function, we must give it the same interface in the <strong>base</strong> and the <strong>derived</strong> classes.  </p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/" rel="tag"># C++</a>
          
            <a href="/tags/Notes/" rel="tag"># Notes</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/06/05/2018/Defining-abstract-data-types-Part-2/" rel="next" title="C++ - Defining abstract data types(Part 2)">
                <i class="fa fa-chevron-left"></i> C++ - Defining abstract data types(Part 2)
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/09/05/2018/C-Managing-memory-almost-automatically/" rel="prev" title="C++ - Managing memory (almost) automatically">
                C++ - Managing memory (almost) automatically <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Liam</p>
              <p class="site-description motion-element" itemprop="description">Stochastic Modelling Notes; Programming Notes</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">50</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/quantliam" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yanshijiutu@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Inheritance"><span class="nav-number">1.</span> <span class="nav-text">Inheritance</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Protection-revisited"><span class="nav-number">1.1.</span> <span class="nav-text">Protection revisited</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Operations"><span class="nav-number">1.2.</span> <span class="nav-text">Operations</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Inheritance-and-constructors"><span class="nav-number">1.3.</span> <span class="nav-text">Inheritance and constructors</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Polymorphism-and-virtual-functions"><span class="nav-number">2.</span> <span class="nav-text">Polymorphism and virtual functions</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Obtaining-a-value-without-knowing-the-objectâ€™s-type"><span class="nav-number">2.1.</span> <span class="nav-text">Obtaining a value without knowing the objectâ€™s type</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Dynamic-binding"><span class="nav-number">2.2.</span> <span class="nav-text">Dynamic binding</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Recap"><span class="nav-number">2.3.</span> <span class="nav-text">Recap</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Using-inheritance-to-solve-our-problem"><span class="nav-number">3.</span> <span class="nav-text">Using inheritance to solve our problem</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Containers-of-virtually-unkown-type"><span class="nav-number">3.1.</span> <span class="nav-text">Containers of virtually unkown type</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Virtual-destructors"><span class="nav-number">3.2.</span> <span class="nav-text">Virtual destructors</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#A-simple-handle-class"><span class="nav-number">4.</span> <span class="nav-text">A simple handle class</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Reading-the-handle"><span class="nav-number">4.1.</span> <span class="nav-text">Reading the handle</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Copying-the-handle-objects"><span class="nav-number">4.2.</span> <span class="nav-text">Copying the handle objects</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Using-the-handle-class"><span class="nav-number">5.</span> <span class="nav-text">Using the handle class</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Subtleties"><span class="nav-number">6.</span> <span class="nav-text">Subtleties</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Liam</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">116.8k</span>
  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
