<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"quantein.com","root":"/","scheme":"Muse","version":"7.7.2","exturl":false,"sidebar":{"position":"right","display":"post","padding":60,"offset":12,"onmobile":true},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Example 3 - Generating sentencesThis section introduces how to write a program that can randomly generate a sentence given certain grammar rules. For example, given following input 1234567891011121314">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ - Using associative containers (Part 2)">
<meta property="og:url" content="http://quantein.com/2018/03/28/C-Using-associative-containers-Part-2/index.html">
<meta property="og:site_name" content="Liam&#39;s Blog">
<meta property="og:description" content="Example 3 - Generating sentencesThis section introduces how to write a program that can randomly generate a sentence given certain grammar rules. For example, given following input 1234567891011121314">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2018-03-28T10:10:13.000Z">
<meta property="article:modified_time" content="2018-03-31T16:47:41.000Z">
<meta property="article:author" content="Liam">
<meta property="article:tag" content="Stochastic Modelling Notes; Programming Notes">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://quantein.com/2018/03/28/C-Using-associative-containers-Part-2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true
  };
</script>

  <title>C++ - Using associative containers (Part 2) | Liam's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Liam's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">If history repeats itself, and the unexpected always happens, how incapable must Man be of learning from experience?â€”George Bernard Shaw.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="search-pop-overlay">
  <div class="popup search-popup">
      <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

  </div>
</div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/quantliam" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="en">
    <link itemprop="mainEntityOfPage" href="http://quantein.com/2018/03/28/C-Using-associative-containers-Part-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Liam">
      <meta itemprop="description" content="Stochastic Modelling Notes; Programming Notes">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Liam's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++ - Using associative containers (Part 2)
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-03-28 18:10:13" itemprop="dateCreated datePublished" datetime="2018-03-28T18:10:13+08:00">2018-03-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2018-04-01 00:47:41" itemprop="dateModified" datetime="2018-04-01T00:47:41+08:00">2018-04-01</time>
              </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span></span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>NaN:aN</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Example-3-Generating-sentences"><a href="#Example-3-Generating-sentences" class="headerlink" title="Example 3 - Generating sentences"></a>Example 3 - Generating sentences</h1><p>This section introduces how to write a program that can randomly generate a sentence given certain grammar rules. For example, given following input</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Categories        Rules</span><br><span class="line"></span><br><span class="line">&lt;noun&gt;            cat</span><br><span class="line">&lt;noun&gt;            dog</span><br><span class="line">&lt;noun&gt;            table</span><br><span class="line">&lt;noun-phrase&gt;     &lt;noun&gt;</span><br><span class="line">&lt;noun-phrase&gt;     &lt;adjective&gt; &lt;noun-phrase&gt;</span><br><span class="line">&lt;adjective&gt;       large</span><br><span class="line">&lt;adjective&gt;       brown</span><br><span class="line">&lt;adjective&gt;       absurd</span><br><span class="line">&lt;verb&gt;            jumps</span><br><span class="line">&lt;verb&gt;            sits</span><br><span class="line">&lt;location&gt;        on the stairs</span><br><span class="line">&lt;location&gt;        under the sky</span><br><span class="line">&lt;location&gt;        wherever it wants</span><br><span class="line">&lt;sentence&gt;        the &lt;noun-phrase&gt; &lt;verb&gt; &lt;location&gt;</span><br></pre></td></tr></table></figure>

<p>The program might generate such a sentence:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">the cat sits on the stairs</span><br></pre></td></tr></table></figure>
<p>Some stylized facts can be observed:</p>
<ol>
<li><p>There are two types of element in the inputs, one type contains a string enclosed by a pair of angle brackets and the other type contains one or more strings. We can always find direct or indirect mapping relations from each first type element to the second type elements. </p>
</li>
<li><p>The first type represents categories of the components that constitute a sentence. One or more categories can construct compound categories. The second type represents the smallest building blocks of a sentence. </p>
</li>
<li><p>The sentence structure is determined by the <strong>Rule</strong> associated with the category <strong><sentence></strong>. A <strong>Rule</strong> may contain either categories or most basic building blocks or mixed. </p>
</li>
</ol>
<p>Therefore, to construct a sentence, we need to</p>
<ol>
<li>find <strong><sentence></strong>, and then find the associated <strong>Rule</strong>.</li>
<li>start to find each element of a sentence follow the instructions of the <strong>Rule</strong>. </li>
<li>if the element is already the most basic building block, then we just store it into a vector for the final output. If the element is a category (i.e. the first type of element), weâ€™ll find the associated <strong>Rule</strong> recursively, until that we find any of the most basic building blocks (i.e. the second type of element).</li>
</ol>
<p>Now, the soluction strategy can be logically divided into three parts:</p>
<ul>
<li>part 1: read and store the grammar including categories and rules into a map</li>
<li>part 2: applying above steps to find all needed elements for a sentence </li>
<li>part 3: write the sentence on the output device. </li>
</ul>
<h2 id="Read-the-grammar"><a href="#Read-the-grammar" class="headerlink" title="Read the grammar"></a>Read the grammar</h2><p>Seen from above example, we can built a map from the first colunm to the second column, two elements of which in each row construct a key-value pair. The elements in the first column have data type <strong>string</strong>. But whatâ€™s the data type for the elements of the second column? We know that each rule may contains one or more strings and hence each rule can be stored into a vector<string>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; Rule;</span><br></pre></td></tr></table></figure>
<p>Also, the mapping from the first column to the second column has one-to-many relations,for example, one <strong><noun></strong> maps to several rules such as <strong>cat</strong>, <strong>dog</strong> and <strong>table</strong>. Therefore, we can store each rule into a high-level vector:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; Rule_collection;</span><br></pre></td></tr></table></figure>
<p>For the sake of brevity, we can use type alias in declaring such a map:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; Rule;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;Rule&gt; Rule_collection;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">map</span>&lt;<span class="built_in">string</span>, Rule_collection&gt; Grammar;</span><br></pre></td></tr></table></figure>
<p>Letâ€™s see how to read the grammar into such a map:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Grammar <span class="title">read_grammar</span><span class="params">(istream &amp;in)</span></span></span><br><span class="line"><span class="function">    Grammar ret</span>;</span><br><span class="line">    <span class="built_in">string</span> <span class="built_in">line</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read the input</span></span><br><span class="line">    <span class="keyword">while</span> (getline(in, <span class="built_in">line</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// split the input into words</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; entry = split(<span class="built_in">line</span>);</span><br><span class="line">        <span class="keyword">if</span>(!entry.empty())</span><br><span class="line">            <span class="comment">// use the category to store the associated rule</span></span><br><span class="line">            ret[entry[<span class="number">0</span>]].push_back(Rule(entry.<span class="built_in">begin</span>() + <span class="number">1</span>, entry.<span class="built_in">end</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The function returns a map <strong>Grammar</strong> that contains all grammar rules to be applied to generate a sentence in the next step. There is only one argument, an input stream object, to be passed. </p>
<p>Inside of the function body, the first statement defines an empty map <strong>ret</strong> for holding the grammar, and the second statement defines an empty string for holding each row of input containing the key (i.e. one category) and the value (i.e. one rule). The next is a <strong>while</strong> loop to read the input repeatedly and read one line once. When the first line is read in, we need to extract all words contained in the line. Then, for the first word (i.e. the category represented by a string enclosed by a pair of angle brackets), we store it into the map as the key, while for the following words, we store them as the value that associates with the key. The core statement is</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret[entry[<span class="number">0</span>]].push_back(Rule(entry.<span class="built_in">begin</span>() + <span class="number">1</span>, entry.<span class="built_in">end</span>()));</span><br></pre></td></tr></table></figure>
<p>It seems complex but actually there is noting new in it. <strong>entry</strong> is the vector returned by the <strong>split</strong> function and hence contains all words extracted from the line of inputs. <strong>ret[entry[0]]</strong> stores the first word (if the word is new for the key), i.e. the category, and returns its associated value, i.e. <strong>Rule_collection</strong>. Then, we uses <strong>push_back</strong> to store the associated <strong>Rule</strong> which is a vector<string> . The <strong>Rule</strong> is filled with values from the range [entry.begin() + 1, entry.end()) using </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;(iterator_first, iterator_last);</span><br></pre></td></tr></table></figure>
<p>The last statement is to return the <strong>Grammar ret</strong>.</p>
<h2 id="Generate-a-sentence"><a href="#Generate-a-sentence" class="headerlink" title="Generate a sentence"></a>Generate a sentence</h2><p>Letâ€™s consider the function that generate a sentence. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generating the sentence</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">gen_sentence</span><span class="params">(<span class="keyword">const</span> Grammar &amp;g)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ret;</span><br><span class="line">	gen_aux(g, <span class="string">"&lt;sentence&gt;"</span>, ret);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Apparently, we need a vector<string> to hold the generated sentence. The only argument to be passed is the value returned by the function <strong>read_grammar</strong>. </p>
<p>The function that really deals with generating a sentence is named as <strong>gen_aux</strong>. It has three parameters, the first one is the grammar produced by <strong>read_grammar</strong>, the second one is a keyword â€œ<sentence>â€œ to be searched, the third one is a <strong>vector<string></strong> to hold the final results. </p>
<p>The function is defined below:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gen_aux</span><span class="params">(<span class="keyword">const</span> Grammar &amp;g, <span class="keyword">const</span> <span class="built_in">string</span> &amp;<span class="keyword">word</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;ret)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!bracketed(<span class="keyword">word</span>))&#123;</span><br><span class="line">		ret.push_back(<span class="keyword">word</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// locate the rule that corresponds to word</span></span><br><span class="line">		Grammar::const_iterator it = g.<span class="built_in">find</span>(<span class="keyword">word</span>);</span><br><span class="line">		<span class="keyword">if</span>(it == g.<span class="built_in">end</span>())</span><br><span class="line">			<span class="keyword">throw</span> logic_error(<span class="string">"empty rule"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// fetch the set of possible rules</span></span><br><span class="line">		<span class="keyword">const</span> Rule_collection &amp;c = it-&gt;second;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// from which we select one at random</span></span><br><span class="line">		<span class="keyword">const</span> Rule  &amp;r = c[nrand(c.<span class="built_in">size</span>())];</span><br><span class="line"></span><br><span class="line">		<span class="comment">// recursively expand teh selected rule</span></span><br><span class="line">		<span class="keyword">for</span> (Rule::const_iterator i = r.<span class="built_in">begin</span>(); i != r.<span class="built_in">end</span>(); ++i)</span><br><span class="line">			gen_aux(g, *i, ret);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The logic of this function is exactly as same as we described above. Ignoring the <strong>if-else</strong> statement first, the first step is to find the category <strong><sentence></strong>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Grammar::const_iterator it = g.<span class="built_in">find</span>(<span class="keyword">word</span>);</span><br></pre></td></tr></table></figure>
<p>The member function <strong>find</strong> finds and returns an iterator that refers to the element with <em>the key</em> equivalent to the given <strong>k</strong>. If such element doesnâ€™t exist in the map, the <strong>find</strong> function returns iterator <strong>g.end()</strong>. Therefore, if there exists such an iterator, getting the associated <strong>Rule_collection</strong>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(it == g.<span class="built_in">end</span>())</span><br><span class="line">    <span class="keyword">throw</span> logic_error(<span class="string">"empty rule"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// fetch the set of possible rules</span></span><br><span class="line"><span class="keyword">const</span> Rule_collection &amp;c = it-&gt;second;</span><br></pre></td></tr></table></figure>
<p>By now, there exists two problems to be solved: </p>
<ol>
<li>how to randomly pick one rule from <strong>Rule_collection</strong></li>
<li>if one rule is picked, how to deal with the case that its elements are still categories. </li>
</ol>
<p>Letâ€™s put question 1 last and solve question 2 first. Assuming we have picked one rule from the <strong>Rule_collection</strong>, we then scan each element of it and store the element if the element is the most basic building block. But if the element is still one of the categories, what we need to do is to find the lower level rule (i.e. its associated value). Therefore, we just repeat above processes until the element is not a category.<br>The <strong>if-else</strong> statement controls the recursive process while the condition that ceases the recursion is a predicate which returns true if the element is not a category:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bracketed</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> s.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; s[<span class="number">0</span>] == <span class="string">'&lt;'</span> &amp;&amp; s[s.<span class="built_in">size</span>() - <span class="number">1</span>] == <span class="string">'&gt;'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The function <strong>gen_sentence</strong> is recursively called in the <strong>for</strong> loop:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// recursively expand teh selected rule</span></span><br><span class="line"><span class="keyword">for</span> (Rule::const_iterator i = r.<span class="built_in">begin</span>(); i != r.<span class="built_in">end</span>(); ++i)</span><br><span class="line">    gen_aux(g, *i, ret);</span><br></pre></td></tr></table></figure>

<h2 id="Random-drawing"><a href="#Random-drawing" class="headerlink" title="Random drawing"></a>Random drawing</h2><p>Now the last piece is to randomly pick a rule from <strong>Rule_collection</strong>.<br>One possible solution is using <strong>rand() % n</strong>. <strong>rand()</strong> is an algorithm defined in standard header <strong><cstdlib></strong> and gives a random integer in the range [0, RAND_MAX]. The upper bound is a large number defined in <strong><cstdlib></strong>. <strong>rand() % n</strong>, computes the remainder when deviding the random number by <strong>n</strong> and hence gives a random integer in the range [0, n). If we set <strong>n = c.size()</strong>, we can then obtain an random index that yields a <strong>rule</strong> via <strong>c[rand() % c.size]</strong>. However, this solution is not a good choice due to(Koenig and Moo 2000):</p>
<ol>
<li><p><em><strong>rand()</strong> returns pseudo-random numbers. Many C++ implementationsâ€™ pseudo-random numbers give remainders that arenâ€™t very random when the quotients are small integers</em>.</p>
</li>
<li><p><em>if <strong>n</strong> is large and <strong>RAND_MAX</strong> is not evenly divisible by <strong>n</strong>,some remainder will appear more often than others</em>.</p>
</li>
</ol>
<p>To circumvent these issues, we can divide the range of available numbers into buckets of exactly equal size:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> bucket_size = RAND_MAX /n;</span><br></pre></td></tr></table></figure>
<p>Then, bucket 0 has values from [0, bucket_size), bucket 1 has values from [bucket_size, bucket_size*2)â€¦..</p>
<p>Then we can random draw a number and get the bucket number where the random number is located in via:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> r = rand() / bucket_size;</span><br></pre></td></tr></table></figure>
<p>But there exist situations that the random number does not fall into any bucket due to the fact that <strong>RAND_MAX</strong> may be not evenly divisible by <strong>n</strong>. Therefore, we uses a <strong>do while</strong> statement to repeat above statement until it finds a random number that locates in the range of one of buckets.  </p>
<p>The function <strong>nrand</strong> is shown below:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// return a random integer in the range [0, n)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nrand</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n &lt;= <span class="number">0</span> || n &gt; RAND_MAX)</span><br><span class="line">		<span class="keyword">throw</span> domain_error(<span class="string">"Argument to nrand is out of range"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> bucket_size = RAND_MAX /n;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> r = rand() / bucket_size;</span><br><span class="line">	<span class="keyword">while</span>(r &gt;= n);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Noting that <strong>rand()</strong> uses a seed to generate the sequence, which should be initialized to some distinctive value using <strong>void srand(unsigned int seed)</strong>. A common practice is to use distinctive runtime value, like the value returned by function time. For example</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">srand (time(<span class="literal">NULL</span>));</span><br></pre></td></tr></table></figure>
<p>In addition, <strong>srand()</strong> is in fact has global effect on <strong>rand()</strong> and hence can be stated at the very begining of the main function. </p>
<h2 id="A-complete-program"><a href="#A-complete-program" class="headerlink" title="A complete program"></a>A complete program</h2><p>Now I files all functions and code discussed above and present the compete program below. The main function easy to understand and hence no further analysis here. </p>
<p><strong>mainfunction.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;		// to get the declaration of srand</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;		// to get the declaration of time</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;		// to get the declaration of vector</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;		// to get the declaration of string</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"read_grammar.h"</span>	<span class="comment">// to get the declaration of read_grammar</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"gen_sentence.h"</span>	<span class="comment">// to get the declaration of gen_sentence</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;		<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::srand;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::time;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// initialize random number generator with distinctive runtime value</span></span><br><span class="line">	srand (time(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// generate the sentence</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; sentence = gen_sentence(read_grammar(<span class="built_in">cin</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// write the first word, if any</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::const_iterator it = sentence.<span class="built_in">begin</span>();</span><br><span class="line">	<span class="keyword">if</span>(!sentence.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *it;</span><br><span class="line">		++it;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// write the rest of the words, each preceded by a space</span></span><br><span class="line">	<span class="keyword">while</span>(it != sentence.<span class="built_in">end</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; *it;</span><br><span class="line">		++it;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>type_alias.h</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_TYPE_ALIAS_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_TYPE_ALIAS_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; Rule;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Rule&gt; Rule_collection;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, Rule_collection&gt; Grammar;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* GUARD_TYPE_ALIAS_H */</span></span></span><br></pre></td></tr></table></figure>

<p><strong>read_grammar.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;		// to get the declaration of istream</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;		// to get the declaration of vector</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;		// to get the declaration of string</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"split.h"</span>		<span class="comment">// to get the declaration of split</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"type_alias.h"</span>		<span class="comment">// to get the declaration of type alias</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"read_grammar.h"</span>	<span class="comment">// to get the declaration of read_grammar</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::istream;		<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// read a grammar from a given input stream</span></span><br><span class="line"><span class="function">Grammar <span class="title">read_grammar</span><span class="params">(istream &amp;in)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Grammar ret;</span><br><span class="line">    <span class="built_in">string</span> <span class="built_in">line</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read the input</span></span><br><span class="line">    <span class="keyword">while</span> (getline(in, <span class="built_in">line</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// split the input into words</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; entry = split(<span class="built_in">line</span>);</span><br><span class="line">        <span class="keyword">if</span>(!entry.empty())</span><br><span class="line">            <span class="comment">// use the category to store the associated rule</span></span><br><span class="line">            ret[entry[<span class="number">0</span>]].push_back(Rule(entry.<span class="built_in">begin</span>() + <span class="number">1</span>, entry.<span class="built_in">end</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>read_grammar.h</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_READ_GRAMMAR_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_READ_GRAMMAR_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"type_alias.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">Grammar <span class="title">read_grammar</span><span class="params">(<span class="built_in">std</span>::istream &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* GUARD_READ_GRAMMAR_H */</span></span></span><br></pre></td></tr></table></figure>

<p><strong>gen_sentence.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;		// to get the declaration of vector</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;		// to get the declaration of string</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;		// to get the declaration of domain_error, logic_error</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;		// to get the declaration of rand</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"type_alias.h"</span>		<span class="comment">// to get the declaration of type_alias</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"gen_sentence.h"</span>	<span class="comment">// to get the declatation of gen_sentence</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;			<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::domain_error;	<span class="keyword">using</span> <span class="built_in">std</span>::logic_error;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::rand;</span><br><span class="line"></span><br><span class="line"><span class="comment">// generating the sentence</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">gen_sentence</span><span class="params">(<span class="keyword">const</span> Grammar &amp;g)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ret;</span><br><span class="line">    gen_aux(g, <span class="string">"&lt;sentence&gt;"</span>, ret);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// auxillary gen function</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gen_aux</span><span class="params">(<span class="keyword">const</span> Grammar &amp;g, <span class="keyword">const</span> <span class="built_in">string</span> &amp;<span class="keyword">word</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;ret)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!bracketed(<span class="keyword">word</span>))&#123;</span><br><span class="line">        ret.push_back(<span class="keyword">word</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">// locate the rule that corresponds to word</span></span><br><span class="line">        Grammar::const_iterator it = g.<span class="built_in">find</span>(<span class="keyword">word</span>);</span><br><span class="line">        <span class="keyword">if</span>(it == g.<span class="built_in">end</span>())</span><br><span class="line">            <span class="keyword">throw</span> logic_error(<span class="string">"empty rule"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// fetch the set of possible rules</span></span><br><span class="line">        <span class="keyword">const</span> Rule_collection &amp;c = it-&gt;second;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// from which we select one at random</span></span><br><span class="line">        <span class="keyword">const</span> Rule  &amp;r = c[nrand(c.<span class="built_in">size</span>())];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// recursively expand teh selected rule</span></span><br><span class="line">        <span class="keyword">for</span> (Rule::const_iterator i = r.<span class="built_in">begin</span>(); i != r.<span class="built_in">end</span>(); ++i)</span><br><span class="line">            gen_aux(g, *i, ret);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the predicate </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bracketed</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; s[<span class="number">0</span>] == <span class="string">'&lt;'</span> &amp;&amp; s[s.<span class="built_in">size</span>() - <span class="number">1</span>] == <span class="string">'&gt;'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// return a random integer in the range [0, n)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nrand</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span> || n &gt; RAND_MAX)</span><br><span class="line">        <span class="keyword">throw</span> domain_error(<span class="string">"Argument to nrand is out of range"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> bucket_size = RAND_MAX /n;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> r = rand() / bucket_size;</span><br><span class="line">    <span class="keyword">while</span>(r &gt;= n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>split.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;	// to get the declarartion of vector</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;	// to get the declaration of string</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;	// to get the declaration of find_if</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"split.h"</span>	<span class="comment">// to get the declaration of split</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::find_if;</span><br><span class="line"></span><br><span class="line"><span class="comment">// true if the argument is whitespace, false otherwise</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">space</span><span class="params">(<span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">isspace</span>(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// false if the argument is whitesapce, true otherwise</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">not_space</span><span class="params">(<span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !<span class="built_in">isspace</span>(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// function extracts words from a line of input</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">split</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">string</span>::const_iterator iter;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ret;</span><br><span class="line"></span><br><span class="line">    iter i = str.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span> (i != str.<span class="built_in">end</span>())&#123;</span><br><span class="line">        <span class="comment">// ignore leading blanks</span></span><br><span class="line">        i = find_if(i, str.<span class="built_in">end</span>(), not_space);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// find end of next word</span></span><br><span class="line">        iter j = find_if(i, str.<span class="built_in">end</span>(), space);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// copy the characters in [i,j)</span></span><br><span class="line">        <span class="keyword">if</span>(i != str.<span class="built_in">end</span>())</span><br><span class="line">            ret.push_back(<span class="built_in">string</span>(i, j));</span><br><span class="line">        i = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>split.h</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GUARD_SPLIT_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GUARD_SPLIT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">space</span><span class="params">(<span class="keyword">char</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">not_space</span><span class="params">(<span class="keyword">char</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">split</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* GUARD_SPLIT_H */</span></span></span><br></pre></td></tr></table></figure>

<h2 id="Test-performance"><a href="#Test-performance" class="headerlink" title="Test performance"></a>Test performance</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Inputs:</span><br><span class="line"></span><br><span class="line">&lt;noun&gt;            cat</span><br><span class="line">&lt;noun&gt;            dog</span><br><span class="line">&lt;noun&gt;            table</span><br><span class="line">&lt;noun-phrase&gt;     &lt;noun&gt;</span><br><span class="line">&lt;noun-phrase&gt;     &lt;adjective&gt; &lt;noun-phrase&gt;</span><br><span class="line">&lt;adjective&gt;       large</span><br><span class="line">&lt;adjective&gt;       brown</span><br><span class="line">&lt;adjective&gt;       absurd</span><br><span class="line">&lt;verb&gt;            jumps</span><br><span class="line">&lt;verb&gt;            sits</span><br><span class="line">&lt;location&gt;        on the stairs</span><br><span class="line">&lt;location&gt;        under the sky</span><br><span class="line">&lt;location&gt;        wherever it wants</span><br><span class="line">&lt;sentence&gt;        the &lt;noun-phrase&gt; &lt;verb&gt; &lt;location&gt;</span><br><span class="line"></span><br><span class="line">Outputs:</span><br><span class="line"></span><br><span class="line">the large brown dog sits wherever it wants</span><br></pre></td></tr></table></figure>
<p>The program works as expected.</p>
<hr>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>Post author:  </strong>Liam
  </li>
  <li class="post-copyright-link">
    <strong>Post link: </strong>
    <a href="http://quantein.com/2018/03/28/C-Using-associative-containers-Part-2/" title="C++ - Using associative containers (Part 2)">http://quantein.com/2018/03/28/C-Using-associative-containers-Part-2/</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> unless stating additionally.
  </li>
</ul>
</div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2018/03/27/C-Using-associative-containers/" rel="prev" title="C++ - Using associative containers (Part 1)">
      <i class="fa fa-chevron-left"></i> C++ - Using associative containers (Part 1)
    </a></div>
      <div class="post-nav-item">
    <a href="/2018/03/30/Accelerated-C-Solutions-to-Exercises-Chapter-7/" rel="next" title="Accelerated C++ Solutions to Exercises(Chapter 7 Part 1)">
      Accelerated C++ Solutions to Exercises(Chapter 7 Part 1) <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Example-3-Generating-sentences"><span class="nav-number">1.</span> <span class="nav-text">Example 3 - Generating sentences</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Read-the-grammar"><span class="nav-number">1.1.</span> <span class="nav-text">Read the grammar</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Generate-a-sentence"><span class="nav-number">1.2.</span> <span class="nav-text">Generate a sentence</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Random-drawing"><span class="nav-number">1.3.</span> <span class="nav-text">Random drawing</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#A-complete-program"><span class="nav-number">1.4.</span> <span class="nav-text">A complete program</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Test-performance"><span class="nav-number">1.5.</span> <span class="nav-text">Test performance</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Liam</p>
  <div class="site-description" itemprop="description">Stochastic Modelling Notes; Programming Notes</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">59</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/quantliam" title="GitHub â†’ https:&#x2F;&#x2F;github.com&#x2F;quantliam" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/yanshijiutu@gmail.com" title="E-Mail â†’ yanshijiutu@gmail.com"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Liam</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">Symbols count total: </span>
    <span title="Symbols count total">NaNm</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">Reading time total &asymp;</span>
    <span title="Reading time total">NaN:aN</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
